<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【CQOI2014】危桥]]></title>
    <url>%2Fposts%2F3001.html</url>
    <content type="text"><![CDATA[Source and JudgeCQOI2014loj2239 Record1h Analysis请先思考后再展开 https://www.luogu.org/blog/39887/solution-p3163]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【COCI2013】hiperprostor]]></title>
    <url>%2Fposts%2F2fdd.html</url>
    <content type="text"><![CDATA[Source and JudgeCOCI2013bzoj3482 Record2h Analysis请先思考后再展开 对于每个st，用最短路求出f(k,ed)表示经过了k条x到达ed的最短路那么每个的贡献就是y=kx+f(k,ed)，这m条直线放到坐标系上，维护最底下的部分和往常不同的是，这些是直线而不是点，然后我就搞了个求交点稍微分类讨论一下（利用本题斜率的特点）然后无论x取什么，k超过n就不会有贡献了，所以其实直线只有n条那么复杂度为 $O(q*(n^2log+n))$ 拍了很久各种情况 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>出题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[楼房重建]]></title>
    <url>%2Fposts%2F4690.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj2957 Record1h Analysis请先思考后再展开 一开始的想法：求一个最顶上，斜率递增的面然后分块维护，询问的时候，加入第i个块的时候前面不会被修改，后面就二分一下接在上面，复杂度为 $O(n\sqrt{n log})$显然不能过…… 正解：vali=yi/xi，则求上升序列，这样就好做多了，我连这个都没转化注意到修改只会修改一个位置，我们要尽量利用已有的信息去剪枝考虑分治，设计一个函数solve(l,r,left)表示只考虑这段区间时候的答案，然后左边被left挡住分类讨论一下，如果left挡住左区间的mx，则solve(mid+1,r,left)否则，solve(l,mid,left)+solve(mid+1,r,lmx)注意到右边那个，通过线段树是可以保存的（线段树减少区间个数为2n）设cnt为只考虑本区间的答案，cnt2是上面说的那个东东，只用于右区间根据等差数列公式，时间复杂度为 $O(nlog^2n)$ undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>出题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SCOI2012】滑雪与时间胶囊]]></title>
    <url>%2Fposts%2Fb8b9.html</url>
    <content type="text"><![CDATA[Source and JudgeSCOI2012bzoj2753 Record1h Analysis请先思考后再展开 显然先处理出1能到的节点，这样保证根是1能穿越回去过的点，每条边长只考虑一次，要求去过所有能去的点看起来很像MST，考虑到是有向边，类似于求最小树形图显然不能朱刘算法，但注意到边的方向是由高度决定的 考虑为什么普通的MST不能用，因为加入某条边的时候，你并不知道是把点加了进去还是把点作为祖先……联想dag的树形图————贪心地选择边权最小的入边还有就是，同一高度的点，内部是无向边，谁找谁都没问题那么我们不妨按照高度从大到小枚举每个点（等价于按拓扑序），然后仿照kruskal那样从小到大枚举入边，尝试加入mst undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>出题</tag>
        <tag>复习</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSU]]></title>
    <url>%2Fposts%2F18cd.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj3450bzoj4318 Record30min Analysis请先思考后再展开 期望入门好题……………………设当前成功的概率为P，考虑一个递推以bzoj3450为例，设g为前面连续长度的期望$f(i)=\sum (1-np) \times p \times 权值和+\sum np \times p \times (权值和+2 \times 连续长度+1)$$f(i)=\sum p \times 权值和+\sum np \times p \times (2*连续长度+1)$$f(i)=\sum f(i-1)+np \times (2 \times g(i-1)+1)$ 然后bzoj4318同理$f(i)=\sum (1-np) \times p \times 权值和+\sum np \times p \times (权值和+3连续长度平方+3连续长度+1)$$f(i)=\sum p \times 权值和+\sum np \times p(3连续长度平方+3连续长度+1)$$f(i)=\sum f(i-1)+np \times (3g1(i-1)+3g2(i-1)+1)$分g1和g2是因为，概率是不平方的，也就是说$连续长度的期望^2 \neq 连续长度平方的期望$ undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>期望</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BJWC2018】餐巾计划问题]]></title>
    <url>%2Fposts%2F509.html</url>
    <content type="text"><![CDATA[Source and Judgeluogu4480 Record1h Analysis请先思考后再展开 考虑枚举新毛巾的购买数量那么贪心地计算代价即可 打个表出来不难发现新毛巾的选取满足单峰性不过我不会证明，网上目前的两篇题解都在乱说……$O(nlog_{1.5}n)$ undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>贪心</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【WC2014】时空穿梭]]></title>
    <url>%2Fposts%2F6b1.html</url>
    <content type="text"><![CDATA[ProblemWC2014uoj54 Analysis请先思考后再展开 完整数据范围请前往uoj如果对像本sb一样对高维空间难以理解，可以看看bzoj3518帮助理解 因为在一条直线上，考虑枚举线段两端的节点那么我们不妨枚举跨度向量a，那么在中间的点的数量就是 $gcd(a_i)-1$ ，这个挺好想的吧，因为右上角的节点会被所有【除以gcd的位置】覆盖考虑每种向量实际有多少个，那么不难得出柿子（如果选不到c-2个，组合数为0）$$\begin{aligned}ans&amp;=\sum_{a_t}^{M_t} \sum \sum C_{gcd(a_t)-1}^{c-2} (\prod M_t-a_t)\\&amp;=\sum_{g=1}^{minM} C_{g-1}^{c-2} \times ( \sum_{m_t=1}^{M_t/g} \sum \sum (\prod M_t-m_t \times g) \times [gcd(m)=1] )\\&amp;然后套路地莫反一下（目的是取消之间的依赖性，利用乘法分配律降低复杂度）\\&amp;=\sum_{g=1}^{minM} C_{g-1}^{c-2} \times ( \sum_{m_t=1}^{M_t/g} \sum \sum (\prod M_t-m_t \times g) \times (\sum_{d|gcd(m_i)} \mu(d)) )\\&amp;=\sum_{g=1}^{minM} C_{g-1}^{c-2} \times ( \sum_{d=1}^{minM/g} \mu(d) \times \prod (\sum_{i=1}^{\frac{M_t}{dg}} M_t-i \times dg) )\\&amp;看到这个形式，做题多的不难发现枚举dg会方便很多\\&amp;=\sum_{D=1}^{minM} (\prod ( \sum_{i=0}^{\frac{M_t}{D}} M_t-i \times D )) \times (\sum_{g|D} C_{g-1}^{c-2} \mu(D/g))\\&amp;=\sum_{D=1}^{minM} (\prod ( (M_t/D) \times M_t-D \times (M_t/D)*(M_t/D+1)/2 )) \times (\sum_{g|D} C_{g-1}^{c-2} \mu(D/g))\\\end{aligned}$$后面那个 cmlogm 预处理为f(c,D)，则每组数据的复杂度为nmlogm到此为止都比较常规，然而还是无法处理多组数据，主要在于致命的枚举D此时很多人肯定会观察到式子中的整除，公所周知现在不同的 $\frac{M_t}{D}$ 只有 $n \sqrt m$ 个但是看到柿子中还有一个D，非常麻烦，但也仅仅只有这个东西是麻烦的，于是我们不妨把D当做未知数！所以我们依然可以用数论分块得出当前D的区间dl和dr，这段区间内中间的东西是个关于D的多项式，可以 $n^2$ 计算出 $D^i$ 的系数a$ans=\sum_{i=0}^n a_i \times ( \sum_{dl}^{dr} f(D) \times D^i )$后面那个可以cnM计算前缀和 组合数用递推式算f(i,c,D)枚举倍数暴力预处理总复杂度为 $O(cmlogm+cnm+Tn^3\sqrt m)$ undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>莫反</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【TJOI2015】线性代数]]></title>
    <url>%2Fposts%2F1b03.html</url>
    <content type="text"><![CDATA[ProblemTJOI2015bzoj3996 Analysis请先思考后再展开 把题意转化为点有点权，边有边权，求权值和最大的点导出子图然后想了想普通的网络流，感觉无法解决，然后就不会了其实是个最小割……好久没用了就完全没想到其实有经验的话，这种决策类的东西，不能贪心基本都是网络流了吧 最大化答案，即最大化总边权+点权-被舍去的部分如果一条边的两个点都没有被舍去，那么边权就必须舍去基于这个思路构图就好了]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>最小割</tag>
        <tag>出题</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小奇挖矿]]></title>
    <url>%2Fposts%2F1596.html</url>
    <content type="text"><![CDATA[ProblemNOIP模拟赛 Analysis请先思考后再展开 wo shi sb 考虑每个a的系数，这样就能直接做了undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>出题</tag>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[graph]]></title>
    <url>%2Fposts%2F405b.html</url>
    <content type="text"><![CDATA[ProblemBernard有n个结点，编号1至n，一开始没有边。现在Bernard要新建m条边，构成一个图。每一条新建的边都是无向边。但是要满足如下的条件：1、选择两个不同编号的结点X和Y，在X和Y之间建立一条边，前提是两个结点的编号的差不超过给定的参数k，即0&lt;|y-x|≤k。注意：允许在A和B之间建立多条边（即两个结点之间可以有重边）。2、当最终建完m条边之后，对于任意的一个结点i，与结点i相连的边共有偶数条。注意：0也被认为是偶数。问：总共可以构造出多少种不同的图？答案对1000000007取模。注意构出来的图可以是不连通的图。 1≤n≤30，0≤m≤30，1≤k≤8 Analysis请先思考后再展开 wo shi sb 一直不知道怎么处理重边但其实如果现在满足度数的奇偶性，那么每条边的重复次数是可以%2的所以最后用隔板法统计一下插入的边即可 f[i][j][S]表示考虑完点i有j条边，包括i在内的k个点的度数奇偶性枚举第i个点相关的边就能通过本题了更优秀的做法是考虑往前的每条边，这样就是 $O(nmk2^k)$ 不过并没有写 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>出题</tag>
        <tag>状压</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【3560】DZY Loves Math V]]></title>
    <url>%2Fposts%2Fb3c.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj3560 Record1h Analysis请先思考后再展开 这道题的第一步挺妙的就是显然你要把phi拆开来，然后一个很自然的想法就是利用其积性函数的性质那么我应该要考虑每个p的贡献，然后我就不会了…… $ans=\prod solve(p)$可以用一个乘法原理理解它，仔细想想就会发现是正确的（很多大佬直接跳过这步让我一开始觉得好懵逼）$$\begin{aligned}\sum \sum \sum_{c_i=0-&gt;b_i} \varphi( p^{\sum ci} )\\但需要考虑特殊的\varphi(1)=1\\1+\frac{p-1}{p} ((\sum \sum \sum_{c_i=0-&gt;b_i} p^{\sum c_i})-1) \\1+\frac{p-1}{p} (( \prod( \sum_{k=0}^{b_i} p^k ) )-1) \\\end{aligned}$$ 那么线性筛一下就是O(nlogn)的undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>出题</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【中山市选2011】完全平方数]]></title>
    <url>%2Fposts%2Fd03f.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj2440 Record30min Analysis请先思考后再展开 市选时代的题目，挺妙的就是你先考虑这种数怎么贡献到单一约数上然而即使你去除那些因子数&gt;1的约数，你发现并不只一个，然而这是可以容斥的然后你发现mu既能去除平方因子，又能帮你容斥然后你需要枚举的地方只有根号级别，mu可以用线性筛处理出来所以最后套个二分就好了，这个倒比较显然]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>容斥</tag>
        <tag>出题</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【cf407e】外星千足虫]]></title>
    <url>%2Fposts%2F27f0.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj1923 Record30min Analysis请先思考后再展开 为什么一大堆人都是直接用高斯消元做？我只会二分的……复杂度显然不优秀考虑动态插入，那么像线性基那样做就好了undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【cf407e】kd-sequence]]></title>
    <url>%2Fposts%2Fd7fc.html</url>
    <content type="text"><![CDATA[Source and Judgecf407ebzoj4527 Record1h Analysis请先思考后再展开 这个序列必须原本就满足所有数的差都是d的倍数（特判0）只需要一个数就能确定该序列对d的余数，所以可以将原序列分为一个个区间然后在值域上考虑插入k个数，即 (max-min)/d+1-(i-j+1)&lt;=k那么我们可以从左往右枚举r，用线段树维护上述柿子，在线段树上二分找答案指针的移动的话，可以用一个单调栈去准确更新，不难发现复杂度是nlogn]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>出题</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模拟赛】旅游【CC】Chef and Bike]]></title>
    <url>%2Fposts%2F17d8.html</url>
    <content type="text"><![CDATA[Problem【模拟赛】旅游：有一个点数为 n 边数为 m 的带边权有向图，可能有重边和自环，求从 1 号点到 n 号点，恰好经过 t 条边，边权和是 k 的倍数，这样的路径数，对 232792561 取模。 【CC】Chef and Bikehttps://www.codechef.com/problems/BIKE毕克出的题目输入 n(n ≤ 22) 个点，m(m ≤ 8000) 个边。每个边连接着点 (si, ei)，有两个长度 fi, ri。问对于每个点 k，有多少条路径（不一定是简单路径）由 t (t ≤ 10^9) 条边组成，从 k 开始，并且以 k 结束；并且路径上所有边 f 的和 mod n 为 x；并且路径上所有边 r 的和 mod (n − 1) 为 y。对于每一个 (x, y) 都要计算。方案数 mod 1163962801 输出。 Record2h Analysis请先思考后再展开 首先，这两题的模数都满足边权和模数任意，都能有对应的单位原根模数的原根分别是71和46 方法一：适用于【旅游】因为只需要求余数为0，可以利用一个式子： $\frac{1}{k} \sum_{i=0}^{k-1} g_k^{ni}=[n\%k=0]$这个式子知道DFT原理的一定知道，不知道也能一眼看出来是正确的（单位复数根和单位原根都适用）因为边权是求和的，那么作为次幂就是g的乘积然后矩阵乘法，维护所有方案的 $\sum( \prod w )$ ，这个东西根据乘法原理直接乘即可时间复杂度 $O(n^3 k log_t)$undefined 方法二：适用于【旅游】考虑矩阵里存多项式（千万别像我这样去想多项式里存矩阵，会自闭的），表示对k余数的生成函数那么这是一个对k的循环卷积，暴力DFT（可参考毛爷爷论文）即可复杂度为 $O(n^2k^2+n^3klog_t)$undefined 方法三：适用于【BIKE】这题就必须老老实实对k求余数了矩阵里面存矩阵，然后是一个二维的卷积，自己仿照一维的推一下即可$O(n^2k^4+n^3k^2log_t)$ undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度2</tag>
        <tag>dft</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Ahoi2005】航线规划【bzoj4229】选择]]></title>
    <url>%2Fposts%2Fa4df.html</url>
    <content type="text"><![CDATA[Source and JudgeAhoi2005bzoj4229bzoj1969 Record1h Analysis请先思考后再展开 仔细想想，发现就是求两点路径上割边数量这个删除很难处理，考虑时间倒流，动态加边一般图比较麻烦，考虑求一个生成树，因为其他边不可能是割边然后用其他边和加的边，更新路径即可，可以用树剖实现]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>思维</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj5040】未来研究]]></title>
    <url>%2Fposts%2Ff5d.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj5040 Record1h Analysis请先思考后再展开 本题题面仿照bzoj4241历史研究（带权众数），建议先去看看那道题，虽然不难注意到范围卡根号，注意到有个性质是区间只会分开或包含那么离线一下，询问呈树状，而且叶子节点的总长度在n以内 如果只是想求子树的信息，那么显然可以线段树合并，但因为是带权的，无法避免再扫一次所以我们希望一个个加入，这样答案就很好维护，所以考虑树上启发式，做法oi之路有 建树的话，可以单调栈 O(n) 建]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树上启发式</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小G的线段树]]></title>
    <url>%2Fposts%2F807.html</url>
    <content type="text"><![CDATA[Problem小G是一名OIer，他最近学习了一种高级数据结构——线段树，做题时，他遇到了如下的问题：维护一个序列，要求支持三种操作：1.区间加上一个数x2.区间赋值为一个数x3.求一个区间的和小G是一个爱思考的同学。他在做出来了这题之后，又提出了一个新的问题：如果把所有的操作随机打乱，那么每个询问的期望输出是多少呢？注意，随机打乱既所有m!种操作排列的出现概率均等。为了方便，我们假设询问在最后且不参与随机打乱。【输入格式】第一行两个整数n m q，分别表示序列长度、修改数和询问数接下来一行n个整数ai，表示序列的初始值接下来m行，每行4个整数c,l,r,x若c=1，则表示把区间[l,r]的元素加上x若c=2，则表示把区间[l,r]的元素全赋为x接下来q行，每行2个整数l,r，代表每次询问的左右端点。【输出格式】q行，每行一个实数，按照输入顺序分别为q个询问的期望答案答案保留3位小数【样例】5 4 82 3 3 3 31 1 3 21 3 5 12 2 4 12 1 3 41 12 23 34 45 51 32 51 5 5.0003.1673.5001.5004.00011.66712.16717.167 Analysis请先思考后再展开 考虑每个格子的期望值，并且把修改和添加分开设修改次数为a，修改权值和为val，添加权值和为add则格子的期望为 $\frac{val}{a}+\frac{add}{a+1}$undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ZJOI2007】捉迷藏 【SPOJ】QTREE4]]></title>
    <url>%2Fposts%2Fc89a.html</url>
    <content type="text"><![CDATA[Source and JudgeZJOI2007bzoj3136QTREE4 Record3h Analysis请先思考后再展开 首先因为修改，显然需要一个可删堆来维护信息 记录子树内前两条链，复杂度为平方，显然考虑点分治点分树上，点对的LCA一定也在原树两点路径上基于这点，对于分治节点x，每个孩子贡献一条链，然后拼接最长的两条放到答案里面f(x)存节点x的子树内孩子到x父亲的距离，g(x)存节点x的每个直接孩子的f(x)的堆顶用A存全局答案，也就是g(x)的前两个之和 复杂度显然log方但这道题非常容易写错细节……要留足够时间对拍undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>动态点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj3136】brunhilda]]></title>
    <url>%2Fposts%2Fb76f.html</url>
    <content type="text"><![CDATA[Source and JudgeBaltic2013bzoj3136 Record2h Analysis请先思考后再展开 首先有个结论，就是每个数搞完的次数是不递减的因为首先每个操作相当于按p分组，然后每组变为第一个，那么一个数只要小，以后都是小的，相对关系不会变$f(i)=f(j)+1$显然j是某个p的倍数 那么每个j，要向后最多，则找j的约数中在P里出现，最大的那个，以影响最大的范围这个可以线性筛出minp来实现递推 方法一，枚举每个j，用单调队列维护影响范围方法二，枚举每个i，观察j+vj&lt;=i的i是递增的，则决策点递增，可以维护指针扫过去]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF1110E】Magic Stones]]></title>
    <url>%2Fposts%2F8e88.html</url>
    <content type="text"><![CDATA[Source and JudgeCF1110E Record2h Analysis请先思考后再展开 看到这道题，就感觉应该是需要某些巧妙的转化，挺吃题量的，就放了赛后看题解，果然如此……不过转化方式比想象中简洁就是差分一下，然后不难发现就是交换相邻两个undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Noi2013】快餐店]]></title>
    <url>%2Fposts%2Fe514.html</url>
    <content type="text"><![CDATA[Source and JudgeNoi2013bzoj3242 Record2h Analysis请先思考后再展开 第一次写基环树（以前总觉得好麻烦啊不想写什么的……）这次写是没事干练练码力 如果是一棵树，那么一定是找直径的中点但在基环树上，直径的许多性质被破坏了，不能直接求图的直径考虑把基环树转化为树，首先断掉一条边不会使答案更优，而且一定有一条边去掉不会有影响（考虑对最优点到各个点的路径一定是树） 把环拉成序列，然后答案的下界是max 各个树内直径/2，而且断边不会影响这个，先处理好，最后更新ans然后设我们枚举的断边，右边的节点编号为k=1~cnt-1（从0开始）然后分情况讨论直径经过环上边的情况，是在断边左边a、右边c或者从右边开始去往左边b$$\begin{aligned}val是挂在这上面的树的最大深度，d是前缀环上距离\\A1(i)=&amp;前缀max的val-d\\B1(i)=&amp;后缀max的val-d\\B2(i)=&amp;后缀max的val+d\\0&lt;i&lt;k,a=&amp;A1(i-1)+d_i+val_i\\0 \leq i&lt;k,b=&amp;B1(k)+d_i+d_{cnt-1}+d_{cnt-1到0}+val_i\\k \leq i&lt;cnt,c=&amp;B2(i+1)-d_i+val_i\\ans=&amp;min(ans,max(a,b,c))\end{aligned}$$ 那么显然可以 O(n) 做了 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU6212】Zuma]]></title>
    <url>%2Fposts%2F4279.html</url>
    <content type="text"><![CDATA[Source and JudgeHDU6212 Record1h Analysis请先思考后再展开 好神仙啊，虽然正解看上去很简单 考试的时候一直往lrj之前一道经典区间dp方面想然而这是一道分类讨论转移的dp题（当然依然要合并同颜色的块） 直接分两半 通过消除中间的，合并两边，两边代价是补上去的 消除两块，使3个合并起来，那么中间一定只能是1个 还有一种情况，但似乎不会是最优解？就是四个球，然后先分别消除两边，然后把2和2合并。但不知道怎么排除这种情况另外，本题应该有非常多种写法 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF1110D】Jongmah]]></title>
    <url>%2Fposts%2F5fd7.html</url>
    <content type="text"><![CDATA[Source and JudgeCF1110D Record1h Analysis请先思考后再展开 一开始有些东西没想清楚就写，太菜了我写的是dp，然后比较无脑地记录了3个位置，然后当时觉得可以贪心到6以内3以上然后一直wa，只能过样例，但自己又举不出反例……当时曾经有缩小贪心范围的想法，但又觉得肯定没用就没有尝试……赛后看看别人的代码感觉差不多，就是上界不一样 那么认真想想，就是x，x+1，x+2最多2次，那么每个位置我们至少需要保留6所以只要不减少到6及以内，就贪心具体dp的话状态可以设两维的，但cf比较快就无脑3维了 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Noi2011】Noi嘉年华]]></title>
    <url>%2Fposts%2F1d84.html</url>
    <content type="text"><![CDATA[Source and JudgeNoi2011bzoj2436 Record2h Analysis请先思考后再展开 题意：n个值域为2n的区间分为A、B、C，要求A交B为空求固定第i个区间或不固定时的最大【A和B中小的集合大小】 那么我们希望求出F[l][r]表示这段值域区间A必选的答案那么我们考虑枚举前后A选择了多少然后我们需要f[i][t]表示前缀值前i个A选了t个区间，B最多选多少个后缀意义下自然也求一个g[i][t]，求的话就是枚举两人选的最后一段区间$f(i,t)=max{f(j,t)+num[j+1][i],f(j,t-num[j+1][i])}$这样就能求出第一问了，第二问目前是 $O(n^4)$$cal(l,r,a,b)=min{ f(l-1,a)+f(r+1,b),a+b+num[l][r] }$$F[l][r]=max{ cal(fl \leq l,r \leq fr,a,b) }$然后对于每个a，b应该是个二次函数，而且a增b减，用个指针即可undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>出题</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Coci2009】podjela]]></title>
    <url>%2Fposts%2F8a58.html</url>
    <content type="text"><![CDATA[Source and JudgeCoci2009bzoj3090 Record1h Analysis请先思考后再展开 因为不用求方案，不用考虑次序什么的，允许负数显然次数不会比点数多，因为每条边单向值很大而次数少，所以应该对次数背包而不是对值$$\begin{aligned}&amp; 设f(x,now)=maxup\\&amp; 1. f(y,b)&lt;ned\\&amp; f_1(x,a+b+1)=f_0(x,a)-(ned-f(y,b))\\&amp; 2. f(y,b) \geq ned\\&amp; f_1(x,a+b)=f_0(x,a)\\&amp; f_1(x,a+b+1)=f_0(x,a)+f(y,b)-ned\end{aligned}$$复杂度显然 $O(n^2)$ undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【cqoi2013】二进制a+b]]></title>
    <url>%2Fposts%2Fd59f.html</url>
    <content type="text"><![CDATA[Source and Judgecqoi2013bzoj3107 Record30min Analysis请先思考后再展开 dp做法比较显然然后这题可以O(1)，当构造来做]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ZJOI2011】细胞]]></title>
    <url>%2Fposts%2F6e7f.html</url>
    <content type="text"><![CDATA[Source and JudgeZJOI2011bzoj2323 Record2h Analysis请先思考后再展开 这题的两部分显然是分开的然后我就一直在想构造一个方案被重复计数的情况，然后发现构造不出来，但总觉得一定是存在的……样例太水所以没体现，恩一定是这样的想半天膜题解看到第一句话就自闭了，怎么你们都有这么好的直觉woc 总之我们只需要考虑分割方案带来的长度就好了，不需要考虑质量知道长度就好办了，不难发现是个fib$\sum fib[(\sum b_i)-1]=\frac{fib[1]}{A^2} \sum( \prod A^{b_i} )$$F_i=\sum F_j \times A^{num(j+1,i)}$然后注意一下矩阵的交换律即可$ans=F_n \times \frac{fib[1]}{A^2}$右边那个考虑一下A的实际意义，手推一下即可undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Baltic2004】sequence]]></title>
    <url>%2Fposts%2Fa3ae.html</url>
    <content type="text"><![CDATA[Source and JudgeBaltic2004bzoj1367 Record3h Analysis请先思考后再展开 首先让ai递增等价于让bi=ai-i不递减前置知识： 对于一个序列，如果变成相同的数，那么变成中位数的绝对值代价最小 两段序列合并的中位数，显然在两边中位数的值域区间内然后我们现在要寻找最小代价，肯定要在多个最优解中尽量找一个最容易算的形式，同理，我们说的中位数是指第 $\lceil \frac{n}{2} \rceil$ 小的数然后我们的思路主要是，对于一个不递增的序列，变成不递减的最小代价方案中一定有变成中位数 那么做法非常容易，每次加入一个数，作为一个区间和上一个区间比较，如果比上个区间的中位数小或相等，则合并两段区间，并用新的中位数作为这段区间的目标值，并不断往前这样做然后实现的话，用可并堆（如左偏树）是nlogn，否则是log方，堆顶就是中位数那样维护，两边都是奇数长度时缩1即可 但是这个做法的正确性呢？hyh的论文有一段没看懂，DraZxlNDdt的博客也有一段没看懂，捣鼓了几天（其实主要是过年巨颓废）才想出来（神仙写的东西依旧没看懂；哦说不定还是伪证？） 第一点，两段区间的中位数不递增的话（不仅是内部递减的情况），合并为新序列的中位数设前一段的中位数为u，后一段的中位数为v设中间的编号为t，设某个最优方案为b，显然只考虑 $b_t,v \leq b_{t+1},u$ 否则没必要说下去了（例如左边如果比u大，改为全部u不会更差，递增性也保证了）所以可以改为 $b_t,b_t,…,b_{t+1},b_{t+1}$此时已经非常棒了，然而还是不好求，考虑进一步转化，这里就比较容易了因为两边分别的代价是越接近中位数越小，显然两边不同是亏的，数学证明的话也很好推，分类讨论一下即可所以两边相同，然后显然取为中位数 第二点，新序列的中位数在保存的数中这个你会经历多个过程，首先你想着维护中位数可以log方，然后你可能会想把中位数放在堆顶，感觉很对，然后又想想万一中位数不在两个堆中呢？再仔细想想又可以证明不会出现这种情况（我觉得这个很难啊……）这需要我们仔细思考现在做法的细节我们现在担心的是，新的中位数出现在右边，而且比右边中位数大合并的时候一定是 $L_{mid} \leq R_{mid},L_{mid} \leq R_{mid_old}$然后因为只有一个数，显然 $mid_old+1=mid$然后因为新的中位数在它们之间，所以如果比右边中位数大的话，不会出现在右边，只会在左边画画图就能理解了，关键是这个细节是否能在证明的时候想到 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>左偏树</tag>
        <tag>好题</tag>
        <tag>难度3</tag>
        <tag>出题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HAOI2006】数字序列]]></title>
    <url>%2Fposts%2Fe4c.html</url>
    <content type="text"><![CDATA[Source and JudgeHAOI2006luogu2501 Record2h Analysis请先思考后再展开 目前本题一大堆人都是抄个n3方的代码完事（似乎难以证明复杂度），在此给出满n方的做法 使a递增等价于让bi=ai-i不递减第一问就是让不改变的最少，直接总长-最长不递减子序列然后第二问要求在第一问的前提下计算代价 结论：一定存在一种最优的区间调整方案，使得存在一个k，k左边和bj一样，右边和bi一样证明：首先对于能转移的j到i，之间的数要么比i大，要么比j小想象一下最后连续的值为一个横线，那么每个x坐标相当于有个橡皮筋在拉着横线往bi方向走那么如果最后的情况不是只有两段，那么总有木板往想去的方向，然后路上某个瞬间和【能任意上下的木板】合并这样最后总是只有两段的 那么先设中间所有人变成bi的代价为old，然后考虑一个分界点k，额外的代价= $(big_{left}-small_{left})*(b_i-b_j)$那么对于每个i，先预处理出$(big_{left}-small_{left})$的前缀和，然后倒序枚举j统计old即可 如果你仅仅是想ac本题，随便加点优化应该就行了]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>出题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SHOI2008】汉诺塔]]></title>
    <url>%2Fposts%2F8125.html</url>
    <content type="text"><![CDATA[Source and Judgeluogu4285 Record1h Analysis请先思考后再展开 这题是真的骚，以后复习一下吧反正我是被这个【看起来很noip的题目】搞自闭了方法一，dp方法二，递推]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>复习</tag>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOI2009】变换序列]]></title>
    <url>%2Fposts%2Feed2.html</url>
    <content type="text"><![CDATA[Source and Judgeluogu1963 Record1h Analysis请先思考后再展开 不难转化为求二分图完备匹配中的字典序最小对应方案匈牙利算法能很好地解决这个问题，从下往上枚举左边（越后优先级越高，类似基数排序），右边则从上往下复杂度为n方，不会太满（当时网络流不普及，这个正解合情合理）这时候就会有人想，为什么不dinic+一些建边顺序的调整呢，n根号呢然而dinic是bfs一次后多路同时dfs，缺乏匈牙利算法那种不断推开别人的过程一个显然的反例就是第一次就完备匹配 upd：rose爷爷给出了一个 O(n) 的做法因为每个点只连出去两条边，把点化为两个选择之间的边，那么如果不是基环树（或基环森林）就无解然后每个环的方向一定是相同的，环上挂的边一定是向外的，每个环独立地贪心即可因为可以计数排序，所以线性]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>匈牙利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串游戏]]></title>
    <url>%2Fposts%2Ff9d8.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj2121 Record2h Analysis请先思考后再展开 因为删除的都是序列，比较难思考，不妨想成删除一段区间中没被删除的部分，那么区间是个dag设 f(l,r,a,b)表示原串l到r，最后匹配第a个字符串（即l和r都是a的）的第b个字符然后为了方便转移，设v(l,r)表示能否删除转移显然，时间复杂度为 $O(L^3ab)$ 理论上是跑不满的，所以注意一些显然的优化即可]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JSOI2009】火星藏宝图]]></title>
    <url>%2Fposts%2Fae6f.html</url>
    <content type="text"><![CDATA[Source and JudgeJSOI2009luogu4056 Record2h Analysis请先思考后再展开 首先权值都都是正数，那么显然如果在一列路径上多一个点一定更优，所以每一列只会从最底下的那个转移然后这样就能nm做了，卡卡常可以过但这个式子显然是可以斜率优化的$f(i)=f(j)-(x-pos_j)^2-(i-j)^2+w_i$$f(j)-pos_j^2-2xpos-j^2=i(-2j)+(f(i)-w_i+i^2+x^2)$最小化截距，然后i还是单调的，那么每行维护一个斜率单降凸壳即可，复杂度m方]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UNR1】合唱队形]]></title>
    <url>%2Fposts%2Fd84e.html</url>
    <content type="text"><![CDATA[Source and JudgeUNR1uoj214 Record2h Analysis请先思考后再展开 不妨先考虑，n=m的时候如何简便地求出期望设总课程为A，需要的课程为B， $E=\sum_{i=0}^{B-1} \frac{A}{B-i}$那么预处理一下g1(B) 然后现在碰到第一个合法的序列就停止，但很难求，不难联想到min-max容斥然后max也非常好求，用二进制表示起点，直接套用上面的式子即可，时间复杂度为 $2^{n-m}(n-m)m$ 考虑m比较小的时候怎么做因为g1只和B有关，明显可以设一个dp统计每种B的系数设 $dp(i,S,tot)$ 表示前面的B=tot，然后现在在考虑第i位，然后用一个S表示前面的起点选择情况，用来辅助判断这次如果选，新产生的课程数量然后这个可以预处理一个g2(i,S)表示第i位选，i-m+1~i-1的选择情况下，新产生的课程数量然后对于每个二进制，在最后一个1出现的时候统计答案即可复杂度为 $O(26n^22^m+nm^2 2^m)$ （大概吧……） 那么对数据分治一下即可]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>min-max容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给自己的话]]></title>
    <url>%2Fposts%2F770.html</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【HNOI2013】游走]]></title>
    <url>%2Fposts%2F47af.html</url>
    <content type="text"><![CDATA[Source and JudgeHNOI2013loj2383 Record1h Analysis请先思考后再展开 我真是菜炸了$ans=\sum e_{边经过次数} w_i$那么只要能求出边经过次数的期望，贪心分配即可求边很麻烦，考虑求点$$Ept_1=1+\sum \frac{Ept_y}{dg_y} \\Ept_n=0 （不出去） \\Ept_i=\sum \frac{Ept_y}{dg_y} \\Eedge_i=\frac{Ept_x}{dg_x}+\frac{Ept_y}{dg_y}$$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JLOI2012】时间流逝]]></title>
    <url>%2Fposts%2Fada4.html</url>
    <content type="text"><![CDATA[Source and JudgeJLOI2012luogu3251 Record1h Analysis请先思考后再展开 这题感觉挺妙的，当然也可能很套路？注意到题目有个很显眼的性质，就是只能获得更小的值这就像个字典树什么的，总之就是一棵树$f(x)=1+pp \cdot f(fa)+\frac{1-pp}{tot} \sum f(son)$然后在树上，高斯消元可以做到线性，抓住唯一父亲这个特征，手动迭代具体而言就是把每个f(x)表示为 $k \cdot f(fa)+b$ ，这个显然是可以实现的记 $A=\frac{1-pp}{tot}$$f(x)=\frac{pp}{1-A \cdot \sum kson} f(fa)+\frac{1+A \cdot \sum bson}{1-A \cdot \sum kson}$每个状态用mi和sum表示，然后每个节点只存储k和b，答案为根节点的b（注意在根时pp=0） undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重返现世]]></title>
    <url>%2Fposts%2Fee60.html</url>
    <content type="text"><![CDATA[Source and Judgeluogu4707 Record3h Analysis请先思考后再展开 首先你需要熟悉kth-minmax容斥，我写了教程，自行搜索然后显然可以得到柿子（K=n-k+1）$Emax=\sum (-1)^{|S|-k} C_{|S|-1}^{k-1} Emin$然后注意到Emin只和【和】有关，显然按和dp一下，但如果仅dp数量的话，没法处理前面的部分，因为和1的数量有关 考虑直接把前面的和求出来，|S|变大1，就是多个-1，然后组合数需要变换一下这个套路可能需要熟练掌握…… $C_{|S|+1}^{k-1}=C_{|S|}^{k-2}+C_{|S|}^{k-1}$然后你会发现，就是k出现了变化 那么设状态 $dp(i,k,sum)$ 表示当前考虑了前i位，当前K=k，和为sum的系数和，需要滚动一下不难得出方程 $dp(i,k,sum)=dp(i-1,k,sum)+dp(i-1,k-1,sum-p_i)-dp(i-1,k,sum-p_i)$还有一个难点就是边界，这里困扰了我非常久，做法也非常秒$dp(0,0,0)=0,dp(0,1~K,0)=-1$ 正确性倒是显然…… undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>min-max容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PKUWC2019 游记与题解]]></title>
    <url>%2Fposts%2F2a15.html</url>
    <content type="text"><![CDATA[PKUWC2019菜鸡博主去不了ccf WC day1自闭了，被广大附中的大爷d飞了，才人家的一半…… t1：n个节点m条边，求边集的子集下每个图的合法拓扑序之和，n小于20题解：考虑统计贡献相同的排列出现次数设$f(S,tot)$表示当前用了S这些点，然后已知有tot条给出的边已知被满足，那么贡献次数就是$2^{tot}$然后直接dp就是$2^n n^3$的先考虑优化空间，按照1的数量滚动数组即可优化时间，灵光一闪发现可以只处理到选n/2个1，大概210000个，dp就很快乐然后关键是合并，一开始没有算复杂度就写写写，到这里以为要枚举tot1和tot2，心态就崩了，以为这个做法凉凉了，又忘记算一算后来因为有点不甘心又想了想，发现可以分别求和然后乘法原理起来然后卡卡常就过了，可能不是最优秀的做法，花了2.5h，同时间大把人已经切了两道题了upd：不难发现我sb了，状态的第二维是没有必要的，因为2的次幂不像阶乘那样不能分解 t2：n个点的树，每个节点有颜色，定义点集的虚树为内部路径的并求多少个颜色的集合，满足这些颜色的虚树的并非空n小于1e5题解：虚树的并还是树，然后贡献到树的深度最浅的节点上然后就不会了……大概是set启发式合并+生成函数+fft什么的 t3：地主斗，给定至少包含的牌，然后判多少种方案平手【无法在某次询问中一个能出牌另一个不行】，规则很繁琐题解：不会 day2上午是数学，啥都不会估计30左右，被爆踩 下午继续上机t1：给出3个长度为100值域在ll内的数组，求严格递增序列b，满足bi在[li,ri]内，而且是ai的超集经历：开场就写了个22的暴力，然后就不会了……题解： t2：对于有向图G求无向图G’，用简单环对应点，然后有公共边就连接，求其联通块数，n在2e5内经历：没时间写暴力了，爆0题解： t3：给出2e5个点，然后2e5次给定询问点，然后以原本的点为圆心，过询问点作圆，求最多去掉多少个圆后总面积不变经历：杠了一场，发现有趣的东西，理论上70分但过不去，调了很久搞不出来，把凸包去掉就拿了47题解： 我校两位神仙又让分了……]]></content>
      <categories>
        <category>竞赛历程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PKUWC2018题解]]></title>
    <url>%2Fposts%2Fbe4c.html</url>
    <content type="text"><![CDATA[太菜了当时没有去，（除斗地主外）题解合集感觉这套题的idea不错 Minimax请先思考后再展开 f[i][j]表示节点i，取值j的概率每个节点开个动态开点的权值线段树，维护区间概率和那么我们现在只要能合并两棵线段树即可 对于线段树节点x(权值=l~r)$$PX(p[left]down[right][l]+down[left][l]p[right])+\\(1-PX)((p[left](1-down[right][l])+(1-down[left][l])p[right]))$$ $$p[left]( PXdown[right][l]+(1-PX)(1-down[right][l]) )+\\p[right]( PXdown[left][l]+(1-PX)(1-down[left][l]) )$$那么两边有某个为空，则打个区间乘法的标记都有则暴力合并 那么我们计算一下线段树合并的复杂度，主要就是公共区域考虑每个叶子，只会被合并一次，此后再经过其祖先不算是他的贡献，那么就是深度也就是log所以说个人认为这个东西并不是由启发式保证的，而是只会被合并一次，严格和不公共的地方无关 Slay the Spire请先思考后再展开 首先，保证了单组数据在3000内，所以是可以n方的其次，因为翻倍牌都大于1，所以如果可以，出k-1张翻倍牌一定是最优的，否则当然是所有翻倍牌然后剩下的就非常容易了，应该也是签到题，不过我在一些细节的地方想错、写错了好多次 设fa(n,k)表示翻倍牌，考虑前n个用了k张的 $\sum 积$ ，然后根据美妙的乘法原理直接转移，但当k超过k-1的时候积的长度只能是k-1设fb(n,k)表示攻击牌，考虑前n个而且用了第n个的 $\sum 和$ ，然后为了转移需要再记录一个tb表示sum的数量设fr(a,b)表示攻击牌，选a个但求和b个的 $\sum 和$设fc(n)表示攻击牌，选m个然后 $\sum 第一个$ ，这个很好做然后我们枚举a和b=m-a表示两边分别选多少牌$a \leq k-1,ans+=fa(n,a) \times fr(b,k-a)$$a&gt;k-1,ans+=fa(n,a) \times fc(m-a)$那么不难注意到，有用的fr状态，a和b的差都是m-k，所以fr也能dp出来undefined 随机算法请先思考后再展开 方法一：$O(n^2 2^n)$设f(i,S)表示填了排列的前i个，当前独立集为S的方案数然后为了避免那些无法被独立集记录但在排列中的点被重复计算，尽管他们的边集情况不同，但对当前状态的影响都是相同的，那就是不能加入独立集，所以乘以【n-i-能加入S的点】就能不重不漏的计数了这种做法理论上的分数为50，但在oj上可ac 方法二：$O(n 2^n)$这时候我们不能再记录多一维了尝试直接dp概率而非计数，有的时候这样好做很多注意到对于一个点集，独立集=去掉独立集中的某个点以及其相邻的点后的独立集+被去掉的独立集中的点直接dp当排列的集合为S时的概率，枚举最后一个被加入独立集的点，转移就像上面说的那样然后【你感受一下】，觉得他们到这里的概率应该是相同的 undefined 方法三：$O(n 2^n)$这是我目前认为最靠谱的做法了就是你顺便记录每个集合，最大的独立集大小然后你只需要转移那些siz=mxsiz[S]的状态，也就是状态就少一维了然后这个和上面的思想也是吻合的 猎人杀有n堆石子，第i堆有wi个，每次随机选一颗石子，然后把整堆拿走，问第一堆最后拿走的概率请先思考后再展开 30分：按题意模拟 题意转化是本题的唯一难点1号最后被杀有点烦，容斥一下，固定后面还有多少个活着然后因为每次概率的分母变来变去很麻烦，考虑等效的转化：如果杀了一个已经死了的人，就重新杀一轮令A为权值和，S为被固定的和那么 $P=\sum_{i=0}^{\infty} (1-\frac{S+w_1}{A})^i \frac{w_1}{A}=\frac{w_1}{S+w_1}$$ans=\sum_{k=0}^{n-1} (-1)^k ( \sum_{S=0}^A times(S) \frac{w1}{S+w_1} )$$ans=\sum_{S=0}^A ( \sum_{k=0}^{n-1} (-1)^k times(S) ) \frac{w1}{S+w_1}$显然中间那个，构造一下生成函数即可$\prod (1-x^{w_i})$然后显然用分治ntt求每一层一定比AlogA小，共logn层，故复杂度为 $O(Alog^2A)$ undefined 随机游走请先思考后再展开 前置知识（套路）：min-max容斥、树上高斯消元、fwt（非必要）特性：有根树的根是固定的（不然就很麻烦了）问题转化为，对于每个点集S，求从根出发的期望步数$f(x)=\frac{1}{tot-\sum kson} f(fa)+\frac{tot+\sum bson}{tot-\sum kson}$最后统计答案时最好用fwt，复杂度为 $O(30n 2^n)$undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF960G】Bandit Blues]]></title>
    <url>%2Fposts%2F62ca.html</url>
    <content type="text"><![CDATA[Source and JudgeCF960G Record3h Analysis请先思考后再展开 考虑一些性质，发现最高点一定是n，然后左边关键点上升右边下降考虑n个位置，有k个是特殊点的方案数，考虑从大到小放入，考虑最小值的位置可得递推式$dp(n,k)=dp(n-1,k-1)+(n-1)dp(n-1,k)$发现这就是第一类斯特林数那么答案就是 $\sum_{i=1}^n {n-1 \choose i-1} S(i-1,a-1) S(n-i,b)$发现这样太慢了，主要原因是两个方向，考虑优化这个东西只从一个方向看，然后把b-1个翻转过去即可${a+b-2 \choose a-1} S(n-1,a+b-2)$一个log求斯特林数详见这里]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>ntt</tag>
        <tag>难度2</tag>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HAOI2015】按位或]]></title>
    <url>%2Fposts%2F1e94.html</url>
    <content type="text"><![CDATA[Source and JudgeHAOI2015luogu3175 Record1h Analysis请先思考后再展开 前置知识：min-max容斥那么我们现在希望求出【或出S的任意一位】的期望步数补集转化一下，发现只要求出补集的子集概率和，1除以概率和就是期望然后FWT一下，套柿子即可 不过我并不知道为什么不开long double会出现负数……undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>min-max容斥</tag>
        <tag>fwt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SDOI2015】序列统计]]></title>
    <url>%2Fposts%2F7068.html</url>
    <content type="text"><![CDATA[Source and JudgeSDOI2015luogu3321 Record1h Analysis请先思考后再展开 对M求原根g，对每个s以及x求g下的离散对数，化乘法为加法然后相当于对生成函数求循环卷积（循环长度为phi(M)，需要手动），ntt即可注意si可能为0undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>ntt</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雅礼集训]]></title>
    <url>%2Fposts%2Fcaf.html</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【arc082c】ConvexScore]]></title>
    <url>%2Fposts%2Fb53a.html</url>
    <content type="text"><![CDATA[Source and Judgearc082c Record30min Analysis请先思考后再展开 n四方：把每个凸包用最下面的点表示（多个则最左）然后极角排序后，跑一个dp，记录内部点的数量（暴力预处理三角形内点的数量） n三方：考虑贡献的形式，就是去掉凸包S后子集U数量然后就会发现（反正我是想不到的），S和U的并是独一无二的，那么只要统计有面积的集合数量即可枚举点，然后去掉重复计数即可 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>难度2</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF720D】Slalom]]></title>
    <url>%2Fposts%2Fbb3b.html</url>
    <content type="text"><![CDATA[Source and JudgeCF720D Record30min Analysis请先思考后再展开 显然是dp，每个位置存储到这里的方案数然后考虑怎么去重给出一个例子：每次向右更新，如果(x+1,y)上方存在某个矩形的边缘，则向上更新 考虑加速，发现dp中前面的信息是没用的，扫描线，每次询问区间和然后单点修改即可]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【WC2018】州区划分]]></title>
    <url>%2Fposts%2Ff65b.html</url>
    <content type="text"><![CDATA[Source and Judgeuoj348 Record5h Analysis请先思考后再展开 先预处理好每一种方案（用二进制表示）的可行性、总人口$f(p1,k) \times sum^p(k)=\sum_{i|j=k} (f(p2,i)) * (okay(p1-p2,j) sum^p(j))$因为是子集卷积，用fwt优化（有教程，第一维是二进制下1数量） 这东西你看起来需要做快速幂，但这样和暴力复杂度差不多了不从快速幂的角度思考，想着是一个无限背包保持前面的东西现在都是被fwt过的，那么你只需要枚举当前计算的p1，然后做出来当前的集合幂级数，然后Ifwt回去，把非法状态去掉，把分母补上去，再fwt回来时间复杂度 $O(n^2 2^n)$ 友情提示：判断合法性，记得要判断联通块数量…… undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>复习</tag>
        <tag>fwt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF528D】Fuzzy Search]]></title>
    <url>%2Fposts%2Fe5f5.html</url>
    <content type="text"><![CDATA[Source and JudgeCF528D Record2h Analysis请先思考后再展开 忘记round了，结果本机还对了……调了很久 这道题还是有点妙的注意到字符集很小，可以逐种字母处理s1是母串，s2是模式串发现这种对齐，然后往后推，然后匹配这种东西，把串反过来，和卷积很像设 $A_i=s2[i]==c,B_i=s1[n-i+1]附近是否含有c$那么Ci就表示从i开始倒着对齐 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>fft</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF553E】Kyoya and Train]]></title>
    <url>%2Fposts%2F7565.html</url>
    <content type="text"><![CDATA[Source and JudgeCF553E Record2h Analysis请先思考后再展开 分治+fft可能是个套路？第一次接触还是有点妙的通过倒推dp期望，规避动态决策这个让人望而却步的条件 注意到边的时间不会是0，所以是个dag，可以dp$f(ti,x)=min ( cost_e + \sum f(ti+k,y) \times P_{e,k} )$然后倒过来就是个卷积，但我们必须要按时间处理，而且看上去边界很多？按时间分治可以轻松解决这些问题，每次把右边处理好，然后用右边更新左边，这样用到的东西是确定的具体的卷积坐标，常规地变换一下即可，请自行yy 然后细节还是很多的，比如分治边缘的，对于没有更新到的地方的恰当补充（没想清楚写错好几次，花费大量时间调试）然后超时用T+1表示，代价用最短路即可时间和代价要分清，不然手算数据容易错…… 时间复杂度为 $O(m T log^2 T)$然后有一个小trick，相同长度时，预处理omega，速度快了一倍然后因为我们只需要次幂为mid~r以内的，所以倍增到1.5倍而非2倍的r-l，可以再快一倍undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>fft</tag>
        <tag>难度2</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF623E】Transforming Sequence]]></title>
    <url>%2Fposts%2F7fbd.html</url>
    <content type="text"><![CDATA[Source and JudgeCF623Ebzoj5381 Record5h多项式题迟早要调，不如早调，先玩玩样例什么的…… Analysis请先思考后再展开 若n&gt;m（即题目中的k），显然无解 考虑朴素dp，设位置和已经填了多少个1（容易发现具体是谁并不重要）$f(1,t)={m \choose t}$$f(x,i)=\sum f(x-1,j) {m-j \choose i-j} 2^j$这东西随便变换一下坐标，是个卷积，直接做复杂度为 $n^2 logn$瓶颈在于每次只加入一个数，没有彻底利用dp的结果，考虑一次加入多个但这时要注意状态的设立，不能考虑到具体的总数，因为是不确定的，需要在最后还原（反面教材：一开始的想法 $f(x+y,i+j)=\sum f(x,i) \times f(y,j) \times {m-i \choose j} \times 2^{iy}$） $f(x+y,i+j)=\sum f(x,i) \times f(y,j) \times {i+j \choose j} \times 2^{iy}$然后我看这玩意半天没看出啥……非常尴尬原来把f()看做多项式，那么x和y随便一对即可，可以快速幂解决$A_x(i)=f(x,i) \times \frac{1}{i!} \times 2^{iy}$$B_x(i)=f(x,i) \times \frac{1}{i!}$$C_x(i)=f(x,i) \times \frac{1}{(i+j)!}$$C_{x+y}(n)=\sum A_x(i) \times B_y(n-i)$时间复杂度为 $O(nlog^2n)$ 因为模数没有原根，要拆系数fft，OI之路中有相关教程undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>fft</tag>
        <tag>难度2</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj2839】集合计数]]></title>
    <url>%2Fposts%2F105f.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj2839 Record1h Analysis请先思考后再展开 考虑选哪k个，因为并集恰好为这k个，所以是不会有重复的，方案数为 ${n \choose k}$然后固定这k个，其他任意选择，设并集至少多i个，则选数方案数为 ${n-k \choose i}$然后，共有 $n-k-i$ 个元素， $2^{n-k-i}$ 个集合， $2^{2^{n-k-i}}-1$ 个方案（不能是空）$ans={n \choose k} \sum_{i=0}^{n-k} (-1)^i {n-k \choose i } (2^{ 2^{n-k-i} }-1)$ nlogn的话，注意到p是质数，所以幂的部分%(p-1)即可然而这道sb题会tle……必须要 $O(n)$那么随便递推一下逆元和2的次幂即可 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HNOI2012】集合选数]]></title>
    <url>%2Fposts%2F462d.html</url>
    <content type="text"><![CDATA[Source and JudgeHNOI2012bzoj2734 Record1h Analysis请先思考后再展开 本题难点：画个图出来……你会发现是一个三角形网格图，然后独立集计数因为边具有这种网格状的特性，直接状压dp即可复杂度理论上很低，但很难计算 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF235E】Number Challenge]]></title>
    <url>%2Fposts%2Fa959.html</url>
    <content type="text"><![CDATA[Source and JudgeCF235E Record2h Analysis请先思考后再展开 弟弟题：sdoi 约数个数和 一直在想怎么把约数个数联系到gcd上，结果原来是个结论: 约数与欧几里得 文章末尾第5条 $\sum \sum \sum d(n \cdot m \cdot k)$$\sum \sum \sum \ \sum \sum \sum [gcd=1][gcd=1][gcd=1]$直接枚举约数，降低复杂度$$\sum_x \sum_y \sum_z\lfloor \frac{a}{x} \rfloor\lfloor \frac{b}{y} \rfloor\lfloor \frac{c}{z} \rfloor[gcd(x,y)=1][gcd(x,z)=1][gcd(y,z)=1]$$然后，把mu的性质柿子带入（看到等于1，可以考虑这样搞，是个套路）$$\sum_x \sum_y \sum_z\lfloor \frac{a}{x} \rfloor\lfloor \frac{b}{y} \rfloor\lfloor \frac{c}{z} \rfloor( \sum_{d|x,d|y} \mu(d) )[gcd(x,z)=1][gcd(y,z)=1]$$这样的好处是能通过枚举d找其倍数得到x和y（从根号变为log，尽管刚带入的时候感觉复杂度变大）调整一下枚举顺序，第二个好处也凸显出来了，就是取消了x和y的关系，让其可以分开求和再乘起来$$\sum_d \mu(d) \times\sum_z (\lfloor \frac{c}{z} \rfloor \times(\Sigma_{d|x} [gcd(x,z)=1] \lfloor \frac{a}{x} \rfloor) \times(\Sigma_{d|y} [gcd(y,z)=1] \lfloor \frac{b}{y} \rfloor))$$预处理gcd后，由调和级数可知复杂度为 $O(n^2logn)$可见定理和mu的性质为本题最关键的两步 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>莫比乌斯</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jzptab]]></title>
    <url>%2Fposts%2F6322.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj2693 Record2h Analysis请先思考后再展开 建议先做yy的gcd和数表 感觉这道题是po姐ppt里面最综合的一道题考虑枚举公约数tt，反演其乘积$a=\lfloor \frac{n}{d} \rfloor,b=\lfloor \frac{m}{d} \rfloor$$F(d)=a(1+a)b(b+1)/4 \cdot d^2$然后把gcd放缩，但因为这次求乘积，要还原$ans=\sum_{tt} tt ( \sum_d \mu(d) \cdot F(d) )$ （F中n=n/tt）套路的换元应对多组数据$T=tt \cdot d$$$ans=\sum_T\lfloor \frac{n}{T} \rfloor (\lfloor \frac{n}{T} \rfloor+1)/2\lfloor \frac{m}{T} \rfloor (\lfloor \frac{m}{T} \rfloor+1)/2\times( \sum_{d|T} \mu(d) T \cdot d )$$然后后面那个是积性函数，随便记录一个质数幂，就可以筛了时间复杂度为 $O(n+T \sqrt n)$ undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>莫比乌斯</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SDOI2014】数表]]></title>
    <url>%2Fposts%2Fa143.html</url>
    <content type="text"><![CDATA[Source and JudgeSDOI2014loj2193 Record2h Analysis请先思考后再展开 建议先做yy的gcd 枚举 $gcd(i,j)=tt$然后a这个东西很恶心，先假设没有这玩意$ans=\sum \sigma(tt) \times times(tt)$$$times(tt)=\sum_{i}\lfloor \frac{n}{tt \cdot i} \rfloor\lfloor \frac{m}{tt \cdot i} \rfloor\mu(i)$$和yy的gcd一样，换元推柿子，设 $T=tt \cdot i$$$ans=\sum_T\lfloor \frac{n}{T} \rfloor\lfloor \frac{m}{T} \rfloor(\sum_{tt|T} \mu(\frac{T}{tt}) \cdot \sigma(tt))$$ 然后a的话，离线排序，用树状数组维护前缀和即可]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>莫比乌斯</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj4644】经典傻逼题【集训队互测2015】最大异或和]]></title>
    <url>%2Fposts%2Fa417.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj4644集训队互测2015uoj91 Record1h Analysis请先思考后再展开 这两题都要先用异或的性质转化题意对于【经典傻逼题】，把边权异或到点权上对于【最大异或和】，把序列异或差分一下那么现在的目标都是一个支持删除的线性基，以【最大异或和】为例 这种看起来非常难删除的东西，有一个有趣的套路观察操作，发现有用的数字只有n+m个把每个数按照出现时间排序，贪心地对结束时间处理 具体而言，维护线性基并惯例地从大往小扫，如果线性基上结束比当前的完，则被替代，然后把拿出来的这个往后更新那么如果需要删除的时候，一定没有替代方案，所以能够直接删除掉 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线性基</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ZJOI2016】小星星]]></title>
    <url>%2Fposts%2Fa379.html</url>
    <content type="text"><![CDATA[Source and JudgeZJOI2016uoj185 Record1h Analysis请先思考后再展开 真心妙 注意到给出的是一棵树，然后暴力是阶乘级别的一个计数问题树上的话可以有序处理，点数较少，不难猜到或者通过经验判断出，应该考虑一个指数级树形dp这个dp非常好写，但复杂度为 $O(n^3 \cdot 3^n)$ ，和暴力区别不大考虑到编号的dp几乎无法优化，然后这个枚举子集的部分非常耗费时间、空间 究其本质，还是因为【编号不能映射到相同的新编号】，所以需要存储一个已经被使用过的编号集合如果去掉，然后通过容斥来满足上述的条件，就可以降低到 $O(n^3 \codt 2^n)$虽然高达6亿，而且个人感觉是满的，感觉上只能拿到60分，但似乎后面的40分都是卡常分……]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CQOI2012】局部极小值]]></title>
    <url>%2Fposts%2Fe62b.html</url>
    <content type="text"><![CDATA[Source and JudgeCQOI2012luogu3160 Record1h Analysis请先思考后再展开 在最坏情况中，可选的区域都是极小的那么考虑每种局部极小值的状态，然后容斥组合起来就好了对于每种情况，相当于一个非常规计数，考虑用dp来统计答案从小到大考虑每个数，那么局部极小值一定需要比周围8个先填那么只有3类点，一个是完全不被覆盖，一个是被解锁，一个是未被解锁那么随便dp一下即可 然后目前时间复杂度难以计算，但明显（随便画点情况）能感受到可行方案极少然后我们的dp也是非常快地，因为极小位置最多只有8个]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SHOI2006】有色图【HNOI2009】图的同构记数]]></title>
    <url>%2Fposts%2F694.html</url>
    <content type="text"><![CDATA[Source and JudgeSHOI2006luogu4128HNOI2009luogu4247Sgu282 Isomorphismbzoj1478 Record1h Analysis请先思考后再展开 好题 以有色图为例，其他都是子问题思路显然是找点循环，然后得出边循环如果a和b不在同一个循环中，那么显然a-&gt;b的边循环大小=lcm(siza,sizb)，所以有gcd(siza,sizb)个循环在一个循环中，需要根据大小的奇偶性分类讨论如果是奇数，则有siz个(siz-1)/2大小的循环如果是偶数，会有1种特殊情况，长度为siz/2；其他 $\frac{siz}{2}-1$ 个长度为siz所以 $C(f)=\sum \lceil \frac{siz}{2} \rceil + \sum \sum gcd(siza,sizb)$ 然后f有阶乘个，显然不能枚举，注意到我们只关心其siz信息，则考虑siz的数量$\sum siz=n,siz有序排列$方案数60时为100000内那么dfs枚举数的划分即可，然后对于一种方案，其出现的次数，可以想象为 $n!$ 个排列，依次放入多个圆排列中因为是圆，然后大小相同的看做等效，所以方案数为 $\frac{n}{ \prod siz \times \prod siz值出现次数}$ 时间复杂度的话，主要是C的计算，在预处理完gcd后还是相对玄学通过写代码验证，得知n=60时，复杂度在一亿以内]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>群论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CTSC2010】珠宝商]]></title>
    <url>%2Fposts%2F5359.html</url>
    <content type="text"><![CDATA[Source and JudgeCTSC2010luogu4218 Record10h Analysis请先思考后再展开 存模板好题做这道题真是历经了各种奇奇妙妙的状态……抱着驯化题解的心态，最后逐渐被题解驯化…… n和m同阶，用n表示先考虑一些暴力的做法 A暴力从每个位置出发，然后用dfs枚举每条路径，在sam上跳，得到出现次数时间为 $块大小^2$ B（非常不显然……本题七成时间都用在理解这上面了）对于树上节点z作为lca的路径，从z出发，用dfs遍历子树内节点，那么z-&gt;x应在原串中出现，z-&gt;y应该反串中出现则建立原串和反串的sam，并尝试把路径加入因为要跳parent，还需要处理出其孩子指针tson，细节也挺多跳到位置后打上标记，那么还应更新包含其的字符串，即其子树，最后往下推标即可然后这部分需要扫描整个子树，同时扫一遍sam因为是无根树，考虑点分治，复杂度降低到 $O(nlogn+n^2)$ A+B注意到A的优势是只和块大小有关，B则适合大的块，故考虑根号分治，设阈值为T分析一下复杂度，比T小的块，在进行一次后不需要向下计算，所以是互不重叠的，那么复杂度为 $\frac{n}{T}\times T^2$然后B的话，比T大的块最多 $\frac{n}{T}$ 个（可根据二的次幂的性质得出）$nT+\frac{n^2}{T}$ ，当 $T=\sqrt n$ 取得最小值 $O(n \sqrt n)$ undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sam</tag>
        <tag>好题</tag>
        <tag>难度3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Ahoi2013】差异]]></title>
    <url>%2Fposts%2Faba4.html</url>
    <content type="text"><![CDATA[Source and JudgeAhoi2013bzoj3238 Record30min Analysis请先思考后再展开 做法一：sa求两两lcp之和，则从前往后按排名扫描每个后缀然后用权值线段树维护【从每个后缀开始到这里的最小值】的和等信息那么每次就是把比当前hei小的取出来做差，删除掉并等量替换成当前hei时间nlogn upd:其实也是可以n的，而且更好些，用的还是你琛爷的套路从大到小枚举长度，并查集合并的时候把siz乘积累加进答案 做法二：sam把串反过来，巧妙的变成【前缀两两的后缀】这个东西用parent树的性质：两点lca所以染一下色然后就是求每个节点是多少对染色节点的lca这个随便统计一下即可时间为n]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sa</tag>
        <tag>sam</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj2865】字符串识别【bzoj1396】识别子串]]></title>
    <url>%2Fposts%2F333f.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj1396bzoj2865 Record2h Analysis请先思考后再展开 做法一：sam求出出现一次的字符串其形式一定是，知道右端点，然后长度至少为某个值后即出现一次也就是说其贡献是min~right的区间取min和max~min的等差数列离线后用单调队列（用并查集，按值从小到大处理也行）、栈即可时间复杂度 $O(n)$但过不了2865，被卡空间undefined 做法二：把sam换成sa即可节省空间，复杂度为nlogn]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sa</tag>
        <tag>sam</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【APIO2014】回文串]]></title>
    <url>%2Fposts%2Fec10.html</url>
    <content type="text"><![CDATA[Source and JudgeAPIO2014luogu3649 Record1h Analysis请先思考后再展开 做法一：思路挺妙的建出sam后，求出每个位置right集合的大小siz和最大值rmax然后反串在上面跑，时刻维护最长的公共子串，设其在原串中是[l,r]，如果包含了当前状态的rmax，则[l,rmax]为回文串，而且是r=rmax里l最小的那么现在就需要在这个回文串内部寻找回文串，因为可能次数更多那么每次就暴力向上找，但为了保证复杂度打一个v标记，这个状态打过，就不用向上了这样就保证了复杂度为n 做法二、三：这个相对来说又好想，复杂度又显然先建好sam然后manacher，只有回文半径增加的时候才会有不同的贡献（也就是所谓本质不同的回文串）找到以后，去sa、sam上随便找到出现次数即可（sa二分，sam的parent树right集合，需要预处理1~ed的位置然后在上面倍增，相对麻烦）复杂度nlogn]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sam</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj3277】串]]></title>
    <url>%2Fposts%2F8cf7.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj3277 Record1h Analysis请先思考后再展开 方法一、后缀数组 拼起来求后缀数组，然后用尺取法求出对于排名i的后缀，往左边到ll才覆盖不同的k个字符串然后对于每个字符串的每个后缀，枚举其前缀来获得子串，设长度为L它的出现次数不方便直接求，但可以简单地用st表+二分在height数组上求出包含它的左右后缀区间，然后用ll判断即可然后注意一个性质，就是每个地方只会被作为终点一次，所以总势能是n的故总复杂度为nlogn，还是非常妙的，而且似乎可以解决一类问题？ 方法二、广义sam在线把所有字符串依次插到sam里面，两个串之间把lst记为rt，从头开始（如果rt有字符c的孩子，则新节点没意义，但代码无需改动）插入每个字符后跳nxt更新直到其他字符串留下的节点（此处复杂度不会证明，国家集训队论文上说是n根号的），修改其时间戳mk以及覆盖串数量cnt然后统计答案的话（要把同一个串多次出现的统计到），就是扫每个前缀的后缀，这个随便dp一下parent树上到根路径权值即可undefined 改进：修改parent的时候，用树链剖分，找到链上第一个mk=strid的位置这个可以利用strid最大的性质，线段树维护最大值的位置即可，时间为log方 upd:rose提供的思路跳parent的复杂度，对每个串分析，最坏为len方，但又不超过总长问题转化成， $a&gt; \sqrt n,a最多 \sqrt n 个$ $a&lt;\sqrt n,max \sum a^2 \leq \sqrt n \sum a \leq n \sqrt n$故总复杂度为n根号 方法三、广义sam+启发式合并用set维护出现在哪些字符串，插入完后在parent树上启发式合并上去这个的时间复杂度也是log方，但空间不太会证明 rose:卡set的话让sam里所有状态都要出现在一个串里 方法四、可以给每个节点一个id，然后离线一下就是多次询问一个区间不同数的数量这是个套路，离线后树状数组即可可前往akc的blog看代码 总结：感觉这题挺不错的，值得细细琢磨等以后回来看看，或许会有新的感受]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sa</tag>
        <tag>sam</tag>
        <tag>好题</tag>
        <tag>难度3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BJWC2010】外星联络]]></title>
    <url>%2Fposts%2F7fcf.html</url>
    <content type="text"><![CDATA[Source and JudgeBJWC2010bzoj2251luogu4341 Record1h Analysis请先思考后再展开 水题后缀排好序，然后每个后缀访问其前缀，向后面暴力询问hei总势能显然是n方的 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sam</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SP8222】NSUBSTR]]></title>
    <url>%2Fposts%2Fd300.html</url>
    <content type="text"><![CDATA[Source and JudgeSP8222luoguSP8222 Record1h Analysis请先思考后再展开 模板练手好题 方法一：后缀数组+并查集，xgc大佬教的新姿势先明确，它一定是递减的，而且如果前面某个长度出现过，那么后面也会出现核心思路：如果某个答案出现至少两次，一定会被两个不同的前缀的lcp覆盖想象在字典序排名上，相邻两个后缀之间的间隔，逐渐消失那么用并查集维护最大联通块即可undefined 方法二：sam，建出parent树在树上做一次dp，right集合意味着出现次数，影响的答案范围是min~max又因为上面提到的性质，不用写数据结构更新，只修改max，最后更新一下即可undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sa</tag>
        <tag>sam</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POI2008】KUP]]></title>
    <url>%2Fposts%2F478c.html</url>
    <content type="text"><![CDATA[Source and JudgePOI2008bzoj1127 Record1h Analysis请先思考后再展开 建议先从一维开始考虑，如果有任何一个在目标区间内，直接判掉那么现在只有两类，比k小和比2k大观察到所有权值都是非负数，观察取值范围，如果矩形内的数都是k以内的，那么不会因为多加一个数而跳过目标范围那么只有找出每个类型一的区域的和，如果大于等于k，那么一定在内部存在一个合法解 拓展到二维，等价于把比2k大的看做障碍点，然后求最大子矩阵及其位置这个可以用悬线法或者单调栈来做]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POI2014】Hotel加强版]]></title>
    <url>%2Fposts%2F40b6.html</url>
    <content type="text"><![CDATA[Source and JudgePOI2014luogu3966 Record2h Analysis请先思考后再展开 考虑三个点两两距离相同的性质： 一定存在一个点，到他们的距离相同 对于这个中介点而言，只有【三个都在下面】和【一个子树外两个子树内两种情况】两种情况 设f(x,a)表示x子树内与x距离为a的节点数量g(x,a)表示x子树内有两个节点a和b到其lca的距离皆为d，lca到x的距离为d-a的点对数量 然后跑一个常规的树形dp即可$ans+=f(x,a-1) \times g(son,a)+g(x,a+1) \times f(son,a)$$g(x,a-1)+=g(son,a)$$g(x,a+1)+=f(x,a+1) \times f(son,a)$$f(x,a+1)+=f(son,a)$要稍微注意一下先后顺序等细节 时间和空间复杂度依然为n方，但拥有了优化空间日常被卡常，不管了undefined 不难发现，时空都是由n和深度组成观察dp式，有一些神奇的性质：首先遍历长儿子，可以O(1)通过指针（这个上网抄吧……没学过）转移（因为没有统计答案的部分）然后非长儿子的转移复杂度为其长链复杂度，根据长链性质可知总时间为n于是剩下的难点就是指针的各种运用了，和我一样 空间的话，不是通过长儿子到父亲，而是把长儿子的指针指向父亲，但注意需要的空间是两倍的，因为有指针的小偏移然后给短儿子，也就是链顶开新空间 因为是指针数组，边界有点多，要细心判断undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>长链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOI2011】阿狸的打字机]]></title>
    <url>%2Fposts%2F4d55.html</url>
    <content type="text"><![CDATA[Source and JudgeNOI2011luogu2414 Record30min Analysis请先思考后再展开 显然先把ac机和fail树建好如果不离线，你需要每个字符串开一个以dfs序为下标的动态开点线段树，然后和上一个合并……（强制在线走一走~）但随便离线以后，只要用树状数组维护当前的字符串信息，就非常方便而快速了]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>ac自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【TJOI2013】单词]]></title>
    <url>%2Fposts%2Fa82a.html</url>
    <content type="text"><![CDATA[Source and JudgeTJOI2013luogu3966 Record1h Analysis请先思考后再展开 题意有点晦涩，就是求每个字符串在别的字符串中出现次数只和+1跑ac机，建出fail树，每个点的点权为被多少个字符串经过，则答案为每个字符串结尾，fail树上子树权值和undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>ac自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HNOI2009】有趣的数列]]></title>
    <url>%2Fposts%2Fcf6b.html</url>
    <content type="text"><![CDATA[Source and JudgeHNOI2009luogu3200 Record1h Analysis请先思考后再展开 难受啊，想了各种奇怪的东西……发现条件都是一些小于的限制，而且是排列，想象拆成奇数和偶数两个序列，往里面从小到大塞数那么条件3就是要求任意时刻，放在奇数的&gt;=放在偶数的，即卡特兰数]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AHOI2012】树屋阶梯]]></title>
    <url>%2Fposts%2F1394.html</url>
    <content type="text"><![CDATA[Source and JudgeAHOI2012luogu2532 Record30min Analysis请先思考后再展开 不错的题目，但要写高精度差评题意就是用n块长方形拼成高度为n的阶梯的方案数从脚踩的那n个突出地方考虑会非常方便，因为是矩形 从最特殊的最左边那一列开始考虑，显然这里的矩形T，宽只能是1，枚举长i画画图找性质后会发现会分割成两个块，之间是不能连接的即T向右覆盖的部分，以及下面的剩余部分右边部分是一个标准的阶梯，下面的部分就是阶梯的延长，显然答案不变$f(n)=\sum_{i=1}^n f(i-1) \times f(n-i)$即卡特兰数]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HNOI2014】世界树]]></title>
    <url>%2Fposts%2Fc70a.html</url>
    <content type="text"><![CDATA[Source and JudgeHNOI2014loj2206 Record3h Analysis请先思考后再展开 对于每个询问建一个虚树（写过教程），然后先在树上面处理出每个节点所属的集合，二次扫描即可 那么对于每条边，其实是一个原树上的链，以及链挂着的节点（不包含首尾即虚树节点挂着的点，后面再统一处理）如果两段所属都在同一个集合内，那么中间的显然也是否则，非链上的点一定要先走到链上，所以从链上考虑距离，找到中间的节点 最后就是一些节点没有被处理过，有两种类型：虚树根之外的点、仅仅挂在虚树上的点为了方便处理，可以强制把1塞到虚树里面，第一类就被转化为虚树边了剩下的点都有个性质，到任何一个关键点，总是先要到达虚树上的点的（其实和虚树边链上的一样），记录每个节点，有多少个挂着的点没有被处理即可 感觉细节还是蛮多的这个中间点的选取有点讲究而且很容易写错啊……还好样例很强 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>虚树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BJOI2018】治疗之雨]]></title>
    <url>%2Fposts%2Fc2cf.html</url>
    <content type="text"><![CDATA[Source and JudgeBJOI2018loj2513 Record2h Analysis请先思考后再展开 常规地倒推dp求期望，因为会奶，未知数间有依赖性那么搞定dp方程，然后高斯消元$f[0]=0$ ，所以共n个未知元显然不能暴力消元，但注意到矩阵基本上是规则的三角，不过可能左边无法到达而已 那么每次往下消元的只有一个元而已 现在唯一的问题就是在时限内计算出正确的转移系数了$S-&gt;S2，z=S2-S$当z=-1，就是一开始奶脸，然后全打随从：$$\frac{1}{m+1} (\frac{m}{m+1})^{k}$$ 除此之外： ①如果到0，因为已知未知数为0，系数无关紧要（虽然也能算）②尚未死亡，那么要恰好受到z点伤害如果能奶脸，考虑一开始奶了什么（方括号表示布尔）：$$[z+1 \leq k] \frac{1}{m+1} C_k^{z+1} (\frac{1}{m+1})^{z+1} (\frac{m}{m+1})^{k-z-1}+\frac{m}{m+1} C_k^z (\frac{1}{m+1})^z (\frac{m}{m+1})^{k-z}$$否则： $C_k^z (\frac{1}{m+1})^z (\frac{m}{m+1})^{k-z}$ 预处理一下 $f(a)=C_k^a \frac{m^{k-a}}{(m+1)^k}$ 即可时间为 $O(Tn^2)$ 但不知道为什么是别人10倍的时间，精a了…… undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【置顶】套路集锦]]></title>
    <url>%2Fposts%2F80c8.html</url>
    <content type="text"><![CDATA[套路集锦 一、解题思路1需求：最大化最小值、最小化最大值做法：二分答案举例：一抓一大把 2有些题可以从简单情况着手然后拓展到复杂情况（数学归纳法或者总结经验、模仿）或者先考虑普通情况，再考虑改进来解决特殊情况举例：noi2015 荷马史诗poj2442 Sequence平面几何，先研究三角形 3研究原问题较复杂时，可能取补会让问题简单化举例：Ch6401 创世纪各种组合数学题 4各种拆点姿势：按照时间等递增坐标按照出度和入度 5对于比较陌生的题目操作形式，可以多造几组数据来模拟，找到一些性质，用这些性质转化题目为简单问题 6对于某些有后效性的操作把时间倒流或许会有帮助举例：【bzoj5040】航线规划【bzoj4229】选择 7平方形式，可以转为为数点对，或者用二次项定理拆开来（内部有东西的时候）举例：NOI2009 管道取珠蔬菜 8目前碰到处理棘手的删除问题的方法主要有两个，基本都需要离线一个是倒着做，这个对题目的要求较高另一个是贪心，离线后按出现时间处理，然后按结束时间贪心举例：【bzoj4644】经典傻逼题【集训队互测2015】最大异或和 9某些dp柿子等，含有组合数的变换时可以利用组合数的性质优化、转移，例如组合数的递推式举例：重返现世，有题解 关于动态点分治点分树上，点对的LCA一定也在原树两点路径上 二、枚举方法1有关区间问题并用到区间最值，求出l[i]和r[i]表示第一个比a[i]大的位置，则l[i]+1~r[i]-1中间，用到的最大值都是a[i]不过要小心最大值相等而重复的情况，可以强行把左边界改严格来限制洛谷18年7月月赛T4 2按照akc说的，碰到搜索，无脑倒序举例：poj1190 生日蛋糕虫食算 3当出现连续的$\lfloor \frac{n}{i} \rfloor$时，值一定是单调不递增的，同值的区间可以合起来计算复杂度：$O(\sqrt n)$① 当$i \leq \sqrt n$,分母只有$\sqrt n$种② 当$i &gt; \sqrt n$,$\lfloor \frac{n}{i} \rfloor &lt; \sqrt n$$last=\lfloor \frac{n}{ \lfloor \frac{n}{i} \rfloor } \rfloor$举例：CQOI2007 余数求和大部分莫比乌斯题，如gdoi2018d2t1 4对于许多计数类问题，如果有多个段可分，可以分成1+(n-1)，这样子能保证不会重复计数举例：noi2001 陨石的秘密 5很多计数问题要求排列可以时刻保证排列性，然后插入一个数，将比它大的数+151nod1296 有限制的排列 6设cnt(x)为x二进制下1的数量$cnt(a \oplus b)$ 为奇，当且仅当一个cnt为奇，另一个是偶因为两个1在一起是偶，不在一起也是偶 三、决策类1需求：维护前k个（方案）做法：堆维护，堆顶为最差元素举例：K远点对树上的路径Supermarket 2把决策转化为边，边权为代价举例：电路维修循环格 3找前k优的区间，固定一个点后，左边的优秀情况是极值问题可以用堆维护左边，取出一个位置后把左边区间拆成两半放回去举例：超级钢琴树上的路径 四、搜索类1搜索去掉次序性的套路：强行限制大小关系举例：poj1011 Sticks 2搜索的复杂度：把每次决策量也就是分支数量计算出来 3其他优化：优化搜索顺序排除等效的决策和物体可行性最优性记忆化 4对于一个序列，拆分成多个序列的问题有两种不同的方向： 给每个元素分配组（通常这个更快） 通过组，找元素 最好能仔细根据题目斟酌一下策略本人多次无脑用2各种剪枝，也比不过裸的1……举例：SticksMissile Defence SystemZebras 550的整数拆分约为1e6，挺有用的举例：[JLOI2012]时间流逝，有题解 五、数论技巧1面对gcd、lcm的限制条件，可以从质因数上考虑，从而变成min、max，省去log暴力判断的复杂度举例：Hankson的趣味题 2由调和级数1+1/2+1/3…1/n=logn 3如果要在中途，用一个简单的状态去尝试满足“成为某个数的倍数”或者需要以此简便地转移可以考虑只保留余数举例：Ahoi2009 同类分布 4小定理：对于一个素数P，任何P以内的x，其倍数在模P意义下可以表示出所有P以内的数ps：原来这东西就是原根啊…… 六、树1在一课树上，与该点最远的一定是直径的某个端点 2两棵树合并起来，新的直径端点一定在两边直径端点中产生 3一棵树上部分点的联通块个数=点-边 4很多问题可以转化为树上问题，即不会有环，某一方向的结果唯一举例：跳跳棋 七、字符串1后缀数组+离线+并查集 八、感觉很假但其实正确的结论1直径的中心唯一每个点的最远点，都一定经过直径的中心 21到n的集合，选若干个不互质的数，要求和最大结论：每个数最多两个不同的质因子，且一个在根号内，一个在根号n外 九、完全不会证明的结论1 树上路径，覆盖所有边需要数量：$\lceil \frac{度=1的点数量}{2} \rceil$ 十、自己容易犯的sb错误1cmp函数不能在结构体内部 2对于一道题意不裸的题，都应该用样例检验没有看错题、想出来算法的基本正确性，再去code 3标准差是方差的算术平方根，所以说所谓方差是不需要开根的 4不等式的移项一定要分析正负性 5stl的比较重载不能随便搞，一定要满足传递性和大小情况单一性（stl用&lt;和&gt;推导出=） 6fft等，得答案时要round 7带取模计数dp，判无解不能用答案=0，因为答案可能是模数的倍数 8曾经对拍几小时，以为超稳……后来挂惨才发现没有srand]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>原创精品</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018 划水记+题解]]></title>
    <url>%2Fposts%2F5e0e.html</url>
    <content type="text"><![CDATA[NOIP2018 day03:30才睡着，超级担心明天会困upd：学到了，以后如果困的话可以喝红牛 day1居然一点也不困？感觉状态不错 考试前曾经感叹：如果到时候有现在这么好用的键盘就好了……结果居然还成真了！一模一样……然后不卡空间好评，瞎jb开评测机超强好评（没注意评测费，听说加了100），不用担心被卡常了 t1，一开始想着差分，但很难做先写了一个不会算复杂度的做法，应该蛮多分的吧，就是solve(l,r)，暴力找最小值去分割然后发现随便卡……但显然可以线段树优化，log找到最左边的最小值，然后以此为分割在右边找那分析一下势能，时间为 $O(nlog^2 n)$好慢啊拍起来已经1h了 t2，加法线性空间？各种二元函数分析？联想到 HAOI2018奇怪的背包？搞了20min还是不会，看下一题 t3，居然还真的非常可做二分答案后，设g表示向上的唯一一条链的长度那么现在问题就是给出一个序列，两两配对成至少ln的链，相同条数下选择【上传最大链】的方案我的做法：维护一个set，每次取出最小，找到能配对的中最小的，都从中删除所有被废弃的取mx上传时间的话，看这次评测机配置这么高，应该不会被卡常的吧 回去看t2，找性质注意到只会是小的影响大的，所以从小到大考虑显然最后一定是原先的子集，否则那个多出来的至少会表示出【其本身】用一个无限背包表示某个数是否被表示，如果能显然不要 一开始想着值域参考【小凯的疑惑】的话，不互质更小，上限ab，但开不下想了想，只需要知道当前这个数而已（此时上面的性质尚未透彻，所以有怀疑），所以只要每次跑值域大小即可 彻底检查完所有方面，看了几次注意事项后，还剩1h，挂机玩3d软件去了…… 上限：100+100+100感觉明天应该会很难【回忆起gdoi】 jcp的t2，没想出值域那个性质，其他人普遍没问题 下午看到师兄们去看毒液，和lxj突发奇想用手机看【在一年前就躺在u盘】的秒五晚上去看看我在广州的新家（组的），老爸真爱吹啊，什么广州CBD区……不过感觉老爸老妈还是有点东西的，以他们的性格不会随便花钱，虽然我不像我弟那样喜欢关心家底吸取经验，跑步跑到【真·上气不接下气】顺利早早睡着，打算以后比赛都要这样（scy不可多得的又一句有用的建议） day2t1，一开始想线性做法，5min后不会，反正放平方，懒得想了，也拍不了，走了走了此时40min，因为代码有点小bug t2，这好像很性质？很爆搜？但暂时没思路，走了 t3, n方暴力显然100%不会，发现很多特殊点，一般都是提示（noip就是良心）如果是一条链，类型一只要正反跑一次，中间合并就好，类型二同理，但并不会类型3深度？哦先dp好，每次重新跑一次祖先的链，那么复杂度就是和深度相关的树上？感觉应该和【正反跑】类似，但不太会此时已经10点，设限20min因为用贪心来决策，dp只计数，计算出每个节点的 $g(x)=min f[x][0/1]$ 后，可以二次扫描记录 $oth(x,0/1)$ 表示当前的选择，然后除了x子树以外的答案（子树间互不影响）那么询问1就搞定了，询问2的话分类讨论，预处理allg和allf1表示无限制下，儿子们的两种和即可 如果我会处理一条链上，固定前后，的答案的话，就可以树剖+虚树，然后套上询问2了（感觉这才是询问2意义所在啊）ps:不过赛后问了问栋老师，好像不是这样做的 回去看t2，以为状压就好了，瞎jb找了个转移的限制条件，就瞎jb写了，还过了2 2的点然而其实根本不会转移……又不是加法原理或者乘法原理……毫无去重思路 剩下时间不算多，赶快写t3，最后暴力过了大样例，然后和暴力拍了询问1匆忙检查各种文件，和d1形成鲜明对比，最后t2特判了样例……好歹有10分 上限：100+10+84怎么高一只有我拿了t3的40，目前只知道gay队（TYB）和我差不多但所有人第二题都顺利找规律拿了50pt……感觉从结果上血亏，不过那个耐心杠特殊数据的体验还是很好的 看了看知乎，t3好像是动态dp？不过似乎学过的tyb也没做出来羊好像是我校唯一做出t2的栋好像是我校唯一会做t3的，不过没写完感觉可能是历年正解难度最大的一次，不过暴力分太足了可能线不会差太多 上限494，随便fail一道题就很悬了（特别是我这种中考无限粗心选手）日常模拟赛上限得分和实际得法相差巨大选手再次上演，比赛完当天晚上一个人在竞赛室写游记系列准备去上文化课了……希望能进wc，不然想想【别人都在训练我在文化课】就很难受 成绩先立个flag，进了就氪个迎新礼包，没进弃游，剩下看天意…… upd 2018.11.15 发代码速度好评然后到处去测学军和牛客478=100+100+100+100+10+68洛谷441（被卡常，没有参考价值）然后看了看，应该是d2t3询问2的情况写错了（当时只拍了询问1，没时间，只能肉眼看了好多次，结果还是错）rose是真的牛逼，d1t3大样例没过，3个oj平均分95（因为其采用了后面找前面的策略，而这个我记得对拍一下就错，为什么出的数据都卡不掉？我的改改交上去也和他差不多） upd 2018.11.20 ccf本来说昨天10点，居然咕咕咕了22h……100+100+95+100+10+68=473好像又被卡常了……但明明学军都没事啊？总之就是只有pkuwc了 d2t3 保卫王国 题解$g(x)=min f[x][0/1]$注意到dp是计数的，基本没有决策显然轻重链剖分，然后非常好的性质就是只有一个重儿子$s0(x)=\sum f(lightson,1)$$s1(x)=z(x)+\sum g(lightson)$$f(x,0)=s0(x)+f(hson,1)$$f(x,1)=s1(x)+min f(hson,0/1)$ 考虑用矩阵优化，每个点，开一个大小为2乘2的矩阵，不表示状态，只表示转移然后询问就是x和y，不允许的状态设inf，重写min运算，如果有-1就表示不能转移然后定义矩阵运算@， $c_{i,j}=min a_{i,k}+b_{k,j}$这个运算是满足结合性（ $(a@b)@c=a@(b@c)$ ）的，证明可以联想floyd 先从x=1的特殊点开始，那么y就向上dp到链dp状态的表示，是1乘2的矩阵，即f(x,0/1)每次重链之间，暴力转移就好了不特殊的话同理，x和y各自跳到lca，然后暴力转移合并成一个状态，然后再跳到根时间复杂度 $8 \times n log^2 n$应该能过大部分点 如何更快？因为儿子是多个的，而父亲只有一个，应该从儿子角度考虑（这也是树上问题重要思想）设 $fs(x,t,0/1,0/1)$ 表示【x的状态，x的第 $2^t$ 个父亲的状态确定】时，祖先子树内，除了x子树的答案外都合法，最小代价注意到前面的做法，答案是 $f(1,0/1)$ ，因为那是总代价但现在，为了更好地动态回答答案，必须把答案拆开，所以fs是只保证上述区域合法时候的答案虽然稍微有点非常规，但显然只是本题计数dp的另一种形式罢了 想通上述内容后，预处理转移显然回答询问时，中间的祖先的状态，因为只和上一个有关，做一个简单的dp即可 最后就是，感觉码量和实现思维量无论哪种做法都很耗时，至少1h考场上就算会，除非很早ak，否则拿84足够了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;;c=getchar();&#125; while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; const int MAX_N=110000; int n; int z[MAX_N];//点权 int hou[MAX_N],dep[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N*2]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; ll add(ll a,ll b) &#123; if(a&lt;0 or b&lt;0) return -1; return a+b; &#125; ll mymin(ll a,ll b) &#123;return a&lt;b?a:b;&#125; ll min(ll a,ll b) &#123; if(a&lt;0) return b; if(b&lt;0) return a; return mymin(a,b); &#125; ll dec(ll a,ll b) &#123; if(a&lt;0 or b&lt;0) return -1; return a-b; &#125; int bin[30]; ll ff[MAX_N][30];//father ll fs[MAX_N][30][2][2]; struct Predp &#123; ll f[MAX_N][2];//dp Predp()&#123;memset(f,0,sizeof f);&#125; void dp(int x,int fa) &#123; ff[x][0]=fa; f[x][0]=0;f[x][1]=z[x]; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dep[y]=dep[x]+1;dp(y,x); f[x][0]=add(f[x][0],f[y][1]); f[x][1]=add(f[x][1],min(f[y][0],f[y][1])); &#125; &#125; void preST() &#123; memset(fs,-1,sizeof fs); f[0][0]=f[1][1],f[0][1]=min(f[1][0],f[1][1]); for(int x=1;x&lt;=n;x++) &#123; int fa=ff[x][0]; fs[x][0][1][0]=dec(f[fa][0],f[x][1]); fs[x][0][0][1]=fs[x][0][1][1]=dec(f[fa][1],min(f[x][1],f[x][0])); &#125; for(int t=1;t&lt;=20;t++) &#123; for(int x=1;x&lt;=n;x++) &#123; ff[x][t]=ff[ff[x][t-1]][t-1]; int mid=ff[x][t-1]; fs[x][t][0][0]=min( add(fs[x][t-1][0][0],fs[mid][t-1][0][0]),add(fs[x][t-1][0][1],fs[mid][t-1][1][0]) ); fs[x][t][0][1]=min( add(fs[x][t-1][0][0],fs[mid][t-1][0][1]),add(fs[x][t-1][0][1],fs[mid][t-1][1][1]) ); fs[x][t][1][0]=min( add(fs[x][t-1][1][0],fs[mid][t-1][0][0]),add(fs[x][t-1][1][1],fs[mid][t-1][1][0]) ); fs[x][t][1][1]=min( add(fs[x][t-1][1][0],fs[mid][t-1][0][1]),add(fs[x][t-1][1][1],fs[mid][t-1][1][1]) ); &#125; &#125; &#125; &#125;predp; ll ans[2][8000][2];//简单dp, ans[x或者y][序数][以此状态结尾]=最小代价 int tmp[2]; void jump(int typ,int &amp;x,int t) &#123; int now=++tmp[typ]; ans[typ][now][0]=ans[typ][now][1]=-1; for(int a=0;a&lt;=1;a++)//x for(int b=0;b&lt;=1;b++)//anc ans[typ][now][b]=min(ans[typ][now][b], add(ans[typ][now-1][a],fs[x][t][a][b]) ); x=ff[x][t]; &#125; ll solve(int x,int a,int y,int b)//点x，y &#123; if(dep[x]&lt;dep[y]) swap(x,y),swap(a,b); tmp[0]=0;tmp[1]=0; ans[0][0][a]=predp.f[x][a];ans[0][0][a^1]=-1; ans[1][0][b]=predp.f[y][b];ans[1][0][b^1]=-1; for(int t=20;t&gt;=0;t--) if(bin[t]&lt;=dep[x]-dep[y]) jump(0,x,t); if(x==y) ans[0][tmp[0]][b^1]=-1; else &#123; for(int t=20;t&gt;=0;t--) if(ff[x][t]!=ff[y][t]) jump(0,x,t),jump(1,y,t); int lca=ff[x][0]; int now=++tmp[0]; ans[0][now][0]=ans[0][now][1]=-1; for(int c=0;c&lt;=1;c++) for(int t1=0;t1&lt;=1;t1++) for(int t2=0;t2&lt;=1;t2++) &#123; if(c==0 and (t1==0 or t2==0)) continue;//debug 这种情况要特判 ll t=add(ans[0][now-1][t1],fs[x][0][t1][c]); t=add(t,ans[1][tmp[1]][t2]); if(c==0) t=dec(t,predp.f[y][1]); else t=dec(t,min(predp.f[y][0],predp.f[y][1])); ans[0][now][c]=min(ans[0][now][c],t); &#125; x=lca; &#125; //x为当前lca，开始向上 for(int t=20;t&gt;=0;t--) if(ff[x][t]&gt;0) jump(0,x,t); return min(ans[0][tmp[0]][0],ans[0][tmp[0]][1]); &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; int m;char op[10];scanf("%d%d%s",&amp;n,&amp;m,op); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;z[i]); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; predp.dp(1,0); predp.preST(); while(m--) &#123; int x,a,y,b;scanf("%d%d%d%d",&amp;x,&amp;a,&amp;y,&amp;b); printf("%lld\n",solve(x,a,y,b)); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; d2t2 填数游戏 题解某些性质：$若w(p1)&gt;w(p2)，则s(p1) \leq s(p2)$显然既然字符串的比较从前往后，所有长度相同的路径间都要满足条件那么显然每个对角线都应该满足从右上往左下【一段0然后一段1】当(i,j+1)和(i+1,j)相同时，以(i+1,j+1)为左上角的矩阵，对角线上必须相同否则从(i,j)走出来，然后路径字典序不同，合并后可能交换走 真题解]]></content>
      <categories>
        <category>竞赛历程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【CF590E】The Tree]]></title>
    <url>%2Fposts%2Fcbab.html</url>
    <content type="text"><![CDATA[Source and JudgeCF590E Record3h Analysis请先思考后再展开 非常综合的好题 字符串匹配方面考虑ac自动机ac机复杂度证明见oi之路 构造fail后，重新考虑每个串的子串因为本来已经建好，不会失配子串除了自己外，包括每个前缀的后缀所以遍历当前的每个前缀，其fail极为最长后缀在各级fail中，可能有的fail是字符串的结尾，如果每个都去建边，会破坏复杂度考虑先只记录最大那个，因为它一定包含后面的小的 最后传递闭包即可恢复偏序集的dag其实有些人的做法是复杂度不能过的，这里的传递闭包应该用bitset显然如果我出题会把这个卡到80分 接下来的问题就是dag的最长反链，在【图论-其他】中有 Dilworth定理 的介绍转化为求最少链覆盖后，拆点二分图，左出右入因为路径覆盖时，每个点只有一条出边，二分图匹配，然后左边没有出度的节点就是链的终点统计其个数即链的数量 接下来构造方案具体做法：oi之路-图论-其他-Dilworth定理然后匈牙利也应该卡！在这种完全图下，显然应该选择网络流，构造方案会很方便 标称时间复杂度为： $O(L+n^3+n^3)$我的时间复杂度为： $O(L+n^3/32+n^2 \sqrt n)$然后就光荣地被卡常了，经过长时间对拍，程序是没有错误的 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>二分图</tag>
        <tag>好题</tag>
        <tag>难度3</tag>
        <tag>传递闭包</tag>
        <tag>ac自动机</tag>
        <tag>最大独立集</tag>
        <tag>出题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Lydsy1711月赛】实时导航]]></title>
    <url>%2Fposts%2F98b4.html</url>
    <content type="text"><![CDATA[Source and JudgeLydsy1711月赛bzoj5097 Record1h Analysis请先思考后再展开 好题先考虑朴素的做法，用堆维护bfs的队列发现不算太慢，用bitset存储边和队列，这样就省掉两个log了 具体而言：每个点只会执行拓展一次（被枚举最多4次）单个拓展的代价为4n/32，不需要通过位运算去重，因为被多次枚举，毫无影响时间复杂度为 $O(\frac{n^2q}{8})$undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JLOI2014】聪明的燕姿]]></title>
    <url>%2Fposts%2F9b81.html</url>
    <content type="text"><![CDATA[Source and JudgeJLOI2014loj2234 Record1h Analysis请先思考后再展开 考虑在约数和公式上搜索剪枝1：判断后面是否只有一个素数，否则通过两个素数乘积大幅剪枝（主要是去除末尾0链）剪枝2：通过枚举下一个非0次幂的具体位置，去除中间的0链（非0最多30个，相对根号大小的dfs深度优化巨大）undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SDOI2015】排序]]></title>
    <url>%2Fposts%2F37a7.html</url>
    <content type="text"><![CDATA[Source and JudgeSDOI2015bzoj3990 Record1h Analysis请先思考后再展开 性质好题首先排列意味着不重叠，很多特殊情况都不可能发生 step1本题操作的特征在于长度为2的整数次幂，而且区间总是对齐的那么会发现，无论如何操作，都存在一种等效的操作，使得顺序没有意义那么我们只考虑长度递增的操作序列，最后乘以操作具体数量的阶乘即可这样数量会少非常多 step2长度递增，意味着当前长度内部，必须是递增而且连续的，否则后面不可能排序又因为每种操作只能使用一次，考虑下一层的情况为分割点那么下一层，考虑当前层尚未操作时，非法的块数如果没有，直接下一步，否则任何操作都会弄巧成拙一个，显然是且一定只能是内部交换两个，总共只有4种情况两个以上，不可能实现 综上所述，爆搜的分支会非常少 最后提醒一下，两个完全相同的01串，即可具体交换的块不同，也试做一种方案]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF1017G】The Tree]]></title>
    <url>%2Fposts%2Fcbab.html</url>
    <content type="text"><![CDATA[Source and JudgeCF1017GCF1017G Record3h Analysis请先思考后再展开 巧妙地转化题意：初始所有点都是-1，表示消耗，每次操作单点+1定义f表示向上的链上，最大后缀和（可跨过-1，不能为空）则x是黑色当且仅当 $f(x) \geq 0$ 那么这个操作二要怎么处理呢？强行让所有人f都变成-1即可，这个可以全部恢复-1，然后对x修改，强行变成即使有后缀和也是-1即可【hint：这里访问父亲的时候要特判根的情况……拍了超久】 考虑用线段树，以dfs序为下标，维护每个区间的data如果我们能设计一个merg(left,right)，注意是有序的，left和right在使用意义上是连续的（链或者dfs序区间）那么询问就很好回答了，按照常规的树剖跳上去，按顺序merg好即可 唯一的问题就是merg如何实现data存储区间的和、左端点的位置，以及最大后缀和（这样左边就可以计算了）那么唯一需要考虑的，就是最大后缀和的左端点在left，显然一定是【左边的后缀和+右边的和】与原本比较 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>树剖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF983E】NN country]]></title>
    <url>%2Fposts%2F856f.html</url>
    <content type="text"><![CDATA[Source and JudgeCF983E Record1h Analysis请先思考后再展开 想到一些小性质：每个点只有向上的深度是有意义的显然这个随便dfs一下就行了 然后关键是怎么连接起来压根没想到倍增的我感觉自己非常sb，像是被套路了 那么每次询问，拆分两个路径，然后最后需要分类讨论一下最顶上那条是否垮lcaans=left+right-【垮lca】 判断这个的话，就是个二维数点了这个最快的应该是离线后扫描线，时间为nlogn]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SDOI2017】树点涂色]]></title>
    <url>%2Fposts%2F31df.html</url>
    <content type="text"><![CDATA[Source and JudgeSDOI2017Loj2001 Record3h Analysis请先思考后再展开 感觉很有趣的一道题关键性质：每种颜色的性质一定是向上的一条链 显然以dfs序为下标，维护每个点到根节点路径上的权值显然x到y的权值为 $d(x)+d(y)-d(LCA)+1$（这个随便讨论一下lca是否有孩子和自己相同颜色） 关键是第一个操作，合并颜色块的总次数应该只有n（ $\sum num[color]$ ，因为总有一点点被侵占的地方，这里并不严谨，个人这个感觉）我自己的想法死在了并查集我不会断开操作看到这个断开， 以我的知识面只会想到lct将每种颜色的所有点放到相同splay中，修改操作和access非常类似然后每次合并的贡献，就是当前子树所有种类都-1，不过如果某孩子颜色和x相同，需要+1因为我们始终维护好splay，所以如果存在，那个孩子就是splay中x的右孩子]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>lct</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF997E】Good Subsegments]]></title>
    <url>%2Fposts%2F1ba5.html</url>
    <content type="text"><![CDATA[Source and JudgeCF997E Record1h Analysis请先思考后再展开 $max-min=R-L+1$$max-min+L-1 \leq R$ 和之前维护非负整数的0的数量类似，直接维护最小值及其个数那么再通过两个单调栈，很容易得出R对应的答案（单次询问log） 本题的关键就在于需要维护好区间的历史答案和，而非单个询问考虑每次统计R的答案，不是累加答案，而是把左边可行的端点统计贡献数量（这主要是因为询问的左端点不确定） 那么我们的关键是如何只对最小值进行这个特殊的维护设每个点向右的贡献为ans[i]，那么每次回答询问就是统计区间的这个答案考虑额外维护一个标记s，表示当前区间所有最小值的ans的加标记注意到min一定来自两边的至少一侧，每次pushdown就先把lazy下放，然后对min的来源更新s和ans 回答询问就是边搞定上述决策集合，边回答询问就好了]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AGC018C】Coins]]></title>
    <url>%2Fposts%2F8ede.html</url>
    <content type="text"><![CDATA[Source and JudgeAGC018C Record1h Analysis请先思考后再展开 先将a从大到小，然后枚举a最小那个位置那么x个位置都在左边了因为选择了x和y个，剩下那种不用计算，可以把所有属性减去c，最后补上即可，这样比较好思考 那么注意到左边一定不会选择0，也就是z只在右边那么左右两边直接贪心选择就好了（通过差值判断即可） 需要一个数据结构，维护左右两边的前k大、小之和，这个随便维护即可]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF878C】Tournament]]></title>
    <url>%2Fposts%2F90ef.html</url>
    <content type="text"><![CDATA[Source and JudgeCF878C Record2h Analysis请先思考后再展开 依次考虑每个人，加入当前维护的信息 想象一下：如果把能战胜关系建边，缩完点将是一个竞赛图再“反传递闭包”一下，将是一条链，否则会形成强连通分量每次询问的答案，就是链的第一个联通块的大小 对于每个联通块，不需要知道其具体元素（反过来的信息则需要）唯一有用的信息，就是其各个属性的min、max，信息量非常小 考虑这个链的特征显然前一个的min大于后一个的max 定义小于为，满足上述k维偏序则如果两个强连通块被判定为相等，即他们应该合并所以每次插入，直接合并与其相同的块即可，复杂度根据势能显然为 $O(nklogn)$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Loj521】抵达]]></title>
    <url>%2Fposts%2Fa414.html</url>
    <content type="text"><![CDATA[Source and JudgeLoj521 Record2h Analysis请先思考后再展开 结论：方案一定只能两两配对证明：从叶子开始考虑，那么只能向上而因为所有点都要被覆盖，所以叶子要被其父亲覆盖此时叶子的祖父往那边是断开的，如果其所有孩子都这么处理，则最优也会变成叶子（或者与叶子配对）根据数学归纳法可得证 然后其实你直接就可以知道，每个点究竟和谁配对这个模拟就好了，可看代码 然后现在得出了许多不等式关系这个可以拓扑排序，用堆维护当前度为0的点即可 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>拓扑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF893F】Subtree Minimum Query]]></title>
    <url>%2Fposts%2Fa2b5.html</url>
    <content type="text"><![CDATA[Source and JudgeCF893F Record10h Analysis请先思考后再展开 感觉挺有难度的 暴力做法是，dfs序为一维，深度为一维，然后二维找最小值，随便用个二维数据结构维护一下就好了然而m很大显然不行 做法一：主席树关键：dfs序内，不存在比x更小深度的点所以以深度为时间轴，不采用权值线段树，而是min线段树线段树插入的时候动态开点，合并取min，询问即前缀和 做法二：预处理+st表+长链剖分这个做法相对更优秀，但实现有点难度 注意到多组询问的对象是静态的，考虑预处理 先求一次bfs序，然后对于x，维护L和R分别表示当前子树，下一层的bfs序的左右端点（因为在相同子树内是连续的）不过，如果不存在子节点，则L为下一层，bfs序下右边第一个点（会跨出），R同理这个主要是为了解决这种情况：注意到bfs序在同一层的相对顺序和上一层是一致的，仔细想想会发现很好处理 然后因为询问的是最小值，允许重叠，所以可以跑一个非常规的ST表设 $f(x,a,b)$ 表示对于 $x到x+2^a-1$ （下文都从bfs序角度），然后他们往下的子树的 $2^b$ 层（包括根）的最小值$fl=L(x)^{2^{b-1}},fr=R(x+2^a-1)^{2^{b-1}}$ （指迭代次数）虽然方向相反，但显然无论跳多少次都满足 $fl \leq fr$$k为最大的 fl+2^k-1 \leq fr$$f(x,a,b)=min f(x,a,b-1),f(fl,k,b-1),f(fr-2^{k-1}+1,k,b-1)$ 这里如果把L和R建成一棵树，相当于询问第k个父亲，可以长链剖分这样询问就可以 O(1) 回答了，参考ST的处理 然后我这道题做了超久（主要是第42个点）烦了很多sb错误，主要是考虑情况不周全 顺便提供几组小数据 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度3</tag>
        <tag>长链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF1034C】Region Separation]]></title>
    <url>%2Fposts%2Fa39a.html</url>
    <content type="text"><![CDATA[Source and JudgeCF1034C Record2h Analysis请先思考后再展开 考虑只割一次的情况设k为联通块数量，设 $f(k)=\sum [\frac{all}{gcd(sum_i,all)} | k]$$ans=\sum [f(k)=k]$割多次的话， $g(t)=\sum_{d|t} f(d)$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF955F】Heaps]]></title>
    <url>%2Fposts%2F39cb.html</url>
    <content type="text"><![CDATA[Source and JudgeCF955F Record2h Analysis请先思考后再展开 设 $f(x,k)$ 表示往下的最大深度如果孩子数小于k，为1，否则为前k大的min利用nth_element达到 $O(n^2)$ 不难发现， $h \leq log_k siz$当k达到 $n^{\frac{1}{3}}$ ，层数最大为3稍微处理一下，应该可以通过本题，时间为 $n^{frac{4}{3}}$ 还有更快的做法$g(x,h)$ 表示深度为h，最大的叉数不考虑k=1，则 $h \leq log2 siz$转移的话，将 $f(y,h-1)$ 排序，倒序找到第一个K，满足 $第k大 \leq k$注意到K的减小，显然更能满足条件，所以正确性显然 然后得到答案的话，因为是求和，很容易统计答案]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HAOI2018】奇怪的背包]]></title>
    <url>%2Fposts%2F7019.html</url>
    <content type="text"><![CDATA[Source and JudgeHAOI2018luogu4495 Record2h Analysis请先思考后再展开 本题的难度主要在于题意的转化 Step1$a \cdot v_i+b \cdot P=anynum$由裴蜀定理得：$a \cdot v_i+b \cdot P=gcd(v_i,P)$$anynum$ 是 $gcd(v_i,P)$ 的若干倍，所以可以将物品的体积转化,则本质不同的物品只有1600个（约数个数上限） Step2$\sum t_i \cdot v_i = w_i (\mod P)$题意转化为求其整数解数量因为忽略个数，其实就是求 $gcd(a_1,a_2,a_3…a_m,P) | w_i$ 的方案数注意到 $w_i$ 的其他质因数没有意义，有用的信息还是P的约数，所以本质不同的询问也只有1600个 Step3转化出上面的柿子后，非常好dp预处理所有约数，设 $f(i,t)$ 表示考虑前i个，当前方案gcd恰为t的方案数转移显然，复杂度很低 Step4暴力统计每个询问的答案（判断是否为约数）即可]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sakits的题]]></title>
    <url>%2Fposts%2F2504.html</url>
    <content type="text"><![CDATA[Source and JudgeSakits的noip模拟赛不过题目不是原创的 Problem1CF1036F Analysis1请先思考后再展开 设 $a^b$设 f(b) 表示以b为次幂，在n以内的a的数量注意到有重复，但可以容斥设 g(t)表示以t为 满足【最大化次幂后恰为t】的数 $g(t)=\sum_{d|t} f(d)$这个是可以反演的，时间为log方，主要是二分出f的花费（将快速幂看做常数）不过这个还是非常慢的 考虑结合多组数据的特征，预处理出例如： $2^4,3^4,4^4……$那么二分查找就省去常数了 然后询问是可以离线的，指针具有单调性，不需要二分了，时间复杂度 $O(nlogn)$ Problem2给一棵节点小于3e5的树，定义一条路径的权值为，经过的点集的编号的最近距离求所有权值大于K的路径数量，k在10以内 Analysis2请先思考后再展开 简化题意（避免被搞晕）：计算所有【点编号不会太靠近】的路径数量为了利用K的大小，转化一下题意，那么所有非法点对只有10n个注意到这些非法点对不能同时出现，有哪些路径包含了这些点对呢？显然是跟子树有关（无论是否有祖先关系）一开始想着容斥（当时处于看错题的状态下，以为点有点权），发现特别难搞 显然子树信息先转化为字典序其实这相当于一个二维坐标上，两维不相关的坐标的连续区间，也就是一个矩形 那么问题变成 $n\times n$ 的大矩形，数矩形的并这个就非常套路了，扫描线一下即可 线段树维护的东西的话，我的做法是维护最小值和其次数主要是其被覆盖次数一定是非负数，可以判断0的出现次数，而上面的这个东西非常好维护 细节特别多，非考场都做了很久，调了很久感觉考场非常容易炸…… undefined Problem3没什么好说的]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【CF1039D】You Are Given a Tree]]></title>
    <url>%2Fposts%2Fd879.html</url>
    <content type="text"><![CDATA[Source and JudgeCF1039D Record2h Analysis请先思考后再展开 本做法的难度不算大，偏套路吧虽然我没想到，官方题解的更优秀做法并没有看懂…… 题目的多组询问很容易让人想到整体二分，然而我并不知道怎么弄……下面介绍一个网上常见的做法： 考虑单独一个k，显然可以在树上用贪心决策，跑计数dpsolve求最多有多少条长度为k的路径f(x)=条数g(x)=条数最大化的前提下最长链（完整路径之外，笔直向上，由最后的父节点累计入答案）贪心正确性：显然在不可重叠的规则下，条数多1不比长长的链差 设T为临界值长度小于T的部分，暴力计算长度大于T的部分，显然答案会小于n/T，可以将答案相同的部分合并处理solve(ln)显然具有单调性，枚举答案ans，则在未计算的右侧，[solve(ln)=ans] 具有单调性，二分找到右端点时间复杂度 $O(Tn+n^2logn/T)$ ，T取 $\sqrt nlogn$ ，该算法达到最小值 然而，因为后面的log不是满的（如果改成倍增应该会快很多），所以实测T取根号时才是最快的这道题我发现全场基本都在第8个点tle了，然后都选择了取卡常例如【按照dfs序倒序处理，规避系统栈】、【记忆化搜索】、【快速IO】等 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF960F】Pathwalks]]></title>
    <url>%2Fposts%2Fae99.html</url>
    <content type="text"><![CDATA[Source and JudgeCF960F Record30min Analysis请先思考后再展开 是否联想到了最长上升子序列？如果有，相信自己！因为有用状态只有O(m)个undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF840C】On the Bench]]></title>
    <url>%2Fposts%2F3ed7.html</url>
    <content type="text"><![CDATA[Source and JudgeCF840C Record30min Analysis请先思考后再展开 有点难，不过也不算神仙题，大概省选t2难度？有综合性，状态感觉也挺难想到的 最难的一步：转化题意这个完全平方数很恶心，但注意到如果每个数的标准分解形式，质因数的次幂膜二后问题变成，不能将两个相同的数放在一起 然后就感觉排列这东西很难搞，唯一会的姿势这里也不能用但如果脱离排列的形式，考虑将数字放入的方案数，就会好搞很多 小套路：将同值的合并处理，看做一组，设数量为num[i]依次考虑每组，顺序任意，设 $f(i,tt)$ 表示【前i组，有tt个相邻关系是非法的】的计数ps：感觉这个第二维非常关键，是【表达一个状态真正最需要的唯一关键信息】 同组的值相同，但在原题中是互不相同的数，所以乘以排列数 $num[i]!$枚举将当前组分成t个，插入到空隙中，那么新产生了 $b=num[i]-1-(t-1)=num[i]-t$ 个非法的相邻量分组方案： $C_{num[i]-1}^{t-1}$枚举将之前a个相邻非法位置变成合法，那么非法数量变成 $tt-a+b$方案数为 $c_{tt}^{a} \times C_{sum+1-tt}^{t-1}$ ，sum为前面的num的和 综上所述：$f(i,tt-a+b)+=f(i-1,tt) \times num[i]! \times C_{num[i]-1}^{t-1} \times C_{tt}^{a} \times C_{sum+1-tt}^{t-a}$ 看起来是四层枚举，但由于 $t \leq num[i],\sum num[i]=n$所以实际复杂度是 $O(n^3)$ undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF1012C】Hills]]></title>
    <url>%2Fposts%2F3470.html</url>
    <content type="text"><![CDATA[Source and JudgeCF1012C Record30min Analysis请先思考后再展开 有点套路，不过太菜了，看了别人的状态才想到 关键性质：只影响前后一个位，而且只能减小设 $f(i,k,0/1)$ 表示前i位，已经有k个满足条件（当i是，后面的一个数尚未修改），然后该数是否满足条件然后这种东西能够满足单调性，但注意到一个数可能被多次统计，所以要记录该状态下，这个数变成了多少其实注意到，如果是1，数不会边，所以可以把0替换成唯一可能出现的三个数：a[i-1]-1,a[i],a[i+1]-1这个也可以设状态的，不过不是很方便吧大概 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Silhouette bzoj3902三向投影]]></title>
    <url>%2Fposts%2F3af6.html</url>
    <content type="text"><![CDATA[Source and Judge雅礼noip模拟题bzoj3902 Problem有一个n乘n的网格，在每个格子上堆叠了一些边长为1的立方体。现在给出这个三维几何体的正视图和左视图，求有多少种与之符合的堆叠立方体的方案。两种方案被认为是不同的，当且仅当某个格子上立方体的数量不同。输出答案对1e9 + 7取模的结果。n&lt;=100000 Record3h Analysis请先思考后再展开 很有难度的一道计数题 关键：对a和b排序，问题不变，求合法解数量从大到小考虑每种取值，考虑该取值的横线和竖线所能确定具体值的形状，大致是一个梯形（也就是说，该行且该列的另一侧已经确定）如果某种值只有行或列，那矩形也算是特殊的L形 对于每个L形，拆成两半枚举至少的非法行数容斥消除一维，再用朴素容斥消除一维因为有两维，朴素容斥搞定一维后（假设是列），那么左下角那个已经由上面的保证好了然后右边的部分，既要考虑枚举的非法行数，还要考虑当前行的合法性然后同类型的列之间互不影响，直接乘法原理 对于当前的L形$ans=\sum (-1)^i f(i)$$$f(i)=C_a^i \times \\[num^i \times (num+1)^{a-i}]^{lb} \\[num^i \times ( (num+1)^{ra-i}-num^{ra-i} )]^b$$然后不同的L形之间已经互不影响（条件是拍好了序），乘法原理即可 常熟略大，可自行优化undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reverse]]></title>
    <url>%2Fposts%2F37e8.html</url>
    <content type="text"><![CDATA[Source and Judge雅礼noip模拟题 Problem小G有一个长度为n的01串T，其中只有TS=1，其余位置都是0。现在小G可以进行若干次以下操作：选择一个长度为K的连续子串（K是给定的常数），左右翻转这个子串。对于每个i，小G想知道最少要进行多少次操作使得Ti=1.特别的，有m个禁止位置，你需要保证在操作过程中1始终不在任何一个禁止位置上。n&lt;=1e5 Record2h Analysis请先思考后再展开 发现每个点可以去的点，分奇偶讨论后是连续的一段区间（虽然边界计算有点麻烦）方法一：线段树优化建图，在上面用deque跑bfs，时间为nlogn方法二：用set维护没有被更新的点，找区间用lowerbound，这样每次找到的都是没有被更新过的点 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4230倒计时 51nod1425减减数 CF331C3The Great Julya Calendar]]></title>
    <url>%2Fposts%2F5f83.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj423051nod1425CF331C3 Record2h Analysis请先思考后再展开 非常好的题目 显然有单调性，所以应该贪心地选择减去最大的数字那么就有了一个O(n)的做法 瓶颈在于具体的数字，考虑拆位处理真正有用的情况其实很少形式1：9999999t形式2：原数的一个后缀设 $f(mx,ln,num)$ 表示当前这个数，其实左边还有一些部分，最大数字是mx，然后右边是长度为ln的num记录二元组：步数和余数，表示再减一次就要借位（一定产生9，转移成形式1） 然后枚举当前位不断被借位的过程，处理好余数，记忆化搜索即可 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>好题</tag>
        <tag>难度3</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Equation]]></title>
    <url>%2Fposts%2F5574.html</url>
    <content type="text"><![CDATA[Source and Judge雅礼noip模拟题 Problem给一棵n个点的树，每个点代表一个未知数xi每条边给出权值，表示两个未知数的和q个询问，op=1表示询问：暂时补充一条边，唯一解输出x1，多解输出inf，无解输出noneop=2表示修改第x个点，向上的那条边的权值n不超过1000000 Record2h Analysis请先思考后再展开 写了有一点慢，比赛没时间写完暴力去拍，幸运地ac了 这道题主要是思维，还需要一点点运气因为输出x1，因为n个未知数的方程组需要n个方程，所以现在一定是不能解完的将第i个点向上的那条边，编号设定为i然后考虑高斯消元的思想，第i个点上面的边，和下面的几条边都有公共元，然后我们定义第i条边的主元是xi，所以向下消除然后设1向下的边为深度1，那么深度为奇数，下端编号为t的边，参与的未知数是xt+x1，否则是xt-x1然后边的权值，经过高斯消元后，形式为 $[奇数则取反] \sum -si$（具体符号请读者自行推导，很好想的） 然后对于每个修改操作，相当于对子树的所有边修改，然后具体的修改按照【当前边深度奇偶性和那条边深度的奇偶性的异或值】所以开两个树状数组，差分一下就好了 然后对于询问，把两条边连接在了一起 两条边深度奇偶性相同，那么形式为 0=S-权值1-权值2 奇偶性不同，那么形式为 2x1=S-权值1-权值2那么这两个方程的解的情况，自己随便判断一下就好了 时间复杂度 $O(nlogn)$ undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
        <tag>难度1</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Merchant]]></title>
    <url>%2Fposts%2F8c5f.html</url>
    <content type="text"><![CDATA[Source and Judge雅礼noip模拟题 Problemn个一次函数，选最多m个，使得有最小的t，令x=t时y的总和达到Sn不超过1000000，答案保证有解，而且在1e9内 Record1h Analysis请先思考后再展开 先考虑一个子问题，如果给出一个x，如何快速求出答案？借助nth_element可以在线性时间内得出答案（如果边加入边比较，不会爆ll） 最重要的提示：一次函数之和还是一次函数……这个打暴力的时候注意到了，但不够灵活，没有联想到 那么你考虑 $2^n$ 种选取情况，每种情况的贡献是一次函数因为我们不关心具体的方案，那么对于每个x，贡献连接起来是一个先向下再向上的形状（无论多少个一次函数，x最大的部分连接起来总是这个形状）然后我们要在这个形状中，找出最小的非负整数x满足y大于等于S这个形状是开口向上的，最小值左边的最大值就在0，右边是可以二分的 更简单一点，连最小值位置都不用找，因为如果你知道0不能达到，那么左边都没有贡献函数 $f(x)=[y \leq S]$ ，这样一个bool函数是满足二分性的 很不错的题目undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOI2014】购票]]></title>
    <url>%2Fposts%2F80e0.html</url>
    <content type="text"><![CDATA[Source and JudgeNOI2014loj2249 Record2h Analysis请先思考后再展开 先从序列的情况开始考虑 如果没有交通工具的距离限制，可以大力李超树$f(i)=- P_i \cdot dis_j + f(j)+ P_i \cdot dis_i + Q_i$或者斜率优化（x坐标单调，询问不单调，要下凸壳上二分）$f(j)=P_i \cdot dis_j + f(i)-P_i \cdot dis_i-Q_i$如果考虑距离限制，由于李超树的标记是永久话的，无法撤回，所以只能用斜率优化了 现在变成树上问题后，先从暴力说起，枚举每个点，向上跳，跳到不能跳为止并维护好凸壳，然后查询那么此时x坐标是递减地插入的，用deque就不能在上面二分了其实稍微变化一下就好啦： $f(j)=(-P_i) \cdot (-dis_j) + f(i)-P_i \cdot dis_i-Q_i$ 注意到为每个点重新建立一个凸壳非常制杖，我们需要尽量少重构凸壳，多利用公共信息然后有一个细节要始终留意：这是一棵有根树，一切都有先后，这个信息不能被破坏这种上面影响下面的特征，（dalao很容易） 联想到序列上的cdq的思想（显然我是想不到的） 设solve(rt,size)表示当前根为rt，rt的所有祖先已经向该子树内所有节点更新，我需要处理区域的大小为size每次在处理区域内找出重心G，将G的所有孩子断开，求解solve(rt,size-siz[G]+1)现在我们希望更新G的孩子，尚未更新他们的祖先显然是x到G的链，深度单调因为使用了cdq，我们只考虑上面对下面的更新，所有下面内部可以任意顺序处理，那么取出所有G的孩子，按照【能更新他的祖先中最浅那个的深度】从大到小排序，那么就可以在链上维护一个指针，用指针到G间的信息更新当前孩子（凸壳上二分即可） 最后每个孩子的子树，已经满足我们刚才的前提条件【rt的所有祖先已经向该子树内所有节点更新】所以可以放心的向下分治下去了 不难发现，分治的深度最大为logn，相同深度的覆盖区域几乎是不重叠的，区域内大部分节点都要在凸壳上二分所以时间复杂度是 $O(nlog^2n)$细节：正如我所说，区域几乎是不重叠的，但总有一些特殊情况，例如只有两个点，如果把重心定在下面，会发现死循环了所以需要稍微处理一下（可能有更巧妙的方法去规避？），等于的情况也替换重心 由于本题有难度，可能单靠我的分析不足以理解，故给出代码以供参考undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>点分治</tag>
        <tag>cdq分治</tag>
        <tag>好题</tag>
        <tag>难度3</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOI2007】货币兑换]]></title>
    <url>%2Fposts%2Fc1b5.html</url>
    <content type="text"><![CDATA[Source and JudgeNOI2007loj2353 Record2h Analysis请先思考后再展开 在dp方程的推导上，个人认为最困难的已经被提示出来了这个结论你告诉我，我会说这很可能是正确的；但我没把握能在考场上及时地想到并运用 那现在既然已经知道这个结论，那么某一时刻不是全是钱就是全是金券因为金券是二元的，涉及到状态的表示，但数量太大不能设状态，而钱是一元的，可以很方便地作为值设 $f(i)$ 表示第i天结束后，拥有的钱， $f(0)=S$设 x(i)=第i天，最多能拥有的A数量，y(i)同理则 $x(i)=\frac{f(i)\times R_i}{R_i \cdot A_i+B_i},y(i)=\frac{f(i)}{R_i \cdot A_i+B_i}$$f(i)=x_j \cdot A_i + y_j \cdot B_i$$y_j=-\frac{A_i}{B_i} \cdot x_j+\frac{f(i)}{B_i}$问题再次转化为，最大化斜距但和朴素的斜率优化不同的地方在于，x坐标不是单调地加入，询问的直线斜率也不是单调的 这意味着，我们需要一个数据结构，支持动态插入一个点后维护上凸壳（斜率递减），并任意查询某条直线的最大斜距 方法一：平衡树插入点以后，如果完全在内部，没有存在的意义，否则向左右删除，直到再次斜率单调递减 方法二：cdq分治solve(l,r)只考虑【l到mid】对于【mid+1到r】的贡献注意到我们希望决策点集关于x单调，被更新的顺序按照斜率单调然而，即使归并，右边的部分，点的坐标能被计算的前提是已经被更新完毕，所以solve(mid+1,r)应该在处理完后再递归然而这意味着，右边的斜率并不单调，对左边归并好，然后按常规构造出左边的凸壳（左边已经被更新完毕了），右边只能再次二分时间复杂度是 $O(nlog^2n)$ ，无法在loj上通过如果在cdq的过程中套个sort，复杂度并不会变小…… 发现网上的人都是单log的，难道是我姿势不对？看了看别人的代码，发现还真的有种非常巧妙地姿势（最大收获……，建议先了解整体二分的思想）先将所有询问排序，然后总是保证，所有当前区间的询问恰好在当前区间（不需要多开两个参数，注意到每个询问是双性人）那这个的实现是非常容易的，排序前记录好原本的时间，按照时间去分类就好了]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SDOI2016】征途]]></title>
    <url>%2Fposts%2F2381.html</url>
    <content type="text"><![CDATA[Source and JudgeSDOI2016luogu4072 Record1h Analysis请先思考后再展开 我以为方差是要开根的（其实那是标准差），所以推半天不知道为什么那是一个整数……$v=\frac{1}{n} \sum (a_i-suma/m)^2$$v=\frac{1}{m} (\sum a_i^2 -\sum 2a_i \times suma/m +\sum (suma/m)^2)$$v=\frac{1}{m} (\sum a_i^2 -2 suma^2/m +suma^2/m)$$v=\frac{1}{m} \sum a_i^2 - suma^2/m^2$$ans=v \times m^2=m \sum a_i^2 -suma^2$ 那么现在要求将n个数分成m段，每段权值为ai，最小化上式现在m和总和都是常量，就是一个裸的斜率优化了]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【agc016e】Poor Turkeys]]></title>
    <url>%2Fposts%2Fdec.html</url>
    <content type="text"><![CDATA[Source and Judgeagc016e Record30min Analysis请先思考后再展开 对于每个元素，维护它最后存活的条件，用一个集合表示，集合内所有元素都必须曾经存活（然后放入意味着死去） 倒着考虑时间，处理x的存活集合如果两个人都要曾求存活（以后的要求），则x必死如果只有一个人，则另一个加入集合（杀死他）如果都不在里面，则不变 最后统计答案，两个元素能同时存活，当且仅当他们各自存活，并且存活集合没有交集因为进入某个集合，意味着在这一刻要被充当替死鬼，所以不能充当两次 本题的精髓在于倒序处理说一个细节：因为本题是二元，不会存在这样一种情况【两个集合的并其实是同一个时间被杀死的】 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF799E】Aquarium decoration]]></title>
    <url>%2Fposts%2F7f0f.html</url>
    <content type="text"><![CDATA[Source and JudgeCF799E Record3h被折叠的数据结构里没开longlong见祖宗！拍了一小时…… Analysis请先思考后再展开 显然分成四类，排好序先枚举两种都包含的数量c，那么单一覆盖的是可以贪心选择的如果超过m，非法小于m，维护好剩余集合，用一个数据结构维护【前k小的和】树状数组会比较好写 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Nwerc2015】赌骆驼]]></title>
    <url>%2Fposts%2F5fb6.html</url>
    <content type="text"><![CDATA[Source and JudgeNwerc2015 Guessing Camelsbzoj4430 Record1h Analysis请先思考后再展开 显然是个三维偏序，可以直接cdq，是log方的然而又一种巧妙的log的做法非法情况存在一种性质：每次取出两个排列的话，三种情况两种相同一种不同不妨设 $PA_i &gt; PA_j,PB_i &lt; PB_j$两两取出来，统计这个二维偏序，那么每队算重复一次，除以2，就是非法情况undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>cdq分治</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【雅礼day4】t2]]></title>
    <url>%2Fposts%2F7387.html</url>
    <content type="text"><![CDATA[Source and Judge雅礼noip模拟题 题意给定一个无向图，n 个点（从1 开始编号）、m 条边（长度为1），每条边有一个权值c(0或1)。一条路径，可以表示为一个长度为经过边数的01 串，串的第i 位为经过的第i 条边的权值。两条路径相同，当且仅当表示其的01 串相同。求从1 号点出发、长度为d 的路径种数。n小于90，可能是完全图d小于20 Record1h Analysis请先思考后再展开 因为前导0的存在，给每种状态加上其长度的二次幂相当于强行插入一个1在最前面，使得所有状态不重不漏，共计 2^{n+1}这样状压好以后，很容易想出 $O(2^n n^2 / 32)$ 的做法，利用bitset可以卡时间过通过折半搜索可以把复杂度除以10，即 $O(2^{n/2} n^3 /32)$先枚举一个起点，然后枚举当前位置，转移即可最后把起点1的部分和其他起点合并起来，dp的时候顺便处理好就能快速实现 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SDOI2013】保护出题人]]></title>
    <url>%2Fposts%2F44ef.html</url>
    <content type="text"><![CDATA[Source and JudgeSDOI2013luogu3299 Record1h Analysis请先思考后再展开 很容易划出柿子：$y_i=max \frac{sum_i-sum_{j-1}}{x_i-(i-j) \cdot d}$看到分数，考虑一下斜率、直线等东西所有以前的点为 $A(j \cdot d,sum_{j-1})$当前的点为 $B(x_i+i \cdot d,sum_i)$那么相当于求与B斜率中最大的那个，显然在凸壳上，三分找到极值横坐标单调很好维护凸壳]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【IOI2000】Post Office]]></title>
    <url>%2Fposts%2F5867.html</url>
    <content type="text"><![CDATA[Source and JudgeIOI2000poj1160 Record1h Analysis请先思考后再展开 放一个就是中位数，用这个来dp打决策表，验证决策单调性undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poi2011】Lightning Conductor]]></title>
    <url>%2Fposts%2Fce55.html</url>
    <content type="text"><![CDATA[Source and JudgePoi2011bzoj2216 Record1h Analysis请先思考后再展开 突破口在根号，显然有决策单调性和诗人小G差不多，所以那个做法就不讲了看题解的时候意外地发现了分治做法，也是利用单调性，挺好的undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOI2009】诗人小G]]></title>
    <url>%2Fposts%2Ffb5d.html</url>
    <content type="text"><![CDATA[Source and JudgeNOI2009bzoj1563 Record2h Analysis请先思考后再展开 题意：多组数据n个句子，分行，每行的代价为【总长度+中间的分割空格数量】与L的差的p次方最小化该代价并输出方案如果超过1e18，输出Too hard to arrange每组数据后输出20个“-” 发现了bzoj的目前唯一优点：将繁琐而sb的输出方案省略 本题通过暴力打表验证，发现决策满足单调性（从证明上说就是满足四边形不等式，虽然我并没有去证明hh）然后我一开始就想了一个很sb的问题：既然决策点单调，每次从那里开始往后移动指针不就好了？但对于每个i，其j的验证并不是单调的，虽然确实可以从那里开始，但不得不全部扫一遍如果每次的下一个就是最优解，那么依然是平方级别的 但反过来考虑，考虑i能够给多少个后面的k作贡献，就好维护多了维护一个数组q，表示最优决策点的位置，此时如果设计一个函数，表示和原本相比是否更优，那么一定是单调的，二分查找即可我在具体实现的时候，分了一下段，稍微加速下~ undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CEOI2008】order]]></title>
    <url>%2Fposts%2F956c.html</url>
    <content type="text"><![CDATA[Source and JudgeCEOI2008bzoj3709luogu4177 Record2h Analysis请先思考后再展开 决策问题考虑网络流依赖关系再深入考虑到闭合子图如果没用租用机器这个选项，这就是个裸题租用机器和其他任务无关，考虑这个特征如果x依赖y，将原本的INF改成租金，表示破除依赖关系 当前弧优化：当层次确定的时候，反向弧是否使用也是确定的那么如果一条边流完了，可以在边链表中去除（有点类似欧拉路径的优化）因为是层次图，不用担心dfs对第一个有效边数组的影响 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>难度2</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poi2010】Bridges]]></title>
    <url>%2Fposts%2F85f0.html</url>
    <content type="text"><![CDATA[Source and JudgePoi2010bzoj2095 Record2h Analysis请先思考后再展开 这题有点东西（ozy语气） 显然先二分，终点是check其实就是验证一个混合图的欧拉回路考虑无向边，先钦定一个方向，到时候再考虑转向 条件：最后每个点的入度=出度而且是连通图（并查集一下即可） 考虑每次换向，相关的点，度的差会+2或者-2，所以说肯定不会差为奇数，要判一下然后这种决策性的问题，可以考虑网络流，假如钦定了x到y，则从y到x连一条边，表示转向，流量为1然后我们要平衡每个点的入度和出度，如果入度多出来，连向起点，流量为需要转向相关的次数即 $(in-out)/2$否则连向终点，表示一种需要平衡的状态最后如果能跑满流，意味着流量的平衡 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>难度2</tag>
        <tag>欧拉路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[联盟]]></title>
    <url>%2Fposts%2F699c.html</url>
    <content type="text"><![CDATA[Source and Judge雅礼noip模拟题 问题给出一棵树，可以断开再连接一条边，求最小直径，n小于300000要求输出最小直径，和最优方案中所有可能断开的边，然后输出一组断开和连接的具体方案 Record7h Analysis请先思考后再展开 真tm佩服我的耐心都快忘记最初的思路了……太可怕了做法繁琐，细节无数，码量巨大，不愧是雅礼的防ak题 果然直径有很多性质，特别好用，虽然不会证明 就是两棵树合并起来，新的直径端点一定是在原本两边直径端点中产生 然后最优的连接方案一定是将两边直径的中点连接起来，这个倒好证明一点，连接其他地方一定不会更优$L=max(L1,L2,\lceil \frac{L1}{2} \rceil+\lceil \frac{L2}{2} \rceil+1)$ 考虑枚举每条边，断开他，然后问题变成求两边的直径，这个在处理了dfs序以后是可以用线段树维护的（注意，为了确保任何区间都能形成联通块，要回溯，这个在st表用深度求lca时也要用到）相当于，只用这段区间内的点，形成的树的直径，利用上面说的那个性质1合并（记录具体端点） 理论复杂度nlogn，但实际上因为结构体的维护，常数巨大，需要卡常本题有线性做法，感觉很繁琐，就没去搞 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蔬菜]]></title>
    <url>%2Fposts%2Fc8e3.html</url>
    <content type="text"><![CDATA[Source and Judge雅礼noip模拟题 问题给出一个矩阵，q次询问，求一个子矩阵中，每种颜色出现次数的平方和n和m在200以内，询问在100000以内 Record1h Analysis请先思考后再展开 这道题同时用到了多个思想显然先离散化一下 有一个子任务，可以给我们启示：颜色种类数比较少那我们可以给每种颜色处理一个二维前缀和 但如果比较多呢？有一个不好想的做法：对每种颜色的出现次数（总矩阵而言），分类讨论处理办法如果某种颜色数量多，意味着在总矩阵中份额大对于数量级达到T的颜色，只有 $\frac{n^2}{T}$ 种，这些是可以预处理前缀和的但对于零散的颜色，就要用另外一种思想了：平方和转点对数量也就是说，如果这些颜色的所有点内部形成点对那么每个询问就转化为一个四维偏序问题（询问为abcd）：$a \leq x1,x2 \leq b;c \leq y1,y2 \leq d$对于这种类型的颜色，处理所有点对，离线后将点对和询问混合再排序，那么就变成一个三位偏序问题，可以用三维树状数组搞这里有个细节，因为第一维我们用的是排序，但同时有可以去等，所以一定将具体类型作为第二关键字 接下来考虑复杂度零散的颜色即使有n方种，每次往前扫k个形成点对总时间为 $O(\frac{n^2}{T}(n^2+q)+(q+n^2T) log^3 n)$考虑均值不等式 $a+b \geq 2 \sqrt{ab}$ ，取等号当且仅当a=b，列等式计算得 $T=\sqrt{ \frac{n^2+q}{log^3 n} }$时间复杂度自行验证，通过计算知其也可以通过本题 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>四维偏序</tag>
        <tag>分类处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【poj2057】The Lost House]]></title>
    <url>%2Fposts%2F4075.html</url>
    <content type="text"><![CDATA[Source and Judgepoj2057 Record2h Analysis请先思考后再展开 感觉这个期望的柿子很不好推啊，我也是看了提示才想到的提示：将以x为根节点的子树代价，分答案是否在其中考虑，其期望分别为f和g “贪婪的动态规划”论文上没有利用期望的线性性，而我感觉用的话容易理解一点……我的方程：$g(x)=\sum 2+有虫子则g(y)$假如我们已经知道某个遍历顺序（尝试顺序，可能走到一半出来）然后考虑枚举某个孩子，答案就在这里的贡献$f(x)=\sum 该后继状态发生的可能 \times 该状态的期望$$f(x)=\sum \frac{叶子数量}{总叶子数量} ( \sum( g(s_1 \to s_{i-1})+2 ) + f(y)+1 )$注意这里g的计算规则和上面g那个一样，根据虫子跳出，具体实现可以前缀和 然后因为题目保证孩子数量最大为8，可以预处理所有排列，可通过本题undefined 其实还有更快的做法考虑相邻的两个，他们产生的贡献，=推推柿子，再交换一下，就会变成：g的贡献（g(x)+2，同样考虑虫子来计算），除以其叶子数量那么这个比较只和自己有关，可以直接排序 这样1000个孩子我都不怕了undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折射]]></title>
    <url>%2Fposts%2Fedc4.html</url>
    <content type="text"><![CDATA[Source and Judge雅礼noip模拟题 问题给出n个点，计数有多少种方案满足：yj &lt; yj−1xj−2 &lt; xj &lt; xj−1 或 xj−1 &lt; xj &lt; xj−2空间128，时间1sn小于6000 Record1h Analysis请先思考后再展开 以我自然的思维，直接把y排序了，然后空间就被卡128MB了正解是把x从小到大排序，那么问题会转化为区间dp，只不过方向稍微有点不同本代码保留了逐步优化的痕迹，应该非常好懂undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2015 接水果]]></title>
    <url>%2Fposts%2F4478.html</url>
    <content type="text"><![CDATA[Source and JudgeHNOI2015 接水果 Record1h Analysis请先思考后再展开 目前见过最难的整体二分了，但也不是很难，可能是我刷题太少 包含这东西，很显然可以化化柿子，然后就是dfs序的一个矩形 问题转化为，求每个点，覆盖它的矩形中，第k大的整体第k大的查询，就是很套路二分以后，重点就是check，用小于mid的部分，询问被多少个覆盖掉那这个暴力搞得话例如cdq、树套树什么的……但都太复杂了没细想其实，重点在于它是一个矩形，可以扫描线搞 例如说拆成左线段和右线段，然后就变成修改和查询，然后就树状数组询问次数就好了 顺便提供一份反例代码，改成盘子是水果的父路径看错题的自我安慰：能出题undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>整体二分</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Wf2016】Swap Space【PA2014】Bohater]]></title>
    <url>%2Fposts%2F2c33.html</url>
    <content type="text"><![CDATA[Source and JudgeWf2016 Swap SpacePA2014 Bohaterbzoj3709bzoj1495 Record30min Analysis请先思考后再展开 神仙栋老师的比赛题然后发现对于下降的类型，按b降序能过样例和随便手出的数据写一发，和其他策略对拍也没错，然后就顺利瞎jb过了…… 赛后补一发证明（忽略相等情况等细节）：设有1号和2号，满足 $a1&gt;b1,a2&gt;b2,b1&gt;b2$$A=max(a1,a1-b1+a2)$$B=max(a2,a2-b2+a1)$仅当 $A&lt;B$ 时，1号放在2号前面 情况1$a1&lt;a2$ 此时1号优 情况2$a1&gt;a2$① $b1&lt;a2$$a1&gt;a2&gt;b2$$A=a1-b1+a2$$B=a2-b2+a1$则1号优 ② $b1&gt;a2$$a1&gt;b1&gt;a2&gt;b2$$A=a1$$B=a2-b2+a1$则1号优 综上所述，b越大越应该放在前面]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适者]]></title>
    <url>%2Fposts%2F81f.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj4700 Record1h Analysis请先思考后再展开 神仙栋老师的比赛题 毫无疑问，应该先把血量转化为需要攻击的次数 先考虑一开始不杀人的情况设有相邻的两个，编号1号和2号，1号在2号前的必要条件是 $t[1] \cdot a[2]&lt;t[2] \cdot a[1]$其实这就是个性价比，比赛的时候顺利猜到结论……那么顺序就确定了 T表示时间的前缀和，A表示攻击力的后缀和然后时间总和就是 $\sum (t[i]-1) \times a[i] + t[i] \times A[i+1]$ 考虑杀死一个的情况，将每个人被秒杀的价值表示出来$c[i]=(T[i]-1) \times a[i] + t[i] \times A[i+1]$但两个（设为 x &lt; y ）怎么处理呢？$c[x]+c[y]-t[x] \cdot a[y]$前一个的决策影响后一个，如果直接枚举，好像也没有什么好办法 做法一把y固定，x的贡献就是一个关于ay的一次函数（直线）然后询问相当于找到与直线交点中y最大的那个有一种名为李超线段树的数据结构能很方便地维护其主要思路就是，记录当前区间内，完全覆盖的线段（本题是直线，不用考虑）中交mid最高的那个然后因为只能和当前层有关，只能标记永久化当一个线段被淘汰的时候，就往某个方向下传更新（自行推导具体方向）undefined 做法二其实看起来会联想到斜率优化的方程形式…… 同样是固定y，设有 a &lt; b则a更优秀的条件： $c[a]-t[a] \cdot a[y] &gt; c[b]-t[b] \cdot a[y]$如果 $t[a]-t[b]&gt;0,\frac{c[a]-c[b]}{t[a]-t[b]} &gt; a[y]$这个斜率是单调递增的，也就是一个下凸壳，具体证明可以随便画一个经典的凸三角 因为在原本的顺序上，t和a都不是单调的，所以相当于维护一个动态凸壳可以用平衡树搞，也可以用cdq 这里讲cdq的做法，因为比较短只考虑左边对右边的影响左边按照t降序，强行满足上面的条件右边按照a升序，那么单调队列的头是只会往后的 undefined 左右两边关键字不同，怎么把log省掉呢？其实维护两个数组，要用哪个用哪个就好了……undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>贪心</tag>
        <tag>动态凸包</tag>
        <tag>标记永久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC41】最短路]]></title>
    <url>%2Fposts%2Fabe2.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC41 Record1h Analysis请先思考后再展开 暴力分是个经典套路，居然忘记了……参见 WC2011 最大XOR和路径，之前写过题解的就是把每条环的异或和放到线性基里面 正解感觉不太好想，不过被xgc大爷秒了就是给r排序，然后不同的线性基只有30个用链表动态维护好左边的每一个位置（记录left表示最后一个有贡献的位置）询问的时候30+30找到包含的第一个查询的时候，因为左边的线性基会包含右边的，从右往左扫，现在插入的num不断少个1，具有单调性这样乍一看是log方的，但如果预处理出每个数的最高位的位置，insert的时候从那里开始，就log的复杂度了 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线性基</tag>
        <tag>难度2</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC40】Erlang]]></title>
    <url>%2Fposts%2Fcc15.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC40 Record1h Analysis请先思考后再展开 一开始看错题意了，决策可以是动态的，根据取出来的数再决定下一步 如果是静态的话，显然最多搞两个集合考虑枚举每一种颜色一、如果某个集合有多个，贡献为 len-其他种类+2（取光其他所有才出来）二、分开来， len-其他种类+1 最少的两个之和（最后才出来）时间复杂度n 其实改成动态并不难，最多搞两个集合这个性质依然是对的，但不能再枚举具体颜色了一、如果某个集合有多个，贡献为 颜色种类+1二、分开来这里是难点自己曾想到一种情况，但不知道怎么解决：可能我后面取出来的答案即使加上取出来的消耗依然比早出来的小然后看到动态决策就很蒙蔽，不知道怎么处理…… 其实很容易证明，最坏情况一定是按贡献从大到小出来的用微扰可以证明，其他的情况都会比这个更优所以排序后每个的贡献就很明确了，即【存在此颜色的所有集合中，除了这个之外，最小的 其他颜色个数+1】（这里我们不再考虑，因为取到别的相同颜色而停止的情况，因为在前面已经计算过了） undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOI2006】网络收费]]></title>
    <url>%2Fposts%2F51ff.html</url>
    <content type="text"><![CDATA[Source and JudgeNOI2006Luogu4297bzoj1495 Record1h Analysis请先思考后再展开 一开始没看懂题意……这里费用的计算，是对于所有的点对，而不是自己配对…… 因为是所有点对，观察系数，发现可以拆分到点权上预处理cost[x][j]表示x这个叶子节点，【与其lca在第j层】的节点的f之和那么如果知道了这个祖先管辖区域内哪种多，就能知道具体费用了 接下来基本上就等价于 JLOI2015 战争调度 了就是管理节点有两种类型，暴力枚举，背包时去除非法状态然后叶子节点也是两种，暴力向上统计 时间复杂度的话，$T(m)=4T(\frac{m}{2})+2m$设 $T(m)=1$ ，则根据主定理得 $T(m)=m^2$然后 $m=2^n,T(2^n)=2^{2n}$考虑到 $T(1)=n$ ，时间复杂度为 $O(n \times 2^{2n})$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC31】MST]]></title>
    <url>%2Fposts%2F381c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC31 Record3h Analysis请先思考后再展开 神仙题，%出题人这道题我能非常认同其做法，但我深知不是我能自己想出来的范围内 如果我按顺序枚举每一条边，那么非树边一定连接同一个块，而树边连接不同两个块因为每个节点都是一样的，用【每个大小的联通块数量】表示，这个状态总数是37338用这个状态的出现编号作为hash，那么就可以用这个来线性dp把状态按照【越大联通块是越前的关键字】排序，这样就能保证线性性然后顺序枚举每个状态，往后继状态转移为了方便找到对应的hash，建议用一个trie，因为map是其15倍（如果hash不稳……） 现在是 $O(n^4 \times 状态)$ 的，分情况加速考虑树边，枚举两个联通块然后合并起来，在这个过程中显然和具体边无关所以可以对于每个状态预处理，记录能否转移以及转移系数（这个自行推算）考虑非树边，因为是一个完全图，我们需要知道有哪些地方还能加入边注意到加入之后状态的表示没有变化，所以其实跟具体在哪个加入是没有关系的所以说，可以动态维护一个全局num数组，表示每个状态在当前可以加入的空位数量这个东西的维护可以自行推导 注意到一个重要的细节，也是我之前的疑惑之处就是我原本认为这个num应当是状态的一部分，但显然这样会炸其实你会发现，在外层枚举了边数之后，某个状态的num其实是确定的（从num的维护可以看出） 然后这道题就做了两天…… 计数dp中，滚动数组用完要清零 注意各种边界 其实这个num是可以不用dp的，不过我不想再花n的时间去计算num，好像ozy会很快的方法，不管了…… 时间复杂度的话，感觉是n三方的，而且个人感觉会跑满……然而最后还是O(能过)，可能会有更优秀的做法? undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC32】Sort]]></title>
    <url>%2Fposts%2Fbfa5.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC32 Record1h Analysis请先思考后再展开 思考排序本质的好题 先考虑只有0和1的做法考虑归并排序，那么一定是000000111110000001111这样的那么只要把中间的部分翻转就好了 回到原问题，回忆朴素的快排，找到一个基准点后，小的放左边，大的放右边，再搞一下去那这个过程可以转化为01序列然后套归并上去 不过这里会出现很多细节，比如132，就不能保证小的到左边如果变成0、1、2或许可以解决问题，但这样再归并会很麻烦一种巧妙的做法是基于值域分治（离散化后） 时间显然是log方的，现在让我们证明代价的复杂度（忽略常数） 归并：$T(n)=2T(\frac{n}{2})+n$根据主定理，$T(n)=nlogn$ 快排：$T_2(n)=2T_2(\frac{n}{2})+T(n)=2T_2(\frac{n}{2})+nlogn$那么每层是nlogn，然后有log层$T_2(n)=nlog^2n$ undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>分治</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod刷题计划]]></title>
    <url>%2Fposts%2F8a7d.html</url>
    <content type="text"><![CDATA[atcoder的题解好像有点少……去刷51nod吧，好像很多是翻译成中文的原题感觉思维难度还是不错的 1 1051 最大子矩阵和9.25 难度1请先思考后再展开 二维版，套个一维的+前缀和就好了undefined 2 1020 逆序排列 HAOI2009 逆序对数列9.25 难度1请先思考后再展开 $f(n,k)=\sum_{i=0}^{n-1} f(n-1,k-i)$不能开ll，会被卡空间然后为了方便可以相邻做差，具体看代码undefined 3 1674 区间的价值 V29.25 难度1请先思考后再展开 枚举每个l，然后向右看，计算贡献分开来考虑每个位，对于and只关心第一个1，or只关心or那么可以统计每个位的贡献，分成两部分的权值，最多共有60个不同的断点那么排序一下就好了，差分统计贡献 我真的好菜啊上一道题的maxn忘记改了……undefined 4 1675 序列变换9.26 难度2请先思考后再展开 莫反显然，但我发现我不会计算条件2……看题解，原来用个桶就好了，根据调和级数是log的undefined 5 1682 中位数计数9.26 难度2请先思考后再展开 又是巧妙地用桶，套路地转化为-1和1，然后找和为0undefined 6 1686 第K大区间9.26 难度2请先思考后再展开 我不会二分了怎么办……undefined 7 1052 最大M子段和9.26 难度1请先思考后再展开 显然的dp前缀和mx优化一下就好了undefined 8 1120 机器人走方格 V39.26 难度2请先思考后再展开 卡特兰数裸题undefined 9 1555 布丁怪9.29 难度2请先思考后再展开 本来以为这是一道找性质题，然后想了个错误的性质，就凉了…… 首先不难想到，问题会转化成，求一个序列的某一段，其中每个数都出现且仅出现一次，并且连续覆盖本来想着可能可以用什么巧妙的技巧去判断bitset中连续的1，但没什么想法…… 正解是转化为区间极值，让极值的差和长度差相同log方的话显然线段树但也可以分治，每一层，处理l和r不在相同区间的问题 这个极值挺麻烦的，用分情况讨论可以简化一、min和max都在左边，此时计算一下前缀后缀与mid的极值即可快速计算二、min在左边，max在右边，此时需要用两个尺取法，同时维护，并用桶维护公共区间 另外的两种情况是镜像问题，可以通过 【翻转序列+调整mid】 简化代码复杂度undefined 10 1125 交换机器的最小代价10.1 难度2请先思考后再展开 每个位置向它想去的点连边，那么因为每个点出度和入度都是1，一定是若干个环组成的对于每个环，有两种策略一、用内部最小的节点逛一圈二、用外部最小的节点逛一圈再回去 undefined 11 1131 覆盖数字的数量10.1 难度2请先思考后再展开 根据 $num\%a \leq b-a+1$ 可知能表示的区间一定是用 $ka \to kb$ 组成的然后当k达到一定大小后，后面都会重叠，所以二分k，前面等差数列，后面连续 打这个细节多到吃屎……undefined 12 1189 阶乘分数10.3 难度2请先思考后再展开 bzoj2721 感觉我不可能想到……$n!(x+y)=xy,x&gt;n!,y&gt;n!$$y=n!+z$$x=\frac{(n!)^2}{z} + n!$$ans=(n!)^2 的约数$那么筛一下最小质因子，套个公式就好了 13 1201 整数划分10.16 难度2请先思考后再展开 好像又被套路了感觉这种思路非常难想主要是因为互不相同，你可以维护一个相对大小关系，这个关系一定是从1开始的然后经过一系列的整体增加1得到当前的方案那么现在dp，要么群体加1，要么群体加1然后前面插入一个1，总是能保证互不相同的undefined 14 1215 数组的宽度10.16 难度2请先思考后再展开 被lxj锤爆了，只会分治的nlogn做法处理出min和max下，每个数能覆盖的范围然后柿子是可以拆开来的，min和max拆开统计就行了 15 1217 Minimum Modular CF303C10.16 难度2请先思考后再展开 感觉这题有点难度考虑相等的二元组， $a_i=a_j (\% m)$如果枚举每个m，那么他们的差一定是m的倍数（包括0）那么如果存储差，通过枚举m的倍数，就能得到所有的数对，而且是mlogm的注意到k很小，数对显然不会超过 $k(k+1)/2$ 对，是很强力的剪枝对于每一种实际的余数，第一个不需要删除，可以用链表拿出所有点对，进行计算该做法的复杂度是有保证的，但常数略大，很容易被暴力枚举n的做法吊锤，而且还被卡空间…… 故本代码暂时没ac，但一定是正确的undefined 16 1241 特殊的排序10.16 难度2请先思考后再展开 非常秒的思维题答案是，保留一段值连续数列，其他的一定存在一种方案，移动到左边或者右边所以线性dp一下就好了 17 1259 整数划分 V210.16 难度2请先思考后再展开 因为可以相同，数的数量会达到n可以巧妙地分块 只用1~T的数， $g(num)=\sum g(num-a)$ 用后面的数，那么这个部分，数的数量会在n/T以内，那么又可以用前面的做法了，不过不在需要保证互不相同了，在插入一个T+1的时候，其他不需要增加$f(i,num)=f(i-1,num-(T+1)),f(i,num-i)$答案就是其卷积undefined 18 1262 扔球10.16 难度1请先思考后再展开 其实画这个图的途中，想了很多东西，最后的结论只和左下角那个反例有关那就是你必须经过这n+1个点！那画图的时候，我枚举了一个跨度，这也是灵感的来源这个跨度必须和n+1互质，用公式求一下欧拉函数即可ans=phi(n+1) 19 1273 旅行计划10.17 难度2请先思考后再展开 我的思路，下限nlogn：维护一个线段树表示，以dfs序为编号，每个点到根的距离然后动态选取最大的那个，把这条链并到根节点，合并的途中影响的总是子树整体，dfs序上是连续的然后每个节点只会被合并一次，所以是nlogn 正解，下限n：显然选择的点总是叶子节点，每个节点只会被一个叶子节点覆盖，父亲节点被覆盖的候选总是在儿子节点中产生，dfs回溯的时候处理即可最后再把叶子排序即可 20 1274 最长递增路径10.17 难度2请先思考后再展开 性质1： 一条边最多经过1次性质2：路径上边权严格递增将每条边排序，然后加入图中，此时一定是路径的最后一条（严格递增），没有后效性，可以直接转移（但为了保证严格单调，需要将同权值的边分组，滚动一下即可） 21 1277 字符串中的最大值10.17 难度2请先思考后再展开 kmp$f(nxt[i])+=f(i)$undefined 22 1293 球与切换器10.17 难度2请先思考后再展开 这是一道sb题，但我也是个sb……唯一提示：可以看作所有球同时放进去undefined 23 1296 有限制的排列10.17 难度2请先思考后再展开 显然先拆开，变成每个位置，和前面的大小关系然后我就卡住了，不知道怎么解决，必须是排列这个条件然后好像这是一个套路？dp的时候保证f(i)是大小为i的排列，时刻保证合法性，然后插入一个数的话可以把前面&gt;=num的部分整体+1 24 1322 关于树的函数10.18 难度2请先思考后再展开 一道sb题，但我这sb又没想到唯一提示：||A1|B1||:-:|:-:|:-:||A2|a|b||B2|c|d| a+b=a+c=b+d=c+d=n 25 1328 比赛往事10.18 难度2请先思考后再展开 这道题ac人数极少，我想写一发网上第一篇正式题解（思路主要是自己想的，少量参考了出题人的口胡）题目的性质：确定一些位置后，内部元素是可以任意交换的抓住这个性质，先定位出所有非法的位置，他们一定是要操作的对于每次固定位置后，最优策略一定是a和b分别排序如果合法了，直接退出，否则利用其它元素进行修正 维护好一个非法集合，那么里面每个元素迟早要被再次替换我们每次选取最大的那个place，外面能参与进来的一定是 $cutoff \geq place$在可参与的集合中，显然应该选择最小的那个place，加入后产生了推移循环地执行此操作即可，最多加入n次，内部要排序一下，所以时间复杂度是 $O(n^2logn)$ （当然你非要写个插入排序也行） 下来我们讨论一些细节： 是否有可能找出来的a，无法使整个串推移呢？答：其实这是个无解情况，break否随你 不选取最小a行不行？答：可能可以，但这样显然不会更差 undefined 26 1353 树10.18 难度2请先思考后再展开 $f(x,siz=1 \to siz_x)=f(x,siz-a) \times f(y,a)+f(x,siz) \times f(y,k \to siz_y)$undefined 27 1354 选数字10.18 难度1请先思考后再展开 离散化约数，做个乘法背包即可undefined 28 1378 夹克老爷的愤怒10.22 难度2请先思考后再展开 贪心+树形dp仅当必须要放的时候再放比【救火站】简单一点（自行搜索blog）undefined 29 1379 索函数10.23 难度2请先思考后再展开 前置知识： 斐波那契通项公式： $\frac{1}{\sqrt 5} [ (\frac{1+\sqrt 5}{2})^n-(\frac{1-\sqrt 5}{2})^n ]$ num在二进制下的位数为 $\lfloor log_2 num \rfloor +1$然后经过打表、感性理解可知， $Sor(n)=2^{Fib(n)的位数}-1$小证明：斐波那契数列的每个1，因为是不断加法得到的，显然一定是通过后一个位的两个1组成的，根据数学归纳法可知，该性质成立 当n=0，输出0当n比较大时，后面的部分趋近于0n较小时暴力计算undefined 30 1383 整数分解为2的幂10.23 难度1请先思考后再展开 方法一：$f(num,k)$ 表示num这个数，最大为 $2^k$ 的方案计数$f(num,k)=\sum_{i=0}^k f(num-2^k,i)$前缀和优化后，时间 $O(nlogn)$ 方法二：$f(num)=f(num-1)+[num是偶数] \times f(num/2)$ 31 1423 最大二“货”10.23 难度2请先思考后再展开 思路从一开始就是错误的枚举每个数作为最大值的贡献，那么找次大值会很麻烦，还曾考虑可持久化字典树什么的……但其实用次大值找最大值就好了……单调栈一下就没了……]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【Cqoi2011】动态逆序对]]></title>
    <url>%2Fposts%2Ffea4.html</url>
    <content type="text"><![CDATA[Source and JudgeCqoi2011bzoj3295luogu3157 Record1h Analysis请先思考后再展开 带修主席树：时间倒流，变成求在前面的比它大的数和后面小的数用前、后缀的带修主席树维护一下就好了 cdq分治：我似乎和网上所有人的都不一样……一开始还怀疑我的做法是错误的，后来发现是枚举顺序有一点问题，不单调了 就是给每个数打上时间戳，然后不删除的就是m+1、m+2……n那么问题变成 $t_a&gt;t_b,p_a&lt;p_b,d_a&gt;d_b$ 和 $t_c&gt;t_b,p_c&gt;p_b,d_c&lt;d_b$ undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>主席树</tag>
        <tag>cdq分治</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POI2009】救火站]]></title>
    <url>%2Fposts%2F9d1.html</url>
    <content type="text"><![CDATA[Source and JudgePOI2009bzoj1117 Record1h Analysis请先思考后再展开 神仙题……而且我不知道怎么证明其正确性所以我权当记录我的做法的合理性和逻辑性，如果有帮助证明的好角度请评论 设 $ned(x,t)$ 表示当前节点x的子树中，有多少个节点是没有被覆盖而且与x距离为t的设 $remain(x,t)$ 表示x的子树中，某些点放置了消防站，而且其配额K即使到达x依然剩下t的距离，的节点数量 我们放置节点，当且仅当有距离为K的节点没有被覆盖（此策略不包括根节点）此时我们放置了足够的消防站，同时产生了许多配额把这些配额随着深度的减小统计起来后，使用当且仅当，我必须在此时去更新，否则到父亲那里我就需要用更大的花费了这里的必须，指对于我而言多出的配额与需要的距离相差在1以内（否则总是可以稍微延后一点的，不会亏，如果有更适合的还会赚） undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>好题</tag>
        <tag>难度3</tag>
        <tag>贪心</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JOI】稻草人]]></title>
    <url>%2Fposts%2Fa999.html</url>
    <content type="text"><![CDATA[Source and JudgeJOIbzoj4237 Record1h Analysis请先思考后再展开 太巧妙了……分治真是世界上最美妙的思想…… 这道题的重点就是矩形中间不能有其他的稻草人任意一个矩形一定会经过一个横线，我们可以分治y，然后考虑两个端点一个在右上一个在左下的情况 不妨把上下分别按照x排序，然后枚举上面的一个点看做右上角，然后考虑下面的贡献首先，显然不能先覆盖到上面的节点，而此时x是单调的，所以维护y比当前小的最近位置这个可以非常轻松地用单调栈维护，因为如果下一个更高，则最近为当前，否则一定在前面而没有被删除从那个位置到当前之间的x都是可选的，接下来考虑下半部分的处理因为不能被前面的点的y覆盖到，可选的点，随着x的增加一定递减不妨用一个单调递减栈维护，内部x递增，可以用刚才得到的x区间来二分查找，统计答案 分治log层，每层nlogn，所以复杂度是 $O(nlog_2^2n)$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ZJOI2016】旅行者]]></title>
    <url>%2Fposts%2Faf7.html</url>
    <content type="text"><![CDATA[Source and JudgeZJOI2016bzoj3319Luogu3350完整题面uoj184 Record1h Analysis请先思考后再展开 神仙分治题（抱着整体二分的目的前来……然而并不太一样）考虑分割矩形，用类似整体二分的思想，把询问也分割但和常见的题型相比（我指我唯一做过的找k大模型……），我们并不能保证询问结果一定完全这么贡献但是，分割的时候，有一个特殊的性质，也是本算法最关键的地方：如果某问题应该在当前分治段解决（最优的路径被分割线划分），那么一定会经过分割线于是，跑最短路的时候就不需要枚举起点了，从s变成根号为了让复杂度尽量低，应该选择短的那条分割线，同时后面的分割区间可以不再管mid（大概是稍微优化点常数吧，跑到了bzojrk62）undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HAOI2012】外星人]]></title>
    <url>%2Fposts%2Ff69a.html</url>
    <content type="text"><![CDATA[Source and JudgeHAOI2012bzoj2749luogu2350 Record2h Analysis请先思考后再展开 题面上的x是指函数的阶，可以理解为嵌套数量 首先，phi有个奇妙的性质：只有phi(2)=1，其他的结果都是偶数这个不难证明，根据欧拉函数的公式，除2以外的素数都是奇数，减一得到偶数 逆向考虑一下，那么为了得到1，迟早要变成2的形式对于a为偶数的情况，枚举拆phi会去除一个2，然后2-1在连乘中没有影响，所以等价于一个2去除了但此时其他的素数会变成p-1，一定会产生2（如果有） 因为这个性质中，2的去除每次拆开只会进行一次（整个a而言，而不是每个素数都这样）那么这个2的次数其实能推导出嵌套深度，所以问题转化为，求出N在不断拆开的过程中，产生的2的数量 而对于a是奇数的情况，这一次拆开不会消除2，所以应该在原本的基础上+1同时不需要考虑以后的情况，就像上文所说的，以后的phi的结果都是偶数 $f(prime)=f(prime-1)$$f(prime^k)=f(prime)*k$$f(num)=\sum f(prime^k)$这个是可以线筛的时候顺便搞的 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>出题</tag>
        <tag>复习</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj3261】最大异或和]]></title>
    <url>%2Fposts%2F10a2.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj3261 Record2h Analysis请先思考后再展开 类似之前做的最大xor路径等题（刷算法竞赛进阶指南的时候）维护区间的trie，在上面贪心即可写的过程非常不顺利，一大堆sb错误 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>可持久化字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SDOI2012】Longge的问题]]></title>
    <url>%2Fposts%2Fafb7.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj270551nod1040 Record1h Analysis请先思考后再展开 约数个数表：num=256 sum=9699690num=512 sum=223092870num=768 sum=446185740num=864 sum=290990700num=1024 sum=892371480num=1152 sum=581981400num=1280 sum=698377680num=1296 sum=857656800num=1344 sum=931170240num=1152 sum=1338557220num=1296 sum=2036934900num=1536 sum=1745944200num=1600 sum=2095133040 $f(x)=\sum gcd(t,x)=\sum{t|x} phi(x/t) t$ 网上普遍的做法是暴力枚举约数，再暴力计算phi这个的复杂度很难计算，感觉非常不可靠 受cty博客的启示，继续深入考虑从公式后者的形式来看，据说叫做狄利克雷卷积（普通卷积是通过和卷起来，这个是通过乘积卷起来）就是因为phi和1函数都是积性函数，所以这个整体也是个积性函数 那么现在我们需要求 $f(p^k)$ ，我们希望规避【暴力计算phi】，所以考虑利用刚才想到的性质，去递推$f(p^{k+1})=\sum f(p^k) \times p + phi(p^{k+1})$ 那么这个东西的计算是可以忽略的所以总时间主要是 根号n来分解质因数，找到p计算f的时间复杂度的外部系数只有30即最大不同质数数量]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>欧拉函数</tag>
        <tag>积性函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj3319】黑白树]]></title>
    <url>%2Fposts%2Faba8.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj3319 Record30min Analysis请先思考后再展开 log方显然不能过考虑特性，黑边只会增加不会减少找向上第一个黑边等价于把所有黑边断开后向上最高的点这个可以离线一下，并查集维护一下就好了]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu4891】序列]]></title>
    <url>%2Fposts%2F6301.html</url>
    <content type="text"><![CDATA[Source and JudgeLuogu4891 Record2h Analysis请先思考后再展开 感谢myh大爷的解释……当时比赛完发现官方不发题解，抱着试一试的想法去找myh，没想到他真的回复了 我们需要维护操作对于操作1，分三种情况 原本小于，后来小于：拿出来再放回去 原本小于，后来大于等于：拿出来不放回去 原本大于等于，此时不用理会 用一个set维护一个不同C的区间，以位置排序每次询问，先二分找到具体位置，然后枚举每个块，直到不能贡献那么因为操作后这些块相当于消失（向前合并），所以枚举的复杂度从从势能上看只有n+q同时这个块一定原本和最后都是相同的值 那么，为了能够维护有多少个 $C&lt;B$ ，如果暴力去维护，势能是值域级别的，没有意义但如果每次log地找到，最小那个B，知道大于等于新的值，那么这个的势能会明确地减少1这个新产生的部分和原本的加起来，会远比每一次重新统计好得多此处的时间同样是n次 具体而言，维护二元组mi和贡献数量sum 对于 $C&lt;B$ 的部分，mi=(B,pos)，sum=1 否则，mi=(INF,0)，sum=0 操作1找mi去更新操作2暴力处理 综上说述，时间复杂度为 $O((n+q) log n)$感觉这道题比较考验思路的清晰和明确]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC44】color]]></title>
    <url>%2Fposts%2Fd64f.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC44 Record1h Analysis请先思考后再展开 对于T=1的情况，对于一个l，考虑其贡献那么从l开始的第一个颜色，权值为1，下一个为-1，仅当只包含1的，那么就能产生贡献对询问排序后，l单调递增，r的变化只需要树状数组询问前缀和那么每次l的移动，把该颜色对应的贡献更新一下即可 而对于T更普通的情况，维护好每个位置向后T次同颜色的位置，那么用类似的方法，向后T+1次的位置为-1即可 还有一种变形：HEOI2012 采花SDOI2009 HH的项链也是类似的方法，只不过不要添加-1，而是用0即可 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC43】ladder]]></title>
    <url>%2Fposts%2F67b3.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC43 Record1h Analysis请先思考后再展开 又是计数题，显然不能直接计算，考虑dp然后比赛我的时候我就一直努力计算非法状态数量，发现超级复杂，不知道如何巧妙地设计状态吃完饭回来，什么鬼？？直接计算就好了，合法状态好表示多了，非要脑残搞非法…… 设 $f(i,dis1,dis2,dis3,dis4)$ 表示现在在位置i，每个梯子与当前的距离如果dis=h，表示已经断开了，此时具体dis没有意义，用非法制h表示此时我们说h是非法值，是指它作为【被继承状态】而言所以答案即 $f(n,0 \leq dis1&lt;h,0 \leq dis2&lt;h,0 \leq dis3&lt;h,0 \leq dis4&lt;h)$显然有一维一定是0，所以可以省略，用0和1表示最后滚动一下即可]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC46】【POI2007】堆积木兼删数游戏]]></title>
    <url>%2Fposts%2Fd023.html</url>
    <content type="text"><![CDATA[Source and JudgePOI2007NOIAC46bzoj1109 Record1h Analysis请先思考后再展开 先从简单一点的堆积木开始 考虑dp，设 $f(i)$ 表示考虑了前面i个数，此时 $a[i]=i$$f(i)=f(j)+1，当j&lt;i，a_j&lt;a_i，j-a_j \leq i-a_i$不过，我们可以把其中一个消除 当 $a_j&lt;a_i，j-a_j \leq i-a_i$不难得出 $j-a_j&lt;i-a_i+1$相减得出 $j \leq i$因为 $a_j&lt;a_i$ ，显然不可能相等，由此可知最前面那个可以去除（注意，此时第一个是第三个的子集，由一和二不能得出三） 观察一下那两个条件，可以发现形式是相同的，是一个二维偏序问题因为有递推性，可以按照第三个排序（否则不能在相同的第一关键字继承），然后把第二个最长不严格上升子序列一下即可 细节1：对于 $a[i]&gt;i$ 的位置，不能参与dp，这个不方便判断，可以直接剔除（但不能影响编号） 细节2：因为要最大化答案，而我们的三是可以相同的所以对于相同的第一关键字，我们也应该把二排序 细节还是有点多的，还不是很好发现可能只能对拍了……undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>偏序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF511A】Enlarge GCD]]></title>
    <url>%2Fposts%2F4ed.html</url>
    <content type="text"><![CDATA[Source and JudgeCF511A Record2h Analysis请先思考后再展开 本文用GCD表示原本的最大公约数，gcd表示最大公约数 第一次尝试开场做c，杠半天，想到一个aloga的做法：要增大gcd，那么统计f[t]表示t的倍数的数量，答案即合法范围内的 $min{ n-f[t] }$注意此时我要求 $t&gt;原GCD$ ，相当于我知道最后的GCD一定是t的倍数，那么把所有不存在t这个因子的数删除即可为什么我不能直接取质数呢？主要是担心，为了增大GCD，可能选择了2GCD，例如2 4 8这组数据 那么这个f怎么求呢？我想了差不多半个小时，只能想到用莫比乌斯函数，再枚举倍数，时间根据调和级数是log的 当时机房大佬们个个都切四道题了，心里慌的一匹然后我觉得可能做法上是理论极限了，是思路的问题，可能需要省去一些状态，但依然毫无思路 正解：显然最后得到的gcd一定是GCD的倍数可以把每个数除以GCD，那么现在总gcd为1，只要变成任何大于1的数，都意味着成功现在我们成功地不用再考虑GCD的影响了，只要考虑t是素数的情况就好了 只关心素数那么就容易多了，可以对每个数分解质因数而不用把它们组合不过暴力去找质数分解需要根号的时间，主要是寻找素数的时间太长了到这里的话，不难想到可以在线性筛的时候记录一下最小素因子，时间复杂度降低成素因子次幂和，最大30 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC47】power]]></title>
    <url>%2Fposts%2F42a8.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC47 Record2h Analysis请先思考后再展开 这道题如果从联通块的角度来思考，情况太多，dfs序也不连续经p老大提醒，如果从那段连续编号着手，然后像异象石那道题一样（自行搜索），找出需要的联通块大小就好了那么因为要求块大小小于等于k，可以用尺取法维护一个set，显然单调（xgc居然不while右指针都过了……） undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC37】染色]]></title>
    <url>%2Fposts%2F7761.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC37 Record30min Analysis请先思考后再展开 好奇妙的dp呀本来一直在想组合数学，然后想着用容斥因为如果互相不重叠，那么是非常好计算的然后我想着应该不需要重叠，因为按照容斥原理，不会互相重复计算后来打了半天，才发现形式上会重复 正解是dp，f(i,j)表示处理到第i个，然后前面j个互不相同，【但是再往前一个就出现相同】的方案数，确保 $j \leq m-1$如果第i+1个是和前面这j个中某个相同，则j减小，否则可以在这j个之外任选一个 如果能成功列出这个dp方程，转移后缀和优化一下，就能达到n方 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>计数dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[atcoder套刷计划]]></title>
    <url>%2Fposts%2F84cd.html</url>
    <content type="text"><![CDATA[发现自己经常打比赛挂机……正好在noip前练习一下思维题 arc102之前做了c、d、e题 1 F - Revenge of BBuBBBlesort!9.20 难度2题意：给你一个长度为n的排列A，可以交换(ai,ai+1,ai+2)当且仅当ai&gt;ai−1&gt;ai−2,问A是否能经过一系列交换最后有序 请先思考后再展开 感觉这种性质题对我来说难度很大如果一次操作以i为轴心，则称对i进行操作 找找性质： 从操作位置来看：因为操作的条件限制，对i操作后，无论i-2和i+2是什么，都不可能再次对i-1和i+1操作既然如此，i上面的数字就动不了了，所以不可能对于一个 $i \neq a_i$ 的位置操作因此，如果连续三个位置， $i \neq a_i$ ，记中间的是i，那么可以直接判断无解因为此时i不能动，唯一希望就是i+1把值i送过来，但这要求 i+1=ai+1 ，但又只能从i+2送过来现在i+1自己都要送过来，那么i+2只能作为轴心，无法得到i 从值来看：如果我一开始向左走，那么我永远只能向左走证明：最初我跨越了位置x，那么我 &lt; x上的数字，而x作为转轴不可能再变化，对于值x而言，无法达成反方向操作的条件 综上所述，如果已经在位置上，就不能再动了，称为定点，其他的就是动点（不能存在连续三个）对于每个位置p，如果上面的值是x，那么x要变成p，而每次操作，上面的数字的奇偶性不会变化所以说x和p的奇偶性要相同 然后我们把原序列分段，每个段满足定点动点交错，那么内部的值可以跳来跳去，但不能跳出去（可能这个段只有单个元素） 然后我们取出每个段，在内部进行判断条件1，所有值的目标不能在该段之外条件2，两个目标方向相同的值，不能相互跨越否则意味着其中一个值没有按照规定方向跳跃，与前面的性质矛盾 总结：感觉这道题很奇怪就是你就算找到了一些性质，也不知道是否找全了典型的【不做完别的题目不会开】的题undefined arc1012 E - Ribbons on Tree9.20 难度2题意：给定一棵点数为偶数的树求有多少种将点两两配对的方案使得每一条边至少被一对匹配点之间的路径覆盖 请先思考后再展开 非常神仙的容斥：设边集T为必定不经过的边，则答案即 $\sum (-1)^{|T|} F(T)$显然大小为t的联通块，任意选择的方案数 $g(t)=(t-1)(t-3)(t-5)… \times 1$具体的奇偶性等细节自行处理如果T把树分成了多个联通块，则答案即每个块的g(t)的乘积 然而指数级枚举T显然是不现实的利用图是一棵树的特性，考虑树形dp设 $f(x,k)$ 表示在x的子树中，有k个是最顶上的联通块这个联通块是可拓展的，所以不统计内部的方案数，直到被其父亲统计 dp转移时，常规地枚举两次siz，然后复杂度也同样是套路：把siz看做子树的每个节点，则每个点对只会在lca处被遍历到，所以复杂度 $O(n^2)$ 转移方程的话，因为边集大小增加，如果不断开，相当于合并上面那个块， $f(x,sz1+sz2)+=f(x,sz1) \times f(y,sz2)$如果断开(x,y)， $f(x,sz1)+=(-1) \times f(x,sz1) \times f(y,sz2) \times g(sz2)$undefined arc1003 E Or Plus Max9.20 难度2题意：又看错题了……细思极恐给定一个正整数 n(n≤18)然后给定一行共 $2^n$ 个正整数 a0,a1,⋯,a2n−1对于每一个 k( $1≤k&lt;2^n$ )，输出满足 i OR j≤k 的最大 ai+aj 值。 请先思考后再展开 我能想到的最好的做法：如果能得出 $i|j=k$ 的情况，那么前缀max就是答案然而很难算出来但如果能得出 $i|j \in k$ 的答案，那么前缀max也是可以的而这个显然好算很多，i和j基本没关系了 枚举每个k，然后枚举其子集，维护最大和次大时间复杂度： $O(3^n)$undefined 然而4亿在atcoder上面居然只需要760ms 正解：既然我们的答案和具体子集没有关系，只关心其最大值和次大值可以不用枚举子集，而是用子集来更新父亲对于一个集T，不一定所有的子集都直接更新到T，也可能先经过T的子集，但这样一定不会漏时间复杂度降低到了 $O(n2^n)$据说这个技巧有个更深入的应用：Fast Zeta Transformundefined 4 F - Colorful Sequences9.26 难度3题意：定义一个长度为n，字符集大小为k的序列是好的，当且仅当其中存在一个长度为k的子串满足1到k每个数在这里面恰好出现一次。现在给一个长度为m的序列a，问在所有好的序列里面，a作为子串的出现次数的和。 请先思考后再展开 感觉这道题好神仙啊，还好有我p老大教我这个菜逼 先思考简化的问题一、问题一只考虑出现的次数，不考虑序列的好坏因为互相之间没有影响，直接搞枚举左边的数量，乱填， $(n-m+1) k^{n-m}$ 二、问题二考虑all-不好的那么问题转化为染色，最近在noiac做的一道比赛题（题解自行搜索）$f(n,ln)=f(n-1,ln-1) \times (k-(ln-1)) + \sum f(n-1,ln&lt;t \leq k)$此处复杂度为nk 三、问题一 + 问题二 A. 串a中包含k个不相同的直接按照问题一计算即可 B. 串a中包含最长不相同，长度小于k，前后延伸最长不重叠同样是计算不合法的数量，左右两边以刚才得到的延伸作为强制起点，按照问题二一样向左右分别dp然后和问题一一样，枚举左边，只不过此时左右两边填写的数量不是乱填，而是要保证非法性 C. 串a整体都是互不重复，但长度小于k我们既要求非法，有要统计贡献因为串a本身是互不相同的，不能像B那样左右搞，因为互相影响 这里用到一个非常巧妙的转化先忽略串a的具体字母，统计所有非法串中，长度为m的互不相同字符串的贡献这样以后我们就不再关心串a的具体值了，反正互不相同且唯一就是了最后把贡献还原回去，可以通过除以 排列数P(m,k) 实现 贡献的计算可以仿照前面的dp方式设f表示串总数，当后缀不可延伸长度满足长度条件的时候就统计进g，然后g自己也转移 undefined arc0995 E - Independence9.21 难度1题意：给定一个有 n 个节点， m条边的无向图，保证没有自环和重边。请你把所有的 n 个节点分成两组，同组中的任意两个节点之间都有边直接连接。问连接同组节点的总边数最小为多少？如果不存在合法的划分方案，则输出 −1 请先思考后再展开 我能想到的最好做法：题目要求分成两个团，取补图后就是分成两个独立集那么这个可以二分图染色，因为边意味着排斥关系然后我们需要最小化 $min{ \frac{a(a-1)+b(b-1)}{2} }$因为染色的时候我们会先入为主，那其实是可以整体取反的，也就是交换a和b为了求最小值，我想到二维背包，但时间为 $O(n^3)$感觉3亿在atcoder上应该是能跑过去的……有了上一道题的经验 我tm在想些什么？？？a+b=n，做个屁的二维背包……气到不想打 arc0986 D - Xor Sum 29.21 难度2题意：给你一个长度为n的整数序列，让你求出满足以下条件的(l, r)的对数：其异或和=其和 请先思考后再展开 能想到的最好做法：维护一个前缀异或和a，前缀和b$a[r]^a[l-1]=b[r]-b[l-1]$然而异或没法和四则运算一起化柿子，复杂度只能是 $O(n^2)$ 正解：刚问出来就被秒掉了$0 xor 0=0,0+0=0$$0 xor 1=1,0+1=1$$1 xor 1=0,1+1=2$唯一的差异就是进位而这个差异是没有办法消除的，只能避免所以该区间一定不会在同一个位置上存在超过一个1所以具有单调性 7 E - Range Minimum Queries9.21 难度2题意：给定一个n个数的数列和两个整数数K,Q，执行Q次操作：选择一段长度为K的区间，删除其中的最小值。问：执行Q次操作后，被删除的数的最小值和最大值之差 的最小值是多少？ 请先思考后再展开 max-min的最小值显得很复杂但因为取得都是原本就有的数，所以可以枚举min，然后找最小的max因为min确定了，那么不能有任何区间包含小于min的数，这些数把整个区间分成很多段对于每个长度为len的段，只能取出前面len-k小的数把每个段能贡献的所有数排序，其中第q小的就是答案 arc0978 D - Equals9.21 难度2题意：给出可交换的两个位置，和一个排列，最大化pi=i的位置 请先思考后再展开 这都没想出来……对于能间接互相交换的位置，假设有a要和b交换，则总是能够a到b，此时b被挤开，跳到a，然后中间的部分不会发生改变 所以，可以用并查集维护间接到达关系，然后询问能够回到原本位置即可 9 E - Sorted and Sorted9.21 难度1题意：排成一列的2N个球，有黑球和白球，黑球和白球上面都写了1-N的数字，给定一个操作：swap相邻两个球。问最少操作次数使得白球和黑球上的序号都分别递增。 请先思考后再展开 从简单问题入手，如果给出一个n的排列，要让a[i]=i，只能相邻交换此时因为每次交换只能消除一个逆序对，所以答案是逆序对数此时所谓逆序对即原位置p1，终位置p2， $p1[i]&gt;p1[j]且p2[i]&lt;p2[j]$ 那么回到本题，求出一个最优秀的终止状态p2，就能得出答案了那么，白球和黑球内部要有序，但交错的顺序不确定即使暴力也不好枚举，但因为黑白内部的顺序已经确定，不难想到可以用类似字符串匹配的方式dp 设 $f(x \leq 2n,a,b)$ 表示填写到第x位，白色填了a个，黑色填了b个的逆序对最少个数显然i=a+b，实现的时候需要去除一维转移的话，关键就是要快速地计算新逆序对设白色的id为x，则对应黑色的id为n+x当放白色， $p1[t]&gt;p1[a]，t=1 \to a-1和n+1 \to n+b$当放黑色， $p1[t]&gt;p1[n+b]，t=1 \to a和n+1 \to n+b-1$这个东西可以预处理一下，然后就能达到 $O(n^2)$ undefined 10 F - Monochrome Cat9.24 难度2题意：给定一棵有n个节点的树，每个点有黑白两个颜色。现在有一只猫可以从任意节点开始，任意一个节点结束，要把所有节点染成黑色。可以执行如下两种操作之一： 移动到相邻节点，并改变其颜色 改变当前节点颜色求：把所有节点染成黑色所需的最少操作次数数据范围：N&lt;=2e5 请先思考后再展开 设白0黑1 不难想到：如果叶子节点是黑色，可以删除，如此重复直到所有叶子节点都是白色位置 如果起点和终点一样，显然遍历所有叶子节点需要遍历每个节点和边（基于上面的操作）如果对于一个点，其度是偶数，意味着会被抵消掉，如果此时是白色则要改变，同理如果是奇数而且是黑色，也要改变自己一次，所以答案为 $\sum 度数+【(度数+颜色)\%2=0】$ 但如果起点和终点不一样呢？和起点终点相同的情况相比，从路径的形式上 就是少了【起点到终点的一条链】，这个过程中，如果本来不需要操作就是黑色的节点，现在少经过一次，但需要操作，代价不变而本来需要操作的节点，现在不经过，也不需要操作，少了2的代价 现在问题转化成，需要找出一条链，经过最多【本来需要操作的节点】，不过每个节点最多经过一次，而且链的终点不能累加 这个终点有点烦人，但注意到终点总是能拓展的，即使是最极端的叶子节点，因为度数=1，颜色一定是白色，所以权值为0，不是必须终点，即使终点为其父亲，形式上也可延伸到叶子节点综上所述，只要在原答案的基础上，减去带权树的直径即可 arc09611 E - Everything on It9.21 难度2题意：拉面有 n 种配料 每种配料可以选择加入到拉面中，也可以不加入一共 $2^n$ 种组合 有人来订购一些拉面要求：每种拉面配料不能相同。每种配料在全部的面中至少出现过两次。 请先思考后再展开 这道题一眼容斥来搞【不能出现少于两次】的这个条件$ANS=\sum_{k=0}^n (-1)^k C(n,k) f(k)$其中f(k)表示有k个颜色只能不用或用一次，剩下n-k个颜色任意放，但不能出现两个完全相同的组合数然后到这里我就不知道怎么处理不能完全相同这个问题了 f(k)应该分两部分去思考① 不合法的k个颜色那么相当于这k个元素，要么不放，要么放进一个集合中假设有t个非空集合，那么这个是类似于第二类斯特林数的（刚学……）递推式： $g(k,t)=g(k-1,t-1)+g(k-1,t) \times (t+1)，0 \leq t \leq k$解释：在原本第二类斯特林数的基础上，加上【可以丢掉】这个选项可以是把第k个元素单独放进第t个位置，也可能第t个集合是混合的，再或者丢掉②其他的n-k个颜色这里非常巧妙，也是我一直不知道怎么解决的地方方案数量为 $2^{n-k}$那么对于那k个非法元素，本来觉得超级复杂，其实因为每个最多出现一次，不同的碗一定不会重复所以是 $2^{(n-k)t}$ 而合法元素的话，不应该和碗的数量扯上关系，而是考虑把每个方案看作一个碗，考虑这个碗是否出现所以是 $2^{2^{n-k}}$ 综上所述， $f(k)=\sum_{t=0}^k g(k,t) \times 2^{(n-k)t} \times 2^{2^{n-k}}$套一个小费马定理即可 12 F - Sweet Alchemy9.24 难度2题意：n≤50的树，每个点有权值，现要选点（可多次选一个点）使点数尽量多，如下限制：选的总权值不超过C≤1e9；ci表示i选的次数，pi表示i的父亲，那么cpi≤ci≤cpi+D，D≤1e9是给定常数。 请先思考后再展开 因为子节点选择的数量至少比父节点多可以把操作看做是选择一整棵子树，那么问题转化成： 有n个物品，有体积和价值，要求在体积小于X的条件下让价值最大化，每个物品也有选择次数的限制（根节点无限，其他节点为D）观察值域，物品的数量很小，体积很大，单个价值很小，次数很大直接用多重背包的模板，无法存下体积，用价值dp的话，总价值可能也会很大（因为次数大） 此时有一个很不好想到的姿势：用贪心代替大部分dp结论：每个物品，只用前面n个去dp，其他的贪心该贪心主要用微扰（应该是吧？）来证明：当物品数量足够大的时候，如果不考虑小的误差，是可以用贪心，选择性价比高的物品来得到大致结果的为什么只能是大致呢？主要可能是部分细小的体积有优化空间 思考什么情况下，选择性价比高的物品一定是正确的设有物品i和j， 并假设i的性价比更高即 $v_i / w_i &gt; v_j / w_j$选择vi个j物品，和选择vj个i物品，其价值都是 $v_i \times v_j$但体积 $w_j \times v_i &gt; w_i \times v_j$ 也就是说选择i的体积更小这就是说，当达到此数量级，一定是性价比高的更优秀 那么，在这个数量级之外的次数可以用贪心计算，内部的情况因为比较复杂，不能贪心，只能dp那么注意到w在单个的时候，和n是同阶的，也就是dp的权值是 $n^3$ 级别的，而体积依然非常大所以应该用权值来dp，即 $f[权值]=min 体积$考虑到用二进制拆分法处理多重dp，值域为 $n^3$ ，时间复杂度为 $O(n^4logn)$ dp完成后，剩余的空间就贪心地在剩余物品中选择即可 up：忘记了，用单调队列优化一下就到n四方了…… undefined arc10313 E - Tr/ee9.30 难度2题意：构造题给出一个01串，位置i表示能否通过去除某条边得到大小为i的联通块 请先思考后再展开 rose秒了……我的思路：显然位置1一定是1，位置n一定是0然后它还必须具有对称性 构造的话我想着可能应该从链开始考虑，然后像样例那样构造出一个大小合法的子树 但随后我就不知道如何保证一定不会出现某个大小了正解：从大到小枚举，如果不可行就作为单个节点挂在根节点那里（反正大小为1一定会产生）否则搞一个大小为i的子树，递归下去 undefined D - Robot Arms9.30 难度2题意：确定小于等于40个步长，长度自己定，但要应对所有询问满足n个询问（1000内），通过上下左右能到达不同的n个位置，并输出具体方案 请先思考后再展开 大致思路是二进制拆分，但本题的难点就在于只能上下左右，不能不走比赛的时候想过，如果放大限制行不行？例如把每个位置拆开成2个、3个乃至4个，但好像都不行比赛就只打了个暴力部分分 正解看起来很暴力，晚上对着yww大爷的代码看半天全机房都不会证明……就是从大到小，然后看x和y哪个绝对值大，然后就“gao”，最后再移动多几步第二天早上过来，忽然就大致理解了这道题的特殊性就在于1和-1的运用，也就是说虽然不能都不走，但是可以对二进制做差而二进制有这许多非常奇妙的性质，比如说后面的t个二进制之和+1是等于t+1个二进制所以如果我们直接把x搞定了，剩下的部分做和、差总是能得出y的（因为最大拼出int，而x+y小于int） undefined F - Distance Sums9.30 难度2题意：构造一棵树给出对于每个节点，其他节点到它的距离之和 请先思考后再展开 按照d排序，d最小的一定是树的重心那么考虑d最大的节点，同理，它一定是叶子节点，否则存在比它更大的d那么每次取出最大的d，它的子树确定，同时它的父亲也是能够确定的（ $d[fa]=d[x]-n+2 \times siz[x]$ ）最后还必须要跑一次dfs验证，因为此时只能说相对大小是正确的 undefined arc096###9.21 难度2题意： 请先思考后再展开 undefined ###9.21 难度2题意： 请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【训练】算法竞赛进阶指南-4数据结构 8题]]></title>
    <url>%2Fposts%2F59da.html</url>
    <content type="text"><![CDATA[本处难度分档以个人实力为参照系难度1：半小时内想出，半小时内ac难度2：半小时想不出，看题解，服气难度3：半小时想不出，看题解，ac后依然觉得难度很大 另外，由于追进度，对于coding部分比较有自信的题目，不再具体实现 0x40 数据结构部分题目 1 Noi2015 程序自动分析9.18 难度1请先思考后再展开 交上去50，真的难受码的时候还在想为什么po姐要拍……立刻就打脸了虽然说没细细检查主要是输入的时候，把x放进去了两次……超搞笑好吧对noip超虚undefined 2 poj1456 Supermarket9.18 难度1请先思考后再展开 我的做法和网上的都不一样lyd1：在前i天，尽量卖出合法的前i个值lyd2：从大到小处理，然后找过期前面的空位，可以用并查集加速我的做法：从大到小枚举天数，每次把这一天的所有新商品放到堆里面，然后卖出其中最大的undefined 3 poj1733 Parity game9.18 难度1请先思考后再展开 lyd边带权做法：奇1偶0，路径压缩时异或同集合判断合法性，不同集合就合并 lyd拓展域做法：拆成奇数域和偶数域，同集合表示一种能互相推导的关系判断非法的话，是根据此前是否有和当前操作相反的信息 我的做法是乱yy的，和拓展域做法类似区别： 在我的理解里面，拆点表示和我不一样（因为只有两个情况） 判断非法时，我是看是否会导致我和我的对立点相同undefined 4 poj2182 Lost Cows9.18 难度1请先思考后再展开 如果前面有k个比我大的，那么显然我就是当前可选里面第k+1名从后往前，那么我们需要一个数据结构维护当前第k大，支持删除splay和树状数组都可以，就看值域了，显然这道题选择树状数组适合 5 4302 Interval GCD9.18 难度2请先思考后再展开 太巧妙了原串的GCD和差分的GCD相同 6 Violet 蒲公英9.19 难度2请先思考后再展开 区间众数！而且因为强制在线，把莫队卡掉了 显然数字先离散化设每个块的长度为T设询问和N相同量级 方法一：暴力处理每次询问，时间复杂度$O(n^2)$ 方法二：以块编号为端点，得出 $(n/T)^2$ 个区间，每个区间存储当前众数具体计算可以确定左端点，然后向右暴力 再以块编号为端点，前缀和存储每个颜色出现个数（可以在刚才的步骤中顺便算好）对于每次询问，A为整区间[L,R]的众数，在前缀和数组的基础上，遍历两边的零散区域，B=A，动态更新维护B，得出答案后再还原时间复杂度$O(n^2/T+nT)$取$T=n……{1/2}$，得出最小值$O(n^{3/2})$，本题=11000000（可以强行把两边相等，一般都是最小……我也不知道为什么） 方法三：以块编号为端点，得出 $(n/T)^2$ 个区间，每个区间存储当前众数具体计算可以确定左端点，然后向右暴力 然后我们还需要维护一个vector，以数值为索引，保存该数字所有出现位置对于每次询问，A为整区间[L,R]的众数，再遍历两边的零散区域，B=A，对于每个数字，在vector中二分得出l到r出现次数，维护B时间复杂度$O((n/T)n+nTlogn)=O(n^2/T+Tnlogn)$（同样可以强行相等），取$T=\sqrt \frac{n}{logn}$时间复杂度$O(n \sqrt {nlogn})$，本题=45000000 7 CH#46 磁力块9.19 难度1请先思考后再展开 一开始没思路，看了看第一句话居然就有想法了因为有两个条件，不妨用其中一个排序，然后在当前的序列中分块，大小为T然后在每个块，相互之间完全独立，然后内部保持另一个条件的有序性 然后我们用类似bfs的思想去维护（这就是我看的那句话，好菜……）那么每次询问，可以二分一个k，保证k前面都是小于，k后面都是大于那么k前面的部分，枚举每个块，然后从左往右扫描，直到不满足条件，此时把满足的删除，放入队列中对于第k个块，暴力处理，维护好l到r的连续性，整体不连续没有关系，因为已经相对独立 分析一下复杂度，当时考虑的时候我是考虑尺取法的思想，就是指针的单调性（整体不单调，局部单调）对于这道题，出去了就不会进来，每个被指针扫描过的点，都不会再次经过所以复杂度是$O(nT+n^2/T)$，T取根号为最优undefined 0x49 数据结构练习部分题目 8 IOI1998 Picture9.19 难度2请先思考后再展开 问题转化为，通过一个数据结构，只有区间+1和-1两种操作，然后保证运算过程中始终不是负数求整个区间的0的数量（通过变化量得出周长） 然后这东西昨天中午想过，想出来了，然后听说是练习的题目，所以就想着到时再说结果今天忘记昨天曾经想过了……而且还不会做其实只要维护区间最小值以及其次数即可，关键是【始终没有负数】的性质undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF#509 比赛总结]]></title>
    <url>%2Fposts%2Fbeed.html</url>
    <content type="text"><![CDATA[CF#509 比赛总结题目即1041F，1041E，1041D，1041C，1041B，1041A 比赛经历t1原本超快做完，然后submit没按到+交错语言，ggt2一开始忘记gcd了，还好良心样例t3感觉可以贪心，对set不太熟悉，因为要找upper-1的位置，然后感觉写不了就感觉只能splay（虽然我知道一定不是正解，毕竟是cf）先去看t4，发现可以尺取法，写完发现tkj也是先t4，感觉可能t3码农，不过同学都切完是什么鬼耐下性子，老老实实写splay，感觉思路特清晰，写的很快（毕竟至少5个月没写过了……）过了以后只剩10min了，发现自己是最慢的（大众四题，毫无竞争力）……手速弱鸡表示怀念oi赛制然后就是真的要认真了解一下stl+结构题的各种语法了 T1_Analysis请先思考后再展开 没什么好说的mx-mi+1-n T1_Code_old请先思考后再展开 undefined T2_Analysis请先思考后再展开 gcd+向下取整 T2_Code_old请先思考后再展开 undefined T3_Analysis请先思考后再展开 我的做法是贪心地去找 $a&lt;a2-d$ 中最大的，时间复杂度nlognset的新内容已经在oi之路的stl处更新然后看rk1发现可以 $O(n)$ 贪心得更加彻底：同样是排序后，维护k为“当天合法最远距离”，可以用尺取法实现，那么中间的一定是其他天数的然后就1 2 3 4 …… k 1 2 3 …… k 这样分配，不难发现这样一定是合法的，最小性同样可以证明，因为如果用更大的，例如r+1和l在同一天，那么答案不会变小 T3_Code_old请先思考后再展开 undefined T3_Code_用set请先思考后再展开 undefined T3_Code_完美贪心请先思考后再展开 自行看众ak爷代码…… T4_Analysis请先思考后再展开 尺取法一下即可 T4_Code_old请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷18年7月月赛比赛总结]]></title>
    <url>%2Fposts%2Fb37c.html</url>
    <content type="text"><![CDATA[洛谷18年9月月赛比赛总结题目 比赛经历哇这次是oi赛制耶感觉心理压力会小很多…… 第一题一开始很自信，觉得可以暴力，因为位数可能不会太大……当时电脑上没有g++，于是就应验了师兄们对在线ide的推测，没来得及装的时候比赛就开始了……主要是没检查到（原电脑在竞赛室不想拿回来）随便出组数据就tle了但仔细看看题目，就是没有说无解的情况，我也不会证明有解后来认真想想，推推柿子，发现原来是bsgs，时间复杂度nlogn然后如果无解，我会输出-1打了个对拍，暴力会出负数，也就是无解情况为了方便对拍，统一输出-1拍了30min的rand数据，范围不会太大（感觉rand的最大值是刚好的），避免暴力太慢，感觉应该没问题了……（30min伏笔） 然后是t2，感觉是约束一下，但没有太明确的思路，先跳t3是一棵树，除以2以后，化一下柿子，发现就是 $min \sum C-&gt;A_i$然后感觉可以参考一下“中位数的应用”，就是考虑移动的贡献那么不难发现，从根向下移动，相当于非该子树的A要多走w，子树内则少走w这样就是每条边走过去的贡献那么我们不妨先把初始的C设在根节点，然后往下重新计算dis，如果最小的dis小于0，那么移动到那里会更优仔细检查一下变量类型，感觉没问题，然后思考一下也应该是正解，时间复杂度n 此时只剩一个半小时，稍微有点慢了看看t4，标题写着分块是什么鬼感觉能拿30分后来忽然发现，统计1的数量需要乘以15，凉凉 看t2，发现只需要转移成第二行的情况，然后维护一下确定的区间具体而言，就是把每个约束条件转化为a~b的形式，而且满足 $2 \leq num \leq 2m$如果宽度小于m多解，大于m无解，否则定位一下就好了一直coding到最后3min，虚的一匹还好最后成功写完，交了上去到比赛首页，居然发现比赛延迟30min！赶快回去细细检查，发现细节稍微有点多，挖掘了一下样例后真发现几个bug，应该问题也不大了 检查一波，然后看t4，发现我制杖了，预处理一下1的数量就好了，值域很小那么又骗了30分目前最高分330时间刚好结束 好像比赛首页因为太多人刷新炸了？出去陪弟弟玩了波大富翁，好颓废啊回来发现145是什么鬼？怎么可能还有rk23，这么sb的分数……woc，80+60+0+5太困了先睡了…… T1_Analysis请先思考后再展开 因为 $n \leq MOD$所以答案是超过int的，没发现这点交上去还是80再仔细想想，因为刚刚发现的这一点，两个MOD相乘会爆ll，所以要快速乘tle!因为现在复杂度变成了log方，真是连锁反应……主要是因为我之前的写法一直都是 $A^b=ed \times inv(A^{at})$ ，n=at+b那么改改就好了，避免以后吃亏$A^b=A^{at} \times inv(ed)$ , n=at-b 所以说，还是考虑不够周全，造成连锁反应感觉这种事情很危险啊，特别是noip之前不久前还跟别人说自己很少fail题，因为大部分题都不会做……立刻就来教训了 T1_Code_std请先思考后再展开 undefined T2_Analysis请先思考后再展开 发现这种做法是错误的因为我不能确定它实际在第二行还是第三行……所以换个思路，考虑直接约束1的位置然而我完全不会怎么解带模的不等式：$(A+k-2) \% m \leq m+A-B-1$总之，如果能解出来，可能是同时多个区间，需要找到被覆盖s次的区间这个的话，可以补集转化一下，维护其补集的交，这样无论解有多少个区间都能解决，非常巧妙 T3_Analysis请先思考后再展开 哇哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈……woc看错题了使得他送货所需的最长距离最小而不是使得他送货所需的距离总长最小我就说怎么会爆零大概是第一次彻头彻尾看错题？可能真的没细看那时候如果要找个理由的话，哪有人会关心最长那个啊还有就是样例恰好只有一个商品…… 不过然后就不会做了……好像二分也没有什么卵用 膜出题人嗯决策和刚才一样，都是具有单调性的，而且最优方向一定是由局部最优组成的然后我自己也能猜到一个性质：题目中的距离，一定是 $2 \times c到ab路径的距离+ab路径长度$那么关键是最小化左边的部分考虑从任意一个点开始，用刚才的思路，考虑跳过去的贡献每一次，暴力计算出所有总答案最大的点对考虑每条边，如果有任何点对跨越该边（可以用dfs序和siz判断），意味着当前是最优位置如果那边有点对，另一边也有点对，跳过去没有意义，当前也是最优位置否则，单纯地往那边跳即可 当前的时间复杂度是 $O(深度 \times n)$套一个点分治即可（因为这是枚举类的解法，但距离等要在原本结构上求） T4_Analysis请先思考后再展开 原来是空间挂了……正解是神仙的莫队改版以后做……]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【Luogu4882】lty loves 96]]></title>
    <url>%2Fposts%2F9a30.html</url>
    <content type="text"><![CDATA[Source and JudgeLuogu4882 Record2h Analysis请先思考后再展开 非常有趣的一次经历（把本题当做是本比赛回忆吧……）如果能ac，就能和rose、xgc平分3块……当时的第一感觉是，从来没做过这么复杂的数位dp预处理非常麻烦，反正不会写然后这时候红太阳xgc出现了，他说不需要预处理，要相信记忆化的力量……其实也没错，数位dp的特性就在于，和具体数字的关系不会太大，一般都是部分 所以就听他的，瞎jb设了个状态开码中途到了5:40，必须要走了，当时xgc有50分在车上，仔细反思，觉得我的思路没有问题，可能超时或者爆long long但应该不会这么少分发现可能是转移的01写错了，匆忙回到家发现没写错……（学校的时候根本没细想） 补充说明一下，比赛7点结束 吃饭的时候一声不吭，觉得应该是边界的地方，忘记判断69数量了匆忙改，成功过了样例……交上去却只有20（他曾经也是，不知道怎么改的，好像思路不太一样） 测一测时间，恩很快但是极限数据出现负数！！（之前学校的错误代码，出来个4000以为没事）当时还剩30min，很赖皮地从以前的高精度模板那里copy下来恩样例还是能过的，但极限数据非常慢不管了交一发吧mle！没时间计算空间了优化一下发现还是不行，那应该意思就是写压位了ps 后来发现，原来是gb出题人把空间改到了64mb…… 当时还剩5min学校的时候和xgc就py过，他的50分代码已经发给了我，作为压箱手段（因为我乐多赛罚分最少）匆忙改了改格式，怕被识别作弊看rk，13是什么鬼？最后这么多人上去了（前10有3块，学校rk9） 当时真的好绝望，本来以为稳了，只是不太想用忽然想起来应该发邮箱给rose，发现有新邮件！标题为“kuai”，来自xgc！发现他打了压位高精度，然后才发现自己又傻了没有提醒他……交上去，ac看着那个rk8忽然觉得人生好神奇hh 方法一先给出一份long long的清纯版谁会想到现在还有这么毒瘤的出题人（所以说以后还是不想做洛谷的非月赛了）因为本来也以“条件很强，不会太多的”来安抚自己 好了说正事，数位dp现在觉得一点也不难大概也就是位数乘以10的复杂度undefined 方法二压位高精度，第一是能解决空间问题但还有个也非常重要的，就是速度快很多空间的计算：$\frac{64 \times 1024^2 /4}{50^2 \times 2 \times 10^2}=30$所以结构体最多30位考虑一下速度，决定压5位 其实压位也不难写，改动一点点而已，但当时时间真的太紧了，又有责任在身，再加上没写过，所以就放弃了undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu4881】hby与tkw的基情]]></title>
    <url>%2Fposts%2F3729.html</url>
    <content type="text"><![CDATA[Source and JudgeLuogu4881 Record30min Analysis请先思考后再展开 非常好推柿子$\sum_{i=0}^{ \lfloor \frac{n-1}{2} \rfloor } (2i+1)26^{i+1}$ 方法一n非常大显然要用快速幂和矩阵乘法那么矩阵的设计可以参考代码undefined 方法二然鹅上面的方法很慢，因为矩阵乘法的常数达到了30其实有高中数学常识的很容易看出是一个差比数列（看题解后学的……）不了解的可以去定理杂烩一章]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度1</tag>
        <tag>差比数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【国家集训队】跳跳棋]]></title>
    <url>%2Fposts%2F4147.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj2144luogu1852 Record2h Analysis请先思考后再展开 很好的题目不妨设a&lt;b&lt;c 考虑我能怎么跳因为题目要求，每次只能跳过一个棋子发现在任意时刻，只有三种移动方法$dis1=b-a,dis2=c-b$ $a-dis1,a,c$ $a,c,c+dis2$ $b,b+dis1,c$ 或者 $a,b-dis2,b$ （如果都不行，则没有）度大部分都是3，你想到了什么？一棵二叉树！把第一种和第二种，看作是孩子，第三种看作是父亲不过，树的深度无限，因为你总是能不停向外跳的 那么我们来证明一下这为什么是一棵二叉树（网上的漏点） 对于没有父亲的节点，本身就是根节点，所以严格来说这是一个二叉树森林 我们必须要证明x的祖先不可能会出现在x的子树中如果我们定义一个值：最接近两点间的距离不难发现，向上时必定变小，向下时必定变大（不能够重叠棋子） 操作可逆，所以是无向图 那么，现在要求的就是两个节点间的lca此时已经有40分了，如何避免暴力存图呢？ 考虑每次向上跳（再也不用考虑向下了，我向下就是等它上来）如果方向是相同的（缩左边或者缩右边），那么间距不变，可以直接通过一个除法来计算出来，然后距离取模那么复杂度基本上就是log（参考gcd的复杂度）如果要限制长度，可以判断一下，确保不超过（当覆盖时） 那么找lca的时候，先到相同高度，然后二分向上距离即可 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>lca</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【TJOI2013】循环格]]></title>
    <url>%2Fposts%2Fccfc.html</url>
    <content type="text"><![CDATA[Source and JudgeTJOI2013bzoj3171luogu3965 Record1h Analysis请先思考后再展开 首先，显然需要一些决策但好像不是很好贪心于是自然鹅言想到了网络流（或者费用流） 然后就不会了，主要是不太熟悉其实很容易发现题目要求的就是，每个点都要在至少一个环中 可以把题目再转化一下：给每个节点一滴水如果每个点都能有水过来，并且消耗掉，那么显然能满足题目的条件 按照这样建图以后，为了追求最小权值，跑费用流，把额外的边设费用1所谓费用流，前提是最大流，所以一定会把每个点都满足 不过有个小问题，就是可能自己立刻就出去了所以要拆一下点，分为入x和出yundefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>lca</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Arc102c】Stop. Otherwise]]></title>
    <url>%2Fposts%2F7deb.html</url>
    <content type="text"><![CDATA[Source and JudgeArc102c Record2h Analysis请先思考后再展开 以下做法层层递进…… 方法一（WA）因为求的是组合数，肯定至少要先n能算出完整数量$T(n,k)={ 1:∞,2:∞ … k:∞ }中选n个$$T(n,k)={ 0:n,1:k-1 }的全排列数量$$T(n,k)=\frac{ (n+k-1)! }{ n! (k-1)! }$然后考虑每个i，能得到i的二元组数量当$i-1 \leq k$，数量为$\lceil \frac{i-1}{2} \rceil$$otherwise$，数量为$\lceil \frac{2k-i+1}{2} \rceil$然后我们固定前面的几个（依然是多重集），根据$(-1)^k$ 去贡献，后面乱搞 然后，手动模拟样例2发现，相同的用多次，后面去重复，会以为多次重叠，但其实反而不应该这样给出代码留作纪念……凉凉undefined 方法二（AC）既然一定要去重，但刚才的思路，会死在【同一种多次用】上面于是膜了发网上题解（官方看不懂……）然后就发现其实我们是可以直接搞出合法数量而不需要取补的（其实有可能，没办法直接求出非法数量……当初主要是觉得不好算，所以习惯性取了补以后，思维又先入为主了） 先把刚才的违法对数的种类称为tot那么为了避免刚才的尴尬，直接枚举k表示【在违法二元组中，只出现其中一个】（也就是其他tot-k种完全不出现）那么每个种，相当于有了一个代表元素，方案为$2^k$当然，这里面不一定都要真的出现那我可以选择的数字就是oth+k个（具体是什么不重要）这个依然可以$$ans=\sum_{k=0}^{tot} (-1)^k C_{tot}^k C2(oth+k,n) 2^{k}$$ 方法三（AC）其实上面那种方法，略微有一点玄学因为你不限制它是否出现，怎么知道在Venn图中被覆盖k次从而使用那个 $(-1)^k$ 呢？然后我就自己再yy了一种做法，稍微改进就连容斥都不需要了，因为按照前面的基础，其实我完全可以把k看作一定出现至少一次（否则你枚举来干嘛，像上面那样） $$ans=\sum_{k=0}^{tot} C_{tot}^k C2(oth+k,n-k) 2^{k}$$ 提醒以下一个细节，要特判$oth+k=0$undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>难度2</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Arc102b】All Your Paths are Different Lengths]]></title>
    <url>%2Fposts%2F9f63.html</url>
    <content type="text"><![CDATA[Source and JudgeArc102b Record2h Analysis请先思考后再展开 原来这就是传说中的构造题首先明确，基本的结构一定是二进制拆分但不难发现，很难保证只有L条路径，得出来的长度还绝对不能重复 其实我有点思维僵化了如果把1和后面的东西拆开来，分开讨论，后面的全部都是完全的二进制（也就是2的次幂边，以及0）那么我们记录一个当前已经搞定的最大范围mx-1，从mx开始然后对L二进制拆分，然后假如加入之后，依然在合法范围内，那么就加上mx，并更新范围不难发现，现在得出来的路径长度，一定不会重复出现（通过简单地记录一个当前上界） Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【训练】算法竞赛进阶指南-6图论 32题]]></title>
    <url>%2Fposts%2F6259.html</url>
    <content type="text"><![CDATA[本处难度分档以个人实力为参照系难度1：半小时内想出，半小时内ac难度2：半小时想不出，看题解，服气难度3：半小时想不出，看题解，ac后依然觉得难度很大 另外，由于追进度，对于coding部分比较有自信的题目，不再具体实现 0x60 图论部分题目 1 poj3662 Telephone Lines8.29 难度2请先思考后再展开 找出一条从1到n的路径，上面第k+1大的那条边，权值最小好弱啊第一题就不会做，天天看题解…… 最小化除了前面k个以外的最大值，二分答案把所有长度在mid以内的边看做0，否则1跑一次最短路，如果花费在k以内，意味着可行代码略 2 noip2009 最优贸易8.29 难度2请先思考后再展开 曾经做过 3 Usaco2011 Jan Gold 道路和航线8.29 难度2请先思考后再展开 这道题挺有意思的，本来以为是裸题想跳的，看到lyd说spfa会tle，就不想以身试法了（网上说加上slf就好了……不过本着锻炼思维的理念，学习一下正解）因为题目保证航线没有环，本来以为这仅仅是保证没有负环，没想到这还是一个突破口（还有就是道路都是双向的这个性质） 如果只加入双向边，那么就会形成多个联通块如果缩点后再加入单向航线，图会形成一个有向无环图，是可以通过拓扑得到最短路的不过具体而言，不能真的缩点，因为需要具体得出每个点的最短路大致上就是沿着负权边找到各个联通块，以拓扑为框架跳来跳去 具体的话有个细节：就是有可能st所在的联通块，入度不为0或者可能出了st联通块外，还有其他入度不为0的联通块所以还是要按照平常拓扑那样，把所有入度为0的加入栈不过为了防止，单源最短路被扰乱，应该先把st联通块的dis置0，这样无论如何也没法更新掉了然后其他联通块的inf也应该设置大一点，这样即使被更新，也是一个很大的值然后输出no path的时候，不能只是和inf比较，因为可能曾经被更新，要看它是否明显超过理论正常最大距离( $T \times 10000=250000000$ )，设为0x3f3f3f3f就够了undefined 4 poj1734 Sightseeing trip8.29 难度2请先思考后再展开 floyd找最小环undefined 5 6201 走廊泼水节8.29 难度2请先思考后再展开 这道题设计得很好个人很喜欢这种，对看似简单、经典的算法，推陈出新地挖掘细节、原理的题目结果就不会做了…… 这道题从边的角度思考会简单一些想到边，以及最小生成树，会想到kruskal把所有边排序，然后关键就是“完全图中的边，是否跨树”对于这一点我只能出个数据把自己的乱搞做法卡掉，但不知道怎么去解决 其实这条边什么时候会跨树呢？盗lyd好图：是不是豁然开朗了？模拟kruskal的过程，连接两个树之间的边，只会在这一次跨树此时，他们的取值都应为z+1，个数则是 $Sx \times Sy-1$undefined 6 poj1639 Picnic Planning8.30 难度2请先思考后再展开 就是限制了根节点度数的最小生成树先去除1节点，跑出每个节点的最小生成树，然后找最小的一条边连接上去然后有可能可以对某个点x，去掉某条1到x的一条边，并连接x和1 7 poj2728 Desert King8.30 难度1请先思考后再展开 01分数规划+最小生成树不过不知道为什么跑得很慢log的大小，无论如何都是在100以内的，那么正常来说这道题就一亿，时限3s个人觉得它非要卡二分我也没办法，Dinkelbach大概只是恰好快而已（毕竟那东西的复杂度很玄学）undefined 8 APIO2010 巡逻8.30 难度2请先思考后再展开 这道题的k=1、2，先从k=0入手不难发现，每条边一定要经过两次（因为是树，一定会递归一次回溯一次），所以就是$2(n-1)$对于k=1，加入一条新的边以后，一定出现了环，就不一定是两次了同时，在这个环上，其他边都从经过两次变成了经过一次（例如题目中的a）不难发现，此时答案为$2(n-1)-(直径长度-1)$ 对于k=2的情况，稍微复杂了一些如果产生的新的环，没有和原本的环重叠，那么同样是不用经过一次（例如题目中的b）但是，如果重叠了（例如题目中的c），那么由于“新的边必须经过一次”这个限制，公共部分又变成了要经过两次 总上所述，第一次找直径L1，把边权变为-1第二次找到直径L2，答案即$2(n-1)-(L1-1)-(L2-1)$ 有木有觉得apio的图片非常良心 9 CH#56C 异象石8.30 难度2请先思考后再展开 先从每个节点上都有石头的情况开始考虑如果从边的角度，那就是边总长但因为这道题，主要从点的情况考虑，所以转化为，按照dfs搜索顺序，经过的相邻两点间距离/2而对于不满的情况也是类似，把存在的所有点，按照dfs序收尾相接，相邻间距离和即为答案那么具体实现的时候，可以搞一个set，用upper_bound等找相邻并动态维护当前总和即可 10 BJWC2010 严格次小生成树8.30 难度2请先思考后再展开 按照惯例，对于这种在树上有非树边的问题，可以考虑一下，由非树边产生的环例如本题，对于这个环，我们断掉任何一个，整个图依然是树（本来就是挂起来的无向无环图）所以说，对于每条边，其贡献就是，把它替换掉原本树上路径中最大那一条产生的差然后因为求的是严格次小，所以有种特殊情况，就是最大那个和当前边相同长 引理：在最小生成树原本的路径中，一定不会有比当前非树边大的边 证明：否则应该被当前非树边替换掉（替换掉一定不会有其他副作用之类，还是那句话，树本来就是挂起来的无向无环图） 那么也就是我们还需要且只需要再考虑次大值具体实现的话，用一个倍增st表维护一下就好了（以倍增lca为框架） 11 IOI2008 Island8.30 难度1请先思考后再展开 题意为，给出一个基环树森林，每个节点只能去一次，起点任意跨基环树的时候，不能回到曾经去过的基环树求最大化的【经过的基环树边的总和】显然答案就是每个基环树内直径之和然后基环树直径这种东西，写个dfs找环，dfs向下找最大深度，然后套个单调队列就好了 12 6401 创世纪8.30 难度2请先思考后再展开 在lxj的提醒下才想到正解……其实一点都不难 图显然是一个内向树森林，要求选自己，则至少一个孩子不被选考虑dp，$f(x,0/1)$表示当前子树满足条件时，x选择0/1的最大选择节点数先搞定树上的部分，如果枚举固定一个孩子不选，然后其他乱搞，但给个菊花图就会炸不难想到取补，把任意情况减去所有孩子都选了的情况（套路之记录次小值） 对于环上的怎么搞呢？看一眼这里就知道了 13 POI2008 BLO-Blockade8.31 难度2请先思考后再展开 教程然后还是不会做…… 在搜索树上考虑对于每个节点，假如它不是割点，那么只有它和其他人是联通块，贡献为$2(n-1)$而如果是割点，我们需要知道产生了多少个联通块，以及他们的大小 但怎么找？$low_y \leq dfn_x$这等价于割点的判定条件主要考虑是可以相等，因为每次我们会断掉所有的边 联通块有三种： x自己，大小1 共有t个满足上面的条件，大小为在搜索树上的子树大小 剩下的所有点（假如大小不为0，则一定存在） 第三点非常容易想漏，所以说建议多构造几组数据，当然对拍也是可以如果求稳的话 时间复杂度$O(n+m)$undefined 14 poj3694 Network8.31 难度1请先思考后再展开 教程考虑合并每个e-DCC，形成一棵树然后倍增预处理一下lca 然后对于操作，其实就是合并x到y树上路径上的所有点，这个可以考虑用并查集维护由于单个的小合并操作，只会发生n次，即使并查集log，也只有nlogn而这个复杂度是超脱于询问这个循环之外的总复杂度 其实细节挺多的，大致流程： tarjan找到e-DCC，确定代表元素，初始化其并查集（最后别漏了根节点） 建立新的边目录，预处理倍增lca 回答询问的时候，一个个向上跳，维护割边数量cntundefined 15 poj2942 Knights of the Round Table9.1 难度2请先思考后再展开 题意：找出有多少个骑士，无法出席任何会议会议的要求是有奇数个人，成环形后相邻的人没有憎恨关系 因为是环形，考虑连成一个环，不难想到建立一个补图，用【无憎恨关系】来建边那么就转化成，有多少个点，不在任何奇环（奇数个点的简单环）中 然后判断奇环可以染色，但怎么标记呢？暴力搞我自己都能出个数据卡成nm百思不得其姐，又去膜题解题解给出的又是两个结论……还好这一次，这两个结论的证明都很简单 结论1：奇环不会垮v-DCC存在证明：显然两个v-DCC能合并成一个v-DCC，与v-DCC的“极大”矛盾 结论2：如果某个v-DCC中有奇环，则整个v-DCC的每个节点，至少被一个奇环所包含假设有奇环外节点x，总是能和奇环上任意两个节点vi和vj形成奇环，因为无论【x到vi+x到vj】的奇偶性如何，奇环上两个点间距离总是能取奇数或者偶数……因为奇=奇+偶，亘古不变…… 怎么说呢？这两个结论都不是太好猜，但偏偏缺一不可 16 poj1236 Network of Schools9.1 难度2请先思考后再展开 开始想法：设强连通分量缩点后，a=【入度=0】，b=【出度=0】那么第一问求a，第二问求b 其实已经和正解接近了，但还是错误的第二问求的其实是max(a,b)重新思考，对于入度为0的scc，如果起点不在这里就凉了，要消除掉对于出度为0的scc，如果起点在这里就凉了，要消除掉因为一次可以同时消除两种各一个，得证 17 poj2226 Muddy Fields9.7 难度2请先思考后再展开 不会做的经典模型将连续的泥地分为行泥泞块和列泥泞块，形成了二分图那么，对于每个小泥地，至少要被其中一种覆盖那么把每个小泥地作为边，恰好连接两个元求最小覆盖即可 18 6902 Vani和Cl2捉迷藏9.9 难度2请先思考后再展开 神仙结论题，结论不好猜，证明不好想，但出得挺好因为不能有路径相连，可以联想到传递闭包（居然没有想到），转移为边的相连（构造新图，边就是用闭包得出来的结果）那么现在类似于要找最大独立集 具体做法：oi之路-图论-其他-Dilworth定理undefined 19 CH#17 舞动的夜晚9.10 难度2请先思考后再展开 详见oi之路的二分图一章undefined 20 Poj3422 Kaka’s Matrix Travels9.10 难度1请先思考后再展开 考虑用流量表示路径的移动然后因为每个格子只能取一次，拆一下点$st=&gt;(1,1,0),flow=k,cost=0$$(i,j,0)=&gt;(i,j,1),flow=1,cost=num(i,j)$$(i,j,0)=&gt;(i,j,1),flow=\infty,cost=0$$(i,j,1)=&gt;(i+tx[t],j+ty[t],0),flow=\infty,cost=0$$(n,n,1)=&gt;ed,flow=\infty,cost=0$跑最大费用最大流即可 0x6B 图论练习部分题目 21 6B02 升降梯上9.11 难度1请先思考后再展开 把每个点拆成m个操作后的状态，最短路即可undefined 22 NOI2007 社交网络9.11 难度2请先思考后再展开 原来最短路路径数是可以用floyd统计的然后记住一定要去除编号相同的情况（以前总是偷懒）还有就是，一开始总是想不通怎么处理一条链的情况，为什么不会重复统计呢？但其实，由于其dp性质，一条路径只会在k为最大编号时才被统计undefined 23 NOI2003 逃学的小孩9.12 难度2请先思考后再展开 算法一：最小化答案：min(c-&gt;a,c-&gt;b)+a-&gt;b结论：可以取直径作为a-&gt;b神仙证明 算法二：最小化答案：min(c-&gt;a,c-&gt;b)+a-&gt;b可能这个稍微常规一点?不妨设最小的是a，题目变成求出 a-&gt;c+a-&gt;b这是两条点不重复的路径，并且要求对于a而言c比b近如果枚举这两条路径的分叉点，巧妙地转化成求不同三个子树的最大深度这个可以用二次扫描+换根法实现还有个小细节，分岔点可能就是a 24 AHOI2008 紧急集合9.12 难度2请先思考后再展开 又感到很惭愧了……想了些数据，发现一定是跑到其中一个lca然后又yy几个情况，发现都是应该找深度最小那两个，然后到他们的lca，就不用枚举三次了然后就秒wa了然后就被rose秒出hack数据了，就是深度大那个点在它们到lca之间的路径上……所以最后还是枚举，发现有点慢，最大0.93s……所以正解应该是用离线lca算法，不过太复杂就不改了，大概yy了一下算法权当复习 下面就只给出朴素代码undefined 25 poj1275 Cashier Employment9.13 难度2请先思考后再展开 本来想着如果在费用流统计答案的时候不把费用乘以流量，就能让边权只表示使用这条边的费用那么就可以构图，从st到每个人，流量8费用1，然后时间连向ed，流量就是需求量然后发现这样的修改没有用，因为我可能流量在下一条增广路采用，然后费用就被多次统计了……看了眼tag居然是差分约束…… 不难想到可以前缀和一下，构造不等式组不过不知道怎么处理环形的情况，好像涉及了三个元$s[i] \geq s[i-1]$$当i leq 7,s[i]+tot-s[i+15] \geq c[i]$$otherwise,s[i]-s[i-8] \geq c[i]$ 膜lxj后发现，显然的单调性，二分即可 26 6B12 最优高铁环9.13 难度2请先思考后再展开 连01规划的sb题都不会做了有点担忧……现在才相同专题都这样，感觉后面要更多地做综合题对于有思考环节深度的题目，经常比别人走得浅当别人在关心判正环太慢的时候，我还毫无思路甚至别人以为我没去做例题…… 总之这道题为了判断负环的速度，写的是栈spfa如果在初始值为0的情况下，只要存在最长路的松弛，就是产生了正环然后不知为何本机ac提交waundefined 27 HNOI2012 矿场搭建9.14 难度2请先思考后再展开 显然先求一下割点，求出每个块的组成分析每个块，如果内部没有割点，那么需要两个出口，位置任意，但不重复如果只有一个割点，那么堵掉就凉了，所以要添加出口，而且不能在割点处如果有两个或以上，那么就无需担心，总能够出去综上说述，乘法原理统计一下即可 然后我以为根节点那个特判会影响vdcc的判断，其实只是影响割点……没有好好思考还有就是完全没考虑孤立点，还好这道题不需要undefined 28 bzoj3033 太鼓达人9.15 难度2请先思考后再展开 非常好的一道题，如果lxj不说是欧拉图我肯定不会做……先考虑长度，显然不会超过 $2^k$ ，否则一定会出现重复那么如果我们能构造出一种方案，保证长度为 $2^k$ ，那么答案就是 $2^k$ 假设该结论成立，那么我们需要覆盖 0~ $2^k-1$ 的每个值有一个不那么好像的方法，但因为自己受到提示，不难想到把每个值作为边然后为了确保出现的独一无二，分割为前面k-1个和后面k-1个，转移的边为了字典序优先选最小的那么因为出度为2，入度为2，一定是一个欧拉图，那么一定能得出 $2^k$ 的长度0 如果讲得不清楚，这位女选手的图片不错 29 中山市选 杀人游戏9.15 难度1请先思考后再展开 这道题的题意不太清晰其实就是尽量少去交给命运决定……（少尝试）答案就是 $\frac{n-尝试数量}{n}$ ，也就是都不是杀手那么缩点后找入度为0即可不过如果本来是一个点，那么可以用排除法得出结果，稍微判断一下即可 30 poj3648 Wedding9.15 难度1请先思考后再展开 2-sat比较显然假设新娘在右边，然后左边不能有通奸，直接scc判断即可那么因为有可能新郎也通奸，导致新娘去左边了，为了防止这种情况，从新娘到新郎连一条边表示非法性undefined 31 poj1112 Team Them Up!9.18 难度2请先思考后再展开 题目关键：直接认识 在本题中，单一的单向边是没有意义的，应转化为双向边因为这个直接到达有点麻烦，如果取补图，边的意义就是【不能在相同的组中】此时成功产生了互斥关系，可以二分图染色，如果不是二分图，直接无解 当然我们染色出来的只是其中一种解对于每个联通块，都是可以取反的那么现在相当于一个有序二元组，目标就是让人数差最小01背包dp一下，转移很快，滚不滚没关系 32 zoj1654/HEOI2016/TJOI2016 游戏9.18 难度2请先思考后再展开 又没看出来……先想了想网络流，肯定不对因为是双向边，想了想二分图，感觉不对，因为我选，下一个不选，并不代表再下一个会选然后想想2-sat，有点像，但不知道怎么满足最大…… 看了看tag，我去，最大独立集好像有道理，但不应该是一般图吗？再想想……哦因为排斥关系是行或列的，所以没有奇环…… 然后就连样例都过不去了……随便考虑一行多个点，然后就会有奇环凉了 lxj提示说和草地排水很像一下得到启发，分行块和列块，把点化作边那么每个点最多连一条边，那么就是一个二分图匹配]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Arc101D】Median of Medians]]></title>
    <url>%2Fposts%2Ff4a4.html</url>
    <content type="text"><![CDATA[Source and JudgeArc101D Record1h Analysis请先思考后再展开 题意：给一个长度为$n$的数列，把每个子串的中位数组成新的序列，求其中位数做法1：枚举$l$和$r$，然后排序组成中位数，时间复杂度$O(n^2log_2n)$做法2：枚举$now$，再枚举$l$和$r$，统计比它小的数量考虑其贡献，时间复杂度$O(n^3)$正解（大小逻辑关系的运用不一定完全相同）： 二分答案，难点在于如何判定问题：答案是否 $\leq mid$ 不难想到，可以判定 $\leq mid$ 的数字，$其贡献 \geq \lfloor \frac{n(n+1)}{4} \rfloor +1$ ，对于每个区间，用类似的思路，考虑是否会被”堵住“，$小于等于的数量&gt;大于的数量$，用前缀和优化一下，$(a_r-a_{l-1})-(b_r-b_{l-1})&gt;0$，为了方便，$c_{l-1}&lt;c_r$ 现在看起来复杂度是$O(n^2log_2n)$，但是显然可以用数据结构如树状数组优化，变成$O(nlog_2^2n)$ 细节：爆int，一开始完全没注意到 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟赛2总结]]></title>
    <url>%2Fposts%2F80fa.html</url>
    <content type="text"><![CDATA[题目 比赛经历开局听说是看谁破百请吃饭的毒瘤题集不愧是tkj出得题（后来听栋老师说，都是煞笔题） 先看t1，fff是什么东西？狗狗协会？因为有spj，尝试找突破口手推不出-1的情况，尝试用rand帮我，所以码了个暴力，结果n到25也搞不出-1的点看来可能根本就没有-1的情况了那感觉就没什么突破口了看下一题 天啊看到这种题面和排序有关的题目就虚因为以前遇到过几次，感觉都和”冒泡排序”有关果不其然，我这种不会冒泡排序的人虚死了看下一题 金坷垃？没有任何思路感觉可能要计算几何，或者扫描线之类的东西反正不会…… 难道这把就要挂机了？好像很多人都是这样……各个都说不想交了，直接讲题什么的，毫无耐心现在想想好像只有第二题可以搏一搏了 这种快排好奇特啊能不能直接先把do while的那个跑一跑，然后枚举每个点，看看后面有多少个比它小的（逆序对贡献），然后如果有再+1？这个加入离散化后，可以用树状数组维护 发现过不了大样例啊，对拍一下试试吧2h过去了……发现暴力超级难打不过也不是虚度，因为通过模拟分段的无数细节，对分段性质理解加深了 然后我发现空间炸的一匹，vector也没有用（因为大数据非常良心，是一个dfs链状结构）所以就放弃出大数据的希望了，用来对拍吧 果然逆序对是错误的主要是两个原因：循环先执行再判断、执行复杂度直接算是当前区间长度 怎么办呢想着交个暴力算了 然后，突然灵光一现，发现可以改良因为每一次的复杂度贡献是按照长度来的，然后每个分段，其实就是由【在该数后面的数中比当前小，而且最远那个】和当前，包围起来的此时因为查错，我右边的备用小数据中已经有差不多10个了发现每一个都满足这个性质（一定要先跑一次，单循环冒泡，这样子分段才是明确的） 然后发现这是一个平方级别的做法，不知道能拿多少分先打了先把，很好改试试大样例 ？？居然过了？？当时就激动得一匹因为至少做法正确性没有问题主要还是速度太慢 想办法优化数据结构中好像只有具备结构体能力的splay能搞但当时只有20min了！以我的码力，这是不可能的 咦考虑一个数组（早就离散化了），存下最后那个？那询问还要按值找哦不对是可以用线段树维护最大值的，如果保存距离的话 当时还剩15min火速开始码他们已经打算交了 那几分钟，我的心跳的好快好快手指尖在键盘间笨拙地跳舞熟悉的单点修改区间询问线段树啊，如果码出来，就有ac的希望了那段时间好漫长，但没想到还是打完了途中还差点被没看懂的编译错误卡住，现在想想真的好险 最后还是打完了，顺利过了大样例然后就去吃饭了心里虚的一匹主要是时间太紧了，要不然能对拍一下就好了现在回想起来，还是在暴力上花费太长时间了，虽然那可能是想出正解的基础 这些东西现在回想起来，感觉也很难说清楚吧其实运气成分还是很大比例的而且我这速度，后面的发展也很虚啊三道题，用全部时间，只能做出一道题 吃饭途中得喜报还是顺利ac了感谢上帝……上一次拿rk1已经是省选前了……只是，没有人和我一样兴奋都对自己很失望吗不过这种东西，风水轮流转吧大概像我上次cf，被吊锤，晚上也是难受的很 ————在断网的中午，胡思乱想 T1-Analysis请先思考后再展开 这是一个非常奇妙的做法首先把情侣之间用无向边连接，然后把2i-1和2i连接这样，所有环因为必定是情侣边和相邻边交替的，而且出发边和结束边一定不一样（度只有2）所以只有偶环，也就是说是个二分图所以就可以愉快地染色了 windows本地栈，63000左右如果不是linux，可以考虑手动模拟 T1-Code-Std请先思考后再展开 undefined T2-Analysis请先思考后再展开 原题 Usaco2018 Open Out of SortsLuogu4372Bzoj5277 现在冷静想一想，发现我傻了，根本没有必要用线段树这种这么长的东西因为已经离散化了，直接用数组，维护最后位置，然后搞一个【前缀最大值】就好了这要是因为我们要维护的是位置，而这种东西可以通过比较直接确定在不在后面然后前缀最大值这种东西，当时太紧张，再加上原本的做法是需要动态维护的，所以就没跳出来当然复杂度没有变化 师兄的做法没看懂，不管了反正不一样 UP：讲课的时候被d飞了86 1 3 2 4 5 2 4答案是19虽然答案一样，但画出来的线段完全不对应（据akc研究后说，它的总数值，代表了某种总贡献，只是神仙地把操作后移了） 去膜了发官方题解发现可以这样考虑：对于所谓的快排下去递归冒泡，其实和对整个序列冒泡是等效的那么考虑每个元素的贡献，就是它左右两边的分隔符都出现之前的时间长度注意： 如果在最开始的时候，它就是单个元素，那么也会被统计一次 枚举元素的时候，是按照排序后的位置来找左右两边的 那么现在问题转化为计算n-1个分隔符出现的时间对于在i和i+1之间那个分隔符，它出现时，序列前i个元素已经在其前面了那么现在的关键就是第i大（稳定排序下）那个元素的位置r，要多久才能到i显然现在位于i的那个元素，一定比位于r的那个要大，否则前面已经足够了因为更大，那么每次冒泡，这个泡i一定会把r给换过来，也就是说每次冒泡往前一位所以说从r到i的时间恰恰是r-i T2-Code-Old请先思考后再展开 undefined T2-Code-Std请先思考后再展开 undefined T3-Analysis请先思考后再展开 原题 Usaco2018 Jan SprinklersLuogu4184Bzoj5187 首先，最后的可行多边形一定是一个外凸边形那么有一个重要的性质，就是对于这种形状（大概是两个阶梯围成的）然后这种图形的可行解非常好处理，因为对于每个点，它的另一个端点的可行区域就在其左下侧区域中如果要直接暴力的话，现在就可以得到50分了 考虑处理出每一列的up和low表示上下界这个东西的维护，可以考虑先记录一个转折点，然后最后再线性推一推就好了（因为有单调性） 接下来推柿子$$\sum_{i=0}^{n-1}{ \sum_{j=low[i]+1}^{up[i]} 【 \sum_{k=low[i]}^{j-1} i-left[k] 】}$$ $$\sum_{i=0}^{n-1}{ \sum_{j=low[i]+1}^{up[i]} 【 i \times (j-low[i]) - \sum_{k=low[i]}^{j-1} left[k] 】}$$ $$\sum_{i=0}^{n-1}{ i \times \sum_{j=low[i]+1}^{up[i]} 【 (j-low[i]) - \sum_{k=low[i]}^{j-1} left[k] 】}$$ $$\sum_{i=0}^{n-1}【 \frac{ i (up[i]-low[i]) (up[i]-low[i]+1) }{2} - \sum_{j=low[i]+1}^{up[i]} \sum_{k=low[i]}^{j-1} left[k]】$$ $$\sum_{i=0}^{n-1}【 \frac{ i (up[i]-low[i]) (up[i]-low[i]+1) }{2} - \sum_{t=low[i]}^{up[i]-1} left[t] \times (up[i]-t)】$$ $$\sum_{i=0}^{n-1}【 \frac{ i (up[i]-low[i]) (up[i]-low[i]+1) }{2} - up[i] \times \sum_{t=low[i]}^{up[i]-1} left[t] + \sum_{t=low[i]}^{up[i]-1} left[t] \times t】$$ $$\sum_{i=0}^{n-1}【 \frac{ i (up[i]-low[i]) (up[i]-low[i]+1) }{2} - up[i] \times \sum_{t=low[i]}^{up[i]-1} left[t] + \sum_{t=low[i]}^{up[i]-1} left[t] \times t】$$ 所以维护一个前缀和就好了 T3-Code-Std请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【训练】算法竞赛进阶指南-5动态规划 24题]]></title>
    <url>%2Fposts%2F18f8.html</url>
    <content type="text"><![CDATA[本处难度分档以个人实力为参照系难度1：半小时内想出，半小时内ac难度2：半小时想不出，看题解，服气难度3：半小时想不出，看题解，ac后依然觉得难度很大 另外，由于追进度，对于coding部分比较有自信的题目，不再具体实现 0x50 动态规划部分题目 1 5101 LCIS8.22 难度2请先思考后再展开 精妙的做法设 $f(i,j)$ 表示以b[j]结尾，匹配到i的最长LCIS$a_i \neq b_j,f(i,j)=f(i-1,j)$$a_i=b_j,f(i,j)=max_{0&lt;k&lt;j,b_k&lt;b_j} f(i-1,k)+1$$a_i=b_j,f(i,j)=max_{0&lt;k&lt;j,b_k&lt;a_i} f(i-1,k)+1$乍一看是$n^3$级别的，但其实k的位置是可以动态维护的undefined 2 5105 Cookies8.22 难度2请先思考后再展开 好题对于决策的分配，可以从等效状态直接转移抓住【排序后分配额递减】和【饼干至少1】的特性同时怒气值是根据相对大小产生的，所以可以整体少1设 $f(i,j)$ 表示给前i个人j块饼干的花费 决策1，所有人减少1块（当$j-i \geq i$）$$f(i,j)=f(i,j-i)$$决策2，后k个人（包括i）都是1块$$f(i,j)=min_{k=1}^{i-1} { f(i-k,j-k) + (i-k) \times \sum_{t=i-k+1}^i g[t] }$$undefined 3 poj1015 Jury Compromise8.22 难度2请先思考后再展开 把差值作为体积，和作为权值，跑背包难点在于回溯刚开始在外层跑第几个物品，然后发现会出现一种情况，即使倒着枚举已选数量：现在使用过的物品，可能把当前依赖的那个位置给更新掉，不符合01背包所以改成在里面枚举，这样每次强行判断一下就好了如果要稍微降低代码复杂度，同时剪剪枝（其实也就是20），可以考虑刷表法 话说跟风akc，第一次用宏对于这道题是真的爽undefined 4 poj1742 Coins8.22 难度2请先思考后再展开 楼教主的题耶二进制拆分法解决多重背包问题undefined 5 USACO2005 Jan Gold Naptime8.23 难度2请先思考后再展开 环形的dp，并且不能使用克隆法（会重复使用）对于这种决策能自动补全的题目，可以用一种巧妙的做法————二次扫描 设 $f(i,j,0/1)$ 表示处理到第i个小时，已经休息了j个小时，当前醒/睡状态下，最大的休息值先不考虑从昨晚就开始睡觉的情况 初始值为负无限（剔除非法状态，例如休息0正在睡）$f(1,0,0)=f(1,1,1)=0$$f(i,j,0)=f(i-1,j,0)$$f(i,j,1)=max{ f(i-1,j-1,0),f(i-1,j-1,1)+w_i }$$ans1=max{ f(n,m,0),f(n,m,1) }$那么昨晚就开始睡觉怎么办？$f(1,0,0)=0,f(1,1,1)=w_1$强行重新跑一次，自动拼接$ans2=f(n,m,1)$ $ANS=max{ ans1,ans2 }$undefined 6 CF24D Broken robot8.23 难度2请先思考后再展开 注意题意细节，一开始看题看错了： 不能向上 可以到最后一行任意位置 停在原地的选择也算是一种行动，要计算步数 如果向左是非法选择，那么随机的时候不会考虑那边非常有趣的思路：用高斯消元解决局部依赖性的dp 分n个阶段去dp同样用倒推解决期望问题$f(i,j)=f(i,j)/4+f(i,j-1)/4+f(i,j+1)/4+f(i+1,j)/4+1$其中 $f(i+1,j)$ 是定值$\frac{3}{4}f(i,j)-\frac{1}{4}f(i,j-1)-\frac{1}{4}f(i,j+1)=f(i+1,j)/4+1$每个阶段列出一个 m个m元方程组，浮点高斯消元求解即可 就这么水？呵呵复杂度是$n^3$ ，不tle才怪主要是高斯消元太慢了考虑通过题目性质改良undefined 形状一定是这样的然后可以这样搞：第一遍，顺着，第i行消第i+1的第i元，变成这样undefined 第二遍，倒着，第i行消第i-1行的第i个 然后就完美了虽然大部分是自己想的，但还是有akc的一点提示，以及lxj的一点题意解释（懒得看）undefined 7 noi2001 炮兵阵地8.26 难度2请先思考后再展开 关键是状态怎么精妙地表示一开始想着用6进制数，炸得很主要是没有考虑到十字的影响很小计算第i+1行，只要考虑第i-1和第i行，确保它们分别与运算都是0（反映列的上下影响两个）同时可以预处理出每个行内合法的状态，也就是没有两个相邻的距离小于3（反映行）这个状态量非常小，极限88个，可以放心搞时间复杂度$O(n |S|^3)$undefined 8 5702 Count The Repetitions8.27 难度2请先思考后再展开 神仙好题看到字符串的“生成”就虚的要死但其实字符串长度很短，可以暴力搞具体等会讲 问题可以转化成，用 $s(s_1,n_1)$ 能生成的 $s(s_2,m’)$ 使m’最大答案即最大的 $n_2 \times m \leq m’$ 因为m’是能拆分二进制的，那么考虑能否用s1来拼出只要有解，那么从某个位置开始的连续一段，花费一些字符长度，总是能拼出来的那么记录具体花费（考虑到题目中的生成是不能跳跃的，那么花费代价是很明确的，也没有任何决策可言）$f(x,p)$ 表示在s1的x开始，需要花费多少个字符，才能生成$s(s_2,2^p)$对于p=0的起始状态，可以直接暴力尝试s2的每个字符，然后如果为了找一个字符连续找了一圈，那么无解，这个地方的复杂度是$100^3$ 倍增的转移就非常简单了（为了方便，字符串从0开始）这时候先假设s1是无限长的，后面拆分的时候再考虑最终长度限制，因为现在还不明确$f(x,p)=f(x,p-1)+f( x+f(x,p-1) \% |s_1|,p-1 )$ 对于每次拆分，设x为当前用到什么地方，限制$x \leq n_1 \times |s_1|$然后x从0开始，lyd不知道干嘛居然还枚举x的起点，这样显然是没意义的……然后就没有然后了 本题ch上数据有错，多了个大括号在输入文件中，用cin可以规避简易前往leetcode466undefined 9 poj3017 Cut the Sequence8.27 难度2请先思考后再展开 $f(i)=min{ f(j)+mx(j+1,i) },sum(j+1,i) \leq M,0 \leq j&lt;i$这个柿子的可以用队列维护，但难以维护单调性 但是有一个结论：对于一个 $j$ ，若 $j$ 可能是最优决策，则不仅要满足$sum(j+1,i) \leq M$还要满足下列其中一个条件： $a_j=max(j,i)$ （单调递减性） $sum(j,i)&gt;M$ （也就是说 $j+1$ 是满足条件中最小的 ）证明：首先如果意会一下，就是在满足条件下，以max结果分割，每段最左边的那个原因是，如果存在一个满足条件的 $j-1$ ，并且和 $j$ 在同一段中，那么再考虑f的单调性（显然多一个数字不会更小），显然 $j-1$ 不会比 $j$ 差 上面两种情况可以分开考虑和继承对于情况2，可以尺取法线性维护（每个 $i$ 只有一个）对于情况1，维护一个 $a$ 单调递减的队列不难发现，对于单调队列中的每个元素，其 $mx(j+1,i)$ 就是下一个元素的a然后，由于条件1，在每次插入 $a_i$ 并维护单调性后，每个决策的大小是不会变的（除了单调队列最后一个元素，因为此时它还没有下一个元素）等维护完以后，再把倒数第二个决策插入到二叉堆里面，取最大更新即可undefined 10 5A01 任务安排18.27 难度2请先思考后再展开 最初的想法，基本上是$O(750000^2 n)$$f(i,ed)=min{ f(j,\leq ed-s-sumT[i]+sumT[j])+ed \times (sumC[i]-sumC[j]) }$其实可以把第二维转化为分段数量，简化状态，时间$O(n^3)$$f(i,t)=min{ f(j,t-1)+(S \times t+sumT[i]) \times (sumC[i]-sumC[j]) }$ 然后有一个神奇的经典思想，叫做“费用提前计算”，就是把当前决策产生的后效性现在就计算，这样子，如果某次决策比不过别人，没有后效性之后是不用任何担心的，再也不会更优$f(i)=min{ f(j)+sumT[i] \times (sumC[i]-sumC[j])+S \times (sumC[n]-sumC[j]) }$时间$O(n^2)$undefined 11 CF559C Gerald and Giant Chess8.28 难度2请先思考后再展开 看到黑色棋子这么少，一定是用总方案数-非法情况得到答案然后就想着，如果统计每个黑色格子经过的数量，用容斥原理统计的话，怎么计算出多个黑色的情况？显然是无法暴力枚举的，然后就懵逼了 其实，这是因为状态的设计有问题，导致同一条路径被多次计算重新设计状态，设$f(x)$表示以黑格子x作为某条【经过黑格子的路径】的第一个黑格子，这样，每条路径只会被它第一个黑格子统计，这样就能不重不漏了至于任意走的时候的方案数，可以参考前面讲到的多重集全排列 $$f(i)=C_{x_i+y_i-2}^{x_i-1} - \sum_{{ j|x_j \leq x_i 且 y_j \leq y_i }} f(j) \times C_{x_i-x_j+y_i-y_j}^{x_i-x_j} $$undefined 12 poj1737 Connected Graph8.28 难度2请先思考后再展开 通常而言，计数类dp需要划分结构来继承，但现在处理的“连通无向图”很难划分所以现在考虑能否算出【任意无向图数量-不连通的无向图数量】任意无向图数量显然为$2^{n(n-1)/2}$对于不连通的无向图数量，可以划分出多个联通块又是运用某个不知名的经典思想，只分割出单一的一个来避免重复计数，剩下的内部还是任意（不能和分割出来的连通） 设 $f(i)$ 表示一个大小为n的连通无向图数量$f(i)=2^{i(i-1)/2}-\sum_{j=1}^{i-1} f(j) \times C_{i-1}^{j-1} \times 2^{(i-j)(i-j-1)/2}$代码略 13 CEOI2002 A decorative fence8.28 难度3请先思考后再展开 整体思路：因为要找第k大，依次枚举每个位置，枚举在这上面放什么，然后计算如果这样放，后面的方案数T如果$k \leq T$，那么证明这是正确的，继续往下找，否则$k-=T$这个思想在【树状数组、各种平衡树中找第k大】等应用中都有体现，不过本题没法也没必要分治 具体而言，设当前位置为i，并假设现在放了一块长度为h的木板作为0低位1高位高低位在第一个确定以后，就是轮流的了，所以说第一个要特判那么怎么计算方案数呢？设 $f(i,j,0/1)$ 表示用i个木板，其中最左边那个在其中是第i小且作为0低位1高位，的方案数那么此时就是$f[n-i+1][h在剩下中的排名][递推出的当前高低位]$ 注意到我们用排名而不是具体的值来表示这样子就不用考虑左边用剩下什么，而只要考虑高低位所需要的相对大小关系就好了（类似离散化）而且因为和具体的值没有关系，放在外面预处理也是可以的 这个dp方程也不是太好想可以从放入后的结果考虑，然后思考什么状态能转移过来：在插入后，最左边那个的排名是j如果是低位，那么插入后的排名，可以在它右边的就是 j+1~i ，还原到i-1时就是 j~i-1$f(i,j,0)=\sum_{p=j}^{i-1} f(i-1,p,1)$如果是低位，那么插入后的排名，可以在它右边的就是 1~j-1 ，还原到i-1时依旧是 1~j-1$f(i,j,1)=\sum_{p=1}^{j-1} f(i-1,p,0)$undefined 14 poj3208 Apocalypse Someday8.28 难度2请先思考后再展开 运用和上一道题类似的思想考虑每一个位置，枚举其数字，将后面能够让当前数字变成魔鬼数有多少种方案 而要称为魔鬼数，需要考虑三点： 前面部分最后连续的6的数量（也可能已经是魔鬼数，此时后面可以任意填） 这一位是否是6（衔接、延长） 后面的方案 这里后面的方案同样是预处理，但又要考虑到其前面6的个数以下内容包含前导0设 $f(i)$ 表示i位魔鬼数的数量$g(i,0/1/2)$ 表示最后有连续 $0/1/2$ 个6，但不是魔鬼数的数量（避免重复） 显然有如下柿子$f(i)=g(i-1,2)+10\times f(i-1)$$g(i,0)=g(i-1,0)+g(i-1,1)+g(i-1,2)$$g(i,1)=g(i-1,0)$$g(i,2)=g(i-1,1)$ 但要注意边界$g(0,0)=1$本来直接写出了i=1的情况错了，好想是因为后面要用到，而不仅预处理undefined 15 Ahoi2009 同类分布8.28 难度2请先思考后再展开 本来觉得是一道神题学完数位dp后，就觉得是一道水题了（主要是太套路，太常规）undefined 0x5E 动态规划练习部分题目 16 USACO2002 Feb BUY LOW, BUY LOWER8.24 难度2请先思考后再展开 难点在于统计和去重很不好想的做法：先处理出f，接着重新枚举一次，根据刚才的转移路径来统计答案为了避免重复，碰到相同的数就break，因为前面的部分是无法直接更新自己的undefined 17 poj1722 SUBTRACT8.24 难度3请先思考后再展开 非常好的一道题，思考难度略大 （就是说我太菜不会做） 转化题目：把两个数做差后合并，就是打负号后再打括号那么相当于把整个数列，在空位写符号，问能否得到目标数T 题目特性：由于值域很小（-10000~10000），考虑一个可加可减的背包$f(i,ed)$ 表示考虑到第i位，能否得到d，-1表示不行，0表示在$i-1和i$ 之间用+，1表示-因为有spj，能找到解就好还原路径也非常简单 求解：合并的做法也很巧妙每次把连续的一段+，打上括号，也就变成了-然后随便地把第一位连续输出长度个即可这样把所有+处理完，只剩-，那么同样直接把第一个位置连续地输出就好了 对了，注意第一个符号不能是+，否则没法变成-undefined 18 noi2001 陨石的秘密8.24 难度2请先思考后再展开 非常巧妙地dp设计之前听嘎爷讲过类似的题目，就是通过一个小小的容斥表示状态这样具体转移的时候只要关心一个上或下限就好了以本题为例，设$f(d,a,b,c)$ 表示$深度 \leq d$ ，同时各个括号分别用a、b、c对时，其可行方案数这样答案就是$f(D,A,B,C)-f(D-1,A,B,C)$ 转移的时候，可以通过简单的乘法原理，分成两边后，考虑右边那个的外层是什么，然后累加起来这样子就能够保证右边那个一定是一个块，而不是多个块，避免了重复这一点之前也见过，把一个多子树的问题，每次只抽出一个子树，其他递归下去考虑，一样的道理$$f(d,a,b,c)= \\f(d,a,b,c-k-1) \times f(d-1,0,0,k) + \\f(d,a,b-j-1,c-k) \times f(d-1,0,j,k) + \\f(d,a-i-1,b-j,c-k) \times f(d-1,i,j,k)$$时间复杂度$O(A^6 \times D)$undefined 19 noi1999 棋盘分割8.25 难度2请先思考后再展开 一开始看错题目了，好像是因为以前见过那样的题目：每次切都是产生切剩下的部分的代销（像合并果子？）那样的话，平均值不固定会非常难处理，于是就跑去膜题解了才发现自己沙茶了（这也可能是没有样例解释的锅）其实是指切n-1刀，最后是n个块，那么其实拼起来就是原本的块，所以平均值是固定的 稍微化简一下柿子（挺意外还有化简这回事……以后题目中见到柿子都要试一试）$ans^2$$=\frac{1}{n}( \sum (xi-\overline x)^2 )$$=\frac{1}{n}( \sum (xi^2-2 x_i \overline x+\overline x^2) )$$=\frac{1}{n}( \sum xi^2 - 2sum\overline x + \sum \overline x^2)$$=\sum xi^2/n - \overline x^2$ 代码实现就非常简单了，先二维前缀和预处理，设$f(n,a,b,c,d)$ 表示当前还有多少次，以及当前区间记忆化搜索，转移的时候枚举端点比较即可 20 poj1390 Blocks8.26 难度2请先思考后再展开 显然先缩点 一开始想了一个贪心的做法，每次选择一个地方消除，分治，并顺便暴力地合并左右两边来更新答案然后发现连样例都过不去，以后应该先对着样例模拟一次的……所以现在的主要问题还是新块合并的处理 一个非常难想的延后处理法：设$f(l,r,k)$ 表示处理l到r的区间，同时存在一个本来不连续的长度为k的块和r相连且颜色相同 直接合并，$f(l,r,k)=f(l,r-1,0)+(k+len_r)^2$ 把k交给前面的某个t（$col_t=col_r$）处理，$f(l,r,k)=f(l,t,k+len_r)+f(t+1,r-1,0)$ 很巧妙地通过增加维，解决了新区间合并的问题其中也含有部分贪心的思想（例如直接把r也交给t处理） 时间复杂度方面不好估计，可能比赛的话，会感觉自己打了一个部分分？然后出来就ac了主要是因为颜色方面的限制，不会跑满（颜色块的不相同和转移时颜色的相同互斥）极限数据如121212121，可以自己造来跑一跑undefined 21 hdu2196 Computer8.26 难度2请先思考后再展开 二次剩余，时间复杂度n为了求出，一个数列中除了某个数以外，其他数的最大值，维护一下次大值即可大概算是小技巧 总之第一次求出子树内距离，第二次从父亲处继承信息undefined 直径结论，时间复杂度nlogn这东西的证明等，自行搜索本博客“直径”undefined 22 HNOI2011 XOR和路径8.26 难度2请先思考后再展开 xor是对整数的运算，所以无法求出期望递推式如果把每个位置拆分（还是那个套路，二进制运算，不同数位间互不影响）那么只要考虑每个数位位置是1的概率，就能求出期望（权值确定，为1） 依旧是倒推，设$f(x)$ 表示当前x到n，异或和这一位是1的概率当$w_i=0$，$f(x)+=f(y)/tot$当$w_i=1$，$f(x)+=(1-f(y))/tot=1/tot-f(y)/tot$然后高斯消元即可 这道题卡精度，eps简易设置为1e-8undefined 23 SCOI2010 股票交易8.29 难度2请先思考后再展开 设 $f(i,k)$ 表示在第i天，拥有k个股票的最大现金答案即 $max f(T,1…maxp)$可能从 $f(j \leq i-w-1,k2 \leq maxp)$ 转移注意到第二维、决策都和第一维没有关系可以考虑一个经典的做法：把最优值后置，减少转移时间也就是说，直接取值 $f(i-w-1,k2 \leq maxp)$ 或者 $f(i-1,k)$时间复杂度为$O(n^3)$ 在这种连log都不能要，必须省掉一个n的时候，不妨考虑一下单调性①买入$f(i,k)=max { f(i-w-1,k2 \geq k-As_i)+k2 \times Ap_i }-k \times Ap_i$②卖出$f(i,k)=max { f(i-w-1,k2 \geq k+Bs_i)+k2 \times Bp_i }-k \times Bp_i$ 编号越大，贡献范围越大，维护一个编号递增，贡献递减的单调队列即可无脑开2n个单调队列，继承于i-w-1，维护i，时空都是完全没毛病的代码略 24 USACO2006 Nov Silver Round Numbers8.29 难度1请先思考后再展开 按照套路来就好了undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF1025C】Plasticine zebra]]></title>
    <url>%2Fposts%2Ff525.html</url>
    <content type="text"><![CDATA[Source and JudgeCF1025C Record1h Analysis请先思考后再展开 要不是因为比赛的时候被第二题卡，还是能做出来的……说多都是泪 然后我的做法和机房其他人都不一样就是从操作的实际意义入手，发现等于没有翻转例如形如 ab|cd 这样的字符串，得到所谓的ba|dc但其实本质上，就是把后面那个放到前面，cd|ab，然后再整体倒过来然后不难发现，整体倒过来没有任何意义所以每次操作其实就是把后面的一段放到前面去，相当于跑一个环状的东西 所以说，只需要枚举一个起点，然后向后延伸就好了比赛还剩五分钟的时候，感觉需要平方级别回去的路上立刻就想到，其实维护一个双指针就好了 总而言之这道题真的很好想从操作入手，思考本质就是了 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SCOI2007】降雨量]]></title>
    <url>%2Fposts%2F20bf.html</url>
    <content type="text"><![CDATA[Source and JudgeSCOI2007luogu2471bzoj1067poj2637 Record1h Analysis请先思考后再展开 裸题就是情况有点多 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度1</tag>
        <tag>st表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟赛1总结]]></title>
    <url>%2Fposts%2F4f83.html</url>
    <content type="text"><![CDATA[题目 T1-Analysis请先思考后再展开 这是一道当时感觉很神，后来感觉很签到的好题关键在于，判断是否是n的倍数把加0看做乘以10，加1看做乘以10再加1这里运用到了一个技巧————用余数表示再通过记忆化，能够把原本【2的次幂】的复杂度，降低到n具体的实现可以用bfs路径的记录，可以以余数为索引，记录从哪个余数继承过来当然无脑string也行，毕竟就是一个等差数列的复杂度 T1-Code-Std请先思考后再展开 undefined T2-Analysis请先思考后再展开 考虑用dp来预处理神仙转化问题：【把原本的串取反，允许修改k的配额，能得到多少个目标串】设$f(S,i,k)$为，当前状态为S，处理到第i位，剩下可分配额为k，后面能够得到多少个目标串计数类dp，显然是倒推的$f(S,i,k)=f(S,i+1,k)+【k&gt;=w_i】f(S^bin[i],i+1,k-w_i)$ T2-Code-Std请先思考后再展开 undefined T3-Analysis请先思考后再展开 原题：cf_R495_div_d然后我的代码其实如果加上快读就卡过去了，大概0.5s的速度……毕竟我的快速check函数，还是下了一番功夫的，从【面积】下降到【最大编号】 先说说我的想法：1.设计一个check函数表示在n乘m的矩阵中，数字i出现了几次（假设(1,1)=1）然后这个东西很多人是暴力【面积】做的其实可以通过找规律，分类讨论一下，降到【最大编号】 2.确认一个最大的完美正方形，每次调用check函数计算数字的需求量，然后判合法性 3.经过上一步，已经保证这个正方形会贴边了，这样我们就能直接把它在那条边上移动（注意交换n和m）最后还是分4个块，然后调用check判合法性 讲讲正解和我不同的部分：1.通过一层层向外枚举，得到第一个不能完美菱形的数字，这个数字就是0的x坐标可以这样考虑：x在外面，则高度为x-1~0，也就是x个然后做法的话，其实可以直接每层数字，数量+4，而我硬生生调用一个函数来计算……当然因为这个在外面，所以速度可以很随便，只是不那么优美 2.在枚举出矩阵的形状后，可以直接把最大那个数字mx放在(n,m)的位置，因为即使它在其他的角落，矩阵也能翻转过来这样的好处在于，最大曼哈顿距离确定为$mx=n-x+m-y$移项后得到$y=n+m-x-mx$，也就是说能够直接得出y这样就省去了枚举y的时间了 现在复杂度就是$O(\sqrt n \times check复杂度)$而check复杂度就是$\sum_{i=1 to \sqrt n} i+n/i$根据等差数列和调和级数$n/2+nlog_2 \sqrt n$ 当然你要是暴力，问题不大，因为实际上外面的循环不会到满的根号，毕竟约数个数不会太大根据我打的表，一千万内最多的也只有448个 T3-Code-Old请先思考后再展开 undefined T3-Code-Std请先思考后再展开 undefined T4-Analysis请先思考后再展开 又是一道很好的脑力题$a_i &amp; a_j =0$其实就是没有同时对应存在的1 依然是巧妙地转化题目：用个数组记录合法性【取反后a】存在合法解a并且因为【有合法解性】是可以传递的所以倒着递推（像背包？），枚举每个数字，每个【有合法解性】的数字，把某个1去掉后，都能从a得到合法解 T4-Code-Std请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【国家集训队】礼物]]></title>
    <url>%2Fposts%2F1774.html</url>
    <content type="text"><![CDATA[Source and Judge国家集训队bzoj2142 Record5h Analysis请先思考后再展开 拓展lucas裸题直接算$\prod C_n^{wi} \% p$，但每次要减少n时间复杂度$O(\sqrt N + p^c)$ 调试了一天……好多细节 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>Lucas</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF1019A】Elections]]></title>
    <url>%2Fposts%2F1dd8.html</url>
    <content type="text"><![CDATA[Source and JudgeCF1019A Record2h Analysis请先思考后再展开 比赛的时候乱想了一个贪心，没有足够的码力实现，而且应该是错误的 曾经想到枚举出最后的数量ed，然后不知道怎么利用其实这样以后，一下就能判断出，比ed高或相同的部分都要去掉，而且一定是选小的。而且，这样以后如果还没达到ed，选择什么地方都和决策没有关系了，直接选最小的即可时间复杂度O(n^2) 其实现在回想起来，又是【把最重要的一点想到后懵逼】系列 还有就是akc说满足三分性，不过反正题目没卡这个，就不管了反正时间优秀的一匹 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC9】小h的树]]></title>
    <url>%2Fposts%2Ff894.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC9 Record1h Analysis请先思考后再展开 这也是一道好题把dp和树结构的性质等结合在了一起 找点性质：因为要遍历每一个点，而且还是个树结构不难发现每条边最多遍历2次 先考虑特殊情况，k=n那么每条边都要遍历，而且“有点难发现”最后只被遍历一次的会是一条链答案就是$2 \times 边总长-链长度$所以为了答案最小，取直径…… 然后推广一下，有些边可以不经过了发现其实就是选取一个子树结构，让【上面说的值】最小然后我们维护的东西是满足可加性的，只要保证一条链 接下来对于我来说有些难度，但可能对大佬来说是一个套路就是搞一个树形dp，考虑直径的出现情况因为满足可加性，设 $f(x,k,0/1/2)$ 表示在x的子树中选k个（根节点必选）最后的下标，表示直径端点出现情况然后在dp的过程中，枚举y，根据直径端点出现情况考虑x到y这条边的贡献情况 感觉这个dp状态的设计还是灰常关键的 最后要证明这个复杂度方法灰常奇特啊就是把枚举siz看做是枚举其子树内每个节点那么对于每个点对，只会在其lca处被枚举到 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF1025D】Recovering BST]]></title>
    <url>%2Fposts%2F7565.html</url>
    <content type="text"><![CDATA[Source and JudgeCF1025D Record1h Analysis请先思考后再展开 这道题出得灰常好再次%一发rose大爷首先，所谓BST就是吓唬人的联想一下splay，其中序遍历不变这道题同样如此甚至都帮你排好序了然后就不知道怎么解决了…… 其实可以继续在中序遍历中做文章因为这是一个一维的序列然后在一颗子树中，其实是连续的一段（完全忘记的我……） 考虑一下区间dp然后有个小性质：我的父亲一定在当前区间的旁边，毕竟当初就是这样分开的而且，这棵树的根节点是可以随便取的 具体实现的话，枚举出当前子树的根节点x，与rt判断是否合法，然后向下用记忆化会灰常方便设f(l,r,op)表示可行性，然后op表示rt在那一侧就好了 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP17 D2T3】列队]]></title>
    <url>%2Fposts%2F1613.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2017 提高组 D2T3Loj2319Luogu3960 Problem【Description】Sylvia 是一个热爱学习的女♂孩子。前段时间，Sylvia 参加了学校的军训。众所周知，军训的时候需要站方阵。Sylvia 所在的方阵中有n×m名学生，方阵的行数为 n，列数为 m。为了便于管理，教官在训练开始时，按照从前到后，从左到右的顺序给方阵中 的学生从 1 到 n×m 编上了号码（参见后面的样例）。即：初始时，第 i 行第 j 列 的学生的编号是(i−1)×m+j。然鹅在练习方阵的时候，经常会有学生因为各种各样的事情需要离队。在一天 中，一共发生了 q件这样的离队事件。每一次离队事件可以用数对(x,y)(1≤x≤n,1≤y≤m)描述，表示第 x 行第 y 列的学生离队。在有学生离队后，队伍中出现了一个空位。为了队伍的整齐，教官会依次下达 这样的两条指令： 向左看齐。这时第一列保持不动，所有学生向左填补空缺。不难发现在这条 指令之后，空位在第 x 行第 m 列。 向前看齐。这时第一行保持不动，所有学生向前填补空缺。不难发现在这条 指令之后，空位在第 n 行第 m 列。教官规定不能有两个或更多学生同时离队。即在前一个离队的学生归队之后， 下一个学生才能离队。因此在每一个离队的学生要归队时，队伍中有且仅有第 n 行 第 m 列一个空位，这时这个学生会自然地填补到这个位置。因为站方阵真的很无聊，所以 Sylvia 想要计算每一次离队事件中，离队的同学 的编号是多少。注意：每一个同学的编号不会随着离队事件的发生而改变，在发生离队事件后 方阵中同学的编号可能是乱序的。【Input】输入共 q+1 行。第 1 行包含 3 个用空格分隔的正整数 n,m,q，表示方阵大小是 n 行 m 列，一共发 生了 q 次事件。接下来 q 行按照事件发生顺序描述了 q 件事件。每一行是两个整数 x,y，用一个空 格分隔，表示这个离队事件中离队的学生当时排在第 x 行第 y 列。【Output】按照事件输入的顺序，每一个事件输出一行一个整数，表示这个离队事件中离队学 生的编号。【Limited conditions】数据保证每一个事件满足 1≤x≤n,1≤y≤m【Sample input】2 2 31 12 21 2【Sample output】114【Sample explanation】列队的过程如上图所示，每一行描述了一个事件。 在第一个事件中，编号为 1 的同学离队，这时空位在第一行第一列。接着所有同学 向左标齐，这时编号为 2 的同学向左移动一步，空位移动到第一行第二列。然后所有同 学向上标齐，这时编号为 4 的同学向上一步，这时空位移动到第二行第二列。最后编号 为 1 的同学返回填补到空位中。 Record2h Analysis请先思考后再展开 如果把每次排队，抽象成操作【删除】和【寻找某一行或者一列的第k个】那么显然就是要用数据结构维护了可以说这是一道我见过最不裸的数据结构题反正我是没有独立看出来的能力的 但这个二维的矩阵要怎么维护呢？如果说每行都开一个，那么每次向前看起的时候，最后一列向前移动了一位也就是说我们需要插入、删除n次？显然是不可能的 其实向前的列只有最后一列，所以我们可以把行上的操作类比到最后一列上也就是说，把最后一列单独维护，前面的n行，每行只维护m-1个元素就好了 接下来把操作具体化一下，设出队的人坐标为(x,y)：①y=m【把最后一列的第x个删除并获得id】，【将id插入到最后一列的最后】②y&lt;m【把第x行的第y个删除并获得id】，【将id插入到最后一列的最后】【把最后一列的第x个删除并获得id】，【将id插入到第x行的最后】 还有一点就是，由于矩阵很大，不能直接存储，需要用一些手段动态利用空间 基于以上考虑，决定使用的数据结构思路一：平衡树，我只会splay思路二：线段树【%rose_max大爷，想到了这么神的做法】 平衡树很好理解，操作很常规，主要是怎么压缩空间然后我自己想了个做法，结果tm到处都是这样做的……就是把连续的节点用二元组(st,tot)表示，需要的时候分裂开就好了找第k大就用siz来找就好了 至于线段树的做法，借鉴主席树的思想，动态开点，只产生链对于找第k大，还是用siz，但这一次是用【线段树下标差-被删除数量】来搞然后删除数量，就用一个sum维护即可因为后面还要插入，所以预先每个线段树开n+q的范围这样的空间复杂度是nlogn，比splay多个log，但是时间理论上会小常数 不过实际情况是，我写的splay总时间和线段树一样，约10000ms，但单点最大1500ms，而线段树是1000ms在极限时间相同的情况下，xgc和rose的线段树总时间只有6000ms对比了一下，也没发现什么不同…… Code1请先思考后再展开 splayundefined Code2请先思考后再展开 线段树undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP17 D2T2】宝藏]]></title>
    <url>%2Fposts%2F301d.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2017 提高组 D2T2Loj2318Luogu3959 Problem【Description】参与考古挖掘的小明得到了一份藏宝图，藏宝图上标出了 n 个深埋在地下的宝藏屋， 也给出了这 n 个宝藏屋之间可供开发的 m 条道路和它们的长度。小明决心亲自前往挖掘所有宝藏屋中的宝藏。但是，每个宝藏屋距离地面都很远， 也就是说，从地面打通一条到某个宝藏屋的道路是很困难的，而开发宝藏屋之间的道路 则相对容易很多。小明的决心感动了考古挖掘的赞助商，赞助商决定免费赞助他打通一条从地面到某 个宝藏屋的通道，通往哪个宝藏屋则由小明来决定。在此基础上，小明还需要考虑如何开凿宝藏屋之间的道路。已经开凿出的道路可以 任意通行不消耗代价。每开凿出一条新道路，小明就会与考古队一起挖掘出由该条道路 所能到达的宝藏屋的宝藏。另外，小明不想开发无用道路，即两个已经被挖掘过的宝藏 屋之间的道路无需再开发。新开发一条道路的代价是：L×KL代表这条道路的长度，K代表从赞助商帮你打通的宝藏屋到这条道路起点的宝藏屋所经过的 宝藏屋的数量（包括赞助商帮你打通的宝藏屋和这条道路起点的宝藏屋） 。请你编写程序为小明选定由赞助商打通的宝藏屋和之后开凿的道路，使得工程总代 价最小，并输出这个最小值。【Input】第一行两个用空格分离的正整数 n,m ，代表宝藏屋的个数和道路数。接下来 m 行，每行三个用空格分离的正整数，分别是由一条道路连接的两个宝藏 屋的编号（编号为 1−n ），和这条道路的长度 v 。【Output】一个正整数，表示最小的总代价。【Limited conditions】1≤n≤12， 0≤m≤1000， v≤500000【Sample input 1】4 51 2 11 3 31 4 12 3 43 4 1【Sample output 1】4【Sample input 2】4 51 2 11 3 31 4 12 3 43 4 2【Sample output 2】5【Sample explanation】无 Record3h去年比赛的时候想了半天，没想出什么数据能卡贪心地最小生成树然后就被卡到了45分 Analysis请先思考后再展开 rose曾经提出的做法:用$f[S][now][dep]$表示当点的状态为S，现在在now且深度为dep时的最优结果那么把不同种起点方式塞进去之后，就可以转移复杂度为$2^n \times n \times n \times n$ 看起来没有任何问题，对吧？我一开始也是这样认为的，就是一直心里有种别扭的感觉后来想半天终于发现，因为把其他点的信息舍去了，再也不能从别的点出发转移了 正解是状压dp这次的状压灰常独特呢反正我是没见过…… 设$f[dep][S]$表示当前的状态是S，最大深度是dep时的最小代价然后枚举每个状态进行转移的时候，每次直接添加一个点集，直接全部作为新的一层至于代价，考虑到题目的特殊性，树的结构具体如何无关紧要，只和每个节点的深度有关既然如此，只要预处理出每个节点添加到一个点集中的代价，再预处理成点集即可 然后让我们分析一下复杂度大致上=dp时枚举dep的时间 × 所有状态转移时枚举【补集的子集】的时间花费那么其实枚举【补集的子集】就是枚举子集 如果直接从循环量看，一定是比$O(2^n \times 2^n)=2亿$少的当然按照akc在省选后的教训，这个也可能跑出灰常多的分数但这个时间到底是多少呢？ 因为这东西是和rose一起xjb想出来的，不一定严谨而且好像和别的大佬看起来不一样？考虑按照【含0数量】分类$2^12 \times C_12^0$$2^11 \times C_12^1$……$2^6 \times C_12^6$……$2^1 \times C_12^11$$2^0 \times C_12^12$ 那么最大的显然是$2^6 \times C_12^6&lt;=60000$那么它们的总和$&lt; 60000*12=720000$所以总复杂度就是8640000 UP 晚上：问了问师兄，得出了和网上大佬相同的结论对于这种连续的枚举子集问题，复杂度其实是$O(3^n)$对于每个数位，只有3种情况，原本是0，原本是1枚举子集成0，原本是1枚举子集成1当然这种复杂度的前提是精准找到那个位置 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>状压</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SDOI2013】随机数生成器]]></title>
    <url>%2Fposts%2F41a1.html</url>
    <content type="text"><![CDATA[Source and JudgeSDOI2013Luogu3306Bzoj3122 Record2h Analysis请先思考后再展开 随便推推柿子，发现有通项公式$x_i=a^{i-1}x_1 + b(1+a+a^2…+a^{i-2}) (\mod p)$$x_i=a^{i-1}x_1 + b \times (a^{i-1}-1) \times inv(a-1) (\mod p)$注意0没有逆元，所以要特判a=1的情况，即一个带模等差数列，解一个同余方程即可而对于普遍情况，可以BSGS，而且不用拓展，因为已经保证p是素数，而且a小于p Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>BSGS</tag>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Abc104-D】We Love ABC]]></title>
    <url>%2Fposts%2Ff88a.html</url>
    <content type="text"><![CDATA[Source and JudgeArc100-D Problem【Description】给出一个字符串，只有A,B,C和通配符?答案为：枚举出各种情况，每种情况，不同位置三元组满足(A,B,C)，其数量之和【Input】字符串s【Output】输出和，模1e9+7【Limited conditions】|s|&lt;=10^5【Sample input 1】A??C【Sample output 1】8【Sample input 2】ABCBC【Sample output 2】3【Sample input 3】????C?????B??????A???????【Sample output 3】979596887【Sample explanation】无 Record30min刚长途旅游完只有abc Analysis请先思考后再展开 第一次想出D因为同样的三元组，可能会多次统计直接枚举每个b和?，考虑其贡献即可 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【训练】算法竞赛进阶指南-3数学30题]]></title>
    <url>%2Fposts%2F82f7.html</url>
    <content type="text"><![CDATA[本处难度分档以个人实力为参照系难度1：半小时内想出，半小时内ac难度2：半小时想不出，看题解，服气难度3：半小时想不出，看题解，ac后依然觉得难度很大 0x30 数学题目 1 poj2689 Prime Distance7.19 难度2请先思考后再展开 有一个很妙的做法：采用类似埃筛的方法筛素数所以只要线性预处理出前面$\sqrt R$内的素数p，然后在后面搞一搞就好了 复杂度计算：$$O(\sum_{质数p \leq \sqrt R} \frac{R-L}{p})$$然后根据什么调和级数之类的东西，$1+1/2+1/3+1/4….1/n ≈ log_2 n$所以说复杂度就大概是$O((R-L) \times log_2 \sqrt R)$ 最后提醒各位特判一下1并且数组的下标是相对位置，错了好多次undefined 2 3101 阶乘分解7.19 难度1请先思考后再展开 枚举素数p，考虑贡献，对于次幂为1，有$\frac{n}{p}$个对于次幂为t，有$\frac{n}{p^t}$个，新贡献恰好为$\frac{n}{p^t}$所以，枚举每个素数，然后以log的时间计算贡献即可undefined 3 HAOI2007 反素数8.6 难度2请先思考后再展开 找找反素数共有的性质吧 性质1：如果约数个数相同，根据性质，应该取最小的 性质2：素因子只有2,3,5,7,11,13,17,19,23证明：回忆约数个数公式，只与每个素数的次幂有关。如果使用更大的素因子，前面这9个中至少有一个空缺（否则超出题目范围）如果用这个空缺替换，次幂不变，会得到更小的数字，违背性质1 性质3：若将反素数表示为$2^{k_2} \times3^{k_3} \times5^{k_5} \times7^{k_7} \times11^{k_{11}} \times13^{k_{13}} \times17^{k_{17}} \times19^{k_{19}} \times23^{k_{23}}$则$k_2 \geqk_3 \geqk_5 \geqk_7 \geqk_{11} \geqk_{13} \geqk_{17} \geqk_{19} \geqk_{23} \geq0$证明：如果不递减，把某个逆序对交换后，可以得到相同约数下更小的数字，违背性质1 最后用dfs枚举一下就好了undefined 4 CQOI2007 余数求和8.6 难度1请先思考后再展开 先化简柿子$ans=\sum_{i=1}^n k-\lfloor \frac{k}{i} \rfloor \times i=nk - \sum_{i=1}^k \lfloor \frac{k}{i} \rfloor \times i$这是因为当i&gt;k时，结果就是k 然后这东西初看时线性的，还是会超时如果有经验的话，可以一眼看出用一个技巧解决详见套路集锦中枚举方法3本来不知道怎么算复杂度，反正比k小，曾经听说期望根号现在已经把书上的证明补充上去了，其实也不复杂 总之就这样枚举过去，等差数列推推柿子就好了undefined 5 poj3090 Visible Lattice Points8.7 难度2请先思考后再展开 先分析题目，不难发现要求的是gcd(1~n,1~n)=1的数量 那么可以直接用莫比乌斯undefined 那么我们尝试用欧拉搞一搞其实就是因为长宽相同，那么对于每一列，累加一下欧拉就好了undefined 6 poj3696 The Luckiest number8.7 难度3请先思考后再展开 x个8连在一起的数字，可以用$\frac{8}{9} (10^x-1)$表示那么题目要求$L | \frac{8}{9} (10^x-1)$等效于$9L | 8(10^x-1)$设$d=gcd(L,8)$假设条件满足，那么L中的偶因子是8的约数两边同时除以d后，左边不再有偶因子，则右边剩下的偶因子没有意义$\frac{9L}{d} | 10^x-1$转化成$10^x=1 (\mod \frac{9L}{d})$ 当$gcd(10,\frac{9L}{d})=1$时，根据中欧拉函数与欧拉定理的定理8，可枚举其约数，快速幂判断即可undefined 7 bzoj2973 1801 石头游戏8.10 难度1请先思考后再展开 脑残题但是题目居然不说清楚：如果操作违法，要把它丢掉还有就是一些sb错误，耽误了一个早上undefined 8 JSOI2008 球形空间产生器8.10 难度2请先思考后再展开 先推推柿子如果把n+1个点，与球心的距离表示出来，会得出一个多元二次方程组为了变成一次，考虑把相邻的相减$\sum (a_{i,j}-x_j)^2-(a_{i+1,j}-x_j)^2=0$$\sum 2(a_{i+1,j}-a_{i,j})x_j=\sum a_{i+1,j}^2-a_{i,j}^2$然后高斯消元就好了undefined 9 poj1830 开关问题8.10 难度2请先思考后再展开 如果把异或看做是不进位的加法，那么就很好理解了undefined 10 JLOI2015 装备购买8.11 难度2请先思考后再展开 卡精度，要开long double所以决定以后无脑long double了hh 为了做第二问，贪心地每次找最小的作为主元证明不会，但是我构造不出反例本来以为找到一个：3 23 04 45 02 1 3但其实，经过消元，第一行不会是0如果非要是0，那么第二行一定是第一行的倍数，则也能反过来……（感觉我表述得乱七八糟，意会一下吧）undefined 11 Hdu3949 XOR8.11 难度2请先思考后再展开 key：高斯消元后，得到的简化阶梯形矩阵，具有一个重要的性质————对于主元i，该列上唯一的1在这上面所以说，在其他相同的情况下，选i一定比不选要大所以说，可以把k按二进制拆分，按位，对应于要不要选择第i行 细节：注意0，线性基可以通过【自己异或自己】得出，但本题不行所以说特判一下最后的矩阵，就好了，具体自己分析 最后补充一下【异或线性基组合出来的数（即span张成）互不相同】的证明：假设有一个柿子，左右两边都是异或出来的数字，把左边留下某一个，其他移项到右边，那么出现，那个数字能被其他数字表示出，则违反线性基定义 顺便说说异或能移项的证明：把两边同时异或那个数 undefined 12 3602 Counting Swaps8.13 难度3请先思考后再展开 多重集组合数 假如写出前面的几个数（谁会这样啊……都退出柿子了，也好像化简不出什么）：1,1,3,16,125会发现$s[n]=n^{n-2}$ 对于k个长度分别为l1,l2,…,lk的环$ans=\prod s[l_1]s[l_2]…s[l_k]\frac{(n-k)!}{(l_1-1)!(l_2-1)!…(l_k-1)!}$undefined 13 CF451E Devu and Flowers8.16 难度2请先思考后再展开 多重集组合数裸题，讲解undefined 14 POI2007 ZAP-Queries8.16 难度1请先思考后再展开 莫比乌斯裸题undefined 15 3801 Rainbow的信号8.16 难度2请先思考后再展开 求期望位运算的特性在于，不同的二进制位之间没有影响所以为了方便统计，先枚举每一个位，然后分类讨论 线性枚举r①and如果出现了0，就是0那么最后一个0把前面l的取值范围分成两半，其中只有后面的部分有贡献所以记录一下lst0②or如果出现1，就是1和and同理，记录lst1③xor这个稍微麻烦一些，因为取值涉及到1出现个数的奇偶性那么把按照1的出现次数，分奇偶，形成交替的区间那么只有贡献为奇数的区间是有用的用c0、c1分别记录偶数区间和奇数区间的总长度即可undefined 16 3802 绿豆蛙的归宿8.16 难度2请先思考后再展开 期望的线性性undefined 17 3803 扑克牌8.16 难度2请先思考后再展开 本来写的是倒着dp，好像被卡边界了结果tm改成记忆化搜索就过了？？undefined 18 poj2311 Cutting Game8.17 难度2请先思考后再展开 博弈不过，如果出现(1,1)，并定义为必败态，本身没有问题但考虑只有一行或一列的情况，会把两个有向图游戏异或起来，然后对方就会“努力翻盘”，导致本来游戏早就结束，却被“莫名其妙翻盘了”所以要跳过这些状态，并早点判断出必败态：(2,2)和(2,3)undefined 0x3B 数学练习题目 19 SDOI2012 Longge的问题8.17 难度2请先思考后再展开 按照反素数的思路，只考虑前面几个素数，按照约数个数公式dfs最终得出，在int范围内约数最多约1500个 那么，如果枚举约数s，把它作为gcd的结果$\sum s \times 【gcd(1 \to n,n)=s的个数】$$\sum s \times 【gcd(1 \to n/s)=1的个数】$$\sum s \times \varphi (n/s)$undefined 20 bzoj1477 poj1061 青蛙的约会8.17 难度1请先思考后再展开 同余方程组裸题t(n-m)+kL=x-yundefined 21 3B04 Xiao 9*大战朱最学8.17 难度1请先思考后再展开 同余方程组裸题undefined 22 SDOI2011 计算器8.17 难度2请先思考后再展开 裸题undefined 23 hdu5015 233 Matrix8.17 难度1请先思考后再展开 矩阵乘法裸题undefined 24 poj2947 Widget Factory8.18 难度1请先思考后再展开 带模数的高斯消元undefined 25 WC2011 最大XOR和路径8.18 难度2请先思考后再展开 这道神题的关键在于 利用异或的抵消性质当然交换、结合律也稍微要用到 对于一个路径，其实就是由链和在上面重叠的环组成这样以后，你会发现，能对最终答案产生影响的就是一条链和几个环因为对于重叠的部分或者为了到达环而经过的边（如果原路返回）被自己抵消了因为这是一个无向图，如果有多条可选的链，而最优的不是这一条，那当前这一条和它组成了一个环，所以说枚举环的时候异或一下，自己就又被抵消了，变成了那条链 所以说，随便找一个链，找一些环放上去，让异或和最大想到异或和会想到线性基那怎么找环呢？dfs去找不难想到，但枚举起点复杂度过高其实直接从1开始就好了，对于一个结束的环，可以把当前值异或从起点到这里的代价这样又抵消掉了 undefined 26 CQOI2013 新Nim游戏8.19 难度2请先思考后再展开 根据博弈的基本知识，普通nim游戏在异或和=0的时候必败，否则必胜那么只要能确保后手无法在第二回合把异或和变成0，那么就胜利 异或和基本上就和线性基有关了，主要是因为，对于异或线性基，其异或空间除了0，其他的表示方法中每个元素最多用一次 什么情况下，能够把异或和变成0？就是在某一次插入x中，发现无法插入因为这意味着，里面的东西能够表示出x这个时候，当前线性基 xor x=0，后手只要把后面取走就好了我们的应对策略是把x取走（因为线性基内部，无法表示出0，否则违背定义） 那怎么求第一问，让取走的东西总数最小呢？有一个精妙的贪心：按照从大到小考虑这个可以用微扰证明，如果某个位置能用小也能用大，我们用了大，不会让答案更差，因为线性基能否插入和其他位置无关undefined Sdoi2016 排列计数8.29 难度2请先思考后再展开 同学提醒这道题漏掉了……所以就没有编号了 把其中m个固定后，剩下的就是错排发现题目要求的是$C_n^m \times D_{n-m}$undefined 27 poj3904 Sky Code8.20 难度1请先思考后再展开 莫反裸题一开始没想到F(d)那么好求……复杂度$O(n \sqrt n)$undefined 28 3B13/CF167B/bzoj4636 守卫者的挑战8.20 难度1请先思考后再展开 概率dp裸题但是有很多细节，中文题目不是很清楚 必须n个都尝试过，最后再离开 某一时刻可以装不下undefined 29 poj2976 Dropping tests8.20 难度2请先思考后再展开 01分数规划裸题浮点二分果然练得还是太少了undefined 30 poj1704 Georgia and Bob8.20 难度2请先思考后再展开 这是一道传说中的阶梯博弈其实就是转化为nim游戏 首先，把两堆石子两两捆绑（奇数堆的时候，把第1堆和边界0捆绑）然后如果每组石子内部，后面的向前移，最多移动就是空格数量所以如果不考虑前面那个的移动情况，就是一个nim游戏 所以对于先手，如果他是赢家，一定按照nim来这个时候如果后手突然移动前面，那么先手把后面那个等距离向前移动，就能还原出相同局面，而且一定能实现而如果先手是输家，那么和上面同理无法改变结局undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷18年7月月赛比赛总结]]></title>
    <url>%2Fposts%2Fb37c.html</url>
    <content type="text"><![CDATA[洛谷18年7月月赛比赛总结题目 比赛经历先把第一题做了然后第二题wa了几次，蹲坑的时候忽然灵光一现想到了漏洞……然后就挂机了……和以前没什么区别 T1_Analysis请先思考后再展开 先离散化一下，统计每个数出现个数如果剩下一个的时候，判断素数即可 看了题解发现原来我的代码是有漏洞的没有考虑，最后没有数字的情况（没有把t初始化为1），然后居然ac了 T1_Code_原请先思考后再展开 undefined T2_Analysis请先思考后再展开 一眼贪心模拟显然碰到连续两个跳过的点，就失败但是一开始写成了【连续两个小段失败】，其实可能只是跳过中间那个点就行还有一个细节漏了，就是不能跳过m-1 T2_Code_原请先思考后再展开 undefined T3_Analysis请先思考后再展开 当时想了1h都没有思路只是想到通过差分和贪心，面对一个局面时可以线性地判断然后就在想方设法【线性扫时间，通过利用残留信息logn判断】然后就实在想不到什么残留信息可以用…… 强行伏笔：一直奇怪那个r给出来有什么用（可能是用来迷惑人的？）然后题目下面一大堆限制条件，以为只是用来手算范围的其实有一个隐藏的特性：$R_i&gt;=i$所以说一次成功后，后面的都能成功，也就是满足二分性（不一定是一个完美的函数，但最后一定都是成功）（让我联想到化学反应的结束图像） 实话说我经常会这样害怕毒瘤题面 T3_Code_std请先思考后再展开 undefined T4_Analysis请先思考后再展开 有关区间最小值，有这样一个套路:先用一个递减的单调栈，分别从前往后和从后往前，求出l[i]和r[i]表示第一个比a[i]大的位置，则l[i]+1~r[i]-1中间，用到的最大值都是a[i] 考虑枚举这个最大值位置，然后枚举左右中数量少的那一边的端点这样另一个端点的取值范围就确定了，静态主席树即可，当然树状数组+离散化+二分查找也行。这样做的话读者可能认为复杂度是$O(n^2 log_2 n)$的，无异于【预处理st表+暴力枚举端点】的复杂度 然鹅，这种做法的复杂度其实是$O(n log_2^2 n)$的证明：对于每个i，它能够把l[i]~r[i]分成两半，分出来后，下一层级的j不能跨越出去所以说每次选取少的那一边，$枚举量 \leq log_2 n$换句话说，这些查询区间的总量是nlogn个，可以用set查重 至于空间，如果用树状数组或者线段树，不离散化的话，复杂度是m至于主席树，因为是静态的，前缀和形式，动态开点则变成nlogm，大大降低 debug:有一个漏洞，就是相同的数会多次作为最大值我的想法灰常暴力：set判重，不影响复杂度，由于区间不多，空间也不大而优秀的rose就有更劲的方法：全覆盖时强行保证只用最左边的具体而言，左边延伸到比x大或相等的，右边延伸到比x大的这样它们右端点相通，但左端点不会重复覆盖 T4_Code_std请先思考后再展开 undefined T5_Analysis请先思考后再展开 看到“凸包”两个字就想跑……]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【USACO2009 NOV Gold】灯]]></title>
    <url>%2Fposts%2F3fa9.html</url>
    <content type="text"><![CDATA[Source and JudgeUSACO2009 NOV GoldBzoj1770Luogu2962 Problem【Description】贝希和她的闺密们在她们的牛棚中玩游戏。但是天不从人愿，突然，牛棚的电源跳闸了，所有的灯都被关闭了。贝希是一个很胆小的女生，在伸手不见拇指的无尽的黑暗中，她感到惊恐，痛苦与绝望。她希望您能够帮帮她，把所有的灯都给重新开起来！她才能继续快乐地跟她的闺密们继续玩游戏！牛棚中一共有N盏灯，编号为1到N。这些灯被置于一个灰常複杂的网络之中。有M条很神奇的无向边，每条边连接两盏灯。每盏灯上面都带有一个开关。当按下某一盏灯的开关的时候，这盏灯本身，还有所有有边连向这盏灯的灯的状态都会被改变。状态改变指的是：当一盏灯是开著的时候，这盏灯被关掉；当一盏灯是关著的时候，这盏灯被打开。问最少要按下多少个开关，才能把所有的灯都给重新打开。数据保证至少有一种按开关的方案，使得所有的灯都被重新打开。【Input】第一行：兩個空格隔開的整數：N和M。第二到第M+1行：每一行有兩個由空格隔開的整數，表示兩盞燈被一條無向邊連接在一起。 沒有一條邊會出現兩次。【Output】一個單獨的整數，表示要把所有的燈都打開時，最少需要按下的開關的數目。【Limited conditions】1 &lt;= N &lt;= 351 &lt;= M &lt;= 595【Sample input】5 61 21 34 23 42 55 3【Sample output】3【Sample explanation】一共有五盞燈。燈1、燈4和燈5都連接著燈2和燈3。按下在燈1、燈4和燈5上面的開關。 Record1h细节很多…… Analysis请先思考后再展开 高斯消元的做法以后再补吧现在讲讲怎么用折半搜索艹过去 其实其核心思想就是把指数暴力地拆开，低消耗地合并起来得到答案左边从起点过来，而右边则从终点过来，找到一个重叠状态（有时是对应状态，例如这道题是相反数）用其中一边去找另外一边记录下来的答案（小就用数组，大就存下来二分查找） 以这道题为例，随便分成两边，右边记录答案（用数组，存储从终点过来需要多少步）左边暴力后，找右边的相反数答案，相加即可 最后再反思点拨一下：虽然产生的状态是2^35量级的，但其不同状态数量只有2^17个人认为这也是折半搜索的精髓之体现 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
        <tag>难度2</tag>
        <tag>折半搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[佛山2015市选2比赛总结]]></title>
    <url>%2Fposts%2F88c1.html</url>
    <content type="text"><![CDATA[佛山2015市选2比赛总结题目 比赛经历看一遍题目发现是做过的题，但当时没有讲，做了和没做一样然后感觉当时多少分现在可能也差不多了【flag】一年过去sa依然不会，因为这不是noip的范围，然后省选计划还没到哪里……这就是所谓知识盲区吧，虽然知道但也没办法，手头上还有不少任务于是就安心爆零吧…… 评测经历T2的stl怎么fail了?少了40暴力分然后T3居然忘记删除输出调试了，少了20暴力分其实当时也想过要不要检查，但是今天本来就没多少分，不想检查了最后[0/100]+[10/100]+[0/100]+[0/100]=10/400两天差距甚大啊，直接加上了“倒数”两个字，变成了倒数rk2……%xgc今天翻盘遥遥领先 T1_Analysis请先思考后再展开 据说这是一道很套路的sg题目主要就是学会sg有个核心公式（以后补教程）$$sg(i)=mex { sg(i-j)|gcd(i,j)=1 }$$然后这个$gcd(i,i-j)=1$然后取值的话不太好想，但证明其正确性灰常简单如果是质数，sg=质数序数+1如果是合数，sg=sg(最小质因数)+1 然后按照套路（异或）起来就好了 T1_Code_std请先思考后再展开 undefined T2_Analysis请先思考后再展开 sam和sa都不会……hash好像也没什么必要吧反正弃了 T3_Analysis请先思考后再展开 主要思路是，进行了前面的第一轮后，就变成一个子问题找规律神题，细节很多，不想写 T4_Analysis请先思考后再展开 没人会的神题……]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[佛山2015市选1比赛总结]]></title>
    <url>%2Fposts%2F4bc4.html</url>
    <content type="text"><![CDATA[佛山2015市选1比赛总结题目 比赛经历先切了T3、T4，回头发现T1很简单，最后杠T2%akc，100分钟想完所有题然后码完巨大心理压力有木有然后rose和我一起杠T2，没什么想法，只能打个暴力 评测经历wocT4的MLE是什么鬼，一度心态爆炸，明明算过的原来是师兄空间只开了64mb最后[100/100]+[0/98]+[63/99]+[98/98]=261/395最后混了个初三rk2%ch文件名打错，实际比我高20,屈居rk3%lhp做过原题虐场，306全场最高 T1_Analysis请先思考后再展开 对于后面的点，没有人覆盖它，只能自己解决问题的从这些点入手，倒推即可 T1_Code_原请先思考后再展开 undefined T2_Analysis请先思考后再展开 这道题考的时候写了个暴力搜索+hash判重，然后成功炸空间其实这题的正解违背【数据范围自适应】定律：把矩阵的元素加起来…… 其实不是很会证明，但大概可以猜个结论？比如说因为总是偶数个，所以最优解不会有浪费？反正没分 然后一个价值30分的细节：有种情况是，点虽然独立，但没有边和它相连，这种情况的话是不算非法的……很难想到啊 T2_Code_原请先思考后再展开 undefined T2_Code_std请先思考后再展开 undefined T3_Analysis请先思考后再展开 一眼查分约束然后就被一个关键句卡了：“栋栋给的分数都是0到10000的正整数” 真的不知道怎么做了这道题其实题意也很不清晰呀弃了 T3_Code_原请先思考后再展开 undefined T4_Analysis请先思考后再展开 网络流即可记得要拆点！akc和hanks_o都忘记了 T4_Code_原请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【置顶】电脑操作知识备忘]]></title>
    <url>%2Fposts%2F7de4.html</url>
    <content type="text"><![CDATA[电脑操作知识备忘 编译-Wall开启提示 -std=c++11等 -O2一定要大写…… -m3232位程序，配合gdb32 -Wl,–stack=SIZE扩栈 gdb查看调用参数info args 查看局部变量info locals 查看函数栈bt 每步操作都显示变量值display frame xxx配合bt，跳转 linux下对拍while true; do … if diff a.out a.ans; then printf AC else exit 0 fidone]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【训练】算法竞赛进阶指南-1基本数据结构21题]]></title>
    <url>%2Fposts%2F7248.html</url>
    <content type="text"><![CDATA[本处难度分档以个人实力为参照系难度1：半小时内想出，半小时内ac难度2：半小时想不出，看题解，服气难度3：半小时想不出，看题解，ac后依然觉得难度很大 0x10 基本数据结构题目 1 hdu4699 Editor7.3 难度1请先思考后再展开 要特判非法情况，这个是题目没有说明清楚的undefined 2 poj2559 Largest Rectangle in a Histogram7.3 难度2请先思考后再展开 看到提示用单调栈，大概是想通了但发现我只会暴力地确定右端点后，枚举左端点来统计答案 看了发题解，发现大概思路差不多，主要就是统计答案的方法如果从右端点开始考虑，其左端点是不定的但如果稍微换个角度，利用一下单调性，可以发现：对于一个左端点，其最优的右端点只有一个，那就是在其存在时期内最后那个 所谓存在时期，就是它从进入到弹出期间我们可以考虑在它被弹出的时候再统计答案，而这时候，新矩形一定比它小所以从它到【第一个被当前新矩形弹出的矩形】之间，就是当前高度下的最优宽度所以边弹出，边累加宽度并统计答案即可undefined 3 poj2259 hdu1387 Team Queue7.3 难度2请先思考后再展开 偷懒，用了链表然后看题，一是会有0，完全没注意就用了0表示空二是多一个空行，读题时看到，写题时忘记回想起不久前中考时也有这个毛病或许应该写下这种注意点undefined 4 bzoj2457 双端队列7.3 难度3请先思考后再展开 思考难度很大因为 要按照顺序处理数字，而又涉及大小关系，直接线性处理是不可能的考虑把数列排序一波（也可以从数据范围上观察得出）然后记录下标思考能够放在同一个双端队列里，需要满足的特性 结论：在同一个双端队列，对于编号最前的，比它大的要在它后面出现，比它小的也要在后面出现，而且与它的差越大，与它的距离差就应该越大如果用图像来表示，把排序后的数列，排名为x，原坐标为y，则必须是一个单谷图像 所以，大致上的流程就是：排序， 按从小到大处理数列，记录递增或递减趋势，记录有多少个图像但还有个细节：对于排名也就是大小一样的数，它们的原坐标顺序是可以任意排列的为了尽量减少单谷数量，对于大小相同的一段，内部在单调时最优。所以只要记录每一段的最大和最小值，任意变形来贪心地连接起来就好了。undefined 5 1201 最大子序和7.3 难度1请先思考后再展开 这道题初看像是有限制条件的最大子段和，然鹅方法完全不一样首先，因为有长度限制，在枚举右端点的过程中，需要把左端点向右移那么因为和可以表示为sum[i]-sum[j-1],i-j+1&lt;=m因为我们的右端点是固定的，所以只要搞出一个符合条件中最小的sum[j-1]即可 稍微提醒一下，一定要明确是sum[j-1]而不是sum[j]，逻辑差别很大然后就wa了多次……undefined 6 poj3349 Snowflake Snow Snowflakes7.4 难度2请先思考后再展开 这道题是真的毒瘤本来用hash判重，然后丢到set里面结果不是hash被卡wa就是stl被卡tle 总之，不得不用hash表，第一次写这玩意，以前只会理论各种tle，抄了很多书上的代码，改了改类型、模数，才卡了过去undefined 7 1401 兔子与兔子7.4 难度1请先思考后再展开 裸题undefined 8 poj1961 Period7.4 难度1请先思考后再展开 经典题undefined 9 1602 The XOR Largest Pair7.4 难度1请先思考后再展开 居然对了！虽然不是1a，因为有个地方，得到的是int，就re了思路：把所有数转化成二进制，用类似字典树的结构存储对于i，先统计答案，i是其中一个，贪心地找另一个具体来说，贪心地从高位开始，尽量往反方向走，累计答案当然是在不行还是要走正方向统计完后，把这个串加入到字典树中供后人用undefined 10 poj3764 The xor-longest Path7.4 难度2请先思考后再展开 想了一个小时，看到题解前半段的那一刻，难受的一匹原来和上一题是一样的！ x到y路径上xor和=x到根xor和 xor y到根xor和这基于同一个数xor自己，得到0，而0 xor 任何数=任何数 然鹅，自己在思考的时候，却想着还要xor lca(x,y)到根因为感觉那部分只出现了一次，神tm自己想再补上一次……感觉这给我的教训是要多动笔写下来，这样不容易错我才不会说这是因为笔被我整天乱扔，摔断墨了……自作自受吧undefined 11 poj1456 Supermarket7.4 难度3请先思考后再展开 一开始写了个错误的贪心：直接按照过期排序，第二关键字是价值但这样就考虑不了【过期冲突，价值极大】的情况 先明确：如果现在是第t天，则应卖出能卖出的前t大有一个套路，能够给限定数量的局部贪心后悔药：维护一个大小为t的堆，堆顶是最不优秀的元素，尝试替换来修正原方案undefined 12 poj2442 Sequence7.5 难度3请先思考后再展开 1.既然跟大小有关，先把每个序列排好序，确认了最小答案 2.因为直接枚举方案会超时这是因为产生了很多因为过大而无用的状态 这就用到了一个新套路（又被akc轻松想出）把所有最小值组成一个方案，放进堆里面通过堆进行决策的同时，基于堆的最优性进行拓展因为我们已经排好了序，拓展只是某个指针的前移此时复杂度是$O( n^2 \times log(nm) )$濒临超时 3.然鹅，上述方案有个致命的问题两个不同的状态可能拓展出相同的状态感觉强行hash判重也可以，不过没必要 4.有一个不那么好想的方法（或许利用了答案要求的数量和序列长度相同这个特性）先把两个序列合并，把得到的前n个作为一个新的序列然后像同余方程组那样逐个合并。而且，由于每次只处理两个数列，可以用bool判重解决上面的问题 复杂度$O( m \times n \times 2 \times log(n) )$，飞快 undefined 13 CTSC2007 数据备份 &amp; bzoj2151 种树7.5 难度2请先思考后再展开 这道题一年多以前做过，当时并没有blog然后我yy着就和远古时期的我产生了共鸣，回忆起了一个细节：在堆中进行可后悔决策然鹅完全没有思路虽然顺便又把一个关键性质想到了：不会有线路的重叠，故只会和旁边产生关系 如果想到这里，想必大佬们都能快速的想到怎么做然后我还是蒙逼状态，尽管我又把一个关键的图画了出来：四个点之间的连线x-1、x、x+1 是不是觉得我灰常无可救药？都已经把所有前提想到了，还是不会…… 事实上：有一种贪心策略：每次找最短的一条边，然后把它两边的删除但这样其实很容易举出反例，例如4,2,4,100000 怎么办？引入后悔机制，不要急着排除两边相反，在堆种放入一个c[x-1]+c[x+1]-c[x]也就是说，如果我再选择了一次，那么我就是花费两条边，把x-1和x+1建好了当然如果没有再被拿出，意味着没必要 细细思考，不难发现这样能同时满足互斥的两种状态决策总而言之，听起来灰常有道理，只不过不好想到【据说是一种模型，靠积累】 还有一些细节 如果我们放进去的被拿出来，意味着建两条边，那还是要找左右两侧的更远的边，在堆中去除因为要延长伸展，用链表比较方便 去除可以用可删堆，但还要确保编号相同；用set就灰常不方便了，毕竟是结构体；还有种方法是判断其是否和外界数据不同，表示其过时，直接弹出undefined 14 NOI2015 荷马史诗bzoj4198 luogu2168 uoj130 loj21327.5 难度2请先思考后再展开 入门好题，教程：【OI之路】09经典问题-3哈夫曼树 唯一不同的是第二问，要求最大深度最小构造哈夫曼树的时候，我们只是保证了带权路径长度和最小但当我们面对两个相同权值，但是一个下面的最大深度大的和小的这个时候，如果先合并下面的最大深度大的，答案会更大而先合并小的，就能把后面的机会留下了，从而减小了树的最大深度 具体做法很简单，重载堆的比较函数时，把下面的最大深度作为第二关键字，优先小的就好了undefined 0x18 基本数据结构练习题目 15 1801 括号画家7.6 难度1请先思考后再展开 考细节……应自己构造数据undefined 16 poj1964 City Game7.6 难度2请先思考后再展开 骚操作预处理出每个点最大向上高度然后看作是二维的Largest Rectangle in a Histogram……undefined 17 NOI1999 内存分配7.6 难度2请先思考后再展开 打了一大半很多细节问题先放着代码吧复杂度估计$O(n \sqrt n)$（如果块状链表）undefined 18 1806 Matrix7.7 难度2请先思考后再展开 第一次二维hash，所以学了下题目的特性在于a和b固定，所以可以直接预处理出每个矩阵的hash然后排个序，后面的询问就灰常快了undefined 19 1807 Necklace7.7 难度1请先思考后再展开 最小表示法裸题undefined 20 poj2185 Milking Grid7.8 难度2请先思考后再展开 有关kmp与最小覆盖的前置知识，请搜索kmp查看教程 然后一开始猜一手结论，行取max，列同样，居然ac了其实后来我和mocha经过探讨发现，max是不正确的（例如6和9，除非问题改成陶陶的名字），应该取lcm UP 2018.7.11其实lcm也是错误的反例8 2AABBBBAAAAABBAAA 正确的方法应该是强行比较的kmp（hash也行，快一点）代码已更正undefined 21 bzoj2288 生日礼物7.9 难度2请先思考后再展开 有一个灰常关键的步骤：由贪心知，连续的正数、负数一定是同时选取的所以可以直接合并起来考虑 把正数的段计数，我们的任务就是，在花费最少的前提下，把正数减少到m及以下减少的方法有两个，一是选取一个正数，然后把相邻的负数合并起来（因为必须要连续），代价为正数值二是选取一个负数，把相邻的正数合并，这样代价是负数绝对值综上所述，我们可以把所有数的绝对值放到小根堆里面，统计正数的数量，每次弹出直到数量在m以下即可 还有两个细节 三个数合并之后，正负性是没有意义的，我们前面是为了统计tot并确保算法正确性 对于边缘的负数，要予以忽略！undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【训练】算法竞赛进阶指南-2搜索13题]]></title>
    <url>%2Fposts%2F9d2f.html</url>
    <content type="text"><![CDATA[本处难度分档以个人实力为参照系难度1：半小时内想出，半小时内ac难度2：半小时想不出，看题解，服气难度3：半小时想不出，看题解，ac后依然觉得难度很大 0x20 搜索题目 1 2101 可达性统计7.9 难度2请先思考后再展开 一开始以为是统计 siz 的sb题原来是我sb了，因为会有重复，那么只能把每个点能到达的统计下来了而且因为是有向的，必须要按照拓扑序（建反边）来统计用bitset统计，查询1的个数即可 复杂度的话，时间是$O(n^2/32)$，空间是128MBundefined 2 2201 小猫爬山7.10 难度2请先思考后再展开 这道题引发了我对暴搜方式的思考：如果用车来找猫，就有次序性；而反过来，新车选择就会减少，次序也固定undefined 3 poj2676 poj3074 Sudoku7.10 难度2请先思考后再展开 poj2676 0mspoj3074 tle，精Aundefined 4 poj1011 luogu1120 Sticks7.11 难度3请先思考后再展开 去掉次序性的套路：强行限制大小关系，例如我选择了递减 由于值的数量比个数少，可以把值映射一下，方便查找，至于可用性可以直接更改数量然后这个方法包含了一个剪枝——同值不再考虑 书上的一个剪枝一直没有理解，就是当空的时候，检验前面决策具体而言是尝试每一个木棒，任何一个失败都意味着前面决策错误然后我的策略是毫不犹豫地选择最大的本来是一直坚信其优越性的，直到惊觉我的做法，发现决策的错误要在以后的层，多出了很多无用枝undefined 5 poj1190 生日蛋糕7.12 难度2请先思考后再展开 剪枝 最优化剪枝nows&gt;=ans 可行性剪枝Ri&gt;=1+2(m-i)Hi&gt;=1+2(m-i) 最小化可行性剪枝nown+getmin()&gt;n 最大化可行性剪枝nown+getmax()&lt;n 最后一个剪枝特tm难想到首先，如果要剪枝，肯定要把上面部分的东西表示出来N表示去掉$\pi$的体积，S表示去掉$\pi$的表面积 $$N_后=\sum_{i=now}^m R_i^2 H_i$$ $$S_后=2 \times \sum_{i=now}^m R_i H_i$$ 所谓剪枝，可以考虑不等式【据说接下来的是高中数学灰常恶心的东西：不等式的缩放】 加入元$R_{now-1}$（很难想）$$S_后=\frac{2}{R_{now-1}}\times\sum_{i=now}^m R_i H_i R_{now-1}$$ 把右边部分缩放一下由于$R_{now-1} &gt; R_i$ $$S_后 \frac{2}{R_{now-1}}\times\sum_{i=now}^m R_i^2 H_i$$ 联系一下体积$$S_后&gt; \frac{2}{R_{now-1}} \times N_剩$$ 因为前面几个剪枝，只有一个是关于【有关答案的表面积】的那么可以说$S_后$一定比某个值大可以最优化剪枝一波，条件：$$S_现+\frac{2}{R_{now-1}} \times N_剩&gt;=ans$$ 最后就是碰到搜索要无脑倒序循环undefined 6 poj2248 Addition Chains7.12 难度1请先思考后再展开 迭代加深这个东西第一次看到感觉它虽然比bfs慢一些，但其优势在于便于还原状态、不用大量空间来存储状态undefined 7 2401 送礼物7.13 难度2请先思考后再展开 其实通常面对一个决策与顺序无关，而且不卡log的题目，排序一下都不亏其实看不出这个正解和折半搜索有什么关系但是灰常鬼畜啊hh主要思路来自【指数级爆搜】把问题分成两边（已排序），搜索左右两边，然后通过枚举左边的结果，二分查找右边的这样子复杂度就被硬生生变成了$O(2^{n/2} log_2 2^{n/2})$ 折半搜索还有道体现得更明显的题目：灯然后我们通过折半，把取值的数量从2^45变成最坏2^22，其实还不少，所以要剪枝 可恶啊卡我的set……undefined 8 2601 电路维修7.14 难度2请先思考后再展开 最巧妙的地方：把决策转化为边，边权为代价于是就变成了最短路问题 spfa一直tle……试一试书上的新做法，以为多特别所以没有打p[x].v=0，一直waundefined 9 poj3635 Full Tank?7.17 难度1请先思考后再展开 本来以为可以dfs去记忆化然鹅这样是错的，因为不能保证第一次就是最优解……话说bfs的复杂度其实灰常悬，可能数据水？undefined 10 poj2449 Remmarguts’ Date7.17 难度2请先思考后再展开 key：第k次出堆，得到第k小的解akc眼中的模版题 不过最后奇奇怪怪mle先放着吧undefined 11 poj3460 Booksort7.17 难度3请先思考后再展开 A=堆+bfs+估价IDA=迭代dfs+估价 最难的就是怎么估价了目标是有序，但我们不能用【逆序对数量】，因为每次消除量是不确定的观察题目性质，每次操作都是对连续的一段进行的再有序的情况下，每个数都有一个正确的后继而每次操作最多消除3个错误后继数不过要向上取整 顺便再介绍一下折半搜索怎么做：先考虑每次决策的分支量如果选a本，有n-a+1种，可以插n-a处同时对于前移，必定有一种后移方案与其等效，所以只后移分支数$ \sum_{a=1}^{n-1} (n-a+1) \times (n-a) /2 = 560 $普通dfs是4次方，折半一下，就变成了平方级别可以用hash+map存储结果，第二次的时候对应找到，然后累计即可总而言之复杂度$O(560^2 log_2 560^2)$ wa了一次，忘记判断完美情况了undefined 0x29 搜索练习题目 12 poj3700 Missile Defence System7.18 难度2请先思考后再展开 先给出一份比较显然的做法，一组组找尽力加上了两个剪枝： 仅当没东西选的时候再结束 当前能被now到nx中间的覆盖时，延迟搜索undefined 然鹅这样依然会tle原因大概是叉太多了?其实想到这么多剪枝，但方向大概都是错误的 正解是考虑元素，分配组（这大概也是一个套路）这样的话只要贪心地找最不优秀但符合条件的即可顺利变成二叉，然后迭代加深也没意义了，最优性剪枝即可代码就不写了 13 poj1945 Power Hungry Cows7.18 难度2请先思考后再展开 网上到处都是打表和玄学（其实错误）剪枝来一股IDA*清流吧因为感性地感觉次数不会太多，迭代一下重点是这个估价函数不难猜出最优解一定先倍增上去再微调的那么如果只考虑倍增，实现容易又能满足$f(s) \leq g(s)$的定义 不过有一个应该是正确的剪枝，不太会证明如果P的约数中没有【x和y的最大公约数】，则返回大概原因是，无论怎么操作，得到的数一定是包含这个【x和y的最大公约数】吧想想，好像无论加减都是如此。这个还是挺妙的 官方数据：19997 1815151 1711111 1710007 165123 145111 151234 131024 101023 111010 1231 6然后在这些数据中，没有卡掉一种错误做法：假设较小值不会超过50反例：18673，答案应该是17然后打表发现其实是6160？听别人说的 顺便吐槽一句lyd的代码是打特判过的，根本错误的做法 反正我是没卡过去所有数据都是正确的 IDA*undefined A*，稍微快一点点undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Arc100-D】Equal_Cut]]></title>
    <url>%2Fposts%2F6a1c.html</url>
    <content type="text"><![CDATA[Source and JudgeArc100-D Problem【Description】给出一个长度为n的数列，要求分成4段非空数列每段数列的和，其中【最大-最小】最小为多少？【Input】第一行为n第二行n个数，表示数列【Output】输出最小差【Limited conditions】4&lt;=n&lt;=2000001&lt;=a[i]&lt;=10^9【Sample input 1】53 2 4 1 2【Sample output 1】2【Sample input 2】1010 71 84 33 6 47 23 25 52 64【Sample output 2】36【Sample input 3】71 2 3 1000000000 4 5 6【Sample output 3】999999994【Sample explanation】无 Record1h Analysis请先思考后再展开 被rose操烂……这是一个贪心，而且感觉上很不科学，但是却又可以证明 假如我们枚举断点1，后面的两个端点会灰常麻烦，所以走到了死胡同然后rose用他的做法ac了……逻辑上讲，不妨换个切入点，考虑枚举中间的断点2先只考虑左边①最大值在左边 那么缩短A和B的差，会更优②最小值在左边 同上③A和B都不是最大值或最小值，那么缩短A和B的差，不会让答案更差上述情况都不是绝对的，可能移动时变成了另外一种情况但做法都是相同的，就是在平均值旁边“摇摆” 那具体怎么实现？如果直接二分查找也没问题，不过因为断点1和断点3都是递增的，所以可以“暴力”地移动却能达到O(n)的复杂度 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【训练】算法竞赛进阶指南-0基本算法23题]]></title>
    <url>%2Fposts%2Fcfc5.html</url>
    <content type="text"><![CDATA[本处难度分档以个人实力为参照系难度1：半小时内想出，半小时内ac难度2：半小时想不出，看题解，服气难度3：半小时想不出，看题解，ac后依然觉得难度很大 0x00 基本算法题目 1 0103 最短Hamilton路径6.27 难度1请先思考后再展开 没难度，虽然一开始灰常尴尬地没注意到终点必须是n-1undefined 2 费解的开关6.28 难度2请先思考后再展开 关键性质：如果从某个格子的状态考虑，它的状态取决于它被覆盖了多少次的奇偶性1而与次序无关！所以说先点还是后点没有意义，只需要知道要点哪里就是了；同理，重复点也是没有用的。 那么第一行的点击方式就确定下来了，接下来一行行消除然后为了把第一行的1消除，只能按第二行的对应点，以此类推undefined 3 [HNOI2003]激光炸弹6.28 难度1见这里激光炸弹 poj3263 Tallest Cow6.28 难度2请先思考后再展开 开始想着查分约束，但是很慢而且没法确保最高点定值，建图也很麻烦实在没有思路看了发题解感觉这种贪心的方式很恶心，而且题意实在太不清晰了（理解分析能力？） 其实就是，假设所有人都是最高点然后因为相互看到必须中间都小于，所以不会交叉（括号序列）所以可以统计被覆盖次数，由于小于的传递性，这个削弱次数直接取-1然后必须要去重，否则无意义削弱undefined 4 poj1845 Sumdiv6.28 难度2以前的原题这里 5 poj3889 Fractal Streets6.28 难度2请先思考后再展开 看到这个分形图就有点慌主要难点就是怎么把编号换成坐标，而且这个编号还是连续的然后随便写了几个，找不到规律膜了膜题解 其实，正是因为这是分形，可以递归求解这个旋转，其实是可以对坐标操作一下的，具体自己推+找规律然后其实它总是从左上到右上到右下到左下的所以可以直接按照编号的大小确定属于哪个区域undefined 6 poj2018 Best Cow Fences6.28 难度2请先思考后再展开 首先用二分，判定是否有满足条件的一段，平均值&gt;=mid然后最精妙的地方就是所有数-mid这样就从【与长度有关的平均值】变成了【与长度无关的和】直观点就是，如今$$sum=s[i]-s[j],0 \le j \le i-L$$如果sum&gt;=0，那么就满足条件 显然在s[j]最小时最优，二每新计算一个i，都带来一个新的j所以记录前面的最小值就好了 至于卡精度这种事……精A罢undefined 7 cf670-C Cinema6.28 难度1请先思考后再展开 离散化裸题居然是c题undefined 8 bzoj3032 七夕祭6.28 难度1请先思考后再展开 中位数这个东西前面已经讲过了，具体请搜索“中位数”典型特征就是能左能右或者类似的相反方向 把所有a-=平均数，这个操作还是掌握了点的看起来a[1]直接=0，其实这是因为总体和=0，没有直接用，这个问题和akc研究了挺久 然后由于等差数列，可能爆intundefined 9 poj3784 Running Median6.29 难度1请先思考后再展开 原来，1.5亿是能跑的……这个对顶堆的做法也是蛮有意思的，稍微比树状数组少log，比splay少常数undefined 第k大数这方法挺有意思的应该就是eth_element的原理吧就是无序数列中，O(2n)找其实就是n+n/2+n/4+…….1&lt;=2n原理就是类似二分排序，但是没必要两边都进入，而是只进入其中一边蛮好理解的 10 poj2299 Ultra-QuickSort6.29 难度2请先思考后再展开 原来相邻比较和交换就是冒泡排序呀那么每次交换的时候，都消除了一个逆序对答案就是其个数了练习一下归并undefined 11 hihocoder 1384 Genius ACM6.29 难度3请先思考后再展开 类似于满足二分性，不过用倍增会更快，特别是当k小的时候然后直接暴力地排序会tle，可以用归并来合并a数组=原本值b数组=排好序值c数组=合并后，用于尝试，成功则copy回b数组undefined 12 poj3614 Sunscreen6.29 难度2请先思考后再展开 不愧是我最虚的贪心 把牛用mx[x]递增排序，每次选最小的 归纳法证明：对于a=sp[t1]，b=sp[t2]已知mi[x]&lt;=a&lt;b&lt;=mx[x]&lt;=mx[y]则对于y，可能【ab可】、【a不可b可】、【ab不可】任何一种，选a 不会更差 同理，把mi[x]递减排序，每次选最大的也行undefined 13 poj3190 Stall Reservations6.29 难度2请先思考后再展开 先按照开始时间把牛排序然后如果以房间为导向，二分查找可行牛，就要解决删除的问题，然后就懵了（其实这个也是错的） 如果以牛为导向去安排，随便放进一个能放的房间就行了证明：假如有两个房间a和b，ed[a]&lt;ed[b]由于后面的开始时间会更后，所以选择a，不会更优 不过这样是平方级别的既然是随便就好，搞个小根堆，这样选择的开销就很小了 回顾一下，关键还是以开始时间排序这个操作，并且要按照这个来安排而不是作为有序数列来二分查找undefined 14 poj1328 Radar Installation6.30 难度2请先思考后再展开 计算出能覆盖每个岛的圆的圆点区间，用最少的点覆盖每个区间把区间按照左端点排序，然后如果无重叠，重新开始，否则可以把覆盖点“挪”到重叠区域 不过思考的时候漏了一种情况：就是重叠的话可能是包含关系 对于那些重叠但是不包含的，可能在后面还会和别人重叠但同样是因为贡献只有1，所以选择前面 不会更差undefined 15 国王游戏6.30 难度2原题 16 poj2054 Color a Tree6.30 难度3请先思考后再展开 先给出一个贪心：每次在能染色的点中找最大的然鹅这是错误的，举个简单的反例：在一个极小节点下有一个极大节点 反思一下，这是因为【必须先染父亲才能染儿子】这个条件但是我们依然可以推出一个结论：【对于非根的最大点，必定在父亲染完后立刻染色】所以说，其实可以把那两个节点看作一个节点不过这个节点的权值是多少才能不影响接下来的判断呢？ 结论2：【合并后的节点，权值为其平均值】证明：网上的证明普遍不堪入目，书上的也半斤八两后来终于在poj的远古评论里看到，简单得令人感动 设有权值a节点和b1~bn的合并节点如果a在前，优势是na如果a在后，优势是b1~bn的和那么按照结论一的步骤，我们每次都要比较权值大小则比较：【公共部分+na】与【公共部分+b1~bn的和】由于我们不能把所有的a改成na，考虑算出一个通用的权值则比较：【a】与【b1~bn的和/n】也就是平均数了另外，如果感性地理解，其实就是把【晚一点染色的影响】均摊了 总之，合并后，它和一个普通的点是没有区别的，可以继续合并合并时，还要用指针存储顺序，最后按照决策计算答案即可 然后有一点是忘记了：最大点不一定是叶子节点（脑海中喜欢这样想，人性的懒惰？）所以要把fa改掉 然后我不会nlogn怎么写……可删堆怕是用不了的undefined 0x08「基本算法」练习题目 17 poj2965 The Pilots Brothers’ refrigerator7.1 难度24乘4的矩阵，每个格子一个开关，+关-开每次操作改变第i行和第j列求所有开的最小操作数，并输出具体操作请先思考后再展开 又忘记这类问题的顺序无关性了……不过复杂度上bfs是可以的undefined 18 poj3714 Raid7.2 难度2请先思考后再展开 kd-tree裸题好久没打了，练练手，果然炸……undefined 19 bzoj1271 luogu4403 秦腾与教学评估7.2 难度2请先思考后再展开 真的没想到这个【具体位置个数】居然可以转化为【点个数前缀和的奇偶性】上来所以就可以二分了 然后就是在bzoj和luogu上的官方数据，疑似总人数爆int，没有满足题意undefined 20 poj3179 Corral the Cows7.2 难度2请先思考后再展开 同样是无法存储的大坐标这一次的操作是离散化，因为没想到这个，就把前缀和否定掉了……然后就是常规的但其实我不熟练的双点法，虽然昨晚打比赛还用过咧undefined 21 poj1723 SOLDIERS7.2 难度2请先思考后再展开 一道很好地融合了贪心的题目至少好过七夕祭这种强行二维题 y直接中位数是没有问题的了主要是有个贪心没有想到：为了解决起点不确定问题，直接设一个起点然后把原数组贪心后a[i]对应st+i-1，并且是一一对应否则造成没有意义的花费这样达到最优解undefined 22 poj1050 To the Max7.2 难度2请先思考后再展开 裸题，枚举l、r，就能顺利转化了（又是想不到）可能因为是远古题吧而且如今这个数据规模暴力是很快过去的，没常数嘛，改成n=300就好很多undefined 23 hdu4864 Task7.2 难度2请先思考后再展开 兼顾策略和实现的贪心好题 观察题目，发现重要性质 价值中，时间的优先级绝对大于等级 价值只和任务有关，和具体机器无关 结论 优先考虑时间 应该用任务去找机器 具体而言 把任务和机器按照时间从小到大排序，从大到小枚举任务（经典套路之尽量从小范围开始） 对于每个任务，可以确定一个区间满足时间的条件,区间左端点单调递减 由于性质2，这样我们就顺利地 消除了时间、等级对决策的直接影响 由于比现在耗时更大的任务已经解决，则选择时间最大的机器 不会使结果更差 至于机器的等级，直接使用满足条件但等级最小的，反正和价值无关，减少浪费 找的时候，两种方法，一是维护一个set这样不用打splay，二是统计某个等级的出现数量，因为等级比较少（之所以能这样又是用了性质2） 综上所述，时间复杂度约O(nlogn)对于结论2，可以再补充一个理由：如果用机器找任务，就不能消除时间对决策的直接影响就是说，当我们确定一个区间时，有两个参考量，毕竟会影响价值而我们现在就只用考虑等级，所以才能直接决定undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[激光炸弹]]></title>
    <url>%2Fposts%2F2726.html</url>
    <content type="text"><![CDATA[Source and JudgeHNOI2003Bzoj1218Luogu2280 Problem【Description】一种新型的激光炸弹，可以摧毁一个边长为R的正方形内的所有的目标。现在地图上有n个目标，用整数Xi,Yi( 其值在[0,5000] )表示目标在地图上的位置，每个目标都有一个价值。激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆破范围，即那个边长为R的正方形的边必须和x，y轴平行。若目标位于爆破正方形的边上，该目标将不会被摧毁。【Input】输入文件的第一行为正整数n和正整数R，接下来的n行每行有3个正整数，分别表示xi,yi,vi【Output】输出文件仅有一个正整数，表示一颗炸弹最多能炸掉地图上总价值为多少的目标。【Limited conditions】N&lt;=10000结果不会超过32767【Sample input】2 10 0 11 1 1【Sample output】1【Sample explanation】无 Record30min Analysis请先思考后再展开 脑残题二维前缀和早知道不单独一篇文章了…… Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP17 D1T3】逛公园]]></title>
    <url>%2Fposts%2Ff27c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2017 提高组 D1T3Loj2316Luogu3953 Problem【Description】策策同学特别喜欢逛公园。公园可以看成一张 N 个点 M 条边构成的有向图，且没有 自环和重边。其中1号点是公园的入口， N 号点是公园的出口，每条边有一个非负权值， 代表策策经过这条边所要花的时间。策策每天都会去逛公园，他总是从1号点进去，从 N 号点出来。策策喜欢新鲜的事物，它不希望有两天逛公园的路线完全一样，同时策策还是一个 特别热爱学习的好孩子，它不希望每天在逛公园这件事上花费太多的时间。如果 1号点 到 N 号点的最短路长为 d ，那么策策只会喜欢长度不超过 d+K 的路线。策策同学想知道总共有多少条满足条件的路线，你能帮帮它吗？为避免输出过大，答案对 P 取模。如果有无穷多条合法的路线，请输出 −1 。【Input】第一行包含一个整数 T , 代表数据组数。接下来 TTT 组数据，对于每组数据： 第一行包含四个整数 N,M,K,P ，每两个整数之间用一个空格隔开。接下来 MMM 行，每行三个整数 ai,bi,ci ，代表编号为 ai,bi​ 的点之间有一条权值为 ci​ 的有向边，每两个整数之间用一个空格隔开。【Output】输出文件包含 T 行，每行一个整数代表答案。【Limited conditions】T&lt;=5,n&lt;=10^5,m&lt;=2*10^5,k&lt;=50有0边1≤P≤10^9,1≤ai​,bi​≤N,0≤ci​≤1000 。数据保证：至少存在一条合法的路线。【Sample input】25 7 2 101 2 12 4 04 5 22 3 23 4 13 5 21 5 32 2 0 101 2 02 1 0【Sample output】3-1【Sample explanation】最短路为 3 。 1 – 5, 1 – 2 – 4 – 5, 1 – 2 – 3 – 5 为 3 条合法路径。 Record1h Analysis请先思考后再展开 通常计数问题可以考虑dp 在本题中，最难的地方在于考虑路径的长度是一个区间，而不是仅仅最短路；我们可以把K看作一个配额，然后我们在路径上进行分配设(x,a)是在x点，使用了a的配额后的路径计数然后显然(y,b)=能到达的(x,a)的和因为配额是单调递增的，所以把配额看作类似时间的东西，按照它来分层那么大致上，dp的转移是定向的 但到底怎么转移呢？由于做题太少，并没有思路请教队长后get到了新姿势：把转移建成边，拓扑dp至于环的存在，由于大致是单向的，所以跨层不会有环如果出现了环，必定在同一层，也就是0环，按照题意输出-1即可不过要确保这个0环是对最短路有影响的，所以跑一遍反图 这样搞一搞后，luogu时间还是差一点的，但保底70为什么呢？反思一下复杂度是nk的，应该完全没有问题====如果非要对此尝试提升（如果考场上显然没有这一步）考虑在转移的时候就进行一下可行性剪枝，直接去除无效转移边这样就达到了灰常优秀的时间了（这属于常数优化吧） Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>拓扑</tag>
        <tag>分层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP17 D1T2】时间复杂度]]></title>
    <url>%2Fposts%2F25a7.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2017 提高组 D1T2Loj2364Luogu3952 Problem【Description】小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。A++语言的循环结构如下：F i x y 循环体E其中F i x y表示新建变量 i （变量 i 不可与未被销毁的变量重名）并初始化为 x ， 然后判断 i 和 y 的大小关系，若 i 小于等于 y 则进入循环，否则不进入。每次循环结束后 iii 都会被修改成 i+1 ，一旦 i 大于 y 终止循环。x 和 y 可以是正整数（ x 和 y 的大小关系不定）或变量 n 。 n 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100。“E”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“O”表示通常意义下“Θ”的概念。【Input】输入文件第一行一个正整数 t ，表示有 t （ t≤10 ）个程序需要计算时间复杂度。 每个程序我们只需抽取其中 F i x y和E即可计算时间复杂度。注意：循环结构允许嵌套。接下来每个程序的第一行包含一个正整数 L 和一个字符串， L 代表程序行数，字符 串表示这个程序的复杂度，O(1)表示常数复杂度，O(n^w)表示复杂度为 n^w ，其中w是一个小于100的正整数（输入中不包含引号），输入保证复杂度只有O(1)和O(n^w) 两种类型。接下来 L 行代表程序中循环结构中的F i x y或者 E。 程序行若以F开头，表示进入一个循环，之后有空格分离的三个字符（串）i x y， 其中 i 是一个小写字母（保证不为 n ），表示新建的变量名， x 和 y 可能是正整数或 n ，已知若为正整数则一定小于 100。程序行若以E开头，则表示循环体结束。【Output】输出文件共 t 行，对应输入的 t 个程序，每行输出Yes或No或者ERR（输出中不包含引号），若程序实际复杂度与输入给出的复杂度一致则输出Yes，不一致则输出No，若程序有语法错误，则输出ERR（其中语法错误只有:① F 和 E 不匹配②新建的变量与已经存在但未被销毁的变量重复两种情况） 。注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 ERR。【Limited conditions】1≤a,b≤1,000,000,000输入数据保证存在小凯无法准确支付的商品。【Sample input】82 O(1)F i 1 1E2 O(n^1)F x 1 nE1 O(1)F x 1 n4 O(n^2)F x 5 nF y 10 nEE4 O(n^2)F x 9 nEF y 2 nE4 O(n^1)F x 9 nF y n 4EE4 O(1)F y n 4F x 9 nEE4 O(n^2)F x 1 nF x 1 10EE【Sample output】YesYesERRYesNoYesYesERR【Sample explanation】无 Record1h Analysis请先思考后再展开 大模拟，不解释考场上没有出数据，过了大数据就信仰杠T1去了结果蜜汁ac感受一下…… 印象中，当时有个小bug就是ce了不能直接break，因为还要输入，调试了好一会儿还有就是，代码中有个地方写错了，但误打误撞没事…… Code1这是比赛代码，留作纪念请先思考后再展开 undefined Code2加上大量注释请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP17 D1T1】小凯的疑惑]]></title>
    <url>%2Fposts%2F34ee.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2017 提高组 D1T1Loj2363Luogu3951 Problem【Description】小凯手中有两种面值的金币，两种面值均为正整数且彼此互素。每种金币小凯都有无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小凯想知道在无法准确支付的物品中，最贵的价值是多少金币？【Input】输入数据仅一行，包含两个正整数 a 和 b，它们之间用一个空格隔开，表示小凯手中金币的面值。【Output】输出文件仅一行，一个正整数 N ，表示不找零的情况下，小凯用手中的金币不能准确支付的最贵的物品的价值。【Limited conditions】1≤a,b≤1,000,000,000输入数据保证存在小凯无法准确支付的商品。【Sample input】3 7【Sample output】11【Sample explanation】无 Record2h Analysis请先思考后再展开 此题为检验人心态的极好题目，值得推荐然后我就挂了…… 题目条件：$a&gt;0,b&gt;0,gcd(a,b)=1$然后求最大的$ax+by \neq K$ 很容易去想exgcd的做法既然互质，exgcd总是有解的，问题只是在于是否满足$x \geq 0,y \geq 0$那么我们求出x的最小正整数解，试图让y最大，这样就能够验证答案了 题外话：比赛时，通过打表，我发现最大是a+b（要是向别人一样直接发现规律就没有这篇文章了）【然后通过这个让我避免的草哥的遭遇，结果又沉迷卡常去了】 然后？我们似乎陷入了一个狭隘区——验证答案考虑寻找答案？ 首先，条件是不变的（正负性），思想也是不变的（x表示最小非负数解）那么对于$ax+by=K$,作为合法答案，要求$0 \leq x \leq b-1,y&lt;0$注意：这个时候K是我们要求的答案，所以x和y之间的关系变得没有影响则y=-1,x=b-1，得到合法最大值$K=a(b-1)+b(-1)=a \times b -a-b$ Code请先思考后再展开 略]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP16 D2T3】愤怒的小鸟]]></title>
    <url>%2Fposts%2Ff5e.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2016 提高组 D2T3Loj2363Uoj265Luogu2831Caioj1580 Problem【Description】Kiana最近沉迷于一款神奇的游戏无法自拔。简单来说，这款游戏是在一个平面上进行的。有一架弹弓位于(0,0)处，每次Kiana可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如y=ax^2+bx的曲线，其中a, b是Kiana指定的参数，且必须满足a&lt;0。当小鸟落回地面（即x轴）时，它就会瞬间消失。在游戏的某个关卡里，平面的第一象限中有n只绿色的小猪，其中第i只小猪所在的坐标为(xi, yi)。如果某只小鸟的飞行轨迹经过了(xi, yi)，那么第i只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行；如果一只小鸟的飞行轨迹没有经过(xi, yi)，那么这只小鸟飞行的全过程就不会对第i只小猪产生任何影响。例如，若两只小猪分别位于(1,3)和(3,3)，Kiana可以选择发射一只飞行轨迹为 y = -x^2 + 4x的小鸟，这样两只小猪就会被这只小鸟一起消灭。而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。这款神奇游戏的每个关卡对Kiana来说都很难，所以Kiana还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在【输入格式】中详述。假设这款游戏一共有T个关卡，现在Kiana想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。【Input】第一行包含一个正整数T，表示游戏的关卡总数。下面依次输入这T个关卡的信息。每个关卡第一行包含两个非负整数n,m，分别 表示该关卡中的小猪数量和Kiana输入的神秘指令类型。接下来的n行中，第i行包含 两个正实数xi, yi，表示第i只小猪坐标为(xi, yi)。数据保证同一个关卡中不存在两只坐标完全相同的小猪。如果m = 0，表示Kiana输入了一个没有任何作用的指令。如果m = 1，则这个关卡将会满足：至多用⌈n/3 + 1⌉只小鸟即可消灭所有小猪。如果m = 2，则这个关卡将会满足：一定存在一种最优解，其中有一只小鸟消灭了至少⌊n/3⌋只小猪。【Output】对每个关卡依次输出一行答案。输出的每一行包含一个正整数，表示相应的关卡中，消灭所有小猪最少需要的小鸟数量。【Limited conditions】保证1&lt;=n&lt;=18，0&lt;=m&lt;=2，0&lt;xi, yi&lt;10，输入中的实数均保留到小数点后两位。【Sample input】75 00.01 0.190.02 0.380.03 0.570.04 0.760.05 0.952 01.00 3.003.00 3.005 21.00 5.002.00 8.003.00 9.004.00 8.005.00 5.002 01.41 2.001.73 3.003 01.11 1.412.34 1.792.98 1.495 02.72 2.722.72 3.143.14 2.723.14 3.145.00 5.0010 07.16 6.282.02 0.388.33 7.787.68 2.097.46 7.865.77 7.448.24 6.724.42 5.115.42 7.798.15 4.99【Sample output】5112236【Sample explanation】无 Record2h卡精度 Analysis请先思考后再展开 前置知识： 中考常规操作之给出两个点，解二次函数y=ax^2+bx 卡精度的eps 然后，这么小的n，又是在noip的环境中，基本就是状压考虑状态压缩dp，然后对于一个s，如果从前往后递推，是可以线性的，因为满足最优子结构，然后前面的已经更新好了 然后一开始傻傻地觉得枚举a和b是灰常多的其实只要枚举两个点，解出一个二次函数就好然后只要预处理出cc，表示枚举两个点，能搞掉的点的集合复杂度就达到了O(2^n×n^2)然后因为多组数据，复杂度炸了 考虑优化掉一个n的方法（其实可以看作一个log般的存在）有一个灰常不显然的特性（很多时候正解都是这样）：因为所有点都在第一象限，对于需要经过的点中【横坐标最左边的】的那个，迟早要被枚举到或者覆盖到的那么与其等着去被覆盖，不如首先枚举那么在dp中，枚举i和j，变成了i确定枚举j这样就达到了无比优秀的O(2^n×n) Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP16 D2T2】蚯蚓]]></title>
    <url>%2Fposts%2F867.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2016 提高组 D2T2Loj2362Uoj264Bzoj4721Luogu2827Caioj1579 Problem【Description】蛐蛐国里现在共有n只蚯蚓（n为正整数）。每只蚯蚓拥有长度，我们设第i只蚯蚓的长度为ai(i=1, 2, …, n)，并保证所有的长度都是非负整数（即：可能存在长度为0的蚯蚓）。每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数p （是满足0&lt;p&lt;1的有理数）决定，设这只蚯蚓长度为x，神刀手会将其切成两只长度分别为⌊px⌋和x - ⌊px⌋的蚯蚓。特殊地，如果这两个数的其中一个等于0，则这个长度为0的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加q （是一个非负整常数）。蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要m秒才能到来…… （m为非负整数）蛐蛐国王希望知道这m秒内的战况。具体来说，他希望知道：1. m秒内，每一秒被切断的蚯蚓被切断前的长度（有m个数）2. m秒后，所有蚯蚓的长度（有n + m个数）。【Input】第一行包含六个整数n,m,q,u,v,t，其中：n,m,q的意义见【问题描述】；u,v,t均为正整数；你需要自己计算p = u/v (保证0&lt;u&lt;v) t是输出参数，其含义将会在 【输出格式】中解释。第二行包含n个非负整数，为a1, a2, …, an，即初始时n只蚯蚓的长度。同一行中相邻的两个数之间，恰好用一个空格隔开。【Output】第一行输出⌊m/t⌋个整数，按时间顺序，依次输出第t秒，第2t秒，第3t秒……被切断蚯蚓（在被切断前）的长度。第二行输出⌊(n+m)/t⌋个整数，输出m秒后蚯蚓的长度；需要按从大到小的顺序依次输出排名第t，第2t，第3t……的长度。同一行中相邻的两个数之间，恰好用一个空格隔开。即使某一行没有任何数需要输出，你也应输出一个空行。【Limited conditions】1&lt;=n&lt;=10^5，0 &lt;= m &lt;= 7 x 10^6， 0 &lt; u &lt; v &lt;= 10^90 &lt;= q &lt;= 200， 1 &lt;= t &lt;= 71， 0 &lt;= ai &lt;= 10^8。【Sample input 1】3 7 1 1 3 13 3 2【Sample output 1】3 4 4 4 5 5 66 6 6 5 5 4 4 3 2 2【Sample input 2】3 7 1 1 3 23 3 2【Sample output 2】4 4 56 5 4 3 2【Sample input 3】3 7 1 1 3 93 3 2【Sample output 3】//空行2【Sample explanation】在神刀手到来前：3只蚯蚓的长度为3,3,2。1秒后：一只长度为3的蚯蚓被切成了两只长度分别为1和2的蚯蚓，其余蚯蚓的长度增加了1。最终4只蚯蚓的长度分别为(1,2),4,3。括号表示这个位置刚刚有一只蚯蚓被切断2秒后：一只长度为4的蚯蚓被切成了1和3。5只蚯蚓的长度分别为：2,3,(1,3),4。3秒后：一只长度为4的蚯蚓被切断。6只蚯蚓的长度分别为：3,4,2,4,(1,3)。4秒后：一只长度为4的蚯蚓被切断。7只蚯蚓的长度分别为：4,(1,3),3,5,2,4。5秒后：一只长度为5的蚯蚓被切断。8只蚯蚓的长度分别为：5,2,4,4,(1,4),3,5。6秒后：一只长度为5的蚯蚓被切断。9只蚯蚓的长度分别为：（1,4),3,5,5,2,5,4,6。7秒后：一只长度为6的蚯蚓被切断。10只蚯蚓的长度分别为：2,5,4,6,6,3,6,5,(2,4)。所以，7秒内被切断的蚯蚓的长度依次为3,4,4,4,5,5,6。7秒后，所有蚯蚓长度从大到小排序为6,6,6,5,5,4,4,3,2,2 Record3h Analysis请先思考后再展开 首先，一个显而易见的做法：当q=0，搞一个堆，那么每次取最大的出来，切开，然后把另外两端塞回去那这个q怎么处理呢？考虑一个全局常量add，然后就是堆里面所有元素都要加上这个常量，放东西进去的时候，放入的是d-add即可 然鹅这样是mlogm的，只有70分一开始没有抄数据范围，还以为是灰常优秀的做法……其实只是最暴力的 怎么优化呢？这个log有点烦 有没有什么题目的特性被忽略了？割点比值的固定！然后因为每次拿出来的蚯蚓，长度不递增所以切完后，左右两边同类比较的话，也是不递增的，满足单调性所以我们可以直接利用这个单调性，把堆用三个队列代替 具体来说：main队列，left队列，right队列，都满足不递增性质然后每次取得时候，取三个中的最大值即可 coding中煞笔错误： 开头的队列要有序 结束的队列，不能用sort，否则复杂度还是一样的，而是继续利用单调性 被卡了好多次…… 卡精度，题目中的p不要立刻算出来，而是用到再计算 卡最小值，应该设为负无穷，我通常是用其一半的，然后就被卡了…… Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>单调队列</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP16 D2T2】换教室]]></title>
    <url>%2Fposts%2F8e5c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2016 提高组 D2T2Loj2360Uoj262Bzoj4720Luogu1850Caioj1577 Problem【Description】对于刚上大学的牛牛来说，他面临的第一个问题是如何根据实际情况申请合适的课程。在可以选择的课程中，有2n节课程安排在n个时间段上。在第i (1 &lt;= i &lt;= n)个时间段上，两节内容相同的课程同时在不同的地点进行，其中，牛牛预先被安排在教室ci上课，而另一节课程在教室di进行。在不提交任何申请的情况下，学生们需要按时间段的顺序依次完成所有的n节安排好的课程。如果学生想更换第i节课程的教室，则需要提出申请。若申请通过，学生就可以在第i个时间段去教室di上课，否则仍然在教室ci上课。由于更换教室的需求太多，申请不一定能获得通过。通过计算，牛牛发现申请更换第i节课程的教室时，申请被通过的概率是一个已知的实数ki，并且对于不同课程的申请，被通过的概率是互相独立的。学校规定，所有的申请只能在学期开始前一次性提交，并且每个人只能选择至多m节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室，而不能根据某些课程的申请结果来决定其他课程是否申请；牛牛可以申请自己最希望更换教室的m门课程，也可以 不用完 这m个申请的机会，甚至可以一门课程都不申请。因为不同的课程可能会被安排在不同的教室进行，所以牛牛需要利用课间时间从一间教室赶到另一间教室。牛牛所在的大学有v个教室，有e条道路。每条道路连接两间教室，并且是可以 双向通行 的。由于道路的长度和拥堵程度不同，通过不同的道路耗费的体力可能会有所不同。当第i (1&lt;= i &lt;= n-1)节课结束后，牛牛就会从这节课的教室出发，选择一条耗费体力最少的 路径 前往下一节课的教室。现在牛牛想知道，申请哪几门课程可以使他因在教室间移动耗费的体力值的总和的 期望值 最小，请你帮他求出这个最小值。【Input】第一行四个整数n, m, v, e。n表示这个学期内的时间段的数量；m表示牛牛最多可以申请更换多少节课程的教室；v表示牛牛学校里教室的数量；e表示牛牛的学校里道路的数量。第二行n个正整数，第i (1&lt;=i&lt;=n)个正整数表示ci，即第i个时间段牛牛被安排上课的教室；第三行n个正整数，第i (1&lt;=i&lt;=n)个正整数表示di，即第i个时间段另一间上同样课程的教室；第四行n个实数，第i (1&lt;=i&lt;=n)个实数表示ki，即牛牛申请在第i个时间段更换教室获得通过的概率。接下来e行，每行三个正整数aj，bj，wj，表示有一条双向道路连接教室aj，bj，通过这条道路需要耗费的体力值是wj；【Output】输出一行，包含一个实数，四舍五入精确到小数点后 恰好2位 ，表示答案。你的输出必须和标准输出 完全一样 才算正确。测试数据保证四舍五入后的答案和准确答案的差的绝对值不大于4 x 10^-3。（如果你不知道什么是浮点误差，这段话可以理解为：对于大多数的算法，你可以正常地使用浮点数类型而不用对它进行特殊的处理）【Limited conditions】保证1 &lt;= Ci &lt;= v。保证1&lt;=di&lt;=v。保证0 &lt;= ki &lt;= 1。保证 1 &lt;= n &lt;= 2000，0 &lt;= m &lt;= 2000， 1 &lt;= v &lt;= 300， 0 &lt;= e &lt;= 90000。保证1 &lt;= aj, bj &lt;= v, 1 &lt;= wj &lt;= 100。保证通过学校里的道路，从任何一间教室出发，都能到达其他所有的教室。道路中可能会有多条双向道路连接相同的两间教室。也有可能有道路两端连接的是同一间教室。保证输入的实数最多包含3位小数。【Sample input】3 2 3 32 1 21 2 10.8 0.2 0.51 2 51 3 32 3 1【Sample output】2.80【Sample explanation】无 Record3h Analysis请先思考后再展开 期望=各种情况的【概率×权值】之和意义即尝试无限次后，平均的权值具有线性性所以就dp过去 $$f(i,j,0)=min\left{\begin{matrix}f(i-1,j,0)+dis(c_{i-1},c_i)\\f(i-1,j,1)+dis(c_{i-1},c_i)\times (1-k_{i-1})+dis(d_{i-1},c_i)\times k_{i-1}\end{matrix}\right.$$ $$f(i,j,1)=min\left{\begin{matrix}f(i-1,j-1,0)+dis(c_{i-1},c_i)\times (1-k_i)+dis(c_{i-1},d_i)\times k_i\\f(i-1,j-1,1)+dis(c_{i-1},c_i)\times (1-k_{i-1}) \times (1-k_i)+dis(c_{i-1},d_i)\times (1-k_{i-1}) \times k_i+dis(d_{i-1},c_i)\times k_{i-1}\times (1-k_i)+dis(d_{i-1},d_i)\times k_{i-1} \times k_i\end{matrix}\right.$$ Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP16 D1T2】天天爱跑步]]></title>
    <url>%2Fposts%2F9594.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2016 提高组 D1T2Loj2359Uoj261Bzoj4719Luogu1600Caioj1576 Problem【Description】 小C同学认为跑步灰常有趣，于是决定制作一款叫做《天天爱跑步》的游戏。《天天爱跑步》是一个养成类游戏，需要玩家每天按时上线，完成打卡任务。这个游戏的地图可以看作一棵包含n个结点和n - 1条边的树，每条边连接两个结点，且任意两个结点存在一条路径互相可达。树上结点编号为从1到n的连续正整数。现在有m个玩家，第i个玩家的起点为Si，终点为Ti。每天打卡任务开始时，所有玩家 在第0秒 同时从 自己的起点 出发，以 每秒跑一条边 的速度，不间断地沿着最短路径向着 自己的终点 跑去，跑到终点后该玩家就算完成了打卡任务。（由于地图是一棵树，所以每个人的路径是唯一的）小C想知道游戏的活跃度，所以在每个结点上都放置了一个观察员。在结点j的观察员会选择在第Wj秒观察玩家，一个玩家能被这个观察员观察到当且仅当该玩家在第Wj秒也 正好 到达了结点j。小C想知道每个观察员会观察到多少人？注意： 我们认为一个玩家到达自己的终点后该玩家就会结束游戏，他不能等待一段时间后再被观察员观察到。即对于把结点j作为终点的玩家：若他在第Wj秒前到达 终点，则在结点j的观察员 不能观察到 该玩家；若他 正好 在第Wj秒到达终点，则在结点j的观察员 可以观察到 这个玩家。【Input】第一行有两个整数n和m。其中n代表树的结点数量，同时也是观察员的数量， m代表玩家的数量。接下来n - 1行每行两个整数u和v，表示结点u到结点v有一条边。接下来一行n个整数，其中第j个整数为Wj，表示结点j出现观察员的时间。 接下来m行，每行两个整数Si和Ti，表示一个玩家的起点和终点。【Output】输出1行n个整数，第j个整数表示结点j的观察员可以观察到多少人。【Limited conditions】对于所有的数据，保证1 &lt;= Si, Ti &lt;= n，0 &lt;= Wj &lt;= n。【Sample input 1】6 32 31 21 44 54 60 2 5 1 2 31 51 32 6【Sample output 1】2 0 0 1 1 1【Sample input 2】5 31 22 32 41 50 1 0 3 03 11 45 5【Sample output 2】1 2 1 0 1【Sample explanation】无 Record5h Analysis请先思考后再展开 首先，树上路径可以分割为两条链咱们推一推柿子吧，d是深度向上：$d_y+w_y=d_x$向下：$w_y-d_y=d_x-2\times d_{lca}$ 然后发现就是两种值的维护，然后分上下讨论但是怎么维护呢？ 我在晚修的时候忽然想到一种奇淫巧技用到了vector（不喜欢也可以写链表）把上面说的维护的两种值，按照值本身分成数组，然后我们要的就是对同值的编号，对于链上的部分，出现次数+1 那么我是使用树链剖分来搞的用线段树维护的话，空间复杂度是很高的使用灵活的差分，看起来还是一样，但其实我们可以运用vector的特点了，那就是实际总空间灰常小，然后定位的话，就是得到了l和r之后，在保证编号有序的情况下，二分查找一下就好了 那么最后的时候递推一下，累计一下答案，这道题就完成了但是其实细节还是很多的例如一开始忘记对两种情况分开维护之类 现在我们分析一下复杂度空间：$O(n)$，常数10以内时间：$O(nlogn)$，常数3以内吧大概；看起来虽然是log方，但数量灰常少，均摊小然鹅这样优秀的时间复杂度，居然不是很快？好像有些oj还会超时……好迷啊，之前那几个数据结构题也是类似的感觉，nlogn巨慢，不知道是不是复杂度算错？ UP 2018.8.9 rose用的是线段树维护虽然是区间操作，但还是可以动态开点至于复杂度，我们无敌的波老师（hanks_o大爷）有个证明：最多只会有logn层，然后每一次分治的时候，最多会分裂成两段，那么在第i层就分裂成logn段，所以说最多新开log方的节点，而且大概是很难构造的吧 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP15 D2T3】运输计划]]></title>
    <url>%2Fposts%2Fbb9.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2015 提高组 D2T3Uoj150Bzoj4326Luogu2680Caioj1574 Problem【Description】 公元 2044 年，人类进入了宇宙纪元。L 国有 n个星球，还有 n-1条双向航道，每条航道建立在两个星球之间，这 n-1 条 航道连通了 L 国的所有星球。小 P 掌管一家物流公司，该公司有很多个运输计划，每个运输计划形如：有一艘物 流飞船需要从 ui 号星球沿最快的宇航路径飞行到 vi 号星球去。显然，飞船驶过一条航道是需要时间的，对于航道 j，任意飞船驶过它所花费的时间为 tj，并且任意两艘飞船之间不会产生任何干扰。为了鼓励科技创新，L 国国王同意小 P 的物流公司参与 L 国的航道建设，即允许小 P 把某一条航道改造成虫洞，飞船驶过虫洞不消耗时间。在虫洞的建设完成前小 P 的物流公司就预接了 m个运输计划。在虫洞建设完成后， 这 m 个运输计划会同时开始，所有飞船一起出发。当这 m个运输计划都完成时，小 P 的 物流公司的阶段性工作就完成了。如果小 P 可以自由选择将哪一条航道改造成虫洞，试求出小 P 的物流公司完成阶段性工作所需要的最短时间是多少？【Input】 第一行包括两个正整数 n、m，表示 L 国中星球的数量及小 P 公司预接的运输计划的 数量，星球从 1 到 n 编号。接下来 n-1 行描述航道的建设情况，其中第 ii 行包含三个整数 ai, bi 和 ti，表示第 ii 条双向航道修建在 ai 与 bi 两个星球之间，任意飞船驶过它所花费的时间为 ti。接下来 m行描述运输计划的情况，其中第 j 行包含两个正整数 uj 和 vj，表示第 j个 运输计划是从 uj 号星球飞往 vj号星球。【Output】共 1 行，包含 1 个整数，表示小 P 的物流公司完成阶段性工作所需要的最短时间。【Limited conditions】【Sample input】6 31 2 31 6 43 1 74 3 63 5 53 62 54 5【Sample output】11【Sample explanation】无 Record2h很多变量忘记清零了……code20mincheck2h…… Analysis请先思考后再展开 首先一眼树链剖分是没问题的但我觉得应该会有更有意思的方法吧……不然就不做了看了看题解，还真有居然是树上差分！这东西我大概知道，但是说实话我一直没有用过然后发现我以前的猜测是错误的，它是从深度大的地方向上的（子树和）所以能很轻松地处理路径通过量的统计问题 总结一下： 先搞一搞lca 显然最小化最大值，搞个二分 然后就优化那个被所有【需要优化的路径】经过的边中长度最大者（不是被所有经过的话，就一定不能彻底解决问题），判断是否可行 时间复杂度：O(nlogn)那么理论上是灰常快的但是caioj和uoj都过不去……可能是被卡栈了？不管了无伤大雅 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>树链剖分</tag>
        <tag>倍增</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP15 D2T1】 跳石头]]></title>
    <url>%2Fposts%2F29c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2015 提高组 D2T1Luogu2678Caioj1572 Problem【Description】一年一度的“跳石头”比赛又要开始了!这项比赛将在一条笔直的河道中进行,河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间,有 N 块岩石(不含起点和终 点的岩石)。在比赛过程中,选手们将从起点出发,每一步跳向相邻的岩石,直至到达 终点。为了提高比赛难度,组委会计划移走一些岩石,使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制,组委会至多从起点和终点之间移走 M 块岩石(不能 移走起点和终点的岩石)。【Input】 输入第一行包含三个整数 L，N，M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。接下来 N 行，每行一个整数，第 i 行的整数 Di（0&lt;Di&lt;L）表示第 i 块岩石与 起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同 一个位置。【Output】输出只包含一个整数，即最短跳跃距离的最大值。【Limited conditions】对于 20%的数据,0 ≤ M ≤ N ≤ 10。 对于50%的数据,0 ≤ M ≤ N ≤ 100。对于 100%的数据,0 ≤ M ≤ N ≤ 50,000,1 ≤ L ≤ 1,000,000,000。【Sample input】25 5 2211141721【Sample output】4【Sample explanation】将与起点距离为 2 和 14 的两个岩石移走后,最短的跳跃距离为 4(从与起点距离 17 的岩石跳到距离 21 的岩石,或者从距离 21 的岩石跳到终点)。 Record20min Analysis1请先思考后再展开 首先，看到最值的最值问题，应该先想到二分答案：例如目标答案是A，那么所有距离都要大于等于A 然后就dp转移，f[i]表示到i位置合法的，移动石子的最小值（显然单调递增）然后logn转移即可 这样的复杂度是O(nlognlogn) Code1请先思考后再展开 undefined Analysis2请先思考后再展开 上面的做法其实还算快，因为出题人并没有去卡然鹅其实可以更快的原谅我脑残了如果从起点开始，找到下一个能跳的地方，跳过去，就好了……这样就省掉了一个log]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP15 D2T2】 子串]]></title>
    <url>%2Fposts%2Fe5d4.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2015 提高组 D2T2Luogu2679Caioj1573 Problem【Description】 有两个仅包含小写英文字母的字符串 A 和 B。现在要从字符串 A 中取出 k 个 互不重叠 的非空子串， 然后把这 k 个子串按照其在字符串 A 中出现的顺序依次连接起来得到一个新的字符串，请问有多少种方案可以使得这个新串与字符串 B 相等？ 注意：子串取出的位置不同也认为是不同的方案。【Input】第一行是三个正整数 n，m，k，分别表示字符串 A 的长度，字符串 B 的长度，以及问题描述中所提到的 k，每两个整数之间用一个空格隔开。第二行包含一个长度为 n 的字符串，表示字符串 A。 第三行包含一个长度为 m 的字符串，表示字符串 B。【Output】输出共一行，包含一个整数，表示所求方案数。(由于答案可能很大，所以这里要求输 出答案对 1,000,000,007 取模的结果。【Limited conditions】对于第 1 组数据:1≤n≤500,1≤m≤50,k=1;对于第 2 组至第 3 组数据:1≤n≤500,1≤m≤50,k=2;对于第 4 组至第 5 组数据:1≤n≤500,1≤m≤50,k=m;对于第 1 组至第 7 组数据:1≤n≤500,1≤m≤50,1≤k≤m;对于第 1 组至第 9 组数据:1≤n≤1000,1≤m≤100,1≤k≤m;对于所有 10 组数据:1≤n≤1000,1≤m≤200,1≤k≤m。【Sample input 1】6 3 1aabaabaab【Sample output 1】2【Sample input 2】6 3 2aabaabaab【Sample output 2】7【Sample input 3】6 3 3aabaabaab【Sample output 3】7【Sample explanation】 Record40min Analysis请先思考后再展开 提高组的字符串……八成是dp那么设$f[i][j][k]=用到A_i，填充到B_j，用了k个段的方案数$然后？？然后就蒙逼了 其实这是因为我们的决策需要把用了$A_i$的和没用的方案数分开来$g[i][j][k]表示用到A_i，填充到B_j，用了k个段的方案数$$f[i][j][k]表示到A_i为止（不一定用），填充到B_j，用了k个段的方案数$那么一下子就可以搞出递推式了： $$g[i][j][k]=\left{\begin{matrix}f[i-1][j-1][k-1]+g[i-1][j-1][k] &amp;(A[i-1]=B[j-1])\\0 &amp; (A[i-1] \neq B[j-1])\end{matrix}\right.$$ 然后累计$f[i][j][k]=f[i-1][j][k]+g[i][j][k]$ 但这样会mle哒循环数组就好了 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP15 D1T2】信息传递]]></title>
    <url>%2Fposts%2F3244.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2015 提高组 D1T2Luogu2312Caioj1568 Problem【Description】有n个同学（编号为1到n）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为i的同学的信息传递对象是编号为Ti同学。游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息，但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？【Input】输入共 2 行。第 1 行包含 1 个正整数 n，表示 n 个人。第 2 行包含 n 个用空格隔开的正整数 T1, T2, … … , Tn，其中第 i 个整数Ti表示编号为 i 的同学的信息传递对象是编号为 Ti 的同学， Ti ≤ n 且 Ti ≠ i。数据保证游戏一定会结束。【Output】输出共 1 行，包含 1 个整数，表示游戏一共可以进行多少轮。【Limited conditions】对于 30%的数据， n ≤ 200；对于 60%的数据，n ≤ 2500；对于 100%的数据，n ≤ 200000。【Sample input】52 4 2 3 1【Sample output】3【Sample explanation】游戏的流程如图所示。当进行完第 3 轮游戏后，4 号玩家会听到 2 号玩家告诉他自己的生日，所以答案为 3。当然，第 3 轮游戏后，2 号玩家、3 号玩家都能从自己的消息来源得知自己的生日，同样符合游戏结束的条件。 Record20min Analysis请先思考后再展开 一眼就是找最小环如果直接暴力枚举是n方级别的考虑题目特性，只有一条出边显然所有强连通都是以环的形式出现的找最小但至少有两个的强连通分量即可 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP14 D2T3】解方程]]></title>
    <url>%2Fposts%2Fc8d.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2014 提高组 D2T3Bzoj3751Luogu2312Caioj1568 Problem【Description】已知多项式方程：$$a_0+a_1x+a_2x^2+\cdots+a_nx^n=0$$求这个方程在 $[1,m]$ 内的整数解（$n$ 和 $m$ 均为正整数）。【Input】输入共 $n + 2$ 行。第一行包含 $2$ 个整数 $n, m$，每两个整数之间用一个空格隔开。接下来的 $n+1$ 行每行包含一个整数，依次为 $a_0,a_1,a_2\ldots a_n$。【Output】第一行输出方程在 $[1,m]$ 内的整数解的个数。接下来每行一个整数，按照从小到大的顺序依次输出方程在 $[1,m]$ 内的一个整数解。【Limited conditions】对于 $30\%$ 的数据：$0&lt;n\le 2,|a_i|\le 100,a_n≠0,m&lt;100$。对于 $50\%$ 的数据：$0&lt;n\le 100,|a_i|\le 10^{100},a_n≠0,m&lt;100$。对于 $70\%$ 的数据：$0&lt;n\le 100,|a_i|\le 10^{10000},a_n≠0,m&lt;10^4$。对于 $100\%$ 的数据：$0&lt;n\le 100,|a_i|\le 10^{10000},a_n≠0,m&lt;10^6$。【Sample input 1】2 101-21【Sample output 1】11【Sample input 2】2 102-31【Sample output 2】212【Sample input 3】2 10132【Sample output 3】0【Sample explanation】无 Record40min Analysis请先思考后再展开 一开始想着高精度肯定超时啊然后膜题解，发现自己忘记了这个套路：自然溢出，或者搞多几个模数之前也用过：等价表达式原理还是类似的：如果$f(x)=0$，那么$f(x)\%p=0$，而这个多项式又没有除法 然后用秦九昭就好了这东西之前看到，结果就觉得：煞笔玩意……然后现在居然没想到了感觉这东西和韦达定理是一个道理的…… 但是现在的复杂度大概是1亿的，然后还有个long long的常数5，还有两个模数的常数2有没有很虚的感觉？那怎么办么？随便卡卡常呗随便搞个小模数10007吧，这里面的数字，如果$f(x)=0$，那么后面的部分（即$f(10007\times b+x)$）显然就不用枚举了不知道为什么就快了灰常多呀（好像时间复杂度证明跟拉格朗日定理有关？） Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>秦九昭</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP14 D2T2】寻找道路]]></title>
    <url>%2Fposts%2Fbc9.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2014 提高组 D2T2Luogu2296Caioj1567 Problem【Description】 在有向图 G 中，每条边的长度均为 1，现给定起点和终点，请你在图中找一条从起点到 终点的路径，该路径满足以下条件：1. 路径上的所有点的出边所指向的点都直接或间接与终点连通。2. 在满足条件 1 的情况下使路径最短。注意：图 G 中可能存在重边和自环，题目保证终点没有出边。 请你输出符合条件的路径的长度。【Input】 第一行有两个用一个空格隔开的整数 n 和 m，表示图有 n 个点和 m 条边。接下来的 m 行每行 2 个整数 x、y，之间用一个空格隔开，表示有一条边从点 x 指向点y。最后一行有两个用一个空格隔开的整数 s、t，表示起点为 s，终点为 t。【Output】 输出只有一行，包含一个整数，表示满足题目描述的最短路径的长度。如果这样的路径不存在，输出-1。【Limited conditions】对于30%的数据，0&lt;n≤10，0&lt;m≤20；对于60%的数据，0&lt;n≤100，0&lt;m≤2000；对于100%的数据，0&lt;n≤10,000，0&lt;m≤200,000，0&lt;x，y，s，t≤n，x≠t。【Sample input】6 61 21 32 62 54 53 41 5【Sample output】3【Sample explanation】如上图所示，满足条件的路径为1 - &gt;3- &gt;4- &gt;5。注意点2 不能在答案路径中，因为点2连了一条边到点6 ，而点6 不与终点5 连通。 Record20min Analysis请先思考后再展开 sb题 建个反向边 判断连通性 从不联通的地方扫描标记 spfa Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【GDOI2018 D1T2】【51nod1357】密码锁]]></title>
    <url>%2Fposts%2Ff4f8.html</url>
    <content type="text"><![CDATA[Source and JudgeGDOI2018 D1T2（模数不固定）51nod1357 Problem【Description】有一个密码锁，其有N位，每一位可以是一个0~9的数字，开启密码锁需要将锁上每一位数字转到解锁密码一致。这个类似你旅行用的行李箱上的密码锁，密码锁的每一位其实是一个圆形转盘，上面依次标了0,1，…9,对每一位来说可以正向或者逆向拨动，正向拨动时原有数字x会变成新的数字(x+1 mod 10),例如1-&gt;2，2-&gt;3，9-&gt;0；同理逆向拨动变为(x-1 mod 10)即9-&gt;8,5-&gt;4,0-&gt;9。定义对密码锁的一次操作：选择一个连续的区间[L,R]，可以只包含一位即L==R，将这个区间的所有数字正向拨动或逆向拨动一次，注意要么全部正着拨，要么全逆着。例如：12397正向后变成23408，逆向后变成01286。给出密码锁初始和解锁需要的终止状态，问最少多少次操作能解锁。【Input】多组测试数据，第一行一个整数T，表示测试数据数量每组测试数据有相同的结构构成：每组数据有两行构成，第一行是密码锁的初始状态S，第二行是解锁的终止状态E【Output】每组数据一行输出，即最少需要的操作数。【Limited conditions】1&lt;=len(S)=len(E)&lt;=2500,且都由0~9构成【Sample input】106076071234456737896565159478927782432854574946297839335216760603277426453582937390990599524328132169880751802416449917850055278844124181670313605874031469333653114254419369610778733406822463469353946356056711090437786504862201123112170209094423232218340629042147624501837850000000【Sample output】031066281421811【Sample explanation】无 Record2h这个是比赛的题目，但当时没有做出来然后因为讲课的时候不是那么明确，想做一做（就是想报仇的心态）在知乎上找到了类似的题目，不过都没人做wa了很多次……所以数据特别多，是我买的几组数据 Analysis请先思考后再展开 首先，gdoi的题目是最后要到0，而这里是指定的如何处理这一步呢？其实很好理解，因为每一个位是相对独立互不影响的，那么可以把目标位对其为0，然后把当前串映射过去（其实就是相减一下），那么现在对正确性没有影响的 但是，这道题目有个很迷惑人的地方，在于有模数刚才我们搞出来的当前串a是有负数的，但是我们先不管它 现在有+1和-1两种区间操作，那么一个不那么显然的套路就是差分一下（没想到啊555）那么现在，我们的目标就是，对于得到的差分数组cf，我们要把其中每一个元素变成m的倍数（包括0）而这两个区间操作，现在就变成了对一个数+1，一个数-1 不难发现这道题是一定有解的，因为你可以一个个拧过去我们要利用这个性质，辅助我们去理解这道题那一个个拧过去，其实就是这个+1，下一个-1所以我们的差分数组，长度应该是n+1而且，我们的+1和-1的个数是要相同的 那么对于每一个差分后的数，它都有一个上下界，因为跨越是没有意义的那么显然我们可以取个模，然后如果还是负数的话，把它+m后，其实是等效的 现在的问题就在于，如何分配+1和-1呢？首先明确一个数，只可能增加或减少，而不会重叠，否则答案不会更优（还不理解可以联想一下原问题，对于两个重叠的+1和-1区间，显然可以把中间的去掉，剩下的还是两个） 接下来，我们可以尝试贪心把差分的数字排个序，然后枚举一个断点（在空隙位置），这个断点左边的，也就是比它小的，全部都是要减小的，右边的都是要增加的那么线性地扫描一遍，如果左边的花费能否等于右边的花费，显然这个时候是最优的 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>贪心</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Sdoi2016】数字配对]]></title>
    <url>%2Fposts%2F6c7a.html</url>
    <content type="text"><![CDATA[Source and JudgeSdoi2016Bzoj4514Luogu4068Loj2031 Problem【Description】有 n 种数字，第 i 种数字是 ai、有 bi 个，权值是 ci。若两个数字 ai、aj 满足，ai 是 aj 的倍数，且 ai/aj 是一个质数，那么这两个数字可以配对，并获得 ci×cj 的价值。一个数字只能参与一次配对，可以不参与配对。在获得的价值总和不小于 0 的前提下，求最多进行多少次配对。【Input】第一行一个整数 n。第二行 n 个整数 a1、a2、……、an。第三行 n 个整数 b1、b2、……、bn。第四行 n 个整数 c1、c2、……、cn。【Output】一行一个数，最多进行多少次配对【Limited conditions】 n≤200，ai≤10^9，bi≤10^5，|ci|≤10^5【Sample input】32 4 82 200 7-1 -2 1【Sample output】4【Sample explanation】无 Record1h Analysis请先思考后再展开 这道题有意思的地方不是构图 首先,对于(i,j),判断能否配对,直接枚举约数要sqrt(a),即使配上线筛也是灰常慢的.考虑条件的特性:多出一个质因数,因为前面有个条件限制着,完全可以看作质因数的幂之和+1所以这个是可以在枚举外面预处理的,然后其实线筛是可以省去的,因为合数已经被前面的筛去了. (st,i),cost=0,flow=b[i](i,j),cost=c[i]*c[j],flow=INF(i,ed),cost=0,flow=b[i]然后跑一下最大费用最大流其实会不会有种杀鸡用牛刀的感觉,毕竟很简单 然鹅最关键的地方在于,这个权值和不能是负数,那么当有一天我们跑出来的最长路乘上哪怕1的流量,已经会导致答案变负数了,显然game over还有一种情况是最长路是负数,那么就要限制一下流量,确保费用是非负数即可. 然后网上有人还要分奇偶,那根本就不是正常人的思维,其实答案直接除二就好,否则显然分配方案不对称的话不会使结果更优. Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDOI2018]]></title>
    <url>%2Fposts%2Fd688.html</url>
    <content type="text"><![CDATA[GDOI2018 这篇文章……或许并没有什么用处只是一个半退役选手的满口胡言乱语罢了 GDOI2017 思考录 day-12018.4.27借koi发的绿册子看去年的题目只会前面两道题 d1t1题意：字符串查找替换kmp裸题，O(N^2*L)忽然想起刚学的时候做字符串都是直接用stl的，特无耻 d1t2感觉自己就是个大沙茶，看错题目了，狂问师兄题意：给一棵树，求对于每个点，除了子树外其他点的mex（对于一个集合，在非负整数中没出现的最小值）对于每种颜色，求出其lca（两两求就好），然后对于lca到root间的点，它都是【没有在其他地方出现的值】，所以维护一下最小值就好了，O(N) GDKOI2014 模拟赛（三个半小时） day0早上用以前的原题做模拟赛，就我们竞赛室的几个人小测一下，据hz说又是很简单然后第一题manacher水题第二题网络流，但是数据有误第三题暴力50分 GDOI2018 游记初中oi生涯要结束了哎前面说的看起来很简单，但gdkoi2018是真的懵逼啊……话说今年可是我们主场呀然后顺带一提,我们几个竞赛室的约定：有谁进了day3就请另外两个人吃饭 day1T1二分水题，nlogn T2打了个bfs拿暴力分，然后搞了搞m=2的暴力中午听ozy大爷讲题： 先差分一波，然后现在目标就是把所有的数变成【m的倍数】 计算出当前数与上下两个【m的倍数】的距离a、b 然后就听不懂了讲课： 通过差分,让区间操作变成一个数+1,一个数-1,而且因为可加可减 那么这个时候，每个数字的顺序已经无关紧要了，可以先排个序 然后有一个显然的性质：一个数没有必要既增加又减少，所以必然是有固定决策的 记录决策的和，线性扫描一遍，枚举两个数中间作为中介点，当左右两侧的和相同（总有这样的位置，因为题目必然有解），则这个和就是最优解「这一步刚开始有点问题，原来是忘记最后一位的差分了，请教了rose」时间复杂度：nlognUP：在知乎上找到了原题：51nod1357-密码锁T3暴力10分和链10分akc大爷：二维线段树rose大爷：四维KD-tree讲课：乱七八糟，但rose被卡了，跑了70分.在打球之前听akc大爷讲： 询问：「dfn1,dfn2」和「t+deprt-1,INF」 修改：「dfnx」和「t+depx-1」 维护双区间，但是如果直接两个树状数组需要n^2的空间，其实完全可以动态开点，改成线段树，然后这样的话，修改是一条链，空间复杂度nlogn，时间复杂度nlognlogn T4完全不会讲课：还是不会UP：在知乎上找到了原题：Uoj#12-B 总结期望总分：100+30+20+0=150实际得分：100+20+10+0=130两道题都是case打wa了，不知原因，毕竟是暴力也不好复评 描述一下心路历程吧开始半个小时看完题目，把t1切了，感觉难度不对劲，此时九点半然后看第二题，没思路，但是部分分还是可以的，然后就写了bfs和m=2和3的情况十点半点了，第三题感觉很难处理掉落的情况啊，没什么思路，感觉考虑深度，也推不上去啊把小数据和链的分拿了，此时已经十一点半了回头搞第二题，发现有m=3的大数据错了，然后打对拍，调策略，直到最后检查一下其他题目后继续搞……比赛结束前忽然又拍出错误，发现我解决不了……（然后原来出题人也没有什么想法woc） 那么如今回顾一下，感觉前面三题真的不难，大概是一场noip+模拟赛难度，也似乎确实有人ak了第二题其实就是个经典套路——差分，然后再贪贪心，但是因为没怎么用差分，所以没想过，而且这个贪心策略也不是那么好想的，似乎有灰常多巨佬也被卡炸了……第三题，其实打链的情况的时候也想过这个深度的关系，但是没想到「把dfs序静态化」，所以灰常不可做，如今看来，其实只要把条件转化一下，然后推推关系式，发现是双区间而且互不影响，树状数组维护一波即可 那么完美的策略：看题目：30minT1：思考10min，实现10minT2：思考40min，实现20minT3：思考1h，实现40minT4：挂机……因为我不会期望剩余检查时间：30min 然鹅这场考试，重在求稳，任何一道题，如果翻车就会灰常麻烦（虽然我并没有高分经验）那么这场考试前面三题的最高预备知识是很简单的：树状数组但是其灵活的命题，灰常考验对套路的熟练使用 这场比赛，我考得相当差，一部分原因是缺乏经验和自信，感觉难度会和koi一样，是那种ac一题就很好的那种第二点是做题太少，整天做脑残noip题目，所以我决定接下来的一年，我的刷题量要增加500题！ 总之，保持自信，相信自己，争取明天翻盘吧！目标：进day3 day2T1杠了三个小时……打了个60分的O(nm)，虽然加了个素数优化10的常数，但本机跑了7秒……而且我居然忘记了大样例输出文件的存在？？？也就是说我只知道时间，却忘记看正确答案输出了打了个对拍，但是很sb地测1000，直接wa，然后只是去检查公式？居然没有自己出个小的数据，或者拍小的数据然后推了一个小时分块，没退出来，因为太久没用了，其实就是n/(n/t)，正确性其实很显然，因为整除是向下的，分母小，必然得到的最大t总之不知道多少分，可能0，也可能60、70 总而言之，这道题不算特别难，算是莫反的一个裸题吧，或许对于别人来说的签到题，我却耗费了大量时间，原因？可能还是要怪中途去做noip这种玩意吧，不知道教练口中那个进了省队刷noip的师兄是怎么想的，或许是时代在变化吧 讲课：莫比乌斯我是真的不自量力，看着题目限制没有下限，然后因为最近没用过莫比乌斯所以想着yy一种替代做法，就是用总量-不互质的数对的贡献然鹅当时过了灰常小的样例就以为没问题了其实稍微用个6这样的多个素因子的数字，就会发现算重复了 如今看来，其实不会也可以跳过的 T2暴力5分听说其实k=1不在乎顺序的时候可以组合数学乱搞，有点亏讲课：不会 T3暴力10分讲课：好像是有单调性什么的，居然最高只用了链表？？不是很懂 T4题意：找出一个点所在的最小环完全不会，然后因为感觉后面会比前面难，所以也没怎么看题目讲课：好像floyd可以搞？ 总结感觉初中oi就这么结束了吧凉凉的感觉期望分数：0+5+10+0实际分数：0+5+0+0暴力分又炸了怎么老是这样，不知不觉，加起来丢了30分，但是又不知道原因 现在感觉，这两天，还是第一天比较友好，但是错失良机了然后在省选前，专题没有完整搞定，去做noip之类的，真的是自寻死路第一天被简单题目拉了差距，第二天又拿不到分 结束了后面，也没我什么事了准备了这么久，并没有明显的收获吧 day3上午听了网络流的讲座，还好吧然后把d1t2切了开始回到noip状态，打算快速做完以后开始搞数论好像说我们可以延迟退役，等丰山的课程，又可以苟延残喘一会了 day4上午颁奖仪式，最精彩的部分就是省队选手的颁奖了那一刻，虽然说名单早就公布，依然全场安静，所有的教练都站了起来，或许心中都带着某种骄傲之情？有一天，我会站在那上面吗？ 总结我能感受到自己在变强，然鹅大家也在变强，可能唯一的优势就是我不怎么颓废？还记得有天早上老妈跟我说：你的实力，其实很可能进不了省队我：但除此之外我也不知道我能干什么了。不进省队也可以搞搞降分的吧（然鹅其实心中依然对进省队抱有期望……） 附录hz大佬的blog:here]]></content>
      <categories>
        <category>竞赛历程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【模板】动态树]]></title>
    <url>%2Fposts%2Fbebe.html</url>
    <content type="text"><![CDATA[Source and JudgeLuogu3690 Problem【Description】给定n个点以及每个点的权值，要你处理接下来的m个操作。操作有4种。操作从0到3编号。点从1到n编号。0：后接两个整数(x，y)，代表询问从x到y的路径上的点的权值的xor和。保证x到y是联通的。1：后接两个整数(x，y)，代表连接x到y，若x到y已经联通则无需连接。2：后接两个整数(x，y)，代表删除边(x，y)，不保证边(x，y)存在。3：后接两个整数(x，y)，代表将点x上的权值变成y。【Input】第1行两个整数，分别为n和m，代表点数和操作数。第2行到第n+1行，每行一个整数，整数在［1，10^9］内，代表每个点的权值。第n+2行到第n+m+1行，每行三个整数，分别代表操作类型和操作所需的量。【Output】对于每一个0号操作，你须输出x到y的路径上点权的xor和。【Limited conditions】单词数n&lt;=60所有字符串长度、m&lt;=100【Sample input】3 31231 1 20 1 20 1 1【Sample output】31【Sample explanation】无 Record1h Analysis请先思考后再展开 省选前模板练手 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LCT</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JSOI2007】文本生成器]]></title>
    <url>%2Fposts%2Feec3.html</url>
    <content type="text"><![CDATA[Source and JudgeJSOI2007 文本生成器Bzoj1030Luogu4052 Problem【Description】给出一些单词和文本固定长度，求所有满足此长度的，包含至少一个单词的文本的数量，对10007取模。【Input】第一行两个数表示单词数量n和文本长度m。接下来每行一个字符串表示单词。【Output】答案。【Limited conditions】单词数n&lt;=60所有字符串长度、m&lt;=100【Sample input】2 2AB【Sample output】100【Sample explanation】无 Record3h Analysis请先思考后再展开 最先，也是最重要的一点：把答案容斥，转化为更容易计算的，不包含任何单词的文本数量，然后用总量26^m-数量即是答案。而这种包含与否的关系，很容易联想到多串匹配，那当然少不了AC自动机。接下来呢？ 我们所要求的，就是跳m次，没有跳到任何一个【单词结尾节点】的方案数。但是考虑这样一种情况：只有单词a和bbabbb，m=3，然后我们跳到第三层的a，然后以为没有经过任何单词，就累计了答案。然鹅，不难发现其实我们还是包含了单词a。所以必须确保其任何后缀都不是单词的结尾。网上大部分人都是暴力跳fail去验证，然鹅其实可以在计算fail的时候，顺便递推过来，能节省时间（注意要用与运算），因为此时的bfs，fail的深度一定比x小。 一种直观的想法就是直接dfs跳，然后套一个记忆化。。。那既然如此不如直接dp？反正是等效的吧 那我们就可以愉快地dp啦你可以想象一个长度为m的任意字符串在ac机上面跳来跳去所以我们可以在任何时刻任意追加字符然鹅这样空间消耗灰常大但是不难发现，对于一个不在ac机上面的点，其接下来的拓展性与自己无关（fail=0），所以是等价于根节点0的，所以为了方便和节省空间，可以把空节点也设为0.一开始连模板都打错了qwq Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>AC自动机</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AHOI2005】【CQOI2014】病毒检测/通配符匹配]]></title>
    <url>%2Fposts%2F4a8c.html</url>
    <content type="text"><![CDATA[Source and JudgeAHOI2005 病毒检测Bzoj1966Luogu2536CQOI2014 通配符匹配Bzoj3507Luogu3167 Problem【Description】给出通配符字符串，其中 * 的意思是可以匹配上0个或任意多个字符，而 ? 的意思是匹配上任意一个字母，询问给出字符串是否能匹配。【Input】如题目描述【Output】如题目描述【Limited conditions】0&lt;N&lt;100通配符字符串的长度不超过100000询问字符串的长度不超过500通配符个数不超过10【Sample input 1】123**ASD*ASDASD*A?SD?*AS?D*SAD?A?D*?1ASDASDASDADSDASSDASDDDSADAASDAAAAS【Sample output 1】0【Sample input 2】1234567*a*5asdasdddasssdd【Sample output 2】2【Sample explanation】无 Record10h话说我的心路历程可真有意思：ac机=》Here=》贪心比它还长……虽然都没有打代码233 Analysis请先思考后再展开 这道题……栋老师跟Claris学，我跟栋老师学…… 前置知识：Hash 通配符就是本题最关键的部分对于星号，连长度都是任意的，是有很高自由度的，也是最高优先级的，所以要以其为分割点分成一个个段。对于问号，虽然说没有星号这么bt，好歹限制了长度，但其作用并非万能字符那么简单。 咱们先从一些显然的事实开始入手： 如果没有星号，直接匹配 对于第一个星号左边的，必须匹配；最后一个星号后面的部分同理 剩下的段，如果每一个都尽量地偏前面匹配，显然是最优的（或者说，否则不会更优）如果不计算匹配的话，以上过程最坏是O(q*星号数量*n)=1kw 然鹅要怎么匹配呢？如果可以常数级别那当然是极好的那验证相同性……当然要祭出hash不过可别忽略问号哦，所以按照问号拆分开来就好了因为通配符数量的保证，复杂度是常数级别的。 然后就没有然后了。。。。 Code1CQOI2014请先思考后再展开 undefined Code2AHOI2005请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SCOI2013】【Bzoj3325】【Luogu3279】密码]]></title>
    <url>%2Fposts%2F4b95.html</url>
    <content type="text"><![CDATA[Source and JudgeSCOI2013Bzoj3325Luogu3279 Problem【Description】已知一个字符串的：1. 长度为N。2. 仅含小写字母。3. 以每一个字符为中心的最长回文串长度。4. 以每两个相邻字符的间隙为中心的最长回文串长度。输出满足条件的字符串中字典序最小的。【Input】输入由三行组成。第一行仅含一个整数N，表示长度。第二行包含N 个整数，表示以每个字符为中心的最长回文串长度。第三行包含N - 1 个整数，表示每两个相邻字符的间隙为中心的最长回文串长度。【Output】输出答案，保证有解【Limited conditions】对于20% 的数据，1 &lt;= n &lt;= 100。另有30% 的数据，1 &lt;= n &lt;= 1000。最后50% 的数据，1 &lt;= n &lt;= 10^5。【Sample input 1】31 1 10 0【Sample output 1】abc【Sample input 2】31 3 10 0【Sample output 2】aba【Sample input 3】31 3 12 2【Sample output 3】aaa【Sample explanation】无 Record2h Analysis请先思考后再展开 一开始想贪心乱搞，然后显然是不可靠の玄学的怎样稳一点呢？相等性和互斥性，而且不是二分图，那不就是并查集了嘛！但是我们并不能单单处理相同的，然后去合并，也不能像某些二分图的时候那样拆成两个对立点，把所有对立的合并起来，因为字母不只2个。有种灰常妙的办法：建边！把与该点所在集合存在互斥关系的集合连上边，然后分配的时候，因为要求字典序最小，则必须选择一个【没有被在前面的，与当前互斥】的字母。注意一定要从整个集合来看，网上有人直接从当前点出发，显然是不正确的，虽然说数据比较水这样，我们就有50分辣！激动吗？（雾 首先，通常来说，如果一个正规比赛题面有灰常类似某个算法的裸题的描述的话，通常来说其实不是用这种算法。。。然鹅今天连做两道题都是要用到那个算法。。（另一个是动物园。。kmp）所以我们还是要借鉴一下manacher的神奇线性做法滴 例如这种情况，就造成了重复，虽然并不是那么直观。manacher的跳过，是不需要验证相同。这道题的跳过，是不需要使它们相同。操作的类似使复杂度也是O(n)的。 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>难度2</tag>
        <tag>manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【USACO12DEC】【Bzoj3012】【Luogu3065】First!]]></title>
    <url>%2Fposts%2F710f.html</url>
    <content type="text"><![CDATA[Source and JudgeUsaco2012 DecBzoj3012Luogu3065 Problem【Description】给n个字符串，问如果重定义字典序，有哪些单词可能排在字典的第一名。字典序计算：1. 优先找不同的字母2. 其次长度小则前【Input】字符串总量n每行一个字符串【Output】满足条件的数量每行一个，输出原串（按输入顺序）【Limited conditions】1 &lt;= N &lt;= 30,000字符总数不会超过300,000只有小写字母【Sample input】4ommmoomomommnom【Sample output】2ommmom【Sample explanation】如果定义 o 在 m 之前，则omm 可排第一，如果定义 m 在 o 之前，则mom 可排第一，但余下两个单词是无论如何不可能排在第一的。 Record2h Analysis请先思考后再展开 首先： 从面向数据编程的角度，看到字符串总长度，而且只有小写字母，可以考虑字典树 从字符串比较的角度，是从前往后的，也就是前缀，那也是字典树 然后可以考虑枚举每一个字符串，然后什么条件下它能够成为字典序最小的呢？ 不能存在某个字符串是它的前缀 对于某个位置，如果前面都一样，则这个不一样的部分，我的将是最小的显然两个都跟前缀有关，可以用字典树搞一搞然后对于2，产生了一些不等关系 那么有三种思路（大致时间复杂度都是O(N^2)）： 用拓扑排序，如果某一时刻没有入度为0的点，则无解 用差分约束，有负环无解 用强连通找环，有环无解那么网上的大部分都是用第一种的，事实上这也是性价比最高的，所以另外两种就不写了，但是理解还是一定要的。 至于空间的话……网上都说每个串不超过20，但为了不被卡，用了string，慢也是正常的。 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>拓扑</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3670】【Luogu2375】动物园]]></title>
    <url>%2Fposts%2F53a7.html</url>
    <content type="text"><![CDATA[Source and JudgeBzoj3670Luogu2375 Problem【Description】对于字符串S的前i个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作num[i]。输出所有(num[i]+1)的乘积，对1,000,000,007取模的结果即可。【Input】第1行仅包含一个正整数n ，表示测试数据的组数。随后n行，每行描述一组测试数据。每组测试数据仅含有一个字符串S，S的定义详见题目描述。【Output】包含 n 行，每行描述一组测试数据的答案，答案的顺序应与输入数据的顺序保持一致。对于每组测试数据，仅需要输出一个整数，表示这组测试数据的答案对 1,000,000,007 取模的结果。【Limited conditions】S中仅含小写字母。1 N ≤ 5, L ≤ 502 N ≤ 5, L ≤ 2003 N ≤ 5, L ≤ 2004 N ≤ 5, L ≤ 10,0005 N ≤ 5, L ≤ 10,0006 N ≤ 5, L ≤ 100,0007 N ≤ 5, L ≤ 200,0008 N ≤ 5, L ≤ 500,0009 N ≤ 5, L ≤ 1,000,00010 N ≤ 5, L ≤ 1,000,000【Sample input】3aaaaaababcababc【Sample output】36132【Sample explanation】S为aaaaa，则num[4] = 2。这是因为S的前4个字符为aaaa，其中a和aa都满足性质‘既是后缀又是前缀’，同时保证这个后缀与这个前缀不重叠。而aaa虽然满足性质‘既是后缀又是前缀’，但遗憾的是这个后缀与这个前缀重叠了，所以不能计算在内。同理，num[1] = 0,num[2] =1， num[3] = 1,num[5] = 2 Record1h Analysis请先思考后再展开 一开始看错题以为是对于当前前缀的长度，以为就kmp特判一下……然后手玩数据才发现错 用kmp搞出nxt数组（注意不重叠的条件暂时不理，否则会影响后面） 用一个x表示上一次的合法值，然后转移为当前i的nxt值（不一定最大）（这一步不能偷懒直接用nxt[i]，否则前功尽弃，50分） 跳nxt直到满足条件 记录一个【无视条件的个数】的sum，然后直接继承 有没有感觉这个sum和num的关系，很像是莫比乌斯中F和f的关系都是从题目要求的，但是很困难的，先计算类似但范围更大而且容易计算的的，然后推导出题目要求的，这种思想灰常值得学习。 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Vijos1677】陶陶的名字]]></title>
    <url>%2Fposts%2F9bc9.html</url>
    <content type="text"><![CDATA[Source and JudgeVijos1677 Problem【Description】某一天，陶陶想把自己的名字涂在墙上。由于他的名字太长，为了省事，他从自己名字的开头截取了一段作为模板。我们不妨设这个模板的长度为l，陶陶的名字的长度为L，那么有1≤l≤L。然后陶陶会用这个模板进行若干次喷涂，喷出自己的名字（后一次喷涂会覆盖前一次喷涂的结果，例如当前墙上已经有abc三个字符，那么如果在c处进行喷涂，就会得到ababc）。陶陶喷涂名字总是从前向后喷的，假设陶陶喷涂了k次，这k次喷涂按时间顺序第i次喷涂的位置是s[i]，那么s[i]&lt;s[i+1]。【Input】陶陶的名字【Output】最短的模版长度【Limited conditions】对于10%的数据， n≤200对于30%的数据， n≤1000对于100%的数据，n≤1000000【Sample input】abcabababc【Sample output】3【Sample explanation】陶陶的名字是abcabababc，最短的模版是abc。注意，印刷只能从前向后印 Record2h Analysis请先思考后再展开 性质： 此前缀一定也是后缀 满足条件1的长度序列上，满足二分性 然后下面用到了exkmp，不想写可以考虑hash+二分，知道自己的复杂度很优秀就行了 方法一，O(nlogn)利用二分性，考虑能否用ln以内的前缀得出考虑dp，记录最后一个能覆盖的位置lst，枚举到lst并尝试向后，长度为max(ln,ext[i]) 方法二，O(n)考虑kmp，如果某个前缀满足条件1，而且后面（不包括自己）没有nxt=0的位置，则合法证明：首先是能构造出方案的，因为所有位置都能在前缀取非0的长度然后不存在更小的，因为如果某个位置后面有这种0的地方，毫无覆盖的办法（如果有覆盖办法，显然不会是0）undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51Nod1304】字符串的相似度]]></title>
    <url>%2Fposts%2F23a.html</url>
    <content type="text"><![CDATA[Source and Judge51Nod1304 Problem【Description】我们定义2个字符串的相似度等于两个串的相同前缀的长度。例如 “abc” 同 “abd” 的相似度为2，”aaa” 同 “aaab” 的相似度为3。给出一个字符串S，计算S同他所有后缀的相似度之和。例如：S = “ababaa”，所有后缀为：ababaa 6babaa 0abaa 3baa 0aa 1a 1S同所有后缀的相似度的和 = 6 + 0 + 3 + 0 + 1 + 1 = 11【Input】输入一个字符串S，L为字符串S的长度，且S由a-z的小写字母组成。【Output】输出S同所有后缀的相似度的和。【Limited conditions】1 &lt;= L &lt;= 1000000【Sample input】ababaa【Sample output】11【Sample explanation】无 Record20min Analysis请先思考后再展开 exkmp裸题ex数组之和一开始忘开long long了，wa了一个 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>exkmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1462】回文串]]></title>
    <url>%2Fposts%2Ff89e.html</url>
    <content type="text"><![CDATA[Source and JudgeCaioj1462 Problem【Description】给出26个字母所代表的权值和一个字符串，要求把字符串分成两段（每一段长度至少为1，也就是必须要有字符），假如这一段子串是一个回文串，那么加上该串所有字符权值之和，求最大的权值和。【Input】输入一个整数T，表示数据组数.每组数据第一行输入26个数，表示26个字母的权值，第二行输入一个字符串【Output】输出每组数据的最大权值和【Limited conditions】保证字符串内全是小写字母,2&lt;=字符串长度&lt;=500000【Sample input】21 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1aba1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1acacac【Sample output】16【Sample explanation】无 Record30min Analysis请先思考后再展开 对于回文字符串，常用的特性：对称性然鹅有个更通俗易懂大众化的但是很容易被忽略的特性：反转后与原串一样而exkmp正好可以后缀匹配另一个的最长前缀 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>exkmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj5290】【Luogu4438】Hnoi2018道路]]></title>
    <url>%2Fposts%2Fd692.html</url>
    <content type="text"><![CDATA[Source and JudgeHnoi2018Bzoj5290Luogu4438 Problem【Description】W 国的交通呈一棵树的形状。W 国一共有 n - 1 个城市和 n 个乡村，其中城市从 1 到 n−1 编号，乡村从 1 到 n 编号，且 1 号城市是首都。道路都是单向的，本题中我们只考虑从乡村通往首都的道路网络。对于每一个城市，恰有一条公路和一条铁路通向这座城市。对于城市i， 通向该城市的道路（公路或铁路）的起点，要么是一个乡村，要么是一个编号比 i 大的城市。 没有道路通向任何乡村。除了首都以外，从任何城市或乡村出发只有一条道路；首都没有往 外的道路。从任何乡村出发，沿着唯一往外的道路走，总可以到达首都。W 国的国王小 W 获得了一笔资金，他决定用这笔资金来改善交通。由于资金有限，小 W 只能翻修 n−1 条道路。小 W 决定对每个城市翻修恰好一条通向它的道路，即从公路和铁 路中选择一条并进行翻修。小 W 希望从乡村通向城市可以尽可能地便利，于是根据人口调 查的数据，小 W 对每个乡村制定了三个参数，编号为 i 的乡村的三个参数是a,b,c 。假设 从编号为 i 的乡村走到首都一共需要经过 x 条未翻修的公路与 y 条未翻修的铁路，那么该乡村 的不便利值为(a+x)×(b+y)×c。在给定的翻修方案下，每个乡村的不便利值相加的和为该翻修方案的不便利值。 翻修 n−1 条道路有很多方案，其中不便利值最小的方案称为最优翻修方案，小 W 自然希望找到最优翻修方案，请你帮助他求出这个最优翻修方案的不便利值。【Input】第一行为正整数 n 。接下来 n−1 行，每行描述一个城市。其中第 i 行包含两个数 si,ti 。si 表示通向第 i 座城市 的公路的起点，ti 表示通向第i座城市的铁路的起点。如果si&gt;0 ，那么存在一条从第si 座城 市通往第 i 座城市的公路，否则存在一条从第 −si个乡村通往第i座城市的公路； ti 类似地，如 果 ti&gt;0 ，那么存在一条从第 ti 座城市通往第i座城市的铁路，否则存在一条从第 −ti 个乡村通 往第 i 座城市的铁路。接下来 n 行，每行描述一个乡村。其中第i行包含三个数 a,b,c，其意义如题面所示。【Output】输出一行一个整数，表示最优翻修方案的不便利值。【Limited conditions】n≤20000,1≤ai,bi≤60,1≤ci≤10^9，任意乡村可以通过不超过40条道路到达首都。【Sample input 1】62 34 5-1 -2-3 -4-5 -61 2 31 3 22 1 32 3 13 1 23 2 1【Sample output 1】54【Sample input 2】92 -23 -34 -45 -56 -67 -78 -8-1 -91 60 11 60 11 60 11 60 11 60 11 60 11 60 11 60 11 60 1【Sample output 2】548【Sample input 3】122 45 3-7 1011 9-1 68 7-6 -10-9 -4-12 -5-2 -3-8 -1153 26 49124 58 19017 37 35615 51 99730 19 3983 45 2752 55 83816 18 93158 24 21243 25 19854 15 17234 5 524【Sample output 3】5744902【Sample explanation】如图所示，我们分别用蓝色、黄色节点表示城市、乡村；用绿色、红色箭头分别表示 公路、铁路；用加粗箭头表示翻修的道路。一种不便利值等于54的方法是：翻修通往城市2和城市5的铁路，以及通往其他城市的 公路。用→和⇒表示公路和铁路，用∗→和∗⇒表示翻修的公路和铁路，那么：编号为1的乡村到达首都的路线为：-1 ∗→ 3 ⇒ 1，经过0条未翻修公路和1条未翻修铁 路，代价为3 × (1 + 0) × (2 + 1) = 9；编号为2的乡村到达首都的路线为：-2 ⇒ 3 ⇒ 1，经过0条未翻修公路和2条未翻修铁 路，代价为2 × (1 + 0) × (3 + 2) = 10；编号为3的乡村到达首都的路线为：-3 ∗→ 4 → 2 ∗→ 1，经过1条未翻修公路和0条未 翻修铁路，代价为3 × (2 + 1) × (1 + 0) = 9；编号为4的乡村到达首都的路线为：-4 ⇒ 4 → 2 ∗→ 1，经过1条未翻修公路和1条未翻 修铁路，代价为1 × (2 + 1) × (3 + 1) = 12；编号为5的乡村到达首都的路线为：-5 → 5 ∗⇒ 2 ∗→ 1，经过1条未翻修公路和0条未 翻修铁路，代价为2 × (3 + 1) × (1 + 0) = 8；编号为6的乡村到达首都的路线为：-6 ∗⇒ 5 ∗⇒ 2 ∗→ 1，经过0条未翻修公路和0条未翻修铁路，代价为1 × (3 + 0) × (2 + 0) = 6；总的不便利值为9 + 10 + 9 + 12 + 8 + 6 = 54。可以证明这是本数据的最优解。 Record30min Analysis请先思考后再展开 好菜啊，没想到记忆化，考试的时候打了个暴力主要是自己傻傻地把边拉出来决策……这样就根本不会联想到记忆化好吧 听说这个题当初省选现场没有省队大爷AC……这道题的精髓就在于，把2^n的大暴力通过记忆化变成了精悍的树形dp Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF838-B】Diverging Directions]]></title>
    <url>%2Fposts%2Fb187.html</url>
    <content type="text"><![CDATA[Source and JudgeCF838-B Problem【Description】西瓜们生活在编号 1⋯n 的 n个平行时空中，2n−2 台时光机将这些平行时空联系在一起。一台时光机有 3个整数参数 u,v,t 表示从时空 u 可以花费 t 的时间穿梭到时空 v。为了确保时空之间可以相互穿梭，同时方便作为现世的 1号时空的通行，西瓜们将这些时光机进行分工：前 n−1 台时光机确保从 1号时空可以直接 / 间接抵达任意时空，后 n−1台时光机负责从 2⋯n号时空直接返回 1号时空。【Input】第一行 3 个整数 n,q 分别表示 平行时空，操作 的个数。接下来 2n−2 行，每行 3 个整数 u,v,t 表示一台时光机。接下来 q 行，每行 3 个整数 id,x,y：若 $id=1$，表示第 $x$ 台时光机的运行时间变成了 $y$。若 $id=2$，表示当前有一个西瓜想要从时空 $x$ 穿梭到 时空 $y$；【Output】每次询问输出最短时间。【Limited conditions】n,q&lt;=2*10^6【Sample input】5 91 3 13 2 21 4 33 5 45 1 53 1 62 1 74 1 82 1 12 1 32 3 52 5 21 1 1002 1 31 8 302 4 22 2 4【Sample output】014810013210【Sample explanation】无 Record1h Analysis请先思考后再展开 显然是一个树类似树链剖分的思想，准确地说是dfs序如果对dfs序不是很懂的话，可以去看看这道经典题软件包管理器很水呀但是机房居然只有三个人过…… Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>树链剖分</tag>
        <tag>dfs序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1178】最长共同前缀长度]]></title>
    <url>%2Fposts%2Ff934.html</url>
    <content type="text"><![CDATA[Source and JudgeCaioj1178 Problem【Description】给出模板串A和子串B，长度分别为lenA和lenB，要求对于每个A[i],(1&lt;=i&lt;=lenA)，求出A[i..lenA]与B的最长公共前缀长度【Input】输入A，B两个串【Output】输出lenA个数，表示A[i…lenA]与B的最长公共前缀长度，每个数之前有空格【Limited conditions】lenB&lt;=lenA&lt;=1000000【Sample input】aabbabaaabaabb【Sample output】4 1 0 0 1 0 2 3 1 0【Sample explanation】无 Record2h Analysis请先思考后再展开 exkmp入门题，求ex数组详见：【OI之路】10字符串-3ExKMP Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>exkmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC096-b】Static Sushi]]></title>
    <url>%2Fposts%2Feb3b.html</url>
    <content type="text"><![CDATA[Source and JudgeARC096-b Problem【Description】给出包含n个寿司的圆环的圆周c，并按顺时针给出其与源点的顺时针距离从源点出发，从任何一个位置离开，总收获=寿司卡路里和-路上花费和【Input】N Cx1 v1x2 v2:xN vN【Output】最大收获【Limited conditions】1≤N≤10^52≤C≤10^141≤x1&lt;x2&lt;…&lt;xN&lt;C1≤vi≤10^9【Sample input】3 202 809 116 120【Sample output】192【Sample explanation】无 Record2h Analysis请先思考后再展开 考试的时候傻了，居然还想单调队列……然后到目前为止还是wa两个点代码太丑，何况还是错的，就不贴了 其实把前面的信息记录一下，然后后面就简单地取mx就好了 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3461】Oulipo]]></title>
    <url>%2Fposts%2Feaf4.html</url>
    <content type="text"><![CDATA[Source and JudgeBAPC 2006 QualificationPoj3461Caioj1460 Problem【Description】给出串A、B，判断A在B中出现次数，可重叠。【Input】第一行的正整数表示数据组数。每组数据两个不包含空格的字符串表示串A、B。【Output】每组数据输出一个数，表示匹配个数。【Limited conditions】字符串仅由大写字母组成。1 ≤ |A| ≤ 10,000|A| ≤ |B| ≤ 1,000,000.【Sample input】3BAPCBAPCAZAAZAZAZAVERDIAVERDXIVYERDIAN【Sample output】130【Sample explanation】无 Record30min Analysis1请先思考后再展开 这道题是kmp的经典入门问题 Code1请先思考后再展开 undefined Analysis2请先思考后再展开 然后这道题练习hash也是极好的$S(l,r)=f[r]-b^{r-l+1}\times f[l-1]$ Code2请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>难度1</tag>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3124】【Luogu3304】直径]]></title>
    <url>%2Fposts%2F15f6.html</url>
    <content type="text"><![CDATA[Source and JudgeSdoi2013Bzoj3124Luogu3304 Problem【Description】给定一棵树，求直径的长度，以及有多少条边满足【所有的直径都经过】。【Input】第一行包含一个整数N，表示节点数。接下来N-1行，每行三个整数a, b, c ，表示点 a和点b之间有一条长度为c的无向边。【Output】共两行。第一行一个整数，表示直径的长度。第二行一个整数，表示被所有直径经过的边的数量。【Limited conditions】2&lt;=N&lt;=200000，所有点的编号都在1..N的范围内，边的权值&lt;=10^9【Sample input】63 1 10001 4 104 2 1004 5 504 6 100【Sample output】11102【Sample explanation】直径共有两条，3 到2的路径和3到6的路径。这两条直径都经过边(3, 1)和边(1, 4)。 Record30min Analysis请先思考后再展开 很有趣的一道题思路来自akc大爷： 找出一条直径 把直径扯直，其它子树挂在上面，此时答案一定从其中产生 预处理出直径上前缀和、后缀和，以及每个子树的最大深度mxi 从右往左找到第一个满足【mx+sum=L（直径长度）】，则意味着排除左边所有边，记录此l 从左往右同理，记录r 于是我们就可以枚举左右端点去枚举这种情况：【mx1+sum+mx2=L】复杂度O(n) Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP14 D1T3】飞扬的小鸟]]></title>
    <url>%2Fposts%2Fad3d.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2014 提高组 D1T3Luogu1941Caioj1565 Problem【Description】Flappy Bird 是一款风靡一时的休闲手机游戏。玩家需要不断控制点击手机屏幕的频率来调节小鸟的飞行高度，让小鸟顺利通过画面右方的管道缝隙。如果小鸟一不小心撞到了水管或者掉在地上的话，便宣告失败。为了简化问题，我们对游戏规则进行了简化和改编：1. 游戏界面是一个长为 n ，高为 m 的二维平面，其中有 k 个管道（忽略管道的宽度）。2. 小鸟始终在游戏界面内移动。小鸟从游戏界面最左边任意整数高度位置出发，到达游戏界面最右边时，游戏完成。3. 小鸟每个单位时间沿横坐标方向右移的距离为1 ，竖直移动的距离由玩家控制。如果点击屏幕，小鸟就会上升一定高度X ，每个单位时间可以点击多次，效果叠加；如果不点击屏幕，小鸟就会下降一定高度Y 。小鸟位于横坐标方向不同位置时，上升的高度X 和下降的高度Y 可能互不相同。4. 小鸟高度等于0 或者小鸟碰到管道时，游戏失败。小鸟高度为 m 时，无法再上升。现在，请你判断是否可以完成游戏。如果可以 ，输出最少点击屏幕数；否则，输出小鸟最多可以通过多少个管道缝隙。【Input】第1 行有3 个整数n ，m ，k ，分别表示游戏界面的长度，高度和水管的数量，每两个整数之间用一个空格隔开；接下来的n 行，每行2 个用一个空格隔开的整数X 和Y ，依次表示在横坐标位置0 ~n- 1上玩家点击屏幕后，小鸟在下一位置上升的高度X ，以及在这个位置上玩家不点击屏幕时，小鸟在下一位置下降的高度Y 。接下来k 行，每行3 个整数P ，L ，H ，每两个整数之间用一个空格隔开。每行表示一个管道，其中P 表示管道的横坐标，L 表示此管道缝隙的下边沿高度为L ，H 表示管道缝隙上边沿的高度（输入数据保证P 各不相同，但不保证按照大小顺序给出）。【Output】共两行。第一行，包含一个整数，如果可以成功完成游戏，则输出1 ，否则输出0 。第二行，包含一个整数，如果第一行为1 ，则输出成功完成游戏需要最少点击屏幕数，否则，输出小鸟最多可以通过多少个管道缝隙。【Limited conditions】对于 30%的数据：5≤n≤10，5≤m≤10，k=0，保证存在一组最优解使得同一单位时间最多点击屏幕 3 次；对于 50%的数据：5≤n≤20，5≤m≤10，保证存在一组最优解使得同一单位时间最多点击屏幕 3 次；对于 70%的数据：5≤n≤1000，5≤m≤100；对于 100%的数据：5≤n≤10000，5≤m≤1000，0≤k&lt;n，0&lt;X&lt;m，0&lt;Y&lt;m，0&lt;P&lt;n，0≤L&lt;H ≤m，L+1&lt;H。【Sample input 1】10 10 63 99 91 21 31 21 12 12 11 62 21 2 75 1 56 3 57 5 88 7 99 1 3【Sample output 1】16【Sample input 2】10 10 41 23 12 21 81 83 22 12 12 21 21 0 26 7 99 1 43 8 10【Sample output 2】03【Sample explanation】如下图所示，蓝色直线表示小鸟的飞行轨迹，红色直线表示管道。 Record3h Analysis1请先思考后再展开 首先，题意不是很明确，有个细节：当高度达到m以上，并不是非法，而是视作m！解法1：bfs爆搜预计得分：75时间复杂度：$O(nm^2log_2(nm))$ Code1请先思考后再展开 undefined Analysis2请先思考后再展开 在上一个做法中，我们忽略了这道题一个重要的特性：方向固定（向右）所以是可以dp的把上升看作【多次背包】，下降看作【单次背包】 朴素的$O(nm^2)$：$$f[i][j] =\left{\begin{matrix}\underset{k}{min}(f[i-1][j-k\times x[i-1]])+k&amp; (j-k\times x[i-1]&gt;0) \\f[i-1][j+y[i-1]]&amp; (j+y[i-1]\leq m)\end{matrix}\right.$$ 然鹅，对于这之中耗时最多的枚举k，其实我们完全可以【放后影响】，从上一遍搞过来（显而易见，打bfs的时候想过但是不适用……然鹅dp是可以的）于是就下降到了$O(nm)$辣：$$f[i][j] =\left{\begin{matrix}min(f[i-1][j-x[i-1]],f[i][j-x[i-1])+1&amp; (j-x[i-1]&gt;0) \\f[i-1][j+y[i-1]]&amp; (j+y[i-1]\leq m)\end{matrix}\right.$$ 注意：对于撞到管子的$f[i][j]$，还是要计算的，因为有这种情况：我们从$f[i][j-x[i-1]]$转移过来，它撞墙了，但$f[i][j]$没有撞墙，它去没得继承了。所以要顺便说一句：感觉这个dp很像维护一个二维前缀 所以，综上所述，对于每一列： 无视水管，dp（特判m的情况），只考虑上升做多重背包 水管上，还原为inf 水管空档的下降，01背包 总结：如果有单向性，先考虑一下dp，再去想爆搜 Code2请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP14 D2T1】无线网络发射器选址]]></title>
    <url>%2Fposts%2F3a8c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2014 提高组 D2T1Luogu1941Caioj1566 Problem【Description】假设某城市的布局为由严格平行的129 条东西向街道和129 条南北向街道所形成的网格状，并且相邻的平行街道之间的距离都是恒定值 1。东西向街道从北到南依次编号为0,1,2…128 , 南北向街道从西到东依次编号为0,1,2…128。东西向街道和南北向街道相交形成路口，规定编号为 x 的南北向街道和编号为 y 的东西向街道形成的路口的坐标是（x, y）。在某些路口存在一定数量的公共场所。由于政府财政问题，只能安装一个大型无线网络发射器。该无线网络发射器的传播范围是一个以该点为中心，边长为 2*d 的正方形。传播范围包括正方形边界。例如下图是一个d = 1 的无线网络发射器的覆盖范围示意图。现在政府有关部门准备安装一个传播参数为 d 的无线网络发射器，希望你帮助他们在城市内找出合适的安装地点，使得覆盖的公共场所最多。【Input】第一行包含一个整数 d，表示无线网络发射器的传播距离。第二行包含一个整数 n，表示有公共场所的路口数目。接下来 n 行，每行给出三个整数 x, y, k, 中间用一个空格隔开，分别代表路口的坐标(x, y)以及该路口公共场所的数量。同一坐标只会给出一次。【Output】输出一行，包含两个整数，用一个空格隔开，分别表示能覆盖最多公共场所的安装地点方案数，以及能覆盖的最多公共场所的数量。【Limited conditions】1 ≤ d ≤ 20，1 ≤ n ≤ 20， 0 ≤ x ≤ 128, 0 ≤ y ≤ 128, 0 &lt; k ≤ 1,000,000【Sample input】124 4 106 6 20【Sample output】1 30【Sample explanation】无 Record10min Analysis请先思考后再展开 sb题 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP14 D1T2】联合权值]]></title>
    <url>%2Fposts%2Fb8ea.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2014 提高组 D1T2Luogu1351Caioj1564 Problem【Description】给出一棵树，点从 1 到 n 依次编号，编号为 i 的点的权值为Wi ，每条边的长度均为1 。对于点对(u, v) ，若它们的距离为2 ，则它们之间会产生Wu×Wv 的联合权值。请问所有可产生联合权值的有序点对中，联合权值最大的是多少？所有联合权值之和是多少？【Input】第一行包含1 个整数n 。接下来n - 1 行，每行包含 2 个用空格隔开的正整数u 、v ，表示编号为 u 和编号为v 的点之间有边相连。最后1 行，包含 n 个正整数，每两个正整数之间用一个空格隔开，其中第 i 个整数表示图G 上编号为i 的点的权值为W i 。【Output】输出共1 行，包含2 个整数，之间用一个空格隔开，依次为图G 上联合权值的最大值和所有联合权值之和。由于所有联合权值之和可能很大，输出它时要对10007 取余。【Limited conditions】对于30% 的数据，1 &lt; n≤ 100 ；对于60% 的数据，1 &lt; n≤ 2000；对于100%的数据，1 &lt; n≤ 200 , 000 ，0 &lt; wi≤ 10, 000 。【Sample input】51 22 33 44 51 5 2 3 10【Sample output】20 74【Sample explanation】本例输入的图如上所示，距离为2 的有序点对有( 1,3) 、( 2,4) 、( 3,1) 、( 3,5) 、( 4,2) 、( 5,3) 。其联合权值分别为2 、15、2 、20、15、20。其中最大的是20，总和为74。 Record20min Analysis请先思考后再展开 先把有序变无序，sum乘2即可那么只有两种情况： 与祖父搞 和同父亲的哥哥搞 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP14 D1T1】生活大爆炸版石头剪刀布]]></title>
    <url>%2Fposts%2Fe3ff.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2014 提高组 D1T1Luogu1328Caioj1563 Problem【Description】石头剪刀布是常见的猜拳游戏：石头胜剪刀，剪刀胜布，布胜石头。如果两个人出拳一样，则不分胜负。在《生活大爆炸》第二季第8 集中出现了一种石头剪刀布的升级版游戏。升级版游戏在传统的石头剪刀布游戏的基础上，增加了两个新手势：斯波克：《星际迷航》主角之一。蜥蜴人：《星际迷航》中的反面角色。这五种手势的胜负关系如表一所示，表中列出的是甲对乙的游戏结果。现在，小A 和小B 尝试玩这种升级版的猜拳游戏。已知他们的出拳都是有周期性规律的，但周期长度不一定相等。已知小A 和小B 一共进行N 次猜拳。每一次赢的人得1 分，输的得0 分；平局两人都得0 分。现请你统计N 次猜拳结束之后两人的得分。【Input】第一行包含三个整数：N ，NA，NB，分别表示共进行 N 次猜拳、小 A 出拳的周期长度，小B 出拳的周期长度。数与数之间以一个空格分隔。第二行包含NA个整数，表示小 A 出拳的规律，第三行包含NB个整数，表示小 B 出拳的规律。其中，0 表示“剪刀”，1 表示“石头”，2 表示“布”，3 表示“蜥蜴人”， 4 表示“斯波克”。数与数之间以一个空格分隔。【Output】输出一行， 包含两个整数，以一个空格分隔，分别表示小A 、小B 的得分。【Limited conditions】0 &lt; N ≤ 200 ，0 &lt; NA ≤ 200 ， 0 &lt; NB ≤ 200 。【Sample input】9 5 50 1 2 3 41 0 3 2 4【Sample output】4 4【Sample explanation】无 Record10min Analysis请先思考后再展开 sb题 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP13 D2T3】华容道]]></title>
    <url>%2Fposts%2F23c4.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2013 提高组 D2T3Luogu1979Caioj1562 Problem【Description】给定一种局面，华容道是否根本就无法完成，如果能完成，最少需要多少时间。游戏规则：1. 在一个 n*m 棋盘上有 n*m 个格子，其中有且只有一个格子是空白的，其余 n*m-1个格子上每个格子上有一个棋子，每个棋子的大小都是 1*1 的；2. 有些棋子是固定的，有些棋子则是可以移动的；3. 任何与空白的格子相邻（有公共的边）的格子上的棋子都可以移动到空白格子上。 游戏的目的是把某个指定位置可以活动的棋子移动到目标位置。给定一个棋盘，游戏可以玩 q 次，当然，每次棋盘上固定的格子是不会变的，但是棋盘上空白的格子的初始位置、指定的可移动的棋子的初始位置和目标位置却可能不同。第 i 次玩的时候，空白的格子在第 EX 行第 EY 列，指定的可移动棋子的初始位置为第 SX 行第 SY 列，目标位置为第 TX 行第 TY 列。假设小 B 每秒钟能进行一次移动棋子的操作，而其他操作的时间都可以忽略不计。请你告诉小 B 每一次游戏所需要的最少时间，或者告诉他不可能完成游戏。【Input】第一行有 3 个整数，每两个整数之间用一个空格隔开，依次表示 n、m 和 q；接下来的 n 行描述一个 n*m 的棋盘，每行有 m 个整数，每两个整数之间用一个空格隔开，每个整数描述棋盘上一个格子的状态，0 表示该格子上的棋子是固定的，1 表示该格子上的棋子可以移动或者该格子是空白的。接下来的 q 行，每行包含 6 个整数依次是Ex、Ey、SX、SY、TX、TY，每两个整数之间用一个空格隔开，表示每次游戏空白格子的位置，指定棋子的初始位置和目标位置。【Output】输出有 q 行，每行包含 1 个整数，表示每次游戏所需要的最少时间.如果某次游戏无法完成目标则输出−1。【Limited conditions】对于 30%的数据，1 ≤ n, m ≤ 10，q = 1；对于 60%的数据，1 ≤ n, m ≤ 30，q ≤ 10；对于 100%的数据，1 ≤ n, m ≤ 30，q ≤ 500。【Sample input】3 4 20 1 1 10 1 1 00 1 0 03 2 1 2 2 21 2 2 2 3 2【Sample output】3【Sample explanation】棋盘上划叉的格子是固定的，红色格子是目标位置，圆圈表示棋子，其中绿色圆圈表示目标棋子。第一次游戏，空白格子的初始位置是 (3, 2)（图中空白所示），游戏的目标是将初始位置在(1, 2)上的棋子（图中绿色圆圈所代表的棋子）移动到目标位置(2, 2)（图中红色的格子）上。移动过程如下：第二次游戏，空白格子的初始位置是（1, 2）（图中空白所示），游戏的目标是将初始位置在（2, 2）上的棋子（图中绿色圆圈所示）移动到目标位置 (3, 2)上。要将指定块移入目标位置，必须先将空白块移入目标位置，空白块要移动到目标位置，必然是从位置（2， 2）上与当前图中目标位置上的棋子交换位置，之后能与空白块交换位置的只有当前图中目标位置上的那个棋子，因此目标棋子永远无法走到它的目标位置， 游戏无法完成。 Record5h Analysis请先思考后再展开 这是一道有脑子的搜索题 本质上就是空白的棋子到处和别人交换来达成目标，固定即不可交换那么只要记录当前空白的位置和目标棋子的位置，就可以bfs了，据说有70分时间复杂度：O(q(nm)^2)，虽然稳tle，但考场上还是灰常值得的，也可以拿来拍 那我们梳理一下，可以这样想象：目标棋子和前面的空白交换，然后空白到后面之后，又屁颠屁颠地跑到目标棋子前面……周边的普通棋子就像群众，一旦墙壁明确，存在性等同于空气。怎么样，题意是不是明确了很多显然仅当【空白在棋子旁边】的状态是有用的，仅有3600种！但是我们虽然减少了状态，但并不代表忽略bfs还是要有的，但不能每一次都搞呀，不然还是炸（特别是无解的时候）因为如果指定棋子要移动，首先空格要到它旁边，而这段信息基本是公共的，尽管空格位置每次不同。也就是说，需要计算出dis(ax,ay,bx,by,d)，分别表示空格和指定棋子位置以及最后空格在棋子的方位（0表示下方，1表示上方，2表示左方，3表示右方）注意！没有必要枚举两点，用到的时候再处理而且，不能忽略终点来bfs（我一开始是这样想的），因为bfs的要求是不能穿越终点（否则空格就会影响到当前棋子的值，而这个我们应单独处理） 那么搜索中有个强大的东西：A*！教程的话，因为也在很多领域有应用，所以网上有灰常多的资料。然后据说这东西的神奇之处在于，对于搜索题，帮你搞定很多想不到的剪枝。但我对这东西不是太熟练，特别是其使用条件（适用范围） 首先，预处理出相邻可移动棋子的距离（用于求解中） 估价函数h(n)：指定棋子到终点位置的曼哈顿距离 实际代价函数g(n)：当前步数 open表：搞一个小根堆即可（ f*(n)=h*(n)+g*(n) ） hash表：hash(state.x,state.y,state.d)=min{ g(state) } 那么，对于每一次求解，先预处理这一次bfs距离值然后每一次取出小根堆中第一个来拓展然后两种情况： 空格与棋子交换，注意方向调换 空格走到棋子其他侧 最后说一句，这道题既考验脑力，也考验码力，挺不错的 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>原创精品</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>bfs</tag>
        <tag>spfa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1379】八数码]]></title>
    <url>%2Fposts%2F6628.html</url>
    <content type="text"><![CDATA[Source and Judge经典问题Luogu1379Caioj1046 Problem【Description】在3×3的棋盘上，摆有八个棋子，每个棋子上标有1至8的某一数字。棋盘中留有一个空格，空格用0来表示。空格周围的棋子可以移到空格中。要求解的问题是：给出一种初始布局（初始状态）和目标布局（为了使题目简单,设目标状态为123804765），找到一种最少步骤的移动方法，实现从初始布局到目标布局的转变。【Input】输入初始状态，一行九个数字，空格用0表示。【Output】只有一行，该行只有一个数字，表示从初始状态到目标状态需要的最少移动次数(测试数据中无特殊无法到达目标状态数据)【Limited conditions】无【Sample input】283104765【Sample output】4【Sample explanation】无 Record30min Analysis请先思考后再展开 这道题可谓搜索算法的超级经典入门题然后方法也灰常多，康托展开（如今看来没有什么卵用，而且想想就知道了）、bool数组乱搞那么今天因为要用到A*算法，打算用这道题试一试然后网上看到一个大概是acmer的，炒鸡变态地用八种做法做了：强烈推介 那关于A*的做法教程，这篇文章还是挺好的：this Code请先思考后再展开 然鹅我并不想打搜索题了……]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP13 D2T2】花匠]]></title>
    <url>%2Fposts%2F56ba.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2013 提高组 D2T2Luogu1970Caioj1561 Problem【Description】花匠栋栋种了一排花，每株花都有自己的高度。花儿越长越大，也越来越挤。栋栋决定把这排中的一部分花移走，将剩下的留在原地，使得剩下的花能有空间长大，同时，栋栋希望剩下的花排列得比较别致。具体而言，栋栋的花的高度可以看成一列整数h1, h2, … , hn。设当一部分花被移走后，剩下的花的高度依次为g1, g2, … , gm，则栋栋希望下面两个条件中至少有一个满足（i为正整数）：注意上面两个条件在m = 1时同时满足，当m &gt; 1时最多有一个能满足。请问，栋栋最多能将多少株花留在原地。【Input】输入的第一行包含一个整数n，表示开始时花的株数。第二行包含n个整数，依次为h1,h2..hn,表示每株花的高度。【Output】输出一行，包含一个整数m，表示最多能留在原地的花的株数。【Limited conditions】对于 20%的数据，n ≤ 10；对于 30%的数据，n ≤ 25；对于 70%的数据，n ≤ 1000，0 ≤ ℎi≤ 1000；对于 100%的数据，1 ≤ n ≤ 100,000，0 ≤ hi≤ 1,000,000，所有的 hi 随机生成，所有随机数服从某区间内的均匀分布。【Sample input】55 3 2 1 2【Sample output】3【Sample explanation】有多种方法可以正好保留 3 株花，例如，留下第 1、4、5 株，高度分别为 5、1、2，满足条件 B。 Record30min Analysis请先思考后再展开 贪心即可 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP13 D2T1】积木大赛]]></title>
    <url>%2Fposts%2Fd499.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2013 提高组 D2T1Luogu1969Caioj1560 Problem【Description】一座宽度为n的大厦可以看成由n块宽度为1的积木组成，第i块积木的最终高度需要是hi。在搭建开始之前，没有任何积木（可以看成n块高度为 0 的积木）。接下来每次操作，小朋友们可以选择一段连续区间[l, r]，然后将第第 L 块到第 R 块之间（含第 L 块和第 R 块）所有积木的高度分别增加1。小 M 是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。【Input】输入包含两行，第一行包含一个整数n，表示大厦的宽度。第二行包含n个整数，第i个整数为hi 。【Output】仅一行，即建造所需的最少操作数。【Limited conditions】对于 30%的数据，有1 ≤ n ≤ 10；对于 70%的数据，有1 ≤ n ≤ 1000；对于 100%的数据，有1 ≤ n ≤ 100000，0 ≤ hi≤ 10000。【Sample input】52 3 4 1 2【Sample output】5【Sample explanation】其中一种可行的最佳方案，依次选择1[1,5][1,3][2,3][3,3][5,5] Record30min Analysis请先思考后再展开 这道题很容易被数据结构和数据范围误导啊然后我又是没有什么好思路不要脸地去膜“普及-”的题解……然后坚定了我noip前必刷usaco的想法 原来方案看起来是灰常复杂的，但是只要求次数，那么问题的难度会暴跌为什么呢？因为答案的单一性意味着可以边搞边调整方案，甚至不理会具体方案 对于这道题，把积木看作山峰，不难发现费用都和上坡有关，因为下坡必然能由上坡搞定所以只要记录上一个，每次比较判断是否为山峰，然后更新答案即可。 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>好题</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP13 D1T3】货车运输]]></title>
    <url>%2Fposts%2F622b.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2013 提高组 D1T3Luogu1967 Problem【Description】A 国有 n 座城市，编号从 1 到 n，城市之间有 m 条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有 q 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。【Input】第一行有两个用一个空格隔开的整数 n，m，表示 A 国有 n 座城市和 m 条道路。接下来 m 行每行 3 个整数 x、 y、 z，每两个整数之间用一个空格隔开，表示从 x 号城市到 y 号城市有一条限重为 z 的道路。注意： x 不等于 y，两座城市之间可能有多条道路 。接下来一行有一个整数 q，表示有 q 辆货车需要运货。接下来 q 行，每行两个整数 x、y，之间用一个空格隔开，表示一辆货车需要从 x 城市运输货物到 y 城市，注意： x 不等于 y 。【Output】输出共有 q 行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出-1。【Limited conditions】对于 30%的数据，0 &lt; n &lt; 1,000，0 &lt; m &lt; 10,000，0 &lt; q&lt; 1,000；对于 60%的数据，0 &lt; n &lt; 1,000，0 &lt; m &lt; 50,000，0 &lt; q&lt; 1,000；对于 100%的数据，0 &lt; n &lt; 10,000，0 &lt; m &lt; 50,000，0 &lt; q&lt; 30,000，0 ≤ z ≤ 100,000。【Sample input】4 31 2 42 3 33 1 131 31 41 3【Sample output】3-13【Sample explanation】无 Record30min Analysis请先思考后再展开 先求出最大生成树，证明见我生成树相关的证明既然是树了，那两点间路径就一条，相当于查询最小值罢了。然后因为是稀疏图，就用kruskal，实在是森林就-1至于查询，因为没有修改，不用出动树链剖分，直接倍增即可。 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>生成树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP11 D1T2】选择客栈]]></title>
    <url>%2Fposts%2Fec55.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2011 提高组 D1T2Luogu1311 Problem【Description】丽江河边有n家很有特色的客栈，客栈按照其位置顺序从1到n编号。每家客栈都按照某一种色调进行装饰（总共k种，用整数0~ k-1表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过p。他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过p元的咖啡店小聚。【Input】第一行三个整数n，k，p，每两个整数之间用一个空格隔开，分别表示客栈的个数，色调的数目和能接受的最低消费的最高值；接下来的n行，第i+1行两个整数，之间用一个空格隔开，分别表示i号客栈的装饰色调和i号客栈的咖啡店的最低消费。【Output】输出只有一行，一个整数，表示可选的住宿方案的总数。【Limited conditions】对于30% 的数据，有 n ≤100；对于50% 的数据，有 n ≤1,000；对于100%的数据，有 2 ≤n ≤200,000，0&lt;k ≤50，0≤p ≤100 ， 0 ≤最低消费≤100。【Sample input】5 2 30 51 30 21 41 5【Sample output】3【Sample explanation】2 人要住同样色调的客栈，所有可选的住宿方案包括：住客栈①③，②④，②⑤，④⑤，但是若选择住4 、5 号客栈的话，4 、5 号客栈之间的咖啡店的最低消费是4 ，而两人能承受的最低消费是3 元，所以不满足要求。因此只有前 3 种方案可选。 Record30min Analysis请先思考后再展开 对于区间问题，可以考虑枚举其中一个端点然后以当前颜色最后一个可行点代表前面的可行点去累计答案 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP13 D1T2】火柴排队]]></title>
    <url>%2Fposts%2F421b.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2013 提高组 D1T2Luogu1966Caioj1558 Problem【Description】两个长为 n 的序列 a,b ，定义两个序列的距离为：sigma (ai-bi)^2每个序列中相邻两个位置的数可以交换，问最少需要交换多少次，可以最小化这个柿子？最小交换次数对 99,999,997 取模。【Input】共三行，第一行包含一个整数 n。第二行有 n 个整数，每两个整数之间用一个空格隔开，表示第一列数。第三行有 n 个整数，每两个整数之间用一个空格隔开，表示第二列数。【Output】输出共一行，包含一个整数，表示最少交换次数对 99,999,997 取模的结果。【Limited conditions】对于 10%的数据， 1 ≤ n ≤ 10；对于 30%的数据，1 ≤ n ≤ 100；对于 60%的数据，1 ≤ n ≤ 1,000；对于 100%的数据，1 ≤ n ≤ 100,000，0 ≤火柴高度≤ maxint【Sample input】41 3 4 21 7 2 4【Sample output】2【Sample explanation】最小距离是 10，最少需要交换 2 次，比如：交换第 1 列的中间 2 根火柴的位置，再交换第 2 列中后 2 根火柴的位置。 Record30min Analysis请先思考后再展开 显然为了让两列差值最小，让【两边同一排名的在一行】显然是最优的（可以自己推推柿子，其他调整不会更优）那么既然只关心排名，先离散化一波 然后两边保证不同，是两个排列，现在要对齐将右边变成1、2、3……左边对应修改然后就相当于对左边排序，逆序对即可 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>难度2</tag>
        <tag>模拟</tag>
        <tag>归并排序</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP13 D1T1】转圈游戏]]></title>
    <url>%2Fposts%2Fd86a.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2013 提高组 D1T1Luogu1965Caioj1557 Problem【Description】n 个小伙伴（编号从 0 到 n-1）围坐一圈玩游戏。按照顺时针方向从0 到 n-1，给 n 个位置编号。最初，第 0 号小伙伴在第 0 号位置，第 1 号小伙伴在第 1 号位置，……，依此类推。游戏规则如下：每一轮第 0 号位置上的小伙伴顺时针走到第 m 号位置，第 1 号位置小伙伴走到第 m+1 号位置，……，依此类推，第n−m号位置上的小伙伴走到第 0 号位置，第n-m+1 号位置上的小伙伴走到第 1 号位置，……，第 n-1 号位置上的小伙伴顺时针走到第m-1 号位置。现在，一共进行了 10^k轮，请问 x 号小伙伴最后走到了第几号位置。【Input】输入共 1 行，包含 4 个整数 n、m、k、x，每两个整数之间用一个空格隔开。【Output】输出共 1 行，包含 1 个整数，表示 10^k 轮后 x 号小伙伴所在的位置编号。【Limited conditions】对于 30%的数据，0 &lt; k &lt; 7；对于 80%的数据，0 &lt; k &lt; 10^7；对于 100%的数据，1 &lt;n &lt; 1,000,000，0 &lt; m &lt; n，1 ≤ x ≤ n，0 &lt; k &lt; 10^9【Sample input】10 3 4 5【Sample output】5【Sample explanation】无 Record10min Analysis请先思考后再展开 sb题ans=x+10^k*m (mod n) Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hdu4902】Nice boat]]></title>
    <url>%2Fposts%2Fddc6.html</url>
    <content type="text"><![CDATA[Source and Judge2014 Multi-University Training Contest 4作者：陈立杰%%%Hdu4902 Problem【Description】多组数据给你n个数，Q次操作操作分两类对于第一类操作(type1)，将区间[l,r]内的数改成x对于第二类操作(type2)，将区间[l,r]内&gt;x的a[i]$改成gcd(x,a[i])你需要输出Q次操作后的序列【Input】第一行正整数T，表示数据组数第一行两个数n,Q接着一行n个数a[i]接下来Q行，每行四个数type,l,r,x，分别代表操作类型，操作区间[l,r]和x【Output】每行n个数，代表Q次操作后的序列，用空格隔开【Limited conditions】n,Q&lt;=100000,0&lt;=x,a[i]&lt;=2^31-1【Sample input】11016807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709101 3 6 742430422 4 8 165317291 3 4 14748331692 1 8 11315709332 7 9 15057953352 3 7 1019292671 4 10 16243791492 2 8 21100106722 6 7 1560917451 2 5 937186357【Sample output】16807 937186357 937186357 937186357 937186357 1 1 1624379149 1624379149 1624379149【Sample explanation】无 Record1h Analysis请先思考后再展开 第一眼就觉得是线段树然后gcd有点烦证明了单纯地gcd是可以叠加的但这道题对于操作对象有讲究所以就不叠加了 比赛的时候码了半小时吧，然后对拍了两小时，还是比较稳的对了，那时候看错时限了，以为是1s（其实是1.5s），然后自己造极限数据，跑了0.95s，于是还搞了点卡常 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1529】【Luogu3420】ska Piggy banks]]></title>
    <url>%2Fposts%2Ff249.html</url>
    <content type="text"><![CDATA[Source and JudgePOI2005Bzoj1529Luogu3420 Problem【Description】Byteazar the Dragon拥有N个小猪存钱罐。每一个存钱罐能够用相应的钥匙打开或者被砸开。Byteazar已经将钥匙放入到一些存钱罐中。现在已知每个钥匙所在的存钱罐，Byteazar想要买一辆小汽车，而且需要打开所有的存钱罐。然鹅，他想要破坏尽量少的存钱罐，帮助Byteazar去决策最少要破坏多少存钱罐。【Input】第一行一个整数 N 表示存钱罐的总数.接下来每行一个整数,第 i+1行的整数代表第i个存钱罐的钥匙放置的存钱罐编号.【Output】一个整数表示最少打破多少个存钱罐.【Limited conditions】1&lt;=N&lt;=1000000【Sample input】42124【Sample output】2【Sample explanation】无 Record30min Analysis1请先思考后再展开 考试的时候打的是强连通，然后被卡空间了 首先，可以通过存储关系建边构图然后最无敌的做法：强连通缩点，统计入度为0的点然后比赛的时候这样是能AC的当然 Code1请先思考后再展开 undefined Analysis2请先思考后再展开 那么上面的做法在bzoj中是会被卡空间的（好像是爆栈）那么有没有更优美的做法呢？来看看题目中的特殊条件你看，边只有n条，那么对于一个强联通块，显然只会有一个入口既然如此，答案就是多少个联通块那在这道题中，强连通块和双向边块是等效的，因为每个点只会有一个入边（不排除是自己）所以用并查集就好啦 Code2请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>难度2</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3784】树上的路径]]></title>
    <url>%2Fposts%2F1486.html</url>
    <content type="text"><![CDATA[Source and JudgeBzoj3784 Problem【Description】给定一个n个结点的树，结点用正整数1..n编号，每条边有一个正整数权值。用d(a,b)表示从结点a到结点b路边上经过边的权值，输出前大M的距离（去同两个点）。【Input】第一行两个正整数N,M下面N-1行，每行三个正整数a,b,c。表示结点a到结点b有一条权值为c的边。【Output】共M行，如题所述。【Limited conditions】a,b&lt;=n，c&lt;=10000N&lt;=50000M&lt;=Min(300000,n*(n-1)/2)【Sample input】5 101 2 11 3 22 4 32 5 4【Sample output】7 7 6 5 4 4 3 3 2 1【Sample explanation】无 Record2h Analysis请先思考后再展开 首先，有个弱化版：超级钢琴那么现在假设你已经理解了上面这道题 然后我们从暴力开始思考，显然枚举每个起点dfs去搞，复杂度是n^2的 然后既然是前m大，当然是用堆维护尝试枚举起点后，搞出一个dfs序，那么以【数量与深度有关的每个父亲】作为中介，搞出一条条链，而且显然【终点】是连续的。那么因为不能重复，考虑对于点y，只找dfs序比y小的点x。为了方便，不先枚举起点，而是先枚举中介父亲，然后才是起点。于是现在每个点被访问的次数是深度，复杂度是深度*n 那么现在大概就能拿到不错的分数了但是很容易被链啊，扫把啊什么的卡主要是这个“深度”所以点分治一波就好啦然后就是nlogn了 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>点分治</tag>
        <tag>难度2</tag>
        <tag>st表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOI2010】超级钢琴]]></title>
    <url>%2Fposts%2Fe5b3.html</url>
    <content type="text"><![CDATA[Source and JudgeBzoj2006Luogu2048 Problem【Description】求给定序列中长度为L~R之间的前k大子串（连续）的和【Input】输入第一行包含四个正整数n, k, L, R。其中n为音符的个数，k为乐曲所包含的超级和弦个数，L和R分别是超级和弦所包含音符个数的下限和上限。接下来n行，每行包含一个整数Ai，表示按编号从小到大每个音符的美妙度。【Output】输出只有一个整数，表示乐曲美妙度的最大值。【Limited conditions】-1000≤Ai≤1000，1≤L≤R≤n且保证一定存在满足要求的乐曲。【Sample input】4 3 2 332-68【Sample output】11【Sample explanation】共有5种不同的超级和弦：1. 音符1~2，美妙度为3 + 2 = 52. 音符2~3，美妙度为2 + (-6) = -43. 音符3~4，美妙度为(-6) + 8 = 24. 音符1~3，美妙度为3 + 2 + (-6) = -15. 音符2~4，美妙度为2 + (-6) + 8 = 4最优方案为：乐曲由和弦1，和弦3，和弦5组成，美妙度为5+2+4=11。 Record2h Analysis请先思考后再展开 哇发现所谓st表就是Sparse Table然后最大子串，也就是区间，如果用前缀和表示，那么当确定一个右端点r，就是要找一个区间内最小的前缀和值来确定l，那么可以用一个st表来搞 有个要注意的点就是，因为不能重复，拿出一个点，需要把两个左右边填回去 然后就算比较水了，提高+吧 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>st表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1112】砖块]]></title>
    <url>%2Fposts%2F2ed3.html</url>
    <content type="text"><![CDATA[Source and JudgePOI2008Bzoj1112 Problem【Description】给出n个数，希望有连续k个是一样的。可以由两种操作：1. 一个数-12. 一个数+1求完成任务的最少操作数【Input】第一行给出N,K。下面N行,每行代表这柱砖的高度.【Output】最小的动作次数【Limited conditions】1≤k≤n≤1000000≤hi≤1000000【Sample input】5 339231【Sample output】2【Sample explanation】无 Record2h Analysis请先思考后再展开 等价于，对于一个长度为k的区间，把所有数变成数轴上的点，找到一个位置使所有点到此距离之和最小。之前在糖果中讲过，这个位置必然是中位数，否则存在使答案更小的办法。 然后搞一个数据结构，维护一下第k大来找中位数，统计答案即可。然后类似在数轴上滑动的一个窗，从而利用之前的信息而不必重构（显然考试的时候还是忘记啦）时间复杂度：$O(nlogn)$ 考试的时候打了个很挫的主席树，而且没想到可以搞中位数，只想到是抛物线至于二次函数上三分……不会，好像也蛮慢的 Code1先来一发无脑splay好处是值可以灰常大而不受限制，空间也少一个log请先思考后再展开 undefined Code2是不是觉得巨长？其实有代码又短，常数又小的树状数组小心空间复杂度请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>伸展树</tag>
        <tag>难度2</tag>
        <tag>中位数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1084】【Bzoj1465】【Bzoj1045】糖果传递]]></title>
    <url>%2Fposts%2Ffa4.html</url>
    <content type="text"><![CDATA[Source and JudgeHAOI2008Luogu2512Bzoj1045Bzoj1465 Problem【Description】有n个小朋友坐成一圈，每人有ai个糖果。每人只能给左右两人传递糖果。每人每次传递一个糖果代价为1。【Input】小朋友个数n下面n个ai【Output】使所有人获得均等糖果的最小代价。【Limited conditions】n&lt;=1000000【Sample input】41 2 5 4【Sample output】4【Sample explanation】无 Record1h Analysis请先思考后再展开 首先，为了方便，把传递的双向改为单向（例如左边），这样传递量可能是负数。 $a[i]$=原本干草数$ed$=期望干草数$x[i]$=给左边干草数(可能是负数) $a[i]-x[i]+x[i+1]=ed$$\Rightarrow x[i+1]=x[i]-(a[i]-ed)$对于第1堆：$x[1]=x[n]-(a[n]-ed)=x[1]$ （还是使用x[1]本身较适合）对于第2堆：$x[2]=x[1]-(a[2]-ed)$对于第3堆：$x[3]=x[2]-(a[3]-ed)=x[1]-(a[2]-ed)-(a[3]-ed)$为了简化模型，变成单变量极值问题定义$c[i]=c[i-1]+(a[i]-ed)（i&gt;1,可能是负数）$于是$x[i]=x[1]-c[i]$ 我们希望 $答案=|x[2]|….+|x[n]|$ 最小也就是 $|x[1]-c[2]|….+|x[1]-c[n]|$ 最小 注意c[1]=0 所以现在x1是变量，而c是常量 绝对值几何意义：数轴上两点距离所以问题变成了：数轴上的n个点，找出一个【到他们的距离】之和最小的点问题解答：中位数 所以原题解答：$最好的x[1]=c的中位数$$ans=\sum_{i=2}^n abs(x1-c[i])$ 中位数证明：想象数轴上任意一点，首先假设，它左边有4个点，右边有2个点，把该点往左移动d单位距离（并且不碰到别的点），距离之和减少了2d当右边点较多时同理，【左右点数量差】越小越好，即最好的是中位数如果输入点有奇数个，则最优解应该是中间那个点即中位数如果有偶数个，则可以位于最中间两个点的任意位置（还是可用中位数解决） 另外，以后只要转化为这个数轴模型，就能使用中位数解决 然后这道题是很久以前做的，今天打比赛碰到类似题没想出来……同学提醒我做过这样一道题 所以有兴趣的也可以看看这道类似题：砖块 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>中位数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj5194】Snow Boots]]></title>
    <url>%2Fposts%2F1f6f.html</url>
    <content type="text"><![CDATA[Source and JudgeUSACO 2018 February Gold 原题 Bzoj5194 Luogu4269 Problem【Brief description】N个点，从1开始编号，第i个位置有个ai有b双鞋，每双有两个属性s和d，使你能走过所有ai&lt;=s的地方，并且跳跃时一次最多能跳d步求每一双鞋子能否只用它从1到达n（确保这两个位置ai=0）【Input】第一行包含两个空格分隔的整数N和B。第二行包含N个空格分隔的整数，表示a。下面b行，每行两个数，表示s和d。【Output】n行，用0和1表示可行性【Limited conditions】1≤N,B≤10^50≤ai≤10^90≤s≤10^91≤d≤N-1【Sample input】8 70 3 8 5 6 9 0 00 50 66 28 110 15 3150 7【Sample output】0110111【Sample explanation】无 Record1h Analysis请先思考后再展开 首先要明确，从1到n的时候，是既可以走（+1）也可以跳（+d以内）的 那么显然，对于一只鞋，我们需要的，就是判断它所不能走的地方最大连续长度，只要这个最大长度是比d小的，就是能走过去的。 【因为做题量少+被“过河”误导+被没说清楚的题目误导（原来是可以跳短一点的），担心了各种细节，把题意复杂化了，所以考试的时候战略性放弃了】 开始讲做法： 把鞋子按照s从大到小排序，然后把点也按照从大到小排序个序 现在按排序还处理鞋子，这样能走的点只会减少，把能走的点用链表维护 维护一个【最大的能走的点间距离】，那么也就是最长的不能走的长度 每次删除链表中的点时，距离只会变大，更新一下答案即可 时间复杂度：O(nlogn+blogb)，那么题目的数据范围是灰常宽松的，加读优的暴力也能跑70 所以出题还是要卡一卡 当然，方法还有很多 用线段树而非链表维护，最长区间长度，但这样会慢一点，实现也麻烦 鞋子也可以从小到大排序，即能走的点增多，则可以考虑写一个可删堆或线段树 也就是说，如果从大到小，是完全没必要写线段树的 如果非要从小到大，可能写个可删堆会比较快？虽然常数大一点 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2500】幸福的道路]]></title>
    <url>%2Fposts%2F73a.html</url>
    <content type="text"><![CDATA[Source and JudgeBzoj2500 Problem【Brief description】给一棵n个点的树，边长为$w_i$。现在假设有n天，每一天都可以从点i出发，然后走一条最长路径（每条边只经过一次）现在要求选择最长的连续几天，这些天的极差不超过$M$，求最大长度。【Input】第一行包含两个整数$N, M$，表示节点数和波动上限。第二至第$N$行,每行两个数字$F_i , w_i$, 第i行表示第i个节点的父亲是$F_i$,且路径长度是$w_i$.【Output】一行表示答案。【Limited conditions】50%的数据N&lt;=100080%的数据N&lt;=100 000100%的数据N&lt;=1000 000【Sample input】3 21 11 3【Sample output】3【Sample explanation】无 Record5h Analysis请先思考后再展开 首先，求每个点的最长链$g[i]$有几个方法： ① 两次dfs求出树的直径，每个点求与直径端点距离，复杂度$O(2n+2nlogn)$ ② 两次dfs求出树的直径，从直径两个端点再dfs更新每个点的答案，复杂度$O(4n)$ ③ dfs1把每个点子树内最长链和次长链计算出，然后dfs2用父亲的答案更新儿子的，复杂度$O(2n)$ 然后因为是连续的一段，所以可以用单调队列搞一搞 但怎么“搞”呢？考试的时候想半天没想到 首先我们单调的限制条件，就是极差是m以内 那所谓极差就是最大和最小值的差 我们可以同时维护两个单调队列【据说这是常规操作】 一个上升，一个下降，先维护其单调性 然后现在加入了一个点$r$，也就是当前连续的几天的右端点 把不符合条件的，从头开始踢出，同时把$l$用$max$维护一下就好了 注意，此时我们不一定把所有$l$前面的踢出了，但他们既不影响更新，也迟早会出去 同理，$l$之后的也不一定都在里面，只是因为不满足单调性而被去除了而已 哎刚开始打的时候没想通，还以为是用单调队列的长度这玩意真的挺有意思的 搞了这么久，主要是犯了很多sb错误 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>单调队列</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF566A】【51Nod1615】Matching Names]]></title>
    <url>%2Fposts%2Ff13e.html</url>
    <content type="text"><![CDATA[Source and JudgeVK Cup 2015 - Finals分配笔名51Nod1626CF566A 但是CF的麻烦，懒得打了…… Problem【Brief description】班里有n个同学。老师为他们选了n个笔名。现在要把这些笔名分配给每一个同学，每一个同学分配到一个笔名，每一个笔名必须分配给某个同学。现在定义笔名和真名之间的相关度是他们之间的最长公共前缀。那么我们就可以得到匹配的质量是每一个同学笔名和真名之间相关度的和。现在要求分配笔名，使得匹配质量最大。【Input】第一行有一个整数n ，表示班级中同学的数目。接下来n行，表示每一个同学的真名，每一个名字是非空串，且由小写字母组成。名字可能重复。最后n行是老师已经安排好的笔名。每一个笔名是一个非空串，且由小写字母组成。笔名可能重复。【Output】输出最大的匹配质量【Limited conditions】1≤n≤100000输入的字符总数目不超过 800000。【Sample input】5gennadygalyaborisbilltoshikbilbotoringendalfsmauggaladriel【Sample output】11以下为CF额外：4 12 51 35 23 4【Sample explanation】无 Record1h Analysis请先思考后再展开 字典树 然后考试的时候写错了，漏了情况 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF11B】【51Nod1615】Jumping Jack]]></title>
    <url>%2Fposts%2Fff50.html</url>
    <content type="text"><![CDATA[Source and Judge跳跃的杰克51Nod1615CF11BCF的原题好像已经被删了 Problem【Brief description】杰克正站在X坐标轴原点上。他想跳到坐标(x,0)上，为了达到训练效果，他决定首次跳跃的距离是1，之后每一次跳跃的距离将会比上一次跳跃的距离大1个单位。每一次跳跃，他可以选择往左或者往右跳。他很好奇至少要经过多少次跳跃才能到达终点。【Input】整数x【Output】输出杰克到达终点所需要的最少的跳跃次数【Limited conditions】-10^9&lt;=x&lt;=10^9【Sample input】2【Sample output】3【Sample explanation】无 Record30min 考试签到题 Analysis请先思考后再展开 思维题 首先，既然我们在0，那x可以直接转正 然后考虑贪心，在没到x前一直往右 然后到了以后有两种情况： now-x是奇数，则试图调整前面的，但无论前面是什么数，调换方向后都是偶数，所以无法到x now-x是偶数，则把(now-x)/2的数，方向反转即可 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>好题</tag>
        <tag>贪心</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1084】疫情控制]]></title>
    <url>%2Fposts%2F32f8.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2012 提高组 D2T3Luogu1084Caioj1556 Problem【Brief description】H 国有 n 个城市，这 n 个城市用 n-1 条双向道路相互连通构成一棵树，1 号城市是首都，也是树中的根节点。H 国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。 【Input】第一行一个整数 n，表示城市个数。接下来的 n-1 行，每行 3 个整数，u、v、w，每两个整数之间用一个空格隔开，表示从城市 u 到城市 v 有一条长为 w 的道路。数据保证输入的是一棵树，且根节点编号为 1。接下来一行一个整数 m，表示军队个数。接下来一行 m 个整数，每两个整数之间用一个空格隔开，分别表示这 m 个军队所驻扎的城市的编号。 【Output】共一行，包含一个整数，表示控制疫情所需要的最少时间。如果无法控制疫情则输出-1。 【Limited conditions】保证军队不会驻扎在首都。对于 20%的数据，2≤ n≤ 10；对于 40%的数据，2 ≤n≤50，0&lt;w &lt;10^5；对于 60%的数据，2 ≤ n≤1000，0&lt;w &lt;10^6；对于 80%的数据，2 ≤ n≤10,000；对于 100%的数据，2≤m≤n≤50,000，0&lt;w &lt;10^9。 【Sample input】41 2 11 3 23 4 322 2 【Sample output】3 【Sample explanation】**第一支军队在 2 号点设立检查点，第二支军队从 2 号点移动到 3 号点设立检查点，所需时间为 3 个小时。 Record5h Analysis请先思考后再展开 显然就是让时间最长的最小，然后可以考虑二分然后，显然除了到根节点，其他时候深度越小越好，而且还是一棵树，那么就可以倍增搞一搞而且，对于那些在时限内无法到达根节点的点，直接跑到最高处即可于是，现在问题转化为：确定时限，判断【能到根节点而又余力的军队】和【没有接触瘟疫的根的子树】如何分配（显然过了根节点，就没有必要往深处走了） 然后又是一波贪心2333，首先把军队和子树从小到大排序一下情况①：同子树未覆盖，则优先覆盖（无条件），这样最节省资源情况②：只能找其他子树下的空缺，有可能无任何贡献这个方法的正确性是显而易见的，然鹅看到有人用奇奇怪怪的贪心也过去了……可能有人看到这个“显而易见”又不爽？补充一下对于一个a，如果本来是由b负责的，因为已经排好序，如果b不是搞a，而是搞a后面的c，把a交给了b后面的d，则可行性不变，不会更优 最后提醒一下：有一种错误的贪心（自己想错了……然后被自己卡了）就是把有余力的军队，留最短的那支去管理自己的但可能有一种情况：三个点，然后一个很长，没人有空余，一个中间，有一个空余，一个很短，有两个空余然后短的那部分，只能去中间长度的按照现在的做法，会强行把中间那个留下，但其实放到长那地方，短的派一个过来会更优 正确的做法是，先把自己不能到根再回来的留下一个（这种情况，到别的更短地方不会更优）那么剩下的就很好处理了，只要贪心的大管大即可其中第一步很重要，避免原本能管理自己的，因为【空余减去到根距离】太小，导致浪费 这个贪心，万一在考场上太激动，没想到这个反例，然后分数被卡炸就惨了…… Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>二分</tag>
        <tag>贪心</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1083】借教室]]></title>
    <url>%2Fposts%2Fb9a5.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2012 提高组 D2T2Luogu1083Caioj1555 Problem【Brief description】在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。面对海量租借教室的信息，我们自然希望编程解决这个问题。我们需要处理接下来n天的借教室信息，其中第i天学校有$ri​$个教室可供租借。共有m份订单，每份订单用三个正整数描述，分别为$dj,sj,tj​$，表示某租借者需要从第$sj​$天到第$tj​$天租借教室（包括第$sj​$天和第$tj​$天），每天需要租借$dj​$个教室。我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供$dj$个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第$sj$天到第$tj$天中有至少一天剩余的教室数量不足$dj$个。现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。【Input】第一行包含两个正整数n,m，表示天数和订单的数量。第二行包含n个正整数，其中第i个数为$ri$，表示第i天可用于租借的教室数量。接下来有m行，每行包含三个正整数$dj,sj,tj$，表示租借的数量，租借开始、结束分别在第几天。每行相邻的两个数之间均用一个空格隔开。天数与订单均用从1开始的整数编号。【Output】如果所有订单均可满足，则输出只有一行，包含一个整数 0。否则（订单无法完全满足）输出两行，第一行输出一个负整数-1，第二行输出需要修改订单的申请人编号。【Limited conditions】对于10%的数据，有1≤ n,m≤ 10；对于30%的数据，有1≤ n,m≤1000；对于 70%的数据，有1 ≤ n,m ≤ 10^5；对于 100%的数据，有1 ≤ n,m ≤ 10^6,0 ≤ ri,dj≤ 10^9,1 ≤ sj≤ tj≤ n。【Sample input】4 32 5 4 32 1 33 2 44 2 4【Sample output】-12【Sample explanation】第 1 份订单满足后，4 天剩余的教室数分别为 0，3，2，3。第 2 份订单要求第 2 天到第 4 天每天提供 3 个教室，而第 3 天剩余的教室数为 2，因此无法满足。分配停止，通知第 2 个申请人修改订单。 Record2h Analysis1请先思考后再展开 先来个线段树 区间最小值和区间减小，打个lazy标记 然后网上说的70分，却拿到了95 终究是因为自己笨 Code1请先思考后再展开 undefined Analysis2请先思考后再展开 网上看到了针对区间修改的”永久标记“，于是试一发 然鹅并没有任何卵用 Code2请先思考后再展开 undefined Analysis3请先思考后再展开 现在的目的就是加速辣 区间修改$O(Klogn)$ （减法） 区间验证$O(Klogn)$ （找最小值） 总时间$O(m\times 2Klogn)$ 其中K是由于区间修改而导致的复杂度上升，当然打标记已经尽量优化了，多大我也不知道 那如果引入差分呢？ 区间修改$O(1)$ 区间验证$O(n)$ （暴力验证） 那么这个差分乍一看是没有这么优秀的，看起来像个暴力，但是具体实现也有两种： ①一个个搞过去，总时间$O(m\times n)$ ②二分验证，验证的时候要花一点时间在把前面订单搞定，总时间$O(logm\times (m+n))$ 于是，采用②，时间才会真正达到$O(nlogn)$的复杂度 而区间修改的线段树则有点危险 这tm怎么想得到？？？ Code3请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>二分</tag>
        <tag>标记永久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1082】同余方程]]></title>
    <url>%2Fposts%2Fad35.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2012 提高组 D2T1Luogu1082Caioj1554 Problem【Brief description】求关于 x 的同余方程 $ax ≡ 1 (\mod b)$的最小正整数解。 【Input】输入只有一行，包含两个正整数 a, b，用一个空格隔开。 【Output】输出只有一行，包含一个正整数 x0，即最小正整数解。输入数据保证一定有解。 【Limited conditions】对于 40%的数据，2 ≤b≤ 1,000；对于 60%的数据，2 ≤b≤ 50,000,000；对于 100%的数据，2 ≤a, b≤ 2,000,000,000。 【Sample input】3 10 【Sample output】7 【Sample explanation】**无 Record10min Analysis请先思考后再展开 经典题 详见【OI之路】02数论算法-1公约数公倍数与欧几里得 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>拓展欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1081】开车旅行]]></title>
    <url>%2Fposts%2Ff1fd.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2012 提高组 D1T3Luogu1081Caioj1553 Problem【Brief description】现在有n个城市，每个城市有它的高度Hi，保证每个Hi互不相同。我们定义两个城市之间的距离$disi,j=|Hi−Hj|$，并且只能从编号小的城市去到编号大的城市。现在有两个人，小A和小B要开车去旅行。小A先开一天，小B再开一天。每一天都可以从一个开到另一个城市。小A会选择去离当前城市第二近的城市，小B会选择去离当前城市最近的那个城市（如果两个城市与现在距离相同，则认为高度低的更近）。如果他们行驶的总路程将会超过给定的X就会不继续开车，结束旅行。求：1：给定一个X，求从哪一个城市出发，【小A行驶的路程/小B行驶的路程】最小（认为一个非0数/0=∞）。若有多个城市相等，选择高度最高的那个。2：给出m个询问，每次询问从S出发，限制为X，小A走的路程和小B走的路程。【Input】第一行包含一个整数 N，表示城市的数目。第二行有 N 个整数，每两个整数之间用一个空格隔开，依次表示城市 1 到城市 N 的海拔高度，即 H1，H2，……，Hn，且每个 Hi都是不同的。第三行包含一个整数 X0。第四行为一个整数 M，表示给定 M 组 Si 和 Xi。接下来的 M 行，每行包含 2 个整数 Si 和 Xi，表示从城市 Si出发，最多行驶 Xi公里。【Output】第一行包含一个整数 S0，表示对于给定的 X0，从编号为 S0的城市出发，小 A 开车行驶的路程总数与小 B 行驶的路程总数的比值最小。接下来的 M 行，每行包含 2 个整数，之间用一个空格隔开，依次表示在给定的 Si 和 Xi 下小 A 行驶的里程总数和小 B 行驶的里程总数。【Limited conditions】对于30%的数据，有1≤N≤20，1≤M≤20；对于40%的数据，有1≤N≤100，1≤M≤100；对于50%的数据，有1≤N≤100，1≤M≤1,000；对于70%的数据，有1≤N≤1,000，1≤M≤10,000；对于100%的数据，有1≤N≤100,000，1≤M≤100,000，-1,000,000,000≤Hi≤1,000,000,000，0≤X0≤1,000,000,000，1≤Si≤N，0≤Xi≤1,000,000,000，数据保证Hi 互不相同。【Sample input 1】42 3 1 4341 32 33 34 3【Sample output 1】11 12 00 00 0【Sample input 2】104 5 6 1 2 3 7 8 9 107101 72 73 74 75 76 77 78 79 710 7【Sample output 2】23 22 42 12 45 15 12 12 00 00 0【Sample explanation】【输入输出样例 1 说明】各个城市的海拔高度以及两个城市间的距离如上图所示。如果从城市 1 出发，可以到达的城市为 2,3,4，这几个城市与城市 1 的距离分别为 1,1,2，但是由于城市 3 的海拔高度低于城市 2，所以我们认为城市 3 离城市 1 最近，城市 2 离城市1 第二近，所以小 A 会走到城市 2。到达城市 2 后，前面可以到达的城市为 3,4，这两个城市与城市 2 的距离分别为 2,1，所以城市 4 离城市 2 最近，因此小 B 会走到城市 4。到达城市 4 后，前面已没有可到达的城市，所以旅行结束。如果从城市 2 出发，可以到达的城市为 3,4，这两个城市与城市 2 的距离分别为 2,1，由于城市 3 离城市 2 第二近，所以小 A 会走到城市 3。到达城市 3 后，前面尚未旅行的城市为4，所以城市 4 离城市 3 最近，但是如果要到达城市 4，则总路程为 2+3=5&gt;3，所以小 B 会直接在城市 3 结束旅行。如果从城市 3 出发，可以到达的城市为 4，由于没有离城市 3 第二近的城市，因此旅行还未开始就结束了。如果从城市 4 出发，没有可以到达的城市，因此旅行还未开始就结束了。【输入输出样例 2 说明】当 X=7 时， 如果从城市 1 出发，则路线为 1 -&gt; 2 -&gt; 3 -&gt; 8 -&gt; 9，小 A 走的距离为 1+2=3，小 B 走的距离为 1+1=2。（在城市 1 时，距离小 A 最近的城市是 2 和 6，但是城市 2 的海拔更高，视为与城市 1 第二近的城市，所以小 A 最终选择城市 2；走到 9 后，小 A 只有城市 10 可以走，没有第 2 选择可以选，所以没法做出选择，结束旅行）如果从城市 2 出发，则路线为 2 -&gt; 6 -&gt; 7 ，小 A 和小 B 走的距离分别为 2，4。如果从城市 3 出发，则路线为 3 -&gt; 8 -&gt; 9，小 A 和小 B 走的距离分别为 2，1。如果从城市 4 出发，则路线为 4 -&gt; 6 -&gt; 7，小 A 和小 B 走的距离分别为 2，4。如果从城市 5 出发，则路线为 5 -&gt; 7 -&gt; 8 ，小 A 和小 B 走的距离分别为 5，1。如果从城市 6 出发，则路线为 6 -&gt; 8 -&gt; 9，小 A 和小 B 走的距离分别为 5，1。如果从城市 7 出发，则路线为 7 -&gt; 9 -&gt; 10，小 A 和小 B 走的距离分别为 2，1。如果从城市 8 出发，则路线为 8 -&gt; 10，小 A 和小 B 走的距离分别为 2，0。如果从城市 9 出发，则路线为 9，小 A 和小 B 走的距离分别为 0，0（旅行一开始就结束了）。如果从城市10出发，则路线为 10，小A 和小B 走的距离分别为0，0。从城市 2 或者城市 4 出发小 A 行驶的路程总数与小 B 行驶的路程总数的比值都最小，但是城市 2 的海拔更高，所以输出第一行为 2。 Record3h Analysis请先思考后再展开 其实这东西有点类似弹飞绵羊，但是因为那个有修改，所以分块更优，而这个不修改，所以搞个倍增。 那么有一个很关键的东西，就是确定，每个点，A和B开一次车会到哪里（即最近和次近） 那么如果模拟需要$O(n^2)$，不过70分的暴力分也算挺多的了 那么有一种显然的思想，就是排序，这样就到了$O(nlogn)$，不过怎么处理只能向右这个条件？ 网上有很多种方法啊，其中双向链表和set还是比较好理解的，当然线段树也可以但麻烦，至于并查集？？懵逼 那么一开始尝试set，发现接口不是很友好啊，那还是自己实现算了，虽然有点麻烦但不算难 20行，半个小时过去了…… 然后正如上面所说的，可以愉快地倍增了 注意到A和B是交替开车的，所以定义交替一次为一轮。 $A[x][i]$=在x点开始，走$2^i$轮，A走过的距离 B数组同理 $m[x][i]$=在x点开始，走$2^i$轮，到达的点 然后预处理倍增一下 然后回答询问： 第一个，枚举每一个点倍增回答，$O(nlogx)$ 后面的，倍增回答，共$O(mlogx)$ Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1080】国王游戏]]></title>
    <url>%2Fposts%2F1b05.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2012 提高组 D1T2Luogu1080Caioj1552 Problem【Brief description】恰逢 H 国国庆，国王邀请 n 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 n 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。【Input】第一行包含一个整数 n，表示大臣的人数。第二行包含两个整数 a和 b，之间用一个空格隔开，分别表示国王左手和右手上的整数。接下来 n 行，每行包含两个整数 a 和 b，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。【Output】输出只有一行，包含一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。【Limited conditions】对于 20%的数据，有 1≤ n≤ 10，0 &lt; a、b &lt; 8；对于 40%的数据，有 1≤ n≤20，0 &lt; a、b &lt; 8；对于 60%的数据，有 1≤ n≤100；对于 60%的数据，保证答案不超过 10^9；对于 100%的数据，有 1 ≤ n ≤1,000，0 &lt; a、b &lt; 10000。【Sample input】31 12 37 44 6【Sample output】2【Sample explanation】按 1、2、3 号大臣这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；按 1、3、2 这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；按 2、1、3 这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；按 2、3、1 这样排列队伍，获得奖赏最多的大臣所获得金币数为 9；按 3、1、2 这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；按 3、2、1 这样排列队伍，获得奖赏最多的大臣所获得金币数为 9。因此，奖赏最多的大臣最少获得 2 个金币，答案输出 2。 Record1h Analysis请先思考后再展开 根据贪心，我们可以证明用每个人左右手乘积从小到大排序，是最优解。 证明：贪心有种证明方式叫做微扰就是说证明，对于任意两个相邻的元素，最优解中，把他们交换可能得到更坏的结果。 那么在本题中就是，设大臣1和大臣2，他们是相邻的 身份 左手 右手 国王 a0 …… …… （乘积省略到a0中） …… 大臣1 a1 b1 …… XXX …… 大臣2 a2 b2 …… …… …… 则有两种方案：方案① 大臣1在前：$A=\frac{a0}{b1}$$B=XXX\times a0\times \frac{a1}{b2}$$ANS1=max(A,B)$ 方案② 大臣2在前：$C=\frac{a0}{b2}$$D=XXX\times a0 \times \frac{a2}{b1}$$ANS2=max(C,D)$ 选择小的那个方案就是最优解 由于都是正整数，已知$A\leq D$$C\leq B$关于A和B的大小关系，又有两种情况情况① $A&lt;B$，则$A,C \leq B,D$，根据B,D大小决策【等价于左右手乘积小的在前面】情况② $A\geq B$，则$C \leq B \leq A \leq D$，可以直接选择方案② 但现在有两种决策方案，显然不利于实现我们可以把情况②看作情况①的一部分因为如果按照乘积比较的话，能得到同样的结果 综上所述，对于相邻的两个元素，乘积小的应该在前面那么根据冒泡排序，我们可以通过交换相邻元素去消除逆序对当逆序对数=0时是最优的，也就是可以通过排序得到最优解。 然后极限是$10000^{1000}$，即4000个位……所以要写高精度的乘和除（还好是与单精度的，不然真的不会） 最后，感谢这位大佬League丶翎在我解题过程中的耐心解释 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>模拟</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1079】Vigenère密码]]></title>
    <url>%2Fposts%2F745a.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2012 提高组 D1T1Luogu1079Caioj1551 Problem【Brief description】16 世纪法国外交家 Blaise de Vigenère 设计了一种多表密码加密算法――Vigenère 密码。Vigenère 密码的加密解密算法简单易用，且破译难度比较高，曾在美国南北战争中为南军所广泛使用。在密码学中，我们称需要加密的信息为明文，用 M 表示；称加密后的信息为密文，用C 表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为 k。在 Vigenère 密码中，密钥 k 是一个字母串，k=k1k2…kn。当明文 M=m1m2…mn时，得到的密文 C=c1c2…cn，其中 ci=mi®ki，运算®的规则如下表所示：Vigenère 加密在操作时需要注意：1. ®运算忽略参与运算的字母的大小写，并保持字母在明文 M 中的大小写形式；2. 当明文 M 的长度大于密钥 k 的长度时，将密钥 k 重复使用。例如，明文 M=Helloworld，密钥 k=abc 时，密文 C=Hfnlpyosnd。【Input】第一行为一个字符串，表示密钥 k，长度不超过 100，其中仅包含大小写字母。第二行为一个字符串，表示经加密后的密文，长度不超过 1000，其中仅包含大小写字母。【Output】一个字符串，表示输入密钥和密文所对应的明文。【Limited conditions】对于10% 的数据，k=0 ；对于20% 的数据，k=1 ；对于40% 的数据，2 ≤ n ≤ 50，1 ≤ m ≤ 1,000，0 ≤ k ≤ 20，0 ≤ Di ≤ 10，0 ≤ T i ≤ 500；对于60% 的数据，1 ≤ n ≤ 100，1 ≤ m ≤ 1,000，0 ≤ k ≤ 100 ，0 ≤ Di ≤ 100，0 ≤ T i ≤ 10,000 ；对于100%的数据，1 ≤ n ≤ 1,000，1 ≤ m ≤ 10,000 ，0 ≤ k ≤ 100,000，0 ≤ Di ≤ 100 ，0 ≤ T i ≤ 100,000。【Sample input】CompleteVictoryYvqgpxaimmklongnzfwpvxmniytm【Sample output】Wherethereisawillthereisaway【Sample explanation】输入的密钥的长度不超过 100，输入的密文的长度不超过 1000，且都仅包含英文字母。 Record10min Analysis请先思考后再展开 设‘a’为0 ci=(mi+ki)%26 mi=(ci-ki+26)%26 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1315】观光公交]]></title>
    <url>%2Fposts%2Fb81a.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2011 提高组 D2T3Luogu1315Caioj1550 Problem【Brief description】风景迷人的小城Y 市，拥有n 个美丽的景点。由于慕名而来的游客越来越多，Y 市特意安排了一辆观光公交车，为游客提供更便捷的交通服务。观光公交车在第 0 分钟出现在 1号景点，随后依次前往 2、3 、4 ……n 号景点。从第 i 号景点开到第 i+1 号景点需要 Di 分钟。任意时刻，公交车只能往前开，或在景点处等待。设共有m 个游客，每位游客需要乘车1 次从一个景点到达另一个景点，第i 位游客在Ti 分钟来到景点 Ai ，希望乘车前往景点Bi （Ai&lt;Bi ）。为了使所有乘客都能顺利到达目的地，公交车在每站都必须等待需要从该景点出发的所有乘客都上车后才能出发开往下一景点。假设乘客上下车不需要时间。一个乘客的旅行时间，等于他到达目的地的时刻减去他来到出发地的时刻。因为只有一辆观光车，有时候还要停下来等其他乘客，乘客们纷纷抱怨旅行时间太长了。于是聪明的司机ZZ给公交车安装了 k 个氮气加速器，每使用一个加速器，可以使其中一个 Di 减1 。对于同一个Di 可以重复使用加速器，但是必须保证使用后Di 大于等于0 。那么ZZ该如何安排使用加速器，才能使所有乘客的旅行时间总和最小？【Input】第 1 行是3 个整数n, m, k ，每两个整数之间用一个空格隔开。分别表示景点数、乘客数和氮气加速器个数。第 2 行是n-1 个整数，每两个整数之间用一个空格隔开，第i 个数表示从第i 个景点开往第i+1 个景点所需要的时间，即 Di 。第 3 行至m+2 行每行 3 个整数 Ti, Ai, Bi，每两个整数之间用一个空格隔开。第 i+2 行表示第i 位乘客来到出发景点的时刻，出发的景点编号和到达的景点编号。【Output】共一行，包含一个整数，表示最小的总旅行时间。【Limited conditions】对于10% 的数据，k=0 ；对于20% 的数据，k=1 ；对于40% 的数据，2 ≤ n ≤ 50，1 ≤ m ≤ 1,000，0 ≤ k ≤ 20，0 ≤ Di ≤ 10，0 ≤ T i ≤ 500；对于60% 的数据，1 ≤ n ≤ 100，1 ≤ m ≤ 1,000，0 ≤ k ≤ 100 ，0 ≤ Di ≤ 100，0 ≤ T i ≤ 10,000 ；对于100%的数据，1 ≤ n ≤ 1,000，1 ≤ m ≤ 10,000 ，0 ≤ k ≤ 100,000，0 ≤ Di ≤ 100 ，0 ≤ T i ≤ 100,000。【Sample input】3 3 21 40 1 31 1 25 2 3【Sample output】10【Sample explanation】对D2 使用2 个加速器，从2 号景点到 3 号景点时间变为 2 分钟。公交车在第1 分钟从1 号景点出发，第2 分钟到达2 号景点，第5 分钟从2 号景点出发，第7 分钟到达 3 号景点。第1 个旅客旅行时间 7-0 = 7 分钟。第2 个旅客旅行时间 2-1 = 1 分钟。第3 个旅客旅行时间 7-5 = 2 分钟。总时间 7+1+2 = 10分钟。 Record6h Analysis1请先思考后再展开 首先，对于同一个点上车的乘客，除了最后那一个，其他人什么时候到达时没有关系的，只影响答案统计但不影响决策，因为他在这个点的等待时间无法改变，所以用lst[i]表示第i个点最后到的人的时间。 先定义几个数组 $tot[t]$=在t点下车的乘客数量 $arr[ t]$=当前方案，开车到t点的时间=$max(arr[t-1],lst[t-1])+d[t]$ 那么思考在什么地方用加速器呢？可以考虑贪心一下 假如要对$(t-1,t)$这条边加速， ①$lst[t]\geq arr[t]$，则对于【不在i点下车的乘客】，旅行时间不变，贡献$tot[t]$ ②$lst[t]&lt;arr[t]​$，贡献$\sum_{i=t}^{g[t]} tot[i]​$，g[t]是当前连续情况②的最后一个，因为一旦碰到①又要等了 然后tot不变，可以搞个前缀和 总结：把没有加速的答案先搞定，然后一个个贪心 复杂度：$O(kn)$ 至于数据……别管了很伪的，反正不会T 但是为什么能贪心呢？这个我没相通，因为感觉决策是变化很大的 Code1请先思考后再展开 undefined Analysis2请先思考后再展开 费用流~ 感觉思路真的很妙，不好想 但还是很好理解的，而且比贪心慢不了太多，但感觉特别稳 核心： 一次加速器，碰到$lst[t]\geq arr[t]$也就是上面的情况①就会停止 那么也就是说加速器个数超过$max(arr[i]-lst[i],0)$就停止影响 那么考虑把每一个点拆成【到达】和【离开】 然后用变化的【加速器分配方案】作为流量 则构图如下（i作为边i~i+1遍历）： 边 单位流量费用 流量 作用 $S\rightarrow S’$ 0 k 限制总个数 $S’\rightarrow i’$ 0 $d[i]$ $边权\geq 0$ $i’\rightarrow i+1$ $-tot[i+1]$ $INF$ 追求最小 $i\rightarrow i’$ 0 $max(arr[i]-lst[i],0)$ 确保影响范围 $i’\rightarrow T$ 0 $INF$ 统计答案 大功告成！ Code2请先思考后再展开 undefined Analysis3请先思考后再展开 然后猛地发现，虽然上面两种看起来都灰常快，事实上跑官方数据也确实算快 然鹅，理论复杂度都是灰常大的 有没有更快的呢？我才不会告诉你这几个解法我一个都没想到 其实优化一下贪心就好了 把arr的更新，从全部减少为更新范围（根据上面的限制公式） 每次用多几个加速器（根据上面的限制公式） 然后速度就从700ms到了12ms…… Code3请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>贪心</tag>
        <tag>坑</tag>
        <tag>模拟</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1314】聪明的质监员]]></title>
    <url>%2Fposts%2Fe6e5.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2011 提高组 D2T2Luogu1314Caioj1549 Problem【Brief description】小 T 是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有n个矿石，从1到n逐一编号，每个矿石都有自己的重量wi以及价值vi。检验矿产的流程是：1、给定m个区间[Li，Ri]；2、选出一个参数W；3、对于一个区间[Li，Ri]，计算矿石在这个区间上的 检验值Yi：$Y_i = (\sum\limits_j 1) * (\sum\limits_j v_j) , j \in [L_i,R_i] 且 w_j \ge W$即数量×价值和这批矿产的检验结果Y为各个区间的检验值之和。即：Y1+Y2…+Ym通过调整参数W 的值，使得S-Y 的绝对值最小。请你帮忙求出这个最小值。【Input】第一行包含三个整数n，m，S，分别表示矿石的个数、区间的个数和标准值。接下来的n 行，每行2个整数，中间用空格隔开，第i+1 行表示 i 号矿石的重量 wi 和价值vi。接下来的m 行，表示区间，每行2 个整数，中间用空格隔开，第i+n+1 行表示区间[Li,Ri]的两个端点Li 和Ri。【Output】输出只有一行，包含一个整数，表示所求的最小值。【Limited conditions】不同区间可能重合或相互重叠。对于10% 的数据，有 1 ≤n ，m≤10；对于30% 的数据，有 1 ≤n ，m≤500 ；对于50% 的数据，有 1 ≤n ，m≤5,000；对于70% 的数据，有 1 ≤n ，m≤10,000 ；对于100%的数据，有 1 ≤n ，m≤200,000，0 &lt; wi, vi≤10^6，0 &lt; S≤10^12，1 ≤ Li ≤ Ri ≤n 。【Sample input】5 3 151 52 53 54 55 51 52 43 3【Sample output】10【Sample explanation】当 W 选 4 的时候，三个区间上检验值分别为 20、5 、0 ，这批矿产的检验结果为 25，此时与标准值S 相差最小为10。 Record30min Analysis请先思考后再展开 首先这个W是满足二分答案的性质的，log2后大概是40 那我的想法是二份答案验证 但是如果一个一个区间搞，很容易被卡 考虑每次验证，构造两个前缀和 然后一个个区间统计即可 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1313】计算系数]]></title>
    <url>%2Fposts%2F8493.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2011 提高组 D2T1Luogu1313Caioj1548 Problem【Brief description】给定一个多项式(by+ax)^k，请求出多项式展开后x^n*y^m 项的系数。【Input】共一行，包含 5 个整数，分别为 a，b，k，n ，m，每两个整数之间用一个空格隔开。【Output】输出共1 行，包含一个整数，表示所求的系数，这个系数可能很大，输出对10007 取模后的结果。【Limited conditions】对于30% 的数据，有 0 ≤k ≤10 ；对于50% 的数据，有 a = 1，b = 1；对于100%的数据，有 0 ≤k ≤1,000，0≤n, m≤k ，且n+m = k ，0 ≤a ，b ≤1,000,000。【Sample input】1 1 3 1 2【Sample output】3【Sample explanation】无 Record30minwa了一次忘记模底数了以后小心点，20分啊 Analysis请先思考后再展开 二项式定理题目转化：$$C_{n+m}^n \timesa^n \timesb^m$$ Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>二项式定理</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1312】Mayan游戏]]></title>
    <url>%2Fposts%2F62b4.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2011 提高组 D1T3Luogu1312Caioj1547 Problem【Brief description】Mayan puzzle是最近流行起来的一个游戏。游戏界面是一个 7 行 5 列的棋盘，上面堆放着一些方块，方块不能悬空堆放，即方块必须放在最下面一行，或者放在其他方块之上。游戏通关是指在规定的步数内消除所有的方块，消除方块的规则如下：1 、每步移动可以且仅可以沿横向（即向左或向右）拖动某一方块一格：当拖动这一方块时，如果拖动后到达的位置（以下称目标位置）也有方块，那么这两个方块将交换位置（参见输入输出样例说明中的图6到图7）；如果目标位置上没有方块，那么被拖动的方块将从原来的竖列中抽出，并从目标位置上掉落（直到不悬空，参见下面图1 和图2）；2 、任一时刻，如果在一横行或者竖列上有连续三个或者三个以上相同颜色的方块，则它们将立即被消除（参见图1 到图3）。上面图1 到图 3 给出了在棋盘上移动一块方块之后棋盘的变化。棋盘的左下角方块的坐标为（0, 0），将位于（3, 3）的方块向左移动之后，游戏界面从图 1 变成图 2 所示的状态，此时在一竖列上有连续三块颜色为4 的方块，满足消除条件，消除连续3 块颜色为4 的方块后，上方的颜色为3 的方块掉落，形成图 3 所示的局面。注意：a) 如果同时有多组方块满足消除条件，几组方块会同时被消除（例如下面图4 ，三个颜色为1 的方块和三个颜色为 2 的方块会同时被消除，最后剩下一个颜色为 2 的方块）。b) 当出现行和列都满足消除条件且行列共享某个方块时，行和列上满足消除条件的所有方块会被同时消除（例如下面图5 所示的情形，5 个方块会同时被消除）。3 、方块消除之后，消除位置之上的方块将掉落，掉落后可能会引起新的方块消除。注意：掉落的过程中将不会有方块的消除。【Input】第一行为一个正整数n ，表示要求游戏通关的步数。接下来的5 行，描述 7*5 的游戏界面。每行若干个整数，每两个整数之间用一个空格隔开，每行以一个0 结束，自下向上表示每竖列方块的颜色编号（颜色不多于10种，从1 开始顺序编号，相同数字表示相同颜色）。【Output】如果有解决方案，输出 n 行，每行包含 3 个整数x，y，g ，表示一次移动，每两个整数之间用一个空格隔开，其中（x，y）表示要移动的方块的坐标，g 表示移动的方向，1 表示向右移动，-1表示向左移动。注意：多组解时，按照 x 为第一关健字，y 为第二关健字，1优先于-1 ，给出一组字典序最小的解。游戏界面左下角的坐标为（0 ，0 ）。如果没有解决方案，输出一行，包含一个整数-1。【Limited conditions】输入数据保证初始棋盘中没有可以消除的方块。对于30% 的数据，初始棋盘上的方块都在棋盘的最下面一行；对于100%的数据，0&lt;n≤5。【Sample input】31 02 1 02 3 4 03 1 02 4 3 4 0【Sample output】2 1 13 1 13 0 1【Sample explanation】按箭头方向的顺序分别为图6 到图11样例输入的游戏局面如上面第一个图片所示，依次移动的三步是：（2，1）处的方格向右移动，（3，1）处的方格向右移动，（3，0）处的方格向右移动，最后可以将棋盘上所有方块消除。 Record3h Analysis请先思考后再展开 首先，把操作看作是相邻交换，所以bfs剪枝：因为有多解的时候优先x、y、右所以如果左边是非空，则交给左边的来搞 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>bfs</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1514】铺地毯]]></title>
    <url>%2Fposts%2F1666.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2011 提高组 D1T1Luogu1514Caioj1544 Problem【Brief description】为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 n 张地毯，编号从 1 到n 。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。【Input】输入共n+2 行。第一行，一个整数n ，表示总共有 n 张地毯。接下来的n 行中，第 i+1 行表示编号i 的地毯的信息，包含四个正整数 a ，b ，g ，k ，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标（a ，b）以及地毯在x轴和y 轴方向的长度。第n+2 行包含两个正整数 x 和y，表示所求的地面的点的坐标（x ，y）。【Output】输出共1 行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出-1 。【Limited conditions】对于30% 的数据，有 n ≤2 ；对于50% 的数据，0 ≤a, b, g, k≤100；对于100%的数据，有 0 ≤n ≤10,000 ，0≤a, b, g, k ≤100,000。【Sample input】31 0 2 30 2 3 32 1 3 32 2【Sample output】3【Sample explanation】如下图，1 号地毯用实线表示，2 号地毯用虚线表示，3 号用双实线表示，覆盖点（2,2）的最上面一张地毯是 3 号地毯。 Record10min Analysis请先思考后再展开 sb题 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1514】引水入城]]></title>
    <url>%2Fposts%2Fd2e5.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2010 提高组 T4Luogu1514Caioj1544 Problem【Brief description】在一个遥远的国度，一侧是风景秀美的湖泊，另一侧则是漫无边际的沙漠。该国的行政区划十分特殊，刚好构成一个N 行M 列的矩形，如图所示。其中每个格子都代表一座城市，每座城市都有一个海拔高度。为了使居民们都尽可能饮用到清澈的湖水，现在要在某些城市建造水利设施。水利设施有两种，分别为蓄水厂和输水站。蓄水厂的功能是利用水泵将湖泊中的水抽取到所在城市的蓄水池中。因此，只有与湖泊毗邻的第1 行的城市可以建造蓄水厂。而输水站的功能则是通过输水管线利用高度落差，将湖水从高处向低处输送。故一座城市能建造输水站的前提，是存在比它海拔更高且拥有公共边的相邻城市，已经建有水利设施。由于第N 行的城市靠近沙漠，是该国的干旱区，所以要求其中的每座城市都建有水利设施。那么，这个要求能否满足呢？如果能，请计算最少建造几个蓄水厂；如果不能，求干旱区中不可能建有水利设施的城市数目。【Input】每行中两个数之间用一个空格隔开。输入的第一行是两个正整数 N 和 M，表示矩形的规模。接下来 N 行，每行 M 个正整数，依次代表每座城市的海拔高度。【Output】如果能满足要求，输出的第一行是整数1，第二行是一个整数，代表最少建造几个蓄水厂；如果不能满足要求，输出的第一行是整数0，第二行是一个整数，代表有几座干旱区中的城市不可能建有水利设施。【Limited conditions】【Sample input】3 68 4 5 6 4 47 3 4 3 3 33 2 2 1 1 2【Sample output】13【Sample explanation】上图中，在 3 个粗线框出的城市中建造蓄水厂，可以满足要求。以这 3 个蓄水厂为源头在干旱区中建造的输水站分别用 3 种颜色标出。当然，建造方法可能不唯一。 Record3h Analysis请先思考后再展开 本来看着这个图，硬是yy了一个本来不会的费用流【因为自己灵光一闪发现好久没用啦】然后中午做了两道裸题学会了费用流然后打、调了两个小时这题，建图：把开通一个地方看作费用为1这是因为之前做过一道费用不是单位而是边的题目但其实那道题是每条边只能用一次的，所以没有关系但这道题的话，用费用的时候，spfa完全没有任何比较能力，所以是错误的！心疼我的两小时，特别是今天已经不得不去考统测五而浪费一天时间 然后正解又是爆搜……noip不搞这个会死 首先，如果有解，显然每一个蓄水站，所覆盖的地方一定是一段连续的区间，否则断开的地方别的蓄水站也无法进入于是就变成了区间覆盖问题 那区间，就是l和r，灰常好维护，考虑dp但是不能直接从下往上来dp，从样例就能看出，可能水会往上所以用更加灵活的记忆化搜索代替dp即可 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>贪心</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj2135】Farm Tour]]></title>
    <url>%2Fposts%2F2acf.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2010 提高组 T4Poj2135Caioj1544 Problem【Brief description】一个无向图有 N 个点和 M 无向边，出发点是 1，终点为 N求从点1出发到点N再从点N回到点1的最短路程，并且要求每条边只能走一次。【Input】第一行： 两个整数N和M。下来M行，每行三个整数: X Y L 分别表示一条无向边两个点的编号和边的长度。【Output】输出一个整数，最短路程。【Limited conditions】1&lt;=N&lt;=10001&lt;=M&lt;=10000每条边的长度小于等于35000。【Sample input】4 51 2 12 3 13 4 11 3 22 4 2【Sample output】6【Sample explanation】无 Record30min Analysis请先思考后再展开 最小费用最大流把边权作为边的费用，1作为边的容量即可 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1525】关押罪犯]]></title>
    <url>%2Fposts%2F8b22.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2010 提高组 T3Luogu1525Caioj1543 Problem【Brief description】S 城现有两座监狱，一共关押着N 名罪犯，编号分别为1~N。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为c 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 c 的冲突事件。每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到S 城Z 市长那里。公务繁忙的Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。在详细考察了N 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。那么，应如何分配罪犯，才能使Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？【Input】每行中两个数之间用一个空格隔开。第一行为两个正整数 N 和 M，分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的 M 行每行为三个正整数aj，bj，cj，表示 aj 号和 bj 号罪犯之间存在仇恨，其怨气值为cj。【Output】共1 行，为Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出0。【Limited conditions】数据保证1&lt;=aj&lt;=bj&lt;=N，0&lt;cj≤1,000,000,000，且每对罪犯组合只出现一次。对于30%的数据有N≤ 15。对于70%的数据有N≤ 2000，M≤ 50000。对于100%的数据有N≤ 20000，M≤ 100000。【Sample input】4 61 4 25342 3 35121 2 283511 3 66182 4 18053 4 12884【Sample output】3512【Sample explanation】罪犯之间的怨气值如下面左图所示，右图所示为罪犯的分配方法，市长看到的冲突事件影响力是3512（由 2 号和 3 号罪犯引发）。其他任何分法都不会比这个分法更优。 Record30min Analysis请先思考后再展开 考虑一个贪心：优先处理权值大的关系证明：因为本题求的是最大值，如果放弃当前，那么无论你后面多么优秀，答案都是确定的然后因为要维护互斥的关系，可以很巧妙地用拆点解决，然后就可以并查集了 Code请先思考后再展开 undefined Analysis2请先思考后再展开 也可以二分答案，然后对于大于mid的边，判断是否是二分图]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1541】乌龟棋]]></title>
    <url>%2Fposts%2Fe616.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2010 提高组 T2Luogu1541Caioj1542 Problem【Brief description】乌龟棋的棋盘是一行N个格子，每个格子上一个分数（非负整数）。棋盘第1格是唯一的起点，第N格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。乌龟棋中M张爬行卡片，分成4种不同的类型（M张卡片中不一定包含所有4种类型的卡片，见样例），每种类型的卡片上分别标有1、2、3、4四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？【Input】第1行2个正整数N和M，分别表示棋盘格子数和爬行卡片数。第2行N个非负整数，a1 a2……aN，其中ai表示棋盘第i个格子上的分数。第3行M个整数，b1 b2……bM，表示M张爬行卡片上的数字。输入数据保证到达终点时刚好用光M张爬行卡片。【Output】1个整数，表示小明最多能得到的分数。【Limited conditions】对于30%的数据有1≤N≤30，1≤M≤12。对于50%的数据有1≤N≤120，1≤M≤50，且4种爬行卡片，每种卡片的张数不会超过20。对于100%的数据有1≤N≤350，1≤M≤120，且4种爬行卡片，每种卡片的张数不会超过40；0≤ai≤100，1≤i≤N；1≤bi≤4，1≤i≤M。【Sample input】9 56 10 14 2 8 8 18 5 171 3 1 2 1【Sample output】73【Sample explanation】小明使用爬行卡片顺序为1，1，3，1，2，得到的分数为6+10+14+8+18+17=73。注意，由于起点是1，所以自动获得第1格的分数6。 Record30min Analysis请先思考后再展开 一眼dp,undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1075】机器翻译]]></title>
    <url>%2Fposts%2F3759.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2010 提高组 T1Luogu1540Caioj1541 Problem【Brief description】小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。题目描述这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。假设内存中有M个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过M-1，软件会将新单词存入一个未使用的内存单元；若内存中已存入M个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。假设一篇英语文章的长度为N个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。【Input】第一行为两个正整数M和N，代表内存容量和文章的长度。第二行为N个非负整数，按照文章的顺序，每个数（大小不超过1000）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。【Output】软件需要查词典的次数。【Limited conditions】对于10%的数据有M=1，N≤5。对于100%的数据有0&lt;=M&lt;=100，0&lt;=N&lt;=1000。【Sample input】3 71 2 1 5 4 4 1【Sample output】5【Sample explanation】整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：空：内存初始状态为空。1． 1：查找单词1并调入内存。2． 1 2：查找单词2并调入内存。3． 1 2：在内存中找到单词1。4． 1 2 5：查找单词5并调入内存。5． 2 5 4：查找单词4并调入内存替代单词1。6． 2 5 4：在内存中找到单词4。7． 5 4 1：查找单词1并调入内存替代单词2。共计查了5次词典。 Record10min Analysis请先思考后再展开 sb题 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1075】靶形数独]]></title>
    <url>%2Fposts%2Fead0.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2009 提高组 T4Luogu1074Caioj1540 Problem【Brief description】小城和小华都是热爱数学的好学生，最近，他们不约而同地迷上了数独游戏，好胜的他们想用数独来一比高低。但普通的数独对他们来说都过于简单了，于是他们向 Z博士请教，Z 博士拿出了他最近发明的“靶形数独” ，作为这两个孩子比试的题目。靶形数独的方格同普通数独一样，在9×9的大九宫格中有9个3×3的小九宫格（用粗黑色线隔开的）。在这个大九宫格中，有一些数字是已知的，根据这些数字，利用逻辑推理，在其他的空格上填入1到9的数字。每个数字在每个小九宫格内不能重复出现，每个数字在每行、每列也不能重复出现。但靶形数独有一点和普通数独不同，即每一个方格都有一个分值，而且如同一个靶子一样，离中心越近则分值越高。比赛的要求是：每个人必须完成一个给定的数独（每个给定数独可能有不同的填法） ，而且要争取更高的总分数。而这个总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和。如图，在以下的这个已经填完数字的靶形数独游戏中，总分数为 2829。游戏规定，将以总分数的高低决出胜负。求出对于给定的靶形数独，能够得到的最高分数。【Input】一共 9 行。每行 9 个整数（每个数都在0—9的范围内），表示一个尚未填满的数独方格，未填的空格用“0”表示。每两个数字之间用一个空格隔开。【Output】输出可以得到的靶形数独的最高分数。如果这个数独无解，则输出整数-1。【Limited conditions】40%的数据，数独中非0数的个数不少于30。80%的数据，数独中非0数的个数不少于26。100%的数据，数独中非0数的个数不少于24。【Sample input】7 0 0 9 0 0 0 0 11 0 0 0 0 5 9 0 00 0 0 2 0 0 0 8 00 0 5 0 2 0 0 0 30 0 0 0 0 0 6 4 84 1 3 0 0 0 0 0 00 0 7 0 0 2 0 9 02 0 1 0 6 0 8 0 40 8 0 5 0 4 0 1 2【Sample output】2829【Sample explanation】无 Record3h Analysis1请先思考后再展开 通过估价函数（实时变化），也就是通过行、列、宫确定数来找最优决策顺序然后暴力即可 本代码可100，但有点危险而且还牺牲了最优化方案【某种平衡？】有点莫队中【分块与哈密顿距离最小生成树】的感觉 UP:洗了个澡回来就想了种新想法：其实直接预处理出顺序就好了瞬间比所谓”跳舞链“差不了多少 应该比大部分题解快而简单了吧于是就是很稳的正解啦！ Code1请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>坑</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1073】最优贸易]]></title>
    <url>%2Fposts%2Fb656.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2009 提高组 T3Luogu1073Caioj1539 Problem【Brief description】C 国有 n 个大城市和 m 条道路，每条道路连接这 n 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 m 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 1 条。C 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。商人阿龙来到 C 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 C 国 n 个城市的标号从 1~n，阿龙决定从 1 号城市出发，并最终在 n 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 n 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品——水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 C 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。现在给出 n 个城市的水晶球价格，m 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。【Input】第一行包含 2 个正整数 n 和 m，中间用一个空格隔开，分别表示城市的数目和道路的数目。第二行 n 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 n 个城市的商品价格。接下来 m 行，每行有 3 个正整数，x，y，z，每两个整数之间用一个空格隔开。如果 z=1，表示这条道路是城市 x 到城市 y 之间的单向道路；如果 z=2，表示这条道路为城市 x 和城市y 之间的双向道路。【Output】共 1 行，包含 1 个整数，表示最多能赚取的旅费。如果没有进行贸易，则输出 0。【Limited conditions】输入数据保证 1 号城市可以到达 n 号城市。对于 10%的数据，1≤n≤6。对于 30%的数据，1≤n≤100。对于 50%的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。对于 100%的数据，1≤n≤100000，1≤m≤500000，1≤x，y≤n，1≤z≤2，1≤各城市水晶球价格≤100。【Sample input】5 54 3 5 6 11 2 11 4 12 3 23 5 14 5 2【Sample output】5【Sample explanation】C 国有 5 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。假设 1~n 号城市的水晶球价格分别为 4，3，5，6，1。阿龙可以选择如下一条线路：1-&gt;2-&gt;3-&gt;5，并在 2 号城市以 3 的价格买入水晶球，在 3号城市以 5 的价格卖出水晶球，赚取的旅费数为 2。阿龙也可以选择如下一条线路 1-&gt;4-&gt;5-&gt;4-&gt;5，并在第 1 次到达 5 号城市时以 1 的价格买入水晶球，在第 2 次到达 4 号城市时以 6 的价格卖出水晶球，赚取的旅费数为 5。 Record1h Analysis1请先思考后再展开 图上灰常规dp注意两个很重要的剪枝【如果不喜欢剪枝，可以用强连通搞一搞，总之就是避免环】 Code请先思考后再展开 undefined Analysis2请先思考后再展开 主要到这道题的方法灰常多，算是不错的题目，比较创新而且大家都是尽力简化各种方法各种奇奇怪怪题解嗯以我的尿性，肯定是选了最简单最快的了…… UP 2018.8.29看了看正规的做法，其实一点都不难对于这种，和路径上先后顺序有关的题目，可以按照节点，把路径拆分一下具体而言就是计算出每个节点，在原图上过来的所有路径中最小，反图上过来最大，这两个信息具体实现大概用spfa会比较方便]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>并查集</tag>
        <tag>dp</tag>
        <tag>难度1</tag>
        <tag>好题</tag>
        <tag>模拟</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1072】Hankson的趣味题]]></title>
    <url>%2Fposts%2F7398.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2009 提高组 T2Luogu1072Caioj1538 Problem【Brief description】已知正整数 a0,a1,b0,b1，正整数 x 满足：1. gcd(x,a0)=a12. lcm(x,b0)=b1求x的个数【Input】第一行为一个正整数 n，表示有 n 组输入数据。接下来的 n 行每行一组输入数据，为四个正整数 a0，a1，b0，b1，每两个整数之间用一个空格隔开。【Output】共 n 行。每组输入数据的输出结果占一行，为一个整数。对于每组数据：若不存在这样的 x，请输出 0；若存在这样的 x，请输出满足条件的 x 的个数；【Limited conditions】输入数据保证 a0 能被 a1 整除，b1 能被 b0 整除。对于 50%的数据，保证有 1≤a0，a1，b0，b1≤10000 且 n≤100。对于 100%的数据，保证有 1≤a0，a1，b0，b1≤2,000,000,000 且 n≤2000。【Sample input】241 1 96 28895 1 37 1776【Sample output】62【Sample explanation】第一组输入数据，x 可以是 9、18、36、72、144、288，共有 6 个。第二组输入数据，x 可以是 48、1776，共有 2 个。 Record1h Analysis1请先思考后再展开 优雅的暴力：观察柿子，不难发现x是a1的倍数，b1的约数枚举b1约数即x，验证即可 时间复杂度：最坏$O(n*sqrt(b1)*log2(b1))$极限26亿，然鹅luogu上还是很快的 Code1请先思考后再展开 undefined Analysis2请先思考后再展开 虽然过去了，显然跑得很慢呀 UP 2018.8.6：讲讲正解吧为了方便，改改字母gcd(x,a)=clcm(x,b)=d 先从优化的角度反思上面的做法，我们可以把暴力判断gcd消耗的log省去具体做法是，从质因数p的层面上考虑gcd和lcm，那么就变成了次幂的min和max也就是说，枚举约数质因数p，设其在a,b,c,d,x中次幂数分别是ma,mb,mc,md,mx对于gcd：①$ma=mc,mx&gt;=mc$②$ma&gt;mc,mx=mc$③$ma&lt;mc,无解$对于lcm：①$mb=md,mx=md$②$mb&lt;md,mx=md$③$mb&gt;md,无解$ 合并情况如下：①$ma=mc,mb=md,mc&lt;=md,则mc&lt;=mx&lt;=md$，共md-mc+1种②$ma=mc,mb&lt;md,mc&lt;=md,则mx=md$，共1种③$ma&gt;mc,mb=md,mc&lt;=md,则mx=mc$，共1种④$ma&gt;mc,mb&lt;md,mc=md,则mx=mc=md$，共1种⑤其他，无解 最后把每种p下，mx可行的选择数乘法原理即可把质数预处理一下，然后根据分布数量这样的复杂度是$O(n \times \sqrt d / log_2( \sqrt d) )$ Code2请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1071】潜伏者]]></title>
    <url>%2Fposts%2F9e5c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2009 提高组 T1Luogu1071Caioj1537 Problem【Brief description】R 国和 S 国正陷入战火之中，双方都互派间谍，潜入对方内部，伺机行动。历尽艰险后，潜伏于 S 国的 R 国间谍小 C 终于摸清了 S 国军用密码的编码规则：1. S 国军方内部欲发送的原信息经过加密后在网络上发送，原信息的内容与加密后所得的内容均由大写字母‘A’-‘Z’构成（无空格等其他字符）。2. S 国对于每个字母规定了对应的“密字”。加密的过程就是将原信息中的所有字母替换为其对应的“密字”。3. 每个字母只对应一个唯一的“密字”，不同的字母对应不同的“密字”。“密字”可以和原字母相同。例如，若规定‘A’的密字为‘A’，‘B’的密字为‘C’（其他字母及密字略），则原信息“ABA”被加密为“ACA”。现在，小C通过内线掌握了 S 国网络上发送的一条加密信息及其对应的原信息。小C希望能通过这条信息，破译S国的军用密码。小C的破译过程是这样的：扫描原信息，对于原信息中的字母 x（代表任一大写字母），找到其在加密信息中的对应大写字母 y，并认为在密码里 y 是 x 的密字。如此进行下去直到停止于如下的某个状态：1. 所有信息扫描完毕，‘A’-‘Z’ 所有 26 个字母在原信息中均出现过并获得了相应的“密字”。2. 所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现。3. 扫描中发现掌握的信息里有明显的自相矛盾或错误（违反 S 国密码的编码规则）。例如某条信息“XYZ”被翻译为“ABA”就违反了“不同字母对应不同密字”的规则。在小C忙得头昏脑涨之际，R国司令部又发来电报，要求他翻译另外一条从S国刚刚截取到的加密信息。现在请你帮助小 C：通过内线掌握的信息，尝试破译密码。然后利用破译的密码，翻译电报中的加密信息。【Input】第 1 行为小 C 掌握的一条加密信息。第 2 行为第 1 行的加密信息所对应的原信息。第 3 行为 R 国司令部要求小 C 翻译的加密信息。输入数据保证所有字符串仅由大写字母‘A’-‘Z’构成，且第 1 行长度与第 2 行相等。【Output】共 1 行。若破译密码停止时出现 2，3 两种情况，请你输出“Failed”（不含引号，注意首字母大写，其它小写）。否则请输出利用密码翻译电报中加密信息后得到的原信息。【Limited conditions】字符串长度在 1 到 100 之间。【Sample input 1】AAABEOWIE【Sample output 1】Failed【Sample input 2】QWERTYUIOPLKJHGFDSAZXCVBNABCDEFGHIJKLMNOPQRSTUVWXYDSLIEWO【Sample output 2】Failed【Sample input 3】MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPPYIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLLFLSO【Sample output 3】NOIP【Sample explanation】【输入输出样例 1 说明】原信息中的字母‘A’和‘B’对应相同的密字，输出“Failed”。【输入输出样例 2 说明】字母‘Z’在原信息中没有出现，输出“Failed”。 Record30min Analysis请先思考后再展开 模拟即可 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1155】双栈排序]]></title>
    <url>%2Fposts%2F958b.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2008 提高组 T4Luogu1155Caioj1536 Problem【Brief description】Tom最近在研究一个有趣的排序问题。如图所示，通过2个栈S1和S2，Tom希望借助以下4种操作实现将输入序列升序排序。操作a如果输入序列不为空，将第一个元素压入栈S1操作b如果栈S1不为空，将S1栈顶元素弹出至输出序列操作c如果输入序列不为空，将第一个元素压入栈S2操作d如果栈S2不为空，将S2栈顶元素弹出至输出序列如果一个1~n的排列P可以通过一系列操作使得输出序列为1，2，…，(n-1)，n，Tom就称P是一个“可双栈排序排列”。例如(1,3,2,4)就是一个“可双栈排序序列”，而(2,3,4,1)不是。下图描述了一个将(1,3,2,4)排序的操作序列：&lt;a,c,c,b,a,d,d,b&gt;当然，这样的操作序列有可能有几个，对于上例(1,3,2,4)，&lt;a,c,c,b,a,d,d,b&gt;是另外一个可行的操作序列。Tom希望知道其中字典序最小的操作序列是什么。【Input】第一行是一个整数n。第二行有n个用空格隔开的正整数，构成一个1~n的排列。【Output】共一行，如果输入的排列不是“可双栈排序排列”，输出数字0；否则输出字典序最小的操作序列，每两个操作之间用空格隔开，行尾没有空格。【Limited conditions】30%的数据满足：n&lt;=1050%的数据满足：n&lt;=50100%的数据满足：n&lt;=1000【Sample input】41 3 2 4【Sample output】a b a a b b a b【Sample explanation】无 Record2h这种题打不了暴力，建议手出数据检验 Analysis1请先思考后再展开 首先，因为放进去就不变了，两个栈都要保持单调递减考虑栈在排序中起了什么作用，其实就是辅助交换逆序对 那么很好想的方法一：贪心也就是说，尽量找操作编号小的来搞 先想简单的出栈，判断条件很简单：只要是当前需要输出的值在栈顶就弹出因为显然弹出一定最优 但是，入栈是有一定条件滴（以下数值都表示相对大小）既然是“双”，有一个经典的套路思想：由一及多先从单栈排序思考：如果出现2…3…1的情况，则无解而有了第二个栈（设为辅栈），就有了缓冲空间，但一旦出现如2…3…4…1的情况，就会炸分析一下为什么？ “1”的存在使2、3不能弹出 “3”和“4”的存在，都无法满足递减的要求 然鹅，双栈的特点在于多种可能所以即使没有直接像上面一样无解，也不能乱入栈，特别是到底入哪个栈考虑哪些情况会导致不能共存（这个方法二也会有）如3…2…5…1？那把5放辅栈就好了，这不是我们当前搞“2”要考虑的【当辅栈什么也没有，我们多了一条命】但，如果辅栈有东西呢？3…2…5…14哇肿么办【可以发现，这个其实无解，但这是等到5的时候再判断的】 “1”的存在又是让我们不能轻易弹出 “4”的存在让5不能过去所以这个时候，只能把“2”放过去 总结：对于主栈，即使有top1&gt;a[now]，如果有a[now]&lt;a[x1]且top2&lt;a[x1]同时有a[now]&gt;a[x2]限制弹出，则now只能尝试去辅栈上述条件对辅栈无效，因为辅栈没用就直接GG了 这样一来，判断无解就简单很多了：什么也干不了的时候 时间复杂度：O(n^2) Code1请先思考后再展开 undefined Analysis2请先思考后再展开 贪心这种东西，其实挺好的但考场上打还是要慎重所以考虑另一种显然的算法：二分图染色构图就是用不能共存的条件，从而划分为两个集合原因：只有两个栈 然后这种做法代码长一点，但比较无脑~时间复杂度：O(n^2) 【但事实上更快】 Code2请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>贪心</tag>
        <tag>模拟</tag>
        <tag>二分图染色</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1004】方格取数]]></title>
    <url>%2Fposts%2F3f83.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2000 提高组 T4Luogu1004Caioj1503 Problem【Brief description】设有N*N的方格图，我们将其中的某些方格中填入正整数，而其他的方格中则放数字0。某人从图的左上角的A点出发，可以向下行走，也可以向右走，直到到达右下角的B点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。此人从A点到B点共走两次，试找出2条这样的路径，使得取得的数之和为最大。【Input】输入的第一行为一个整数N（表示N*N的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的0表示输入结束。【Output】一个整数，表示2条路径上取得的最大的和。【Limited conditions】N&lt;=10【Sample input】82 3 132 6 63 5 74 4 145 2 215 6 46 3 157 2 140 0 0【Sample output】67【Sample explanation】12345678910A0 0 0 0 0 0 0 00 0 13 0 0 6 0 00 0 0 0 7 0 0 00 0 0 14 0 0 0 00 21 0 0 0 4 0 00 0 15 0 0 0 0 00 14 0 0 0 0 0 00 0 0 0 0 0 0 0 B Record30min Analysis请先思考后再展开 dp经典题两个人一起dp，避免过于贪心，便于处理只能拿一次的条件 UP:之前代码有误，现已更正详见：传纸条 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1006】传纸条]]></title>
    <url>%2Fposts%2F7e9b.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2008 提高组 T3Luogu1006Caioj1535 Problem【Brief description】小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排做成一个m行n列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标(1,1)，小轩坐在矩阵的右下角，坐标(m,n)。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用0表示），可以用一个0-100的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的两条路径。【Input】第一行有2个用空格隔开的整数m和n，表示班里有m行n列。接下来的m行是一个m*n的矩阵，矩阵中第i行j列的整数表示坐在第i行j列的学生的好心程度。每行的n个整数之间用空格隔开。【Output】包含一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。【Limited conditions】1&lt;=m,n&lt;=50【Sample input】3 30 3 92 8 55 7 0【Sample output】34【Sample explanation】 Record30minWA:枚举行的时候忽略了步数的限制，导致错误下标访问【感谢网上一篇文章，讲了一个错误点，让我解决了问题，所以我也要传递一下】【所以说之前方格取数的代码也是错误的，但20个数据只有一个错误……】 Analysis请先思考后再展开 首先，所谓双向，其实就是单向其次，所谓只能帮忙一次，就是只有一次贡献，因为所有数大于等于0，所以经过这里相当于没有经过 综上说述，问题转化为方格取数真没想到NOIP居然会重复考同一道题目…… Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1126】火柴棒等式]]></title>
    <url>%2Fposts%2Fce8e.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2008 提高组 T2Luogu1126Caioj1534 Problem【Brief description】给你n根火柴棍，你可以拼出多少个形如“A+B=C”的等式？等式中的A、B、C是用火柴棍拼出的整数（若该数非零，则最高位不能是0）。用火柴棍拼数字0-9的拼法如图所示：注意：1. 加号与等号各自需要两根火柴棍2. 如果A≠B，则A+B=C与B+A=C视为不同的等式（A、B、C&gt;=0）3. n根火柴棍必须全部用上【Input】共一行，又一个整数n。【Output】能拼成的不同等式的数目【Limited conditions】n&lt;=24【Sample input】14【Sample output】2【Sample explanation】2个等式为0+1=1和1+0=1。 Record1h Analysis请先思考后再展开 整理每个数字：2: 13: 74: 45: 2,3,56: 0,6,97: 8然后暴力走一走详细点说就是预处理费用下所有数然后枚举分配方案 Code请先思考后再展开 undefined 如何毒瘤地Hack？其实当看到题目难度标签是普及-的时候就感觉有点不对劲于是在噼里啪啦打完上面的不简单的爆搜后，一看题解woc都是直接枚举每一种数字但想半天也搞不懂他们是怎么取这个数字的（如1000、1111、2400） 那我当然就很不爽啊所以要把他们卡掉！那如果空间128MB的话，可能n可以出30，那25~30，恩怎么说卡30分是可以的~毕竟他们是N^2]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1125】笨小猴]]></title>
    <url>%2Fposts%2F8bcb.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2008 提高组 T1Luogu1125Caioj1533 Problem【Brief description】假设maxn是单词中出现次数最多的字母的出现次数，minn是单词中出现次数最少的字母的出现次数，如果maxn-minn是一个质数，那么笨小猴就认为这是个Lucky Word，这样的单词很可能就是正确的答案。【Input】一个单词【Output】第一行是一个字符串，假设输入的的单词是Lucky Word，那么输出“Lucky Word”，否则输出“No Answer”；第二行是一个整数，如果输入单词是Lucky Word，输出maxn-minn的值，否则输出0。【Limited conditions】单词中只可能出现小写字母，并且长度小于100。【Sample input】error【Sample output】Lucky Word2【Sample explanation】单词error中出现最多的字母r出现了3次，出现次数最少的字母出现了1次，3-1=2，2是质数。 Record10min Analysis请先思考后再展开 sb题 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1999】【Luogu1099】树网的核]]></title>
    <url>%2Fposts%2Fb262.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2007 提高组 T4Bzoj1999Luogu1099Caioj1532 Problem【Brief description】一句话：求直径上的路径F，长度不超过s，使树上最远点与其距离最小。精炼完整版：在无根树T上有n个结点，称d(a,b)为a,b两结点间的距离。一点v到一条路径P的距离为该点与P上的最近的结点的距离。无根树的直径：无根树中最长的路径称为无根树的直径。对于给定的无根树T，直径不一定是唯一的，但各直径的中点是唯一的。（不一定恰好是某个结点，可能在某条边的内部），我们称该点为无根树的中心。偏心距ECC(F)：无根树T中距路径F最远的结点到路径F的距离。任务：对于给定的无根树T和非负整数s，求一个路径F，它是某直径上的一段路径（该路径两端均为无根树中的结点），其长度不超过s，使偏心距ECC(F)最小。我们称这个路径为无根树T的核。必要时，F可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。下面的图给出了无根树的一个实例。图中，A-B与A-C是两条直径，长度均为20。点W是无根树的中心，EF边的长度为5。如果指定s=11，则无根树的核为路径DEFG（也可以取为路径DEF），偏心距为8。如果指定s=0（或s=1、s=2），则无根树的核为结点F，偏心距为12。【Input】第1行，两个正整数n和s。其中n为树网结点的个数，s为树网的核的长度的上界。设结点编号依次为1，2，……，n。从第2行到第n行，每行给出3个用空格隔开的正整数，依次表示每一条边的两个端点编号和长度。【Output】只有一个非负整数，为指定意义下的最小偏心距。【Limited conditions】5&lt;=n&lt;=500000, 0&lt;=s&lt;2^31边长度为不超过1000的正整数。【Sample input】8 61 3 22 3 23 4 64 5 34 6 44 7 27 8 3【Sample output】5【Sample explanation】无 Record5h Analysis请先思考后再展开 其实就是一道大水题关键：不同直径具有等效性经典思想（来自akc）：想象把直径挂起来成一条横线，然后其他东西挂在下面假设当前直径有ed个节点，等会当做已经有连续的编号，便于理解 解法1：n^3随便找一个直径，假设上面有t个节点乱搞枚举l和r，dfs找下面的东西 解法2：n^2首先，显然在合法（长度s内）的情况下，核的长度越大越好在解法1的基础上面用尺取法即可 解法3：nlogsum二分答案，然后把两个端点l和r缩短直到与直径左右端点的距离即将超过mid那么把l到r之间的，作为核最后检查中间部分是否超过s，同时看挂在核上面的子树，最深距离是否在mid以内即可 不用检查1~l-1和r+1~ed部分的地方，向下挂的部分，是因为由于直径的最长性对于那上面的任意位置x，下面挂的最大深度不会超过x与端点的最短距离（否则会有更长的直径） 解法4：n对于直径上的ed节点，考虑每个l和r的贡献$min { max (l到r间挂的最大深度,dis(直径左端点,l),dis(r,直径右端点)) }$此时如果用单调队列是可以直接搞定的了但还能更简单：根据解法3的最后一条，左右两边向下深度没有影响所以直接记从1到ed这每个节点向下最大深度的最大值为mx$min { max (mx,dis(直径左端点,l),dis(r,直径右端点)) }$ Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>单调队列</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1005】矩阵取数游戏]]></title>
    <url>%2Fposts%2F836e.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2007 提高组 T3Luogu1005Caioj1531 Problem【Brief description】对于一个给定的n*m的矩阵，矩阵中的每个元素均为非负整数。游戏规则如下：1.每次取数时须从每行各取走一个元素，共n个，m次后取完矩阵所有元素2.每次取走的各个元素只能是该元素所在行的行首或行尾3.每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分=被取走的元素值*2^i，其中i表示第i次取数（从1开始编号）；4.游戏结束总得分为m次取数得分之和。帅帅想请你帮忙写一个程序，对于任意矩阵取数后的最大得分。【Input】第1行为两个用空格隔开的整数n和m。第2~n+1行为n*m矩阵，其中每行有m个用单个空格隔开的非负整数。【Output】一个整数，即输入矩阵取数后的最大得分【Limited conditions】1&lt;=n, m&lt;=80，0&lt;=aij&lt;=1000【Sample input】2 31 2 33 4 2【Sample output】82【Sample input】2 1096 56 54 46 86 12 23 88 80 4316 95 18 29 30 53 88 83 64 67【Sample output】316994【Sample explanation】无 Record1h Analysis请先思考后再展开 分析题目，先简化问题：答案是由行组成的，所以可以每一行算出答案再累加而没有影响 首先，我的第一想法是贪心但是让我们举个反例： 解释 1 2 3 4 矩阵 13 1 10 11 我的傻瓜贪心 16 8 4 2 显然更合理的分配 2 4 8 16 分析一下为什么？显然贪心这种东西通常都是鼠目寸光的而每一次我们的选择显然会对后面的状态有影响 那么怎么办？正着不行就反过来嘛，从什么也没有开始，一个个加入？【因为总次数已经确定，所以能实现】但怎么加呢？难道枚举起点？那然后呢？总不能又回到贪心的老路子上 其实反过来后，很容易发现虽然一次选择鼠目寸光，但我们可以比较方案啊！再仔细思考，没错，这玩意是满足最优子结构的，也就是说，可以区间dp搞一搞 总结：区间dp+高精度【这很显然】 Code1惯例，先没有高精度请先思考后再展开 undefined Code2正确代码请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1098】字符串的展开]]></title>
    <url>%2Fposts%2Fa5cf.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2007 提高组 T2Luogu1098Caioj1530 Problem【Brief description】约定如下：(1) 遇到下面的情况需要做字符串的展开：在输入的字符串中，出现了减号“-”，减号两侧同为小写字母或同为数字，且按照ASCII码的顺序，减号右边的字符严格大于左边的字符。(2) 参数p1：展开方式。p1=1时，对于字母子串，填充小写字母；p1=2时，对于字母子串，填充大写字母。这两种情况下数字子串的填充方式相同。p1=3时，不论是字母子串还是数字字串，都用与要填充的字母个数相同的星号“*”来填充。(3) 参数p2：填充字符的重复个数。p2=k表示同一个字符要连续填充k个。例如，当p2=3时，子串“d-h”应扩展为“deeefffgggh”。减号两边的字符不变。(4) 参数p3：是否改为逆序：p3=1表示维持原来顺序，p3=2表示采用逆序输出，注意这时候仍然不包括减号两端的字符。例如当p1=1、p2=2、p3=2时，子串“d-h”应扩展为“dggffeeh”。(5)如果减号右边的字符恰好是左边字符的后继，只删除中间的减号。例如：“d-e”应输出为“de”，“3-4”应输出为“34”。如果减号右边的字符按照ASCII码的顺序小于或等于左边字符，输出时，要保留中间的减号例如：“d-d”应输出为“d-d”，“3-1”应输出为“3-1”。【Input】第1行为用空格隔开的3个正整数，依次表示参数p1，p2，p3。第2行为一行字符串，仅由数字、小写字母和减号“-”组成。行首和行末均无空格。【Output】只有一行，为展开后的字符串。【Limited conditions】1&lt;=p1&lt;=3，1&lt;=p2&lt;=8，1&lt;=p3&lt;=2字符串长度不超过100【Sample input】1 2 1abcs-w1234-9s-4zz【Sample output】abcsttuuvvw1234556677889s-4zz【Sample explanation】无 Record20min Analysis请先思考后再展开 sb题 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1097】统计数字]]></title>
    <url>%2Fposts%2Fc868.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2007 提高组 T1Luogu1097Caioj1529 Problem【Brief description】某次科研调查时得到了n个自然数，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。【Input】第一行是整数n，表示自然数的个数；第2~n+1每行一个自然数。【Output】包含m行（m为n个自然数中不相同数的个数），按照自然数从小到大的顺序输出。每行输出两个整数，分别是自然数和该数出现的次数，其间用一个空格隔开。【Limited conditions】1&lt;=n&lt;=200000每个数均不超过1500000000（1.5*10^9）【Sample input】8242451002100【Sample output】2 34 25 1100 2【Sample explanation】无 Record10min Analysis请先思考后再展开 sb题 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1066】2^k进制数]]></title>
    <url>%2Fposts%2Fa045.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2006 提高组 T4Luogu1065Caioj1528 Problem【Brief description】设r是个2^k进制数，并满足以下条件：（1）r至少是个2位的2^k进制数。（2）作为2^k进制数，除最后一位外，r的每一位严格小于它右边相邻的那一位。（3）将r转换为2进制数q后，则q的总位数不超过w。在这里，正整数k和w是事先给定的。我们再从另一角度作些解释：设S是长度为w的01字符串，S对应于上述条件（3）中的q。将S从右起划分为若干个长度为k的段，每段对应一位2^k进制的数，如果S至少可分成2段，则S所对应的二进制数又可以转换为上述的2^k进制数r。问：满足上述条件的不同的r共有多少个？【Input】输入只有1行，为两个正整数，用一个空格隔开：k W【Output】输出为1行，是一个正整数，为所求的计算结果，即满足条件的不同的r的个数（用十进制数表示），要求最高位不得为0，各数字之间不得插入数字以外的其他字符（例如空格、换行符、逗号等）。（提示：作为结果的正整数可能很大，但不会超过200位）【Limited conditions】1&lt;=k&lt;=9k&lt;W&lt;=30000【Sample input】3 7【Sample output】36【Sample explanation】例：设k=3，w=7。则r是个八进制数（2^3=8）。由于w=7，长度为7的01字符串按3位一段分，可分为3段（即1，3，3，左边第一段只有一个二进制位），则满足条件的八进制数有：2位数：高位为1：6个（即12，13，14，15，16，17），高位为2：5个，…，高位为6：1个（即67）。共6+5+…+1=21个。3位数：高位只能是1，第2位为2：5个（即123，124，125，126，127），第2位为3：4个，…，第2位为6：1个（即167）。共5+4+…+1=15个。所以，满足要求的r共有36个。 Record2h Analysis1请先思考后再展开 比较裸的数位dp，套个高精度说的很轻松，居然没有想出来，好菜啊 首先，分析条件由条件1知，r的长度最少为2由条件3知，r的长度最多为$s= \left \lceil \frac{w}{k} \right \rceil$并且当达到最大长度的时候，r的最高位最多为$q=2^{w\%k}-1$，否则转化为二进制后超过w 那么剩下的就是条件2了，这个限制条件可以看做一种递推关系考虑设$f(i,j)$表示长度为i的r，$最后一位\leq j$的方案数则有$f(i,j)=f(i,j-1)+f(i-1,j-1)$意思就是，$(最后一位\leq j-1)+(最后一位=j)$【注意：题目要求是严格小于】 那么答案就是$$\sum_{长度ln=2}^{s-1} f(ln,2^k-1)+\sum_{最高位m=1}^{q} f(s-1,q-m)$$解释右式：最高位m已经确定，剩下的s-1个数，范围是$m+1 \sim mx$，相当于$1 \sim mx-m$ 补充一个细节：向上取整的时候，可以直接+1，即使加多了，q=0，没有影响 先丢个简单易懂的非高精度吧，居然有70，但加上高精度也没多难 Code1请先思考后再展开 undefined Analysis2请先思考后再展开 基本功——高精度但是这样会炸空间呀……考场是只能瞎搞一个大小了【其实也有可能是其他解法，例如组合数学】恩通过计算，在不炸空间的情况下，只能开190然鹅事实证明太小啦！其实压位不就好了……手动抠鼻压9位就阔以1600了，这三十分能拿多少拿多少嘛~ 【以上模拟考场策略】 Code2请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>数位dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1065】作业调度方案]]></title>
    <url>%2Fposts%2Fa978.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2006 提高组 T3Luogu1065Caioj1527长长的原题面，我已简化 Problem【Brief description】我们现在要利用m台机器加工n个工件，每个工件都有m道工序。每道工序都在不同的指定的机器上完成，每个工件的每道工序都有指定的加工时间。每个工件的每个工序称为一个操作，给出操作顺序，你的任务就是设计符合该顺序的实施方案。实施方案条件（后面不得违背前面）：1. 对同一个工件，每道工序必须在它前面的工序完成后才能开始；2. 同一时刻每一台机器至多只能加工一个工件。3. 在安排后面的操作时，不能改动前面已安排的操作的工作状态。4. 尽量靠前插入空档。5. 如果有多个空档可以插入，就插入到最前面的一个空档。操作顺序以以下格式描述：共n*m个正整数，表示对应的工件编号，同一工件编号共出现m次，分别表示m个工序的执行顺序【原理是方案条件1】注意，“安排顺序”只要求按照给定的顺序安排每个操作。不一定是各机器上的实际操作顺序。在具体实施时，有可能排在后面的某个操作比前面的某个操作先完成。显然，在这些约定下，对于给定的安排顺序，符合该安排顺序的实施方案是唯一的。请你计算出该方案完成全部任务所需的总时间。【Input】输入文件的第1行为两个正整数，用一个空格隔开：m n （其中m表示机器数，n表示工件数）第2行：m*n个用空格隔开的数，为给定的安排顺序。接下来的2n行，每行都是用空格隔开的m个正整数，每个数不超过20。其中前n行依次表示每个工件的每个工序所使用的机器号，第1个数为第1个工序的机器号，第2个数为第2个工序机器号，等等。后n行依次表示每个工件的每个工序的加工时间。【Output】一个正整数，为最少的加工时间【Limited conditions】m&lt;20n&lt;20物品的价格都是10元的整数倍【Sample input】2 31 1 2 3 3 21 21 22 13 22 52 4【Sample output】10【Sample explanation】 Record30min Analysis请先思考后再展开 时间上限：8000模拟即可 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1064】金明的预算方案]]></title>
    <url>%2Fposts%2F8231.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2006 提高组 T2Luogu1064Caioj1526 Problem【Brief description】如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。【Input】输入的第1行，为两个正整数，用一个空格隔开：N m （其中N表示总钱数，m为希望购买物品的个数。）从第2行到第m+1行，第j行给出了编号为j-1的物品的基本数据，每行有3个非负整数v p q（其中v表示该物品的价格，p表示该物品的重要度（1~5），q表示该物品是主件还是附件。如果q=0，表示该物品为主件，如果q&gt;0，表示该物品为附件，q是所属主件的编号）【Output】输出只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（&lt;200000）【Limited conditions】N&lt;32000m&lt;60v&lt;10000物品的价格都是10元的整数倍【Sample input】1000 5800 2 0400 5 1300 5 1400 3 0500 2 0【Sample output】2200【Sample explanation】无 Record30min Analysis请先思考后再展开 这题的关键在于附件的存在，但“附件的个数不超过2”大大降低了难度那么对于每个主件，只有以下情况 只买主件 买主件和附件1 买主件和附件2 买主件和两个附件将输入整理后，就转化成了背包问题中的经典问题：采药 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1063】能量项链]]></title>
    <url>%2Fposts%2Fd69c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2006 提高组 T1Luogu1063Caioj1525 Problem【Brief description】在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为m*r*n（Mars单位），新产生的珠子的头标记为m，尾标记为n。需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。【Input】输入的第一行是一个正整数N，表示项链上珠子的个数。第二行是N个用空格隔开的正整数，所有的数均不超过1000。第i个数为第i颗珠子的头标记（1≤i≤N），当1≤i&lt;N时，第i颗珠子的尾标记应该等于第i+1颗珠子的头标记。第N颗珠子的尾标记应该等于第1颗珠子的头标记。至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。【Output】一个正整数E，为一个最优聚合顺序所释放的总能量。【Limited conditions】4≤N≤100E≤2.1*10^9【Sample input】42 3 5 10【Sample output】710【Sample explanation】4颗珠子的头标记与尾标记依次为(2，3) (3，5) (5，10) (10，2)。我们用记号⊕表示两颗珠子的聚合操作，(j⊕k)表示第j，k两颗珠子聚合后所释放的能量。则第4、1两颗珠子聚合后释放的能量为：(4⊕1)=10*2*3=60。这一串项链可以得到最优值的一个聚合顺序所释放的总能量为((4⊕1)⊕2)⊕3）=10*2*3+10*3*5+10*5*10=710。 Record30min Analysis请先思考后再展开 首先，这是一个环，经典的套路就是复制一次在后面然后就是一个单纯的dp了 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1051】篝火晚会]]></title>
    <url>%2Fposts%2Fb7e3.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2005 提高组 T3Luogu1053Caioj1523 Problem【Brief description】佳佳刚进高中，在军训的时候，由于佳佳吃苦耐劳，很快得到了教官的赏识，成为了“小教官”。在军训结束的那天晚上，佳佳被命令组织同学们进行篝火晚会。一共有n个同学，编号从1到n。一开始，同学们按照1，2，……，n的顺序坐成一圈，而实际上每个人都有两个最希望相邻的同学。如何下命令调整同学的次序，形成新的一个圈，使之符合同学们的意愿，成为摆在佳佳面前的一大难题。佳佳可向同学们下达命令，每一个命令的形式如下：(b1, b2,… bm -1, bm)这里m的值是由佳佳决定的，每次命令m的值都可以不同。这个命令的作用是移动编号是b1，b2，…… bm的这m个同学的位置。要求b1换到b2的位置上，b2换到b3的位置上，……，要求bm换到b1的位置上。执行每个命令都需要一些代价。我们假定如果一个命令要移动m个人的位置，那么这个命令的代价就是m。我们需要佳佳用最少的总代价实现同学们的意愿，你能帮助佳佳吗？【Input】第一行是一个整数n，表示一共有n个同学。其后n行每行包括两个不同的正整数，以一个空格隔开，分别表示编号是1的同学最希望相邻的两个同学的编号，编号是2的同学最希望相邻的两个同学的编号，……，编号是n的同学最希望相邻的两个同学的编号。【Output】这一行只包含一个整数，为最小的总代价。如果无论怎么调整都不能符合每个同学的愿望，则输出-1。【Limited conditions】3&lt;=n&lt;=50000【Sample input】43 44 31 21 2【Sample output】2【Sample explanation】无 Record2h Analysis请先思考后再展开 首先，假设现在有k个人在错误的位置上，那么最小花费显然就是k【猜结论】那么问题就在于如何判断多少个人错误呢?因为这是一个环，当构造出当前环和目标环后，比较也是要O(n^2)，tle妥妥的 那么接下来就是求最少错误的，等价于求最多正确的当然这里的错误与正确只是相对的，分离出不同的链就有不同的结果，取得是最多的罢了那么怎么求呢？有个很妙的方法：所谓正确的，在环状态下，其实它们与原位置的偏移量是相同的那么计算出偏移量，选取其中最多的一种方案即可 不过猜结论还是有点危险啊，因为还要反着跑一遍栗子：当前：2 3 4 1目标：4 3 2 1其实目标就是4 1 2 3，也就是反过来那么答案不是2而是0 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1054】等价表达式]]></title>
    <url>%2Fposts%2F146c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2005 提高组 T4Luogu1054Caioj1524 Problem【Brief description】明明进了中学之后，学到了代数表达式。有一天，他碰到一个很麻烦的选择题。这个题目的题干中首先给出了一个代数表达式，然后列出了若干选项，每个选项也是一个代数表达式，题目的要求是判断选项中哪些代数表达式是和题干中的表达式等价的。这个选择题中的每个表达式都满足下面的性质：1． 表达式只可能包含一个变量‘a’。2． 表达式中出现的数都是正整数，而且都小于10000。3． 表达式中可以包括四种运算‘+’，‘-’，‘*’，‘^’，以及小括号‘(’，‘)’。（注意：运算符‘+’，‘-’，‘*’，‘^’以及小括号‘(’，‘)’都是英文字符）小括号的优先级最高，其次是‘^’，然后是‘*’，最后是‘+’和‘-’。‘+’和‘-’的优先级是相同的。相同优先级的运算从左到右进行。4． 幂指数只可能是1到10之间的正整数（包括1和10）。5． 表达式内部，头部或者尾部都可能有一些多余的空格。下面是一些合理的表达式的栗子：123456((a ^1)^2)^3a* a+a-a((a+a) )9999+(a-a)*a1+(a -1)^31^ 10^9【Input】第一行给出的是题干中的表达式。第二行是一个整数n，表示选项的个数。后面n行，每行包括一个选项中的表达式。这n个选项的标号分别是A，B，C，D……输入中的表达式的长度都不超过50个字符，而且保证选项中总有表达式和题干中的表达式是等价的。【Output】一系列选项的标号，表示哪些选项是和题干中的表达式等价的。选项的标号按照字母顺序排列，而且之间没有空格。【Limited conditions】2&lt;=n&lt;=26【Sample input】12345( a + 1) ^23(a-1)^2+4*aa + 1+ aa^2 + 2 * a * 1 + 1^2 + 10 -10 +a -a【Sample output】AC【Sample explanation】无 Record30min Analysis请先思考后再展开 看到题面，突然就想到了NOIP2017D1T2的“时间复杂度”都是很有意思的题目呢虽然理论上“侦探推理”也很有意思，但纯属码农题 其实这道题感觉小学的时候想过，当时想设计四则运算的计算器，但半途而废了…… 好了讲正事用函数递归求解每次找优先级最低的地方，递归左右后计算即可 然后本来想自然溢出的，结果差一个点，改long long就行了 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1092】虫食算]]></title>
    <url>%2Fposts%2F6a62.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2004 提高组 T4Luogu1092Caioj1519 Problem【Brief description】所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的字母。来看一个简单的栗子：123 43#9865#045+ 8468#6633=44445509678其中#号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是5和3，第二行的数字是5。现在，我们对问题做两个限制：首先，我们只考虑加法的虫食算。这里的加法是N进制加法，算式中三个数都有N位，允许有前导的0。其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是N进制的，我们就取英文字母表的前N个大写字母来表示这个算式中的0到N-1这N个不同的数字,但是这N个字母并不一定顺序地代表0到N-1。输入数据保证N个字母分别至少出现一次。123 BADC+CBDA DCCC上面的算式是一个4进制的算式。很显然，我们只要让ABCD分别代表0123，便可以让这个柿子成立了。你的任务是，对于给定的N进制加法算式，求出N个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解.【Input】包含四行。第一行有一个正整数N，后面的3行每行有一个由大写字母组成的字符串，分别代表两个加数以及和。这3个字符串左右两端都没有空格，从高位到低位，并且恰好有N位。【Output】包含一行。在这一行中，应当包含唯一的那组解。解是这样表示的：输出N个数字，分别表示A，B，C……所代表的数字，相邻的两个数字用一个空格隔开，不能有多余的空格。【Limited conditions】N&lt;=26【Sample input】5ABCEDBDACEEBBAA【Sample output】1 0 3 4 2【Sample explanation】无 Record1h Analysis1请先思考后再展开 先打了个暴力，想着数据可能水【其实的确没有极限数据】但依然TLE，但已经剪枝了然后跟着题解，发现可以不递推进位，减更多这时候还是差一点，然后就是一个神奇的玄学操作了：重新编号（从后往前），dfs决断的时候编号从大到小我一开始想着，这是为了搞掉首位进位（这个也是跟题解学的）那既然如此编号从前往后，dfs的时候从小到大也一样吧结果差距是几十倍？？ 考场上绝对不能这么玩，会死的很惨 Code1请先思考后再展开 undefined Analysis2请先思考后再展开 并没有看懂的正解：https://blog.csdn.net/JeremyGJY/article/details/50611568https://blog.csdn.net/outer_form/article/details/50611820 Code2请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>坑</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1052】过河]]></title>
    <url>%2Fposts%2F200e.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2005 提高组 T2Luogu1052Caioj1522 Problem【Brief description】在河上有一座独木桥，一只青蛙想沿着独木桥从河的一侧跳到另一侧。在桥上有一些石子，青蛙很讨厌踩在这些石子上。由于桥的长度和青蛙一次跳过的距离都是正整数，我们可以把独木桥上青蛙可能到达的点看成数轴上的一串整点：0，1，……，L（其中L是桥的长度）。坐标为0的点表示桥的起点，坐标为L的点表示桥的终点。青蛙从桥的起点开始，不停的向终点方向跳跃。一次跳跃的距离是S到T之间的任意正整数（包括S,T）。当青蛙跳到或跳过坐标为L的点时，就算青蛙已经跳出了独木桥。题目给出独木桥的长度L，青蛙跳跃的距离范围S,T，桥上石子的位置。你的任务是确定青蛙要想过河，最少需要踩到的石子数。【Input】第一行有一个正整数L，表示独木桥的长度。第二行有三个正整数S，T，M，分别表示青蛙一次跳跃的最小距离，最大距离，及桥上石子的个数。第三行有M个不同的正整数分别表示这M个石子在数轴上的位置（数据保证桥的起点和终点处没有石子）。所有相邻的整数之间用一个空格隔开。【Output】只包括一个整数，表示青蛙过河最少需要踩到的石子数。【Limited conditions】1&lt;=L&lt;=10^91&lt;=S&lt;=T&lt;=10，1&lt;=M&lt;=100【Sample input】102 3 52 3 5 6 7【Sample output】2【Sample explanation】无 Record30min Analysis请先思考后再展开 虽然说s和t都是不固定的，但它们的范围都灰常小，一种方案是状压，但代码复杂度较高，而且对新手不友好，按下不表。 其实，既然步数只有可能是1到10，那么由于题目根本不关心具体是怎么走过去的，甚至总步数都不关心，那么对于一段很长的距离，怎么走几乎是随便的。那么其实，无论s和t的取值是什么，对于1到10的最小公倍数2520（有的人会问怎么计算？把所有数字列出来，然后诸如4和8，就只取8，剩下7、8、9、10，那么因为10里面有2,8变成4，于是它们的乘积即2520了）然后根据位置差，排序后压缩路径，用bool数组对点记录即可 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1051】谁拿了最多奖学金]]></title>
    <url>%2Fposts%2F5b4d.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2005 提高组 T1Luogu1051Caioj1521 Problem【Brief description】某校的惯例是在每学期的期末考试之后发放奖学金。发放的奖学金共有五种，获取的条件各自不同：1)院士奖学金，每人8000元，期末平均成绩高于80分，并且在本学期内发表1篇或1篇以上论文的学生均可获得；2)五四奖学金，每人4000元，期末平均成绩高于85分，并且班级评议成绩高于80分的学生均可获得；3)成绩优秀奖，每人2000元，期末平均成绩高于90分的学生均可获得；4)西部奖学金，每人1000元，期末平均成绩高于85分的西部省份学生均可获得；5)班级贡献奖，每人850元，班级评议成绩高于80分的学生干部均可获得；只要符合条件就可以得奖，每项奖学金的获奖人数没有限制，每名学生也可以同时获得多项奖学金。现在给出若干学生的相关数据，请计算哪些同学获得的奖金总数最高（假设总有同学能满足获得奖学金的条件）。【Input】第一行是一个整数N，表示学生的总数。接下来的N行每行是一位学生的数据，从左向右依次是姓名，期末平均成绩，班级评议成绩，是否是学生干部，是否是西部省份学生，以及发表的论文数。姓名是由大小写英文字母组成的长度不超过20的字符串（不含空格）；期末平均成绩和班级评议成绩都是0到100之间的整数（包括0和100）；是否是学生干部和是否是西部省份学生分别用一个字符表示，Y表示是，N表示不是；发表的论文数是0到10的整数（包括0和10）。每两个相邻数据项之间用一个空格分隔。【Output】第一行是获得最多奖金的学生的姓名，第二行是这名学生获得的奖金总数。如果有两位或两位以上的学生获得的奖金最多，输出他们之中在输入文件中出现最早的学生的姓名。第三行是这N个学生获得的奖学金的总数。【Limited conditions】1&lt;=N&lt;=100【Sample input】4YaoLin 87 82 Y N 0ChenRuiyi 88 78 N Y 1LiXin 92 88 N N 0ZhangQin 83 87 Y N 1【Sample output】ChenRuiyi900028700【Sample explanation】例如姚林的期末平均成绩是87分，班级评议成绩82分，同时他还是一位学生干部，那么他可以同时获得五四奖学金和班级贡献奖，奖金总数是4850元。 Record30min Analysis请先思考后再展开 模拟题 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1091】合唱队形]]></title>
    <url>%2Fposts%2F10e.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2004 提高组 T3Luogu1091Caioj1518 Problem【Brief description】N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学排成合唱队形。剩下的k个同学，要求顺序不变的情况下，身高从低到高再到低。已知所有N位同学的身高，计算最少需要几位同学出列。【Input】第一行是一个整数N，表示同学的总数。第一行有n个整数，用空格分隔，第i个整数Ti是第i位同学的身高(厘米)。【Output】一个整数，就是最少需要几位同学出列【Limited conditions】2&lt;=N&lt;=100130&lt;=Ti&lt;=230【Sample input】8186 186 150 200 160 130 197 220【Sample output】4【Sample explanation】无 Record20min Analysis请先思考后再展开 相当于求最长上升子序列和最长下降子序列 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1090】合并果子]]></title>
    <url>%2Fposts%2F7e7e.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2004 提高组 T2Luogu1090Caioj1517 Problem【Brief description】在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n-1 次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。【Input】包括两行，第一行是一个整数n，表示果子的种类数。第二行包含n个整数，用空格分隔，第i个整数ai是第i种果子的数目。【Output】一个整数，也就是最小的体力耗费值。【Limited conditions】1&lt;=n&lt;=100001&lt;=ai&lt;=20000最小的体力耗费值小于2^31【Sample input】31 2 9【Sample output】15【Sample explanation】有3种果子，数目依次为1，2，9。可以先将1、2堆合并，新堆数目为 3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为12。所以多多总共耗费体力=3+12=15。可以证明15为最小的体力耗费值。 Record20min Analysis请先思考后再展开 唉没看清题目，以为是石子合并其实这道题是任意两堆合并，不在乎顺序的……所以只要每次取最小的两个，贪心即可 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1041】传染病控制]]></title>
    <url>%2Fposts%2F5005.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2003 提高组 T4Luogu1041Caioj1515 Problem【Brief description】研究表明，这种传染病的传播具有两种很特殊的性质；第一是它的传播途径是树型的，一个人 X 只可能被某个特定的人 Y 感染，只要 Y 不得病，或者是XY之间的传播途径被切断，则X就不会得病。第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。你的程序要针对给定的树，找出合适的切断顺序。【Input】输入格式的第一行是两个整数n和p。接下来p行，每一行有两个整数i和j，表示节点i和j间有边相连（意即，第i人和第j人之间有传播途径相连）。其中节点1是已经被感染的患者。【Output】输出总共被感染的人数【Limited conditions】1≤n≤300【Sample input】7 61 21 32 42 53 63 7【Sample output】3【Sample explanation】无 Record1h Analysis1请先思考后再展开 一开始打了个贪心，居然90？？？简易数据：10 91 21 32 42 52 63 77 88 99 10 Code1请先思考后再展开 undefined Analysis2请先思考后再展开 原来爆搜就好了QAQ Code2请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1089】津津的储蓄计划]]></title>
    <url>%2Fposts%2Fe897.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2004 提高组 T1Luogu1089Caioj1516 Problem【Brief description】津津的零花钱一直都是自己管理。每个月的月初妈妈给津津300元钱，津津会预算这个月的花销，并且总能做到实际花销和预算的相同。为了让津津学习如何储蓄，妈妈提出，津津可以随时把整百的钱存在她那里，到了年末她会加上20％还给津津。因此津津制定了一个储蓄计划：每个月的月初，在得到妈妈给的零花钱后，如果她预计到这个月的月末手中还会有多于100元或恰好100元，她就会把整百的钱存在妈妈那里，剩余的钱留在自己手中。例如11月初津津手中还有83元，妈妈给了津津300元。津津预计11月的花销是180元，那么她就会在妈妈那里存200元，自己留下183元。到了11月月末，津津手中会剩下3元钱。津津发现这个储蓄计划的主要风险是，存在妈妈那里的钱在年末之前不能取出。有可能在某个月的月初，津津手中的钱加上这个月妈妈给的钱，不够这个月的原定预算。如果出现这种情况，津津将不得不在这个月省吃俭用，压缩预算。现在请你根据2004年1月到12月每个月津津的预算，判断会不会出现这种情况。如果不会，计算到2004年年末，妈妈将津津平常存的钱加上20％还给津津之后，津津手中会有多少钱。【Input】包括12行数据，每行分别表示1月到12月津津的预算。【Output】一行，这一行只包含一个整数。如果储蓄计划实施过程中出现某个月钱不够用的情况，输出-X，X表示出现这种情况的第一个月；否则输出到2004年年末津津手中会有多少钱。【Limited conditions】预算是一个小于350的非负整数【Sample input】29023028020030017034050908020060【Sample output】-7【Sample explanation】无 Record20min Analysis请先思考后再展开 模拟 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1006】加分二叉树]]></title>
    <url>%2Fposts%2F1339.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2003 提高组 T3Luogu1006Caioj1535 Problem【Brief description】设一个n个节点的二叉树tree的中序遍历为（1,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下：subtree的左子树的加分×subtree的右子树的加分+subtree的根的分数若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出；（1）tree的最高加分（2）tree的前序遍历【Input】第1行：一个整数n，为节点个数。第2行：n个用空格隔开的整数，为每个节点的分数。【Output】第1行：一个整数，为最高加分。第2行：n个用空格隔开的整数，为该树的前序遍历。【Limited conditions】n＜30分数＜100结果不会超过4,000,000,000【Sample input】55 7 1 2 10【Sample output】1453 1 2 4 5【Sample explanation】无 Record30min Analysis请先思考后再展开 经典题 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2326】数学作业]]></title>
    <url>%2Fposts%2F34da.html</url>
    <content type="text"><![CDATA[Source and JudgeHNOI2011 Day1 T1Bzoj2326Luogu3216 Problem【Brief description】给定正整数 N 和 M 要求计算 Concatenate (1 .. N) Mod M 的值，其中 Concatenate (1 ..N)是将所有正整数 1, 2, …, N 顺序连接起来得到的数。例如，N = 13, Concatenate (1 .. N)=12345678910111213.小C 想了大半天终于意识到这是一道不可能手算出来的题目，于是他只好向你求助，希望你能编写一个程序帮他解决这个问题。【Input】只有一行且为用空格隔开的两个正整数N和M，【Output】仅包含一个非负整数，表示 Concatenate (1 .. N) Mod M 的值。【Limited conditions】1≤N≤10^18且1≤M≤10^9.【Sample input】13 13【Sample output】4【Sample explanation】无 Analysis请先思考后再展开 矩阵乘法分层即可今天早上考试的签到题 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1038】神经网络]]></title>
    <url>%2Fposts%2F3ef1.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2003 提高组 T1Luogu1038Caioj1512 Problem【Brief description】在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的栗子：神经元〔编号为1）图中，X1―X3是信息输入渠道，Y1－Y2是信息输出渠道，C1表示神经元目前的状态，Ui是阈值，可视为神经元的一个内在参数。神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的栗子。兰兰规定，Ci服从公式：（其中n是网络中所有神经元的数目）公式中的Wji（可能为负值）表示连接j号神经元和i号神经元的边的权值。当 Ci 大于0时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为Ci。如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（Ci），要求你的程序运算出最后网络输出层的状态。【Input】第一行是两个整数n和p。接下来n行，每行两个整数，第i＋1行是神经元i最初状态和其阈值（Ui），非输入层的神经元开始时状态必然为0。再下面P行，每行由两个整数i，j及一个整数Wij，表示连接神经元i、j的边权值为Wij。【Output】输出文件包含若干行，每行有两个整数，分别对应一个神经元的编号，及其最后的状态，两个整数间以空格分隔。仅输出最后状态大于零的输出层神经元状态，并且按照编号由小到大顺序输出！若输出层的神经元最后状态均为 0，则输出 NULL。【Limited conditions】1≤n≤200【Sample input】5 61 01 00 10 10 11 3 11 4 11 5 12 3 12 4 12 5 1【Sample output】3 14 15 1【Sample explanation】无 Record30min Analysis请先思考后再展开 拓扑裸题坑点: 输入层c不用计算，u没用 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>拓扑</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1039】侦探推理]]></title>
    <url>%2Fposts%2F9061.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2003 提高组 T2Luogu1039Caioj1513 Problem【Brief description】明明的同学们先商量好由其中的一个人充当罪犯（在明明不知情的情况下），明明的任务就是找出这个罪犯。接着，明明逐个询问每一个同学，被询问者可能会说：证词中出现的其他话，都不列入逻辑推理的内容。明明所知道的是，他的同学中有N个人始终说假话，其余的人始终说真。现在，明明需要你帮助他从他同学的话中推断出谁是真正的凶手，请记住，凶手只有一个！【Input】输入由若干行组成，第一行有三个整数，M、N和P；M是参加游戏的明明的同学数，N是其中始终说谎的人数，P是证言的总数。接下来M行，每行是明明的一个同学的名字（英文字母组成，没有空格，全部大写）。往后有P行，每行开始是某个同学的名宇，紧跟着一个冒号和一个空格，后面是一句证词，符合前表中所列格式。证词每行不会超过250个字符。输入中不会出现连续的两个空格，而且每行开头和结尾也没有空格。【Output】如果你的程序能确定谁是罪犯，则输出他的名字；如果程序判断出不止一个人可能是罪犯，则输出 Cannot Determine；如果程序判断出没有人可能成为罪犯，则输出 Impossible。【Limited conditions】1≤M≤201≤N≤M1≤P≤100【Sample input】3 1 5MIKECHARLESKATEMIKE: I am guilty.MIKE: Today is Sunday.CHARLES: MIKE is guilty.KATE: I am guilty.KATE: How are you??【Sample output】MIKE【Sample explanation】无 Record30min Analysis请先思考后再展开 真有意思的题面嘿嘿然后又去看了看数据没有极限数据是意料之中【取而代之的是恶心数据，不知道满分的都是什么人……】的了，但居然还有这个hhI love you!If there must be a deadline,I hope it is 10000 years!!!然后他的名字是拼音，翻译过来就是：曾经有一段真挚的感情。芳，在我面前，我没有珍惜。等到失去了以后，才追悔莫及。人世间最痛苦的事莫过于此。如果上天能给我一个再来一次的机会，我会对那个女孩子说三个字 好了讲正事，暴力枚举判断可行性即可就是这个输入麻烦……大小写敏感测试点#2：有一位同志，既承认自己有罪，又承认自己无罪。【然后答案居然是Impossible，辣鸡题面没说清】测试点#9：“I is not guilty.”，I是人名 woc，这道题大家别写了……虽然我已经把代码尽量精炼，依然是毒瘤题，特别是输入对了，理论上判断废话的时候，前面和后面可能会有废话，而中间重要，但没有这种数据就不打了，太恶心了这种题…… UP:弃坑了可能以后也不会填了贴一个别人的代码吧哎【灰常优质】 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1034】矩形覆盖]]></title>
    <url>%2Fposts%2F7.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2002 提高组 T4Luogu1034Caioj1511 Problem【Brief description】在平面上有 n 个点，每个点用一对整数坐标表示。例如：当 n=4 时，4个点的坐标分另为：p1(1,1),p2(2,2),p3(3，6),P4(0,7)，见图一。这些点可以用 k 个矩形（1&lt;=k&lt;=4）全部覆盖，矩形的边平行于坐标轴。当 k=2 时，可用如图二的两个矩形 s1，s2 覆盖，s1，s2 面积和为 4。问题是当 n 个点坐标和 k 给出后，怎样才能使得覆盖所有点的 k 个矩形的面积之和为最小。约定：覆盖一个点的矩形面积为 0；覆盖平行于坐标轴直线上点的矩形面积也为0。各个矩形必须完全分开（边线与顶点也都不能重合）。【Input】n k x1 y1 x2 y2 ……xn yn【Output】一个整数，即满足条件的最小的矩形面积之和。【Limited conditions】n&lt;=500&lt;=xi,yi&lt;=500【Sample input】4 21 12 23 60 7【Sample output】4【Sample explanation】无 Record1h Analysis1请先思考后再展开 首先手痒看了看数据，一如既往地水，连极限数据都没有一开始想着50^6枚举矩形对角点，发现很麻烦，计算量大于是又看了题解，正解太复杂，不管了……【其实正解(极角排序是计算几何的玩意)没有存在的必要，因为我测试了极限数据，灰常快】那么其实只要预设k个矩阵，枚举每个点，假设加入即可 Code1请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1033】自由落体]]></title>
    <url>%2Fposts%2F19c9.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2002 提高组 T3Luogu1033Caioj1510辣鸡题面一大堆错误 Problem【Brief description】在高为 H 的天花板上有 n 个小球，体积不计，位置分别为 0，1，2，… ，n-1。在地面上有一个小车（长为 L，高为 K，距原点距离为 S1）。已知小球下落距离计算公式为 $d=\frac{g\times t^2}{2}$ ，其中 g=10，t为下落时间。地面上的小车以速度 V 前进。小车与所有小球同时开始运动，当小球距小车的距离 &lt;= 0.0001时，即认为小球被小车接收（小球落到地面后不能被接收）。请你计算出小车能接收到多少个小球（当球落入车的尾部时，算作落入车内）。【Input】H，S1，V，L，K，n【Output】小车能接收到的小球个数【Limited conditions】1&lt;=H，S1，V，L，K，n&lt;=100000【Sample input】5.0 9.0 5.0 2.5 1.8 5【Sample output】1【Sample explanation】无 Record30min Analysis请先思考后再展开 一开始想错了……现在越来越觉得noip2017真的是太幸运了，题目比较正常这种精度题，公式很容易推错，特别是那个精度不是很懂怎么用然后比赛的时候也出不了什么强力数据 主要从最早和最晚情况考虑自由落体公式化简：$ t=\sqrt{\frac{d}{5}} $早：落到地面（底部）时间：$ a=\sqrt{\frac{H}{5}} $车头到达时间：$ b=\frac{S-(i+0.0001)}{v} $条件：$ a\geq b $晚：落到车尾（顶部）时间：$ c=\sqrt{\frac{H-K}{5}} $车尾到达时间：$ d=\frac{(S+L)-(i-0.0001)}{v} $条件：$ c\leq d $【注意很多网上代码的d都是错误的，0.0001应该是负】 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1032】字串变换]]></title>
    <url>%2Fposts%2F3d30.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2002 提高组 T2Luogu1032Caioj1509 Problem【Brief description】已知有两个字串 A, B 及一组字串变换的规则（至多6个规则）:A1 -&gt; B1A2 -&gt; B2规则的含义为：在 A中的子串 A1 可以变换为 B1、A2 可以变换为 B2 ……例如：A＝’abcd’ B＝’xyz’变换规则为：‘abc’-&gt;’xu’‘ud’-&gt;’y’‘y’-&gt;’yz’则此时，A 可以经过一系列的变换变为 B，其变换的过程为：‘abcd’-&gt;’xud’-&gt;’xy’-&gt;’xyz’共进行了三次变换，使得 A 变换为 B。【Input】A BA1 B1A2 B2… …【Output】若在 10 步（包含 10步）以内能将 A 变换为 B ，则输出最少的变换步数；否则输出”NO ANSWER!”【Limited conditions】所有字符串长度的上限为 20。【Sample input】abcd xyzabc xuud yy yz【Sample output】3【Sample explanation】无 Record2h剪枝是灰常重要滴！ Analysis1请先思考后再展开 边跑步边想……然后最好bfs，但去重好麻烦，先打个dfs试试感觉会超时，真的太危险啦然鹅事实上set的log可以剪掉灰常多的枝 or 数据乱出，很水果然是陈年老题s stl大法好 哦有个坑点：题目是可以变换，那就不一定要全部变 一直wa啊，有一个很玄学的地方，不知有没有dalao知道？UP:原来是因为，size返回的是一个无符号数，要转化为int Code1请先思考后再展开 undefined Analysis2请先思考后再展开 然后akc教我hash，自然溢出什么的终于到最快的正解bfs了不过因为是手写的数组，空间不好控制【不明确的数据范围】 Code2请先思考后再展开 undefined Analysis3请先思考后再展开 其实如果不满足也可以用折半搜索（不会刻意搜索我的其他题，应该会找到些解释）懒得打了……]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1031】均分纸牌]]></title>
    <url>%2Fposts%2F24a0.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2002 提高组 T1Luogu1031Caioj1508 Problem【Brief description】有N堆纸牌，编号分别为 1，2，…… , N。每堆上有若干张，但纸牌总数必为 N 的倍数。可以在任一堆上取若于张纸牌，然后移动。移牌规则为：在编号为1堆上取的纸牌，只能移到编号为2的堆上；在编号为N的堆上取的纸牌，只能移到编号为 N-1 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。【Input】N（N 堆纸牌）A1 A2 …… An （N 堆纸牌，每堆纸牌初始数）【Output】所有堆均达到相等时的最少移动次数。【Limited conditions】1 &lt;= N &lt;= 1001 &lt;= Ai &lt;= 10000【Sample input】49 8 17 6【Sample output】3【Sample explanation】123456N=4，4堆纸牌数分别为：(1) 9 (2) 8 (3) 17 (4) 6移动3次可达到目的：从 (3) 取 4 张牌放到 (4)（9 8 13 10） -&gt; 从 (3) 取 3 张牌放到 (2)（9 11 10 10） -&gt; 从 (2) 取 1 张牌放到 (1)（10 10 10 10） Record30min Analysis1请先思考后再展开 显然我的贪心很菜 首先，显然我们要与平均数比较，所以可以直接全部减去平均数那么把方向固定，以从左到右为例，对于i，前面i-1个已经解决【不一定是顺序上的】因为只能相邻操作，才保证了这种做法的正确性，总会有与i+1交互的过程那么自己不平衡的时候，步数+1，转移不平衡即可 Code1请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>好题</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1027】Car的旅行路线]]></title>
    <url>%2Fposts%2Fe9ee.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2001 提高组 T4Luogu1027Caioj1507 Problem【Brief description】又到暑假了，住在城市A的Car想和朋友一起去城市B旅游。她知道每个城市都有四个飞机场，分别位于一个矩形的四个顶点上，同一个城市中两个机场之间有一条笔直的高速铁路，第I个城市中高速铁路了的单位里程价格为Ti，任意两个不同城市的机场之间均有航线，所有航线单位里程的价格均为t。那么Car应如何安排到城市B的路线才能尽可能的节省花费呢?她发现这并不是一个简单的问题，于是她来向你请教。找出一条从城市A到B的旅游路线，出发和到达城市中的机场可以任意选取，要求总的花费最少。【Input】第一行为一个正整数n，表示有n组测试数据。每组的第一行有四个正整数s，t，A，B。S表示城市的个数，t表示飞机单位里程的价格，A，B分别为城市A，B的序号。接下来有S行，其中第I行均有7个正整数xi1，yi1，xi2，yi2，xi3，yi3，Ti，这当中的(xi1，yi1)，(xi2，yi2)，(xi3，yi3)分别是第I个城市中任意三个机场的坐标，T I为第I个城市高速铁路单位里程的价格。【Output】共有n行，每行一个数据对应测试数据。保留一位小数【Limited conditions】0&lt;=n&lt;=100&lt;S&lt;=1001&lt;=A，B&lt;=S【Sample input】13 10 1 31 1 1 3 3 1 302 5 7 4 5 2 18 6 8 8 11 6 3【Sample output】47.5【Sample explanation】 Record1h Analysis1请先思考后再展开 这就是一个复杂构图的最短路裸题属于码农题 关于矩形的第四个点，我是自己yy出来的，写了较多注释 Code1请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1026】统计单词个数]]></title>
    <url>%2Fposts%2Fd51a.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2001 提高组 T3Luogu1026Caioj1506 Problem【Brief description】给出一个长度不超过200的由小写英文字母组成的字母串。约定：该字串以每行20个字母的方式输入，且保证每行一定为20个。要求将此字母串分成k份，且每份中包含的单词个数加起来总数最大。每份中包含的单词可以部分重叠。当选用一个单词之后，其第一个字母不能再用。例如字符串this中可以包含this和is，选用this之后就不能包含th。单词在给出的一个不超过6个单词的字典中。要求输出最大的个数。【Input】第一行有2个正整数p，k。p表示字串的行数；k表示分为k个部分。接下来的p行，每行均有20个字符。再接下来有一个正整数s，表示字典中单词个数。接下来的s行，每行均有一个单词。【Output】一个整数，表示划分出来的最多单词个数【Limited conditions】1≤s≤6，1&lt;k≤40【Sample input】1 3thisisabookyouareaoh4isaoksab【Sample output】7【Sample explanation】按如下方式划分字符串：this/isabookyoua/reaoh Record1h Analysis1请先思考后再展开 错误解法：kmp乱搞会wa的……【居然也就20分】数据:1 4aaaaaaaaaaaaaaaaaaaa1aaaaa 主要思路：所谓寻找字符串，那划分一定不是重点【flag】那么就先kmp查找，统计一下断点的影响量即可 但这样会减重复然后不知道怎么更正……又去膜题解了 Code1请先思考后再展开 undefined Analysis2请先思考后再展开 居然又是dp哎好菜主要是预处理出区间的答案本做法其实灰常慢……因为匹配的时候是暴力但数据太水，而且题目居然还不说单词长度 Code2请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1025】数的划分]]></title>
    <url>%2Fposts%2F2ac6.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2001 提高组 T2Luogu1025Caioj1505 Problem【Brief description】将整数n分成k份，且每份不能为空，任意两份不能相同(不考虑顺序)。例如:n=7,k=3,下面三种分法被认为是相同的。1，1，5；1，5，1；5，1，1；问有多少种不同的分法。【Input】n,k【Output】一个整数，即不同的分法。【Limited conditions】6&lt;n&lt;=200，2&lt;=k&lt;=6【Sample input】7 3【Sample output】4【Sample explanation】4种分法为：1,1,5；1,2,4；1,3,3；2,2,3 Record1h Analysis请先思考后再展开 较慢：dfs但加上记忆化就和dp一样了……没必要纠结 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1024】一元三次方程求解]]></title>
    <url>%2Fposts%2Ff28f.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2001 提高组 T1Luogu1024Caioj1504 Problem【Brief description】有形如：ax^3+bx^2+c^x+d=0 这样的一个一元三次方程。给出该方程中各项的系数，并约定该方程存在三个不同实根(根的范围在-100至100之间)，且根与根之差的绝对值&gt;=1。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后2位。提示：记方程f(x)=0，若存在2个数x1和x2，且x1&lt;x2，f(x1)*f(x2)&lt;0，则在(x1，x2)之间一定有一个根。【Input】4个实数A，B，C，D【Output】三个实根，并精确到小数点后2位【Limited conditions】a，b，c，d 均为实数【Sample input】1 -5 -4 20【Sample output】-2.00 2.00 5.00【Sample explanation】无 Record10min Analysis1请先思考后再展开 神题…… Code1请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1019】单词接龙]]></title>
    <url>%2Fposts%2Ff653.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2000 提高组 T3Luogu1019Caioj1502 Problem【Brief description】单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 beast和astonish，如果接成一条龙则变为beastonish，另外相邻的两部分不能存在包含关系，例如at 和 atide 间不能相连。【Input】第一行为一个单独的整数n表示单词数，以下n行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在.【Output】只需输出以此字母开头的最长的“龙”的长度【Limited conditions】n&lt;=20【Sample input】5attouchcheatchoosetacta【Sample output】23【Sample explanation】连成的“龙”为atoucheatactactouchoose Record1h Analysis请先思考后再展开 躺床上想了半天，没什么思路无奈看正解tm居然是爆搜？？？这是提高组？？？ 合并条件： 重叠长度&gt;=1,并!=min(长度) 使用次数&lt;2 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1017】进制转换]]></title>
    <url>%2Fposts%2F375d.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2000 提高组 T1Luogu1017Caioj1500 Problem【Brief description】我们可以用这样的方式来表示一个十进制数:将每个阿拉伯数字乘以一个以该数字所处位置的(值减1)为指数,以10为底数的幂之和的形式。例如:123可表示为 1*10^2+2*10^1+3*10^0 这样的形式。与之相似的,对二进制数来说,也可表示成每个二进制数码乘以一个以该数字所处位置的(值-1)为指数,以2为底数的幂之和的形式。一般说来,任何一个正整数R或一个负整数-R都可以被选来作为一个数制系统的基数。如果是以R或-R为基数,则需要用到的数码为 0,1,….R-1。例如,当R=7时,所需用到的数码是0,1,2,3,4,5和6,这与其是R或-R无关。如果作为基数的数绝对值超过10,则为了表示这些数码,通常使用英文字母来表示那些大于9的数码。例如对16进制数来说,用A表示10,用B表示11,用C表示12,用D表示13,用E表示14,用F表示15。在负进制数中是用-R 作为基数,例如-15(十进制)相当于110001(-2进制),并且它可以被表示为2的幂级数的和数:110001=1*(-2)^5+1*(-2)^4+0*(-2)^3+0*(-2)^2+0*(-2)^1+1*(-2)^0设计一个程序,读入一个十进制数和一个负进制数的基数,并将此十进制数转换为此负进制下的数【Input】输入文件有若干行，每行有两个输入数据。第一个是十进制数N第二个是负进制数的基数-R。【Output】输出此负进制数，若此基数超过10，则参照16进制的方式处理。【Limited conditions】-R∈{-2,-3,-4,…,-20}-32768&lt;=N&lt;=32767【Sample input】30000 -2【Sample output】11011010101110000【Sample explanation】无 Record30min Analysis请先思考后再展开 自己推把7和-7，转换成-3进制即可 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1018】乘积最大]]></title>
    <url>%2Fposts%2F87af.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2000 提高组 T2Luogu1018Caioj1501 Problem【Brief description】设有一个长度为N的数字串，要求使用K个乘号将它分成K+1个部分，找出一种分法，使得这K+1个部分的乘积能够为最大。【Input】第一行共有2个自然数N，K第二行是一个长度为N的数字串。【Output】最大乘积【Limited conditions】6≤N≤40，1≤K≤6【Sample input】4 21231【Sample output】62【Sample explanation】无 Record30min Analysis请先思考后再展开 当年的梦魇f[i][k]=max( f[j][k-1]*(j+1~i) ) Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2186】【Luogu2155】沙拉公主的困惑]]></title>
    <url>%2Fposts%2F5557.html</url>
    <content type="text"><![CDATA[Source and JudgeSdoi2008Bzoj2186Luogu2155 Problem【Brief description】现有钞票编号范围为1到N的阶乘，但是，政府只发行编号与M!互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数灰常大，你只需计算出对R取模后的答案即可。R是一个质数。【Input】第一行为两个整数T，R。T表示该组中测试数据数目，R为模后面T行，每行一对整数N，M，见题目描述【Output】共T行，对于每一对N，M，输出1至N！中与M！互质的数的数量对R取模后的值【Limited conditions】R&lt;=10^9+10，T&lt;=10000，m&lt;=n1&lt;=N,M&lt;=10000000【Sample input】1 114 2【Sample output】1【Sample explanation】2^3=81+2+4+8=15 Record2h恶心数据卡常数……所以别开ll存 Analysis请先思考后再展开 首先，有这样一个我不会证明的定理：如果$gcd(x,a)=1$,则$gcd(x+k\times b,a)=1$那么如果对应这道题：如果$gcd(x,m!)=1$,则$gcd(x+k\times m!,m!)=1$而n!一定是m!的倍数，考虑把n!分成长度m!的一个个块，答案恰好变成这样的柿子(有关欧拉函数请找OI之路)：$$ANS=\frac{n!}{m!} \times \varphi(m!) (\mod R)$$那么套上欧拉函数的公式$\varphi(m!)=m! \times \frac{p1-1}{p1}\times \frac{p2-1}{p2}……\times \frac{pk-1}{pk}$：$$ANS=\frac{n!}{m!}\times m!\times \Pi_{t=1}^k \frac{pt-1}{pt} (\mod R) $$ $$ ANS=n!\times \Pi_{t=1}^k \frac{pt-1}{pt} (\mod R) $$ $$ ANS=n!\times\frac{\Pi_{t=1}^k(pt-1) }{\Pi_{t=1}^k pt} (\mod R) $$ $$ ANS=n!\times \Pi_{t=1}^k(pt-1) inv(pt) (\mod R) $$ 那就成功地消除了恶心的m!，瞬间简单很多预处理n!、小于等于m的质数p的【p-1】和【p的逆元】即可（因为m!的质因数显然是在m以内的，别被吓到） 嗯补充一句【经常要考虑】：$gcd(pt,R)\neq 1$而pt和R都是质数，那就只有一种情况了：pt=R那因为$n\geq m$，只要n不处理，逆元也不处理即可相当于除以R再乘以R网上经典数据：input1 34 3output2 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>逆元</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj5192】【Luogu4271】New Barns]]></title>
    <url>%2Fposts%2Fdd1c.html</url>
    <content type="text"><![CDATA[Source and JudgeUsaco2018 Feb PlatinumBzoj5192Luogu4271 Problem【Brief description】每次添加一个点（形成森林）求距离这个点最远的点【Input】第一行包含一个整数Q以下Q行，每行包含一个请求。每个请求的格式都是“B p”或是“Q k”分别告诉你建造一个牛棚并与牛棚p连接，或是根据定义求从牛棚k出发最远的距离。如果p=-1，则新的牛棚不会与其他牛棚连接。否则，p是一个已经建造的牛棚的编号。牛棚编号从1开始，所以第一个被建造的谷仓是1号谷仓，第二个是2号谷仓，以此类推。【Output】对于每个距离请求输出一行。注意一个没有连接到其他牛棚的牛棚的最远距离为0【Limited conditions】1≤Q≤10^5【Sample input】7B -1Q 1B 1B 2Q 3B 2Q 2【Sample output】021【Sample explanation】(1) \ (2)–(4) /(3)对于请求1，我们建造牛棚1。对于请求2，我们询问从1出发到最远连接的牛棚的距离。由于牛棚1没有与其他牛棚连接，所以回答是0。对于请求3，我们建造牛棚2并将其与牛棚1连接。对于请求4，我们建造牛棚3并将其与牛棚2连接。对于请求5，我们询问从3出发到最远连接的牛棚的距离。在这时，最远的是牛棚1，距离为2单位。对于请求6，我们建造牛棚4并将其与牛棚2连接。对于请求7，我们询问从2出发到最远连接的牛棚的距离。所有其他三个牛棚1，3，4都与2相距相同的距离1，所以这就是我们的回答。 Record5h考试考的题目 Analysis1请先思考后再展开 好难哇splay是二叉树，不行，而且无法维护距离【结构会变】题目还是很有特性的，没必要lct吧？然后就以为是qtree4，乱搞一通，写挂了…… 然后暴力居然也写挂了是什么鬼方法1：2428ms做法1，也是比较显然的做法：每个点维护它的子树下，与他距离的最大和次大，并记录他们的来源，从而避免与x来自同一个子树而造成路径重复然后询问的时候直接向上面的祖先询问即可但是这样碰到一条链会被卡所以要点分治保证复杂度【离线后进行，注意打上现在是否可用的标记即可】 然后这个东西我考试的时候也是想过的，甚至也想过了点分治但打到一半发现不知道怎么维护因为做题太少，被qtree4毒害太深，只知道用堆……结果不知道怎么确保不会重复路径……难不成又要两个堆？麻烦死了而且没时间了……其实只要最大和次大，万一与最大重复子树就次大好了，很轻松嘛~ 哦还要注意，因为点分治的存在，树的结构改变，距离要在原树上面求 Code1请先思考后再展开 undefined Analysis2请先思考后再展开 哇两百行呀真烦人不是吗？有没有更便捷的方法呢？ 对于树上的，某一点固定的，最长路径，有这样一个性质： 定义 树的直径为，树上最长路径（长度相等的话任意一条即可，对答案没有影响） 某一点固定的最长路径，其另一个端点就是 树的直径 的两个端点之一 然后如果加入一个点，新的 树的直径 的端点必定是这三个点中的两个证明不会，但找不到反例，有兴趣的反证法试试？其实好像OI很多玄学的定理主要都是用反证法的…… UP【思路from rose，作了修正】:果然是用反证法设树上直径a、b，对于当前查询节点now，假设存在一个非a、b的节点p到now的距离最大那么对于now和a的一个公共祖先也就是now和a路径上的点k，则必定也是a和b路径上的点【这里其实依然不是太完美】既然如此，必定k-p大于k-a，则p应该成为直径的端点，与非b矛盾Q.E.D【其实这个没什么好纠结的，用akc的话说，感性地认知就好了】 UP 2018.4.6：这个好像来自一个这样的性质对于直径中的任意一点，其距离树中其他点的最远距离不超过该点到达直径端点的距离。【这个还是灰常显而易见的，否则就不是端点了，rose的证明更多是搞这个】然后再补充一个：所有直径交于一点，且必定是中点类似的证明但是他有图：果然有图就是一切吗 那明确这个性质之后就很舒服了师兄和beginend是用LCT维护的……但其实根本不用，直接用根当标记就好了就问你短不短！ ps：感觉以后如果要出题，这个可以有hh Code2请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>动态点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj1845】Sumdiv]]></title>
    <url>%2Fposts%2Fecf1.html</url>
    <content type="text"><![CDATA[Source and JudgeRomania OI 2002Poj1845 Problem【Brief description】给出自然数A、B，求S=A^B的所有自然数因子和【Input】A,B【Output】S模9901【Limited conditions】0&lt;=A,B&lt;=50000000【Sample input】2 3【Sample output】15【Sample explanation】2^3=81+2+4+8=15 Record2h是求积而不是求和……脑子里想着题目是求和…… Analysis请先思考后再展开 题目要的就是：$$\sum_{t|A^B} t (\mod 9901)$$那么其实就是约数和公式啦：【OI之路】02数论算法-7约数个数与和然后把A分解质因数（线性筛搞一搞），就变成了经典的等比数列求和$$p^0+p^1+p^2+…+p^a (\mod 9901)——①$$那有两种做法，一个是二分法（之前说过），以及师兄教的常规操作：$①\times (p-1)$于是我想半天，结果是什么呢？其实……这样会更容易算:$①\times p-①=p^{a+1}-p^0$然后再除回去即可$$ANS=\Pi_{k=1}^{质因数个数} \frac{p_k^{a+1}-1}{p_k-1} (\mod 9901)$$于是就简单了，快速幂加上逆元即可 哦对了再说一句之前做一道noi的dp（寿司晚宴）的时候，学会了一个套路：分解质因数的时候，预处理 sqrt(n) 的即可，因为后面的只会有一个~ 嗯还有，万一没有逆元怎么办？也就是$gcd(9901,p_k-1)=1$那已知p是素数了，也就是说$p_k-1$是9901的倍数本来希望没有，结果一打印，贼多！都怪这模数太小！怎么办？别着急，不是还有二分法吗？反正好像都是logn的算法woc其实直接二分法得了，干嘛写两个 UP 2018.8.9:其实如果没有逆元也是可以做的观察一下，如果$p_k-1$是9901的倍数，那么$p_k \mod 9901=1$所以说此时，等比数列的底数是1，可以直接计算…… 送几组数据:59407 1259407 5940720 101 113 013131 654971933 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>逆元</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3240】【Luogu1397】矩阵游戏]]></title>
    <url>%2Fposts%2Fe426.html</url>
    <content type="text"><![CDATA[Source and JudgeNoi2013Bzoj3240Luogu1397 Problem【Brief description】$F[1][1]=1$$F[i][j]=a\times F[i][j-1]+b (j!=1)$$F[i][1]=c\times F[i-1][m]+d (i!=1)$输出F[n][m]除以1,000,000,007的余数。【Input】六个整数n,m,a,b,c,d【Output】F[n][m]除以1,000,000,007的余数【Limited conditions】【Sample input】3 4 1 3 2 6【Sample output】85【Sample explanation】样例中的矩阵为：1 4 7 1026 29 32 3576 79 82 85 Record2h呃我的矩阵是3乘3的，时间可能是别人的两倍以上?反正问题不大 Analysis请先思考后再展开 首先，这个n、m的大小这么奇葩，那就是有一定暗示的了（其实有的时候我就在想为啥非要搞特大、小数据范围来提示？有检验正确性能力即可）（UP：好像有人直接写十进制快速幂+常数优化搞过去了……）那么我们引用伟大的费马小定理：【OI之路】11更高级数论-1定理杂烩这个神奇玩意居然对矩阵也有效！【flag，见后文】在mod MOD（也就是1e9+7）下，设操作矩阵为A，那么$A^{1e9+6}=1 (\mod MOD)$ ，相当于单位矩阵所以对于同一行下，第m个=第m%(MOD-1)个而如果把【一行的转移+m到下一行第一个的转移】看作一个操作矩阵B，同理第n行=第n%(MOD-1)行综上所述，$f[n][m]=f[n\%(MOD-1)][m\%(MOD-1)]$ 然后我到这里就懵逼了：这么大的数字怎么存储？还要写高精度取模？？？如果你也是这么想，嗯英雄所见略同事实上，%(MOD-1)=%( (MOD-1)*10^k )，意思就是说，完全可以放到字符串里面，取一个模一下真是让人涨见识的骚操作QAQ剩下的就是推一个sb矩阵了 UP:发现自己wa了两个点【90分，其实也该满足了】？别着急我也是自信满满地提交，然后看别人题解才看到：a=1和c=1的特殊情况网上清一色“要特判”，但都没讲理由？ 首先，实验证明，我的两个操作矩阵$A^{MOD-1}\neq 1 (\mod MOD)$,事实上循环结长度是MOD为什么会出现这种情况呢？【开始解决flag】我们回顾一下，费马小定理的条件之一：gcd(A,MOD)=1但这里A是一个矩阵呀，怎么会有gcd？咳咳，别着急。前面我们直接啥也不管，以为网上题解说能就直接用了，所以才会有现在的状况 那么我先是问了下师兄，然后两人一起捣鼓半天，大概搞了个解释：注意，所有公式都是在模意义下进行我们回归到最初的公式【以行内转移举例，忽略行数，反正也就是二维】$$f[i]=a\times f[i-1]+b (\mod MOD)——①$$ 我们希望把它变成一个等比数列来搞出一个通项公式【没学过高中数学没关系，我也没学】构造一个b’使满足这个柿子：$$f[i]+b’=a\times (f[i-1]+b’) (\mod MOD)——②$$ 现在通过①和②推导出这道题的$b’=\frac{b}{a-1} (a\neq1)$辣么现在就能搞出一个通项公式啦$$f[i]+b’=a^{i-1}\times (f[1]+b’) (\mod MOD)$$ 既然是等比数列，那就搞上费马小定理吧~【gcd(a,MOD)=1并没有影响，因为题目条件里面限制了a的范围】$$f[i]+\frac{b}{a-1}=a^{ (i-1)\%(MOD-1) }\times (f[1]+\frac{b}{a-1}) (\mod MOD) (a\neq1)$$ 好了，我们搞这么多有什么用呢？师兄的说法：用来给你十进制快速幂呀！啊那行之间怎么转移呢？不会呀这么说原来根本就不是同一个做法好吗。那我干嘛要写在博客上呀 仅仅因为那个$a\neq1$没错我们现在说这么多就是为了解决我们丢了10分的问题【终于回到正题了】不扯了那a=1的时候，其实就变成了一个等差数列，通项公式：$$f[i]=f[1]+b\times (i-1) (\mod MOD)$$ 然后有个东西叫欧拉函数，$\phi(x)=在1到x的正整数中与x互质的数的个数$显然在x为质数的时候，$\phi(x)=x-1$那么在我们刚才矩阵乘法的时候，循环节可以记作$p=\phi(MOD)$由此而知$f[p+1]=f[1]$【当$a\neq1$的时候，p已经算出来了，现在算a=1的情况，p未知】$$f[p+1]=f[1]+b\times p (\mod MOD)$$ 那么$b\times p=0 (\mod MOD)$而这道题中，b一不是MOD的倍数，二不是0，则$p=0 (\mod MOD)$而p肯定又不是0，所以可以考虑把p看作MOD的倍数哇那就是说$$p=MOD 【a=1】$$ $$p=\phi(MOD)=MOD-1 【Otherwise】$$ 哈哈搞定~其实我自己觉得有种东扯扯西扯扯的感觉但好歹也是有理有据的嘛总结：综上所述，我们在搞n和m的时候，分别根据a和c是否是1来决定MOD（详见代码）然后经验就是，这种有特殊条件的定理，先不要引入矩阵乘法，而是把公式搞清楚，把各种细节考虑周到再去优化【虽然这道题也就10分】 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>好题</tag>
        <tag>难度3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hdu1588】Gauss Fibonacci]]></title>
    <url>%2Fposts%2F7e2f.html</url>
    <content type="text"><![CDATA[Source and JudgeDYGGHDU “Valentines Day” Open Programming Contest 2007-02-14Hdu1588Caioj1488 Problem【Brief description】g[i]=k*i+b。f[0]=0,f[1]=1,f[i]=f[i-1]+f[i-2] (i&gt;=2)求f[ g[0] ]+f[ g[1] ]+…+f[ g[n-1] ]的值，结果需要mod M【Input】多组数据四个整数k,b,n,M【Output】每行一个答案【Limited conditions】每个数不超过1,000,000,000.【Sample input】2 1 4 1002 0 4 100【Sample output】2112【Sample explanation】无 Record30min Analysis请先思考后再展开 那个。。推公式的时候注意矩阵乘法操作顺序不可调转$$f[b]+f[k+b]+f[2\times k+b]…+f[(n-1)\times k+b]$$转化为矩阵A（通常计算斐波拉契的递推矩阵，自己推）$$A^b\times f[0]+A^{k+b}\times f[0]…+A^{(n-1)\times k+b}\times f[0]$$提取公因式$A^b\times f[0]$$$( A^0+A^k…+A^{(n-1)\times k} )\times A^b\times f[0]$$令$B=A^k$$$( B^0+ B^1…+B^{n-1} )\times A^b\times f[0]$$于是就变成了一个等比数列求和问题了 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3233】Matrix Power Series]]></title>
    <url>%2Fposts%2F3bd.html</url>
    <content type="text"><![CDATA[来源和评测点POJ Monthly–2007.06.03, Huang, JinsongPoj3233 题目【题目大意】给出一个n×n矩阵A和正整数k,输出S=A+A^2+A^3+…+A^k，元素模m【输入格式】多组数据。第一行正整数n,k和m。接下来n行包括n个在32,768以内的非负整数【输出格式】S【限定条件】n≤30k≤10^9m&lt;10^4【输入样例】2 2 40 11 1【输出样例】1 22 3【样例解释】无 刷题记录30min 分析请先思考后再展开 二分求等比序列和 代码请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF946-F】Fibonacci String Subsequences]]></title>
    <url>%2Fposts%2F6a8a.html</url>
    <content type="text"><![CDATA[Source and JudgeCF946-F Problem【Brief description】定义 F(x) 为 F(x−1) 与 F(x−2) 的连接（其中 F(0)=”0”,F(1)=”1” ）。给出一个长度为n的01字符串 s ，询问 s 在 F(x) 的所有子序列中出现了多少次。【Input】第一行n和x第二行字符串s【Output】如上【Limited conditions】1≤n≤100,0≤x≤100【Sample input】2 411【Sample output】14【Sample explanation】F(4)=101101011101101 11 1 01 111 1101 11 10 011 0110 11 110好难想…… Record30min我会告诉你我看错两次题吗？ Analysis请先思考后再展开 其实就是一个裸区间dpf[i][l][r]表示F(i)的子序列中有多少个s[l,r]然后就三种情况 从左边继承，f[i-1][l][r]，次数默认1；若r=n，右边有2^{ln[i-2]}种选取方案（就是任选） 从右边继承，f[i-2][l][r]，次数默认1；若l=1，左边有2^{ln[i-1]}种选取方案（就是任选） 从两边继承，f[i-1][l][k]*f[i-2][k+1][r]，次数1 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2002】【Luogu3203】弹飞绵羊]]></title>
    <url>%2Fposts%2F8065.html</url>
    <content type="text"><![CDATA[Source and JudgeHNOI2010Bzoj2002Luogu3203 Problem【Brief description】有n个点，一开始有n条边，点只会向比自己编号大的一个点连一条边，其中有的边（保证至少有一条）会连不到点，被弹飞。有两种操作：op=1,x :询问从x点出发，需要经过多少个点（包括x）才会被弹飞op=2,x,k:将x点连向其他点的边删掉，然后从x向x+k连一条边【Input】第一行为一个正整数n，表示点的个数。第二行n个数ki，表示第i个点向第i+ki个点连一条边，若i+ki&gt;n被弹飞。第三行为一个正整数m，表示操作的个数。以下m行，一行表示一个操作。每行开头是一个整数op，op=1时之后有一个整数x代表询问点的编号。op=2时之后有两个整数x，k代表点的编号和改变连边的距离。操作如题意。【Output】如上【Limited conditions】对于20%的数据,n,m&lt;=10000对于100%的数据,n&lt;=200000,m&lt;=100000【Sample input】41 2 1 131 12 1 11 1【Sample output】23【Sample explanation】无 Record1h打错变量了…… Analysis1请先思考后再展开 灰常不容易想出来的解法：LCT主要是因为修改操作，相当于删边和连边，而且结构改变了，所以不能树剖然后把“弹飞”形象化为点n+1但这样并没形成森林过…… Code1请先思考后再展开 undefined Analysis2请先思考后再展开 看看能否对上面的算法进行改进要不干脆就真的被弹飞吧！那就是森林了。然后发现根本不用makeroot了于是立刻又快又短！ Code2请先思考后再展开 undefined Analysis3请先思考后再展开 分块大法好！既然说分块是暴力的优化，先想想暴力：从后往前预处理，然后查询瞬间，修改再次从后往前那么找个【暴力与分块】的关系和【前缀和与树状数组】的关系是类似的，就是前一种查询快，但难修改。那么树状数组让两个操作的时间均衡了。分块也类似如此，设法把修改的时间缩短：对于每个位置，记录两个值：跳出这个块的步数、跳出后到了哪里。于是时间都达到了sqrt(n)了 Code3请先思考后再展开 undefined 总结一下LCT：O(Bignlogn)分块：O(nsqrt(n))其实都不是特别好想然后Big的可怕：就算把耗时很高的makeroot去掉，也能硬生生把logn变成sqrt(n)（甚至更慢）]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>伸展树</tag>
        <tag>LCT</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2152】【Luogu2634】聪聪可可]]></title>
    <url>%2Fposts%2F1124.html</url>
    <content type="text"><![CDATA[Source and Judge国家集训队Bzoj2152Luogu2634 Problem【Brief description】给一棵带权树，求任选两个点间路径和是3的倍数的概率【Input】输入的第1行包含1个正整数n。后面n-1行，每行3个整数x、y、w，表示x号点和y号点之间有一条边，上面的数是w。【Output】以既约分数的形式输出（即“a/b”的形式，其中a和b必须互质）如果概率为1，输出“1/1”【Limited conditions】n&lt;=20000【Sample input】51 2 11 3 21 4 12 5 3【Sample output】13/25【Sample explanation】13组点对分别是(1,1) (2,2) (2,3) (2,5)(3,2) (3,3) (3,4) (3,5)(4,3) (4,4) (5,2) (5,3) (5,5) Record40min Analysis请先思考后再展开 显然可以点分治，时间为nlogn 树形dp也非常显然f[x][0/1/2]表示到x，距离的余数，的点数 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>点分治</tag>
        <tag>难度1</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj4196】【Luogu2146】软件包管理器]]></title>
    <url>%2Fposts%2F6263.html</url>
    <content type="text"><![CDATA[Source and JudgeNoi2015Bzoj4196Luogu2146 Problem【Brief description】就是给出一个n个点(0~n-1) 的有根树（根为0），和q次操作；初始时树上所有结点均为白；1、将根到x结点的所有结点置为黑，并输出这次操作有多少个元素改变了状态；2、将x结点的子树中所有结点置为白，并输出这次操作有多少个元素改变了状态；【Input】输入文件的第1行包含1个正整数n。随后一行包含n−1个整数，相邻整数之间用单个空格隔开，分别表示1,2,3,…,n−2,n−1点的父亲节点。接下来一行包含1个正整数q，表示询问的总数。之后q行，每行1个询问。询问分为两种：Install x：表示1操作Uninstall x：表示2操作对于每个操作，输出这步操作有多少个点改变了状态。【Output】输出文件包括q行。输出文件的第i行输出1个整数，为第i步操作中改变状态的点数。【Limited conditions】n，q&lt;=100000【Sample input】70 0 0 1 1 55install 5install 6uninstall 1install 4uninstall 0【Sample output】31323【Sample explanation】一开始所有的软件包都处于未安装状态。安装5号软件包，需要安装0,1,5三个软件包。之后安装6号软件包，只需要安装6号软件包。此时安装了0,1,5,6四个软件包。卸载1号软件包需要卸载1,5,6三个软件包。此时只有0号软件包还处于安装状态。之后安装4号软件包，需要安装1,4两个软件包。此时0,1,4处在安装状态。最后，卸载0号软件包会卸载所有的软件包。 Record40min1RE边又忘记开两倍了…… Analysis请先思考后再展开 裸题首先dfs搞出来的编号，重链上是连续的，子树也是连续的于是问题主要在线段树上，要区间修改，区间查询还要返回修改量，所以记录两个值：c（-1为黑，0为混杂，1为白），b（黑点数量）即可 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1036】【Luogu2590】树的统计]]></title>
    <url>%2Fposts%2Fa490.html</url>
    <content type="text"><![CDATA[Source and JudgeZJOI2008Bzoj1036Luogu2590 Problem【Brief description】一棵树上有n个节点，编号分别为1到n，每个节点都有一个权值w。操作：I. CHANGE u t : 把结点u的权值改为tII. QMAX u v: 询问从点u到点v的路径上的节点的最大权值III. QSUM u v: 询问从点u到点v的路径上的节点的权值和注意：从点u到点v的路径上的节点包括u和v本身【Input】输入文件的第一行为一个整数n，表示节点的个数。接下来n–1行，每行2个整数a和b，表示节点a和节点b之间有一条边相连。接下来一行n个整数，第i个整数wi表示节点i的权值。接下来1行，为一个整数q，表示操作的总数。接下来q行，每行一个操作，以“CHANGE u t”或者“QMAX u v”或者“QSUM u v”的形式给出。【Output】对于每个“QMAX”或者“QSUM”的操作，每行输出一个整数表示要求输出的结果。【Limited conditions】1&lt;=n&lt;=30000，0&lt;=q&lt;=200000；中途操作中保证每个节点的权值w在-30000到30000之间。【Sample input】41 22 34 14 2 1 312QMAX 3 4QMAX 3 3QMAX 3 2QMAX 2 3QSUM 3 4QSUM 2 1CHANGE 1 5QMAX 3 4CHANGE 3 6QMAX 3 4QMAX 2 4QSUM 3 4【Sample output】412210656516【Sample explanation】无（良心数据） Record30min Analysis请先思考后再展开 裸题 Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC093-b】Grid Components]]></title>
    <url>%2Fposts%2F7ef5.html</url>
    <content type="text"><![CDATA[Source and JudgeARC093-b Problem【Brief description】给出正整数A和B，求一个长宽都在100以内，并且白色联通块和黑色联通块分别是A和B的矩阵保证有解，输出任意一个合法解即可。【Input】正整数A和B【Output】第一行h和w分别表示竖直长度和横向长度然后是矩阵，‘.’表示白色，‘#’表示黑色【Limited conditions】1≤h,w≤1001≤A≤5001≤B≤500【Sample input】3 14【Sample output】1234567898 18........................................##.......####.....#.#.....#........#...#....#.......#.###.#...#......#.......#..#.....#.........#..####.【Sample explanation】无 Record30min Analysis请先思考后再展开 神题啊！有木有所以spj的题就是要乱搞？上次乱搞了一次，这次居然还没学会…… 所以我原本的想法是：哇要是矩阵大小无限制就好了，直接一列，乱搞AC…… 那现在有限制了怎么办呢？首先，h=100，w=100然后分均匀的两边，然后A–,B–然后再黑色那边补白色，白色那边补黑色，只要隔一行就好，这样正在补的联通块只增不减，另一个颜色完全不变！妙不可言地解决了…… Code请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1003】【Luogu1772】物流运输]]></title>
    <url>%2Fposts%2F90dd.html</url>
    <content type="text"><![CDATA[来源和评测点ZJOI2006NOI导刊2010提高（01）Bzoj1003Luogu1772 题目【题目大意】物流公司要把一批货物从码头A运到码头B。由于货物量比较大，需要n天才能运完。货物运输过程中一般要转停好几个码头。物流公司通常会设计一条固定的运输路线，以便对整个运输过程实施严格的管理和跟踪。由于各种因素的存在，有的时候某个码头会无法装卸货物。这时候就必须修改运输路线，让货物能够按时到达目的地。但是修改路线是—件十分麻烦的事情，会带来额外的成本。因此物流公司希望能够订一个n天的运输计划，使得总成本尽可能地小。【输入格式】第一行是四个整数n(l≤n≤100)、m(l≤m≤20)、K和e。n表示货物运输所需天数，m表示码头总数，K表示每次修改运输路线所需成本，e表示航线条数。接下来e行每行是一条航线描述，包括了三个整数，依次表示航线连接的两个码头编号以及航线长度(&gt;0)。其中码头A编号为1，码头B编号为m。单位长度的运输费用为1。航线是双向的。再接下来一行是一个整数d，后面的d行每行是三个整数P(1&lt;P&lt;m)，a，b(1≤a≤b≤n)。表示编号为P的码头从第a天到第b天无法装卸货物（含头尾）。同一个码头有可能在多个时间段内不可用。但任何时间都存在至少一条从码头A到码头B的运输路线。【输出格式】包括了一个整数表示最小的总成本。总成本=n天运输路线长度之和+K*改变运输路线的次数。【限定条件】30%的数据中N和M均不超过650%的数据中N和M至少有一个数不超过8100%的数据中N和M均不超过100【输入样例】5 5 10 81 2 11 3 31 4 22 3 22 4 43 4 13 5 24 5 242 2 33 1 13 3 34 4 5【输出样例】32【样例解释】上图依次表示第1至第5天的情况，阴影表示不可用的码头。前三天走1-4-5，后两天走1-3-5，这样总成本为(2+2)3+(3+2)2+10=32。 刷题记录30min1AC小心爆int 分析请先思考后再展开 好巧妙！枚举天数区间，狂跑最短路……然后进行灰常简单的dp即可快！狠！准！ 代码请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1037】【Luogu2592】生日聚会]]></title>
    <url>%2Fposts%2F4e5e.html</url>
    <content type="text"><![CDATA[来源和评测点ZJOI2008Bzoj1037Luogu2592 题目【题目大意】今天是hidadz小朋友的生日，她邀请了许多朋友来参加她的生日party。hidadz带着朋友们来到花园中，打算坐成一排玩游戏。为了游戏不至于无聊，就座的方案应满足如下条件：对于任意连续的一段，男孩与女孩的数目之差不超过k。很快，小朋友便找到了一种方案坐了下来开始游戏。hidadz的好朋友Susie发现，这样的就座方案其实是很多的，所以大家很快就找到了一种，那么到底有多少种呢？热爱数学的hidadz和她的朋友们开始思考这个问题……假设参加party的人中共有n个男孩与m个女孩，你是否能解答Susie和hidadz的疑问呢？由于这个数目可能很多，他们只想知道这个数目除以12345678的余数。【输入格式】共3个整数，分别为男孩数目n, 女孩数目m, 常数k【输出格式】题中要求的答案【限定条件】对于30%的数据，n,m≤20；对于100%的数据，n,m≤150，k≤20。【输入样例】1 2 1【输出样例】1【样例解释】无 刷题记录30min1AC 分析请先思考后再展开 别人眼中的水题……网上题解可能都懒得说什么了，于是我一开始并没有理解。在我的美妙构想中，dp式长这样：f[q][w]，觉得男女生差距哪些自己算不就好了？然鹅，这并没有考虑到，我们要求的条件是针对任意一段的差。然后，我们在dp中，假设做到了第i-1个要得出第i个，那么新增加了哪些段呢（因为之前的段已经保证合法性了）？显然就是i的所有后缀那么新增加两个维度变成f[q][w][a][b]来存储任意长度的后缀的男女最大差，以此来作为约束条件。 代码请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2298】【Luogu2523】problem c]]></title>
    <url>%2Fposts%2F3d19.html</url>
    <content type="text"><![CDATA[来源和评测点HAOI2011Bzoj2302Luogu2523 题目【题目大意】给n个人安排座位，先给每个人一个1~n的编号，设第i个人的编号为ai（不同人的编号可以相同），接着从第一个人开始，大家依次入座，第i个人来了以后尝试坐到ai，如果ai被占据了，就尝试ai+1，ai+1也被占据了的话就尝试ai+2，……，如果一直尝试到第n个都不行，该安排方案就不合法。然鹅有m个人的编号已经确定(他们或许贿赂了你的上司…)，你只能安排剩下的人的编号，求有多少种合法的安排方案。由于答案可能很大，只需输出其除以M后的余数即可。【输入格式】第一行一个整数T，表示数据组数对于每组数据，第一行有三个整数，分别表示n、m、M若m不为0，则接下来一行有m对整数，p1、q1，p2、q2 ,…, pm、qm，其中第i对整数pi、qi表示第pi个人的编号必须为qi【输出格式】对于每组数据输出一行，若是有解则输出YES，后跟一个整数表示方案数mod M，注意，YES和数之间只有一个空格，否则输出NO【限定条件】1≤T≤10，1≤n≤300，0≤m≤n，2≤M≤10^9，1≤pi、qi≤n 且保证pi互不相同。【输入样例】24 3 101 2 2 1 3 110 3 88827 9 2 9 5 10【输出样例】YES 4NO【样例解释】无 刷题记录30min 分析请先思考后再展开 好难啊赶脚这种东西感觉完全想不出来好吧 首先，一个显然的不合法情况：编号&lt;=i的人少于i个（后面人太多了，冲突）然后具体人的编号是完全不重要的，递推的时候乘上组合数就可以了。然后用一个num[i]记录，已经确定的编号为i的人的个数然后用sum[i]表示num[i]的前缀和，特别的是sum[0]=n-m，表示所有未决定的在极端情况下相当于0，这样sum[i]又多了一个意义：编号&lt;=i的人 最多有多少设f[i][j]表示编号&lt;=i的人，有j个的方案数（同理，i&lt;=j），用k表示编号=i的个数那么，k最小当然就是num[i]，最大则是j-(i-1)，因为sum[i-1]&gt;=i-1然后我们这一轮新选择（除去已经固定的）有num[i]个，总共是sum[i]-num[i]-(j-k)所以得出方程(i=1~n,j=i~sum[i])：$$f[i][j]=\sum_{k=num[i]}^{j-i+1} f[i-1][j-k]\times C_{sum[i]-num[i]-(j-k)}^{k-num[i]}$$时间复杂度$O(Tn^3)$ upd 2019.1.29:一开始看错题+把组合数放外面耗费了些时间这就是道sb题……只要记得不能用答案判无解，dp的话随便dp就行了，上面那个说这么多其实很好理解 代码请先思考后再展开 以前代码太丑了，放新的undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2298】【Luogu2519】problem a]]></title>
    <url>%2Fposts%2Ff583.html</url>
    <content type="text"><![CDATA[来源和评测点HAOI2011Bzoj2298Luogu2519 题目【题目大意】一次考试共有n个人参加，第i个人说：“有ai个人分数比我高，bi个人分数比我低。”问最少有几个人没有说真话(可能有相同的分数)。【输入格式】第一行一个整数n，接下来n行每行两个整数，第i+1行的两个整数分别代表ai、bi【输出格式】一个整数，表示最少有几个人说谎【限定条件】1≤n≤1000000≤ai、bi≤n【输入样例】32 00 22 2【输出样例】1【样例解释】无 刷题记录1h 分析请先思考后再展开 假话=n-真话，最少假话=最多真话 定位可能的区间[ai+1,n-bi]为[li,ri]，直接跳过l&gt;r的情况（显然的假话） 将所有区间排序，从而获得有哪些是相同的[li,ri]，合并为一个块 给这个块定义一个价值vi：最大可能人数（如果比ri-li+1多，多余的忽略，显然的假话） 开始dp。设f[i]表示到当前块的真话最大值然后二分查找，得到编号最大（最优秀，因为f是前缀max的）且rj&lt;li的j，f[i]=max(f[i-1],f[j]+vi) ANS=n-f[块数]时间复杂度O(nlogn) upd 2019.1.29：上面说的太乱了转化为求最多真话给每个人一个区间[bi+1,ai-1] 这个区间相当于=然后转化为每个人在区间内选一个数，然后每个人互不重叠而且最后选出的区间不能有除了重合外的重叠，因为区间之间是&lt; 这题可以n做的，桶排+顺便处理每个r的lst提供组数据：32 21 02 0ans=2 代码请先思考后再展开 新的代码，不过没写桶排undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj4069】【Luogu3646】巴厘岛的雕塑]]></title>
    <url>%2Fposts%2Fa4aa.html</url>
    <content type="text"><![CDATA[来源和评测点Apio2015 Bali SculpturesBzoj4069Luogu3646Uoj110 题目【题目大意】给出一些有序的值，在连续的情况下进行分组，并且a&lt;=组的数量&lt;=b求最小的 所有（组的和）的按位或值。【输入格式】输入的第一行包含三个用空格分开的整数N,A,B第二行包含N个用空格分开的整数。【输出格式】输出一行一个数，表示最小的按位或值。【限定条件】子任务1 （9 分）1&lt;=N&lt;=201&lt;=A&lt;=B&lt;=N0&lt;=Yi&lt;=1000000000子任务2 （16 分）1&lt;=N&lt;=501&lt;=A&lt;=B&lt;=min{20,N}0&lt;=Yi&lt;=10子任务3 （21 分）1&lt;=N&lt;=100A=11&lt;=B&lt;=N0&lt;=Yi&lt;=20子任务4 （25 分）1&lt;=N&lt;=1001&lt;=A&lt;=B&lt;=N0&lt;=Yi&lt;=1000000000子任务5 （29 分）1&lt;=N&lt;=2000A=11&lt;=B&lt;=N0&lt;=Yi&lt;=1000000000【输入样例】6 1 38 1 2 1 5 4【输出样例】11【样例解释】分为2组，(8,1,2)和(1,5,4)，它们的和是 (11) 和 (10)，最终优美度是 (11 OR 10)=11，不难验证，这也是最终优美度的最小值。 刷题记录1h 分析请先思考后再展开 显然，直接写dp是不行的，因为区间小并不代表最终小。既然是按位或，可以考虑数位dp。然后区间静态求和，前缀和是不能少滴。 然后网上看到一句话： 对于数位极值问题，应该贪心地优先从高位开始考虑，极小值优先0，极大值优先1 然后就可以愉快地考虑dp了：假设现在在努力地把右数第k位变成0，那么我们就要尽量让所有和的第k位为0。并且前面的已经解决，用tmp表示现在已经能变成0的位置（所以最后输出答案就是tot-tmp） 然后f[i][p]表示前面i个数分p段能否第k位是0（状压），然后n^2来常规dp即可转移条件：( (sum[i]-sum[j])&amp;tmp )==0 （也就是tmp为1的地方这一段的和必须是0，否则前功尽弃）那么这个复杂度是O(60*n^3)的，而最后一个子任务是2000，会TLE然后发现这一次，A=1，那么怎么利用这个条件呢？考虑贪心一波：因为现在的限制只有B，那么当然是段数越小，成功率越高。设g[i]表示前i个数最小分多少段能第k位是0成功变成O(60*n^2) 代码请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>数位dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj4197】【Luogu2150】寿司晚宴]]></title>
    <url>%2Fposts%2Fbe34.html</url>
    <content type="text"><![CDATA[来源和评测点Noi2015Bzoj4197Loj2131Uoj129Luogu2150 题目【题目大意】为了庆祝NOI的成功开幕，主办方为大家准备了一场寿司晚宴。小G和小W作为参加NOI的选手，也被邀请参加了寿司晚宴。在晚宴上，主办方为大家提供了n−1种不同的寿司，编号1,2,3,……,n-1，其中第种寿司的美味度为i+1（即寿司的美味度为从2到n）。现在小G和小W希望每人选一些寿司种类来品尝，他们规定一种品尝方案为不和谐的当且仅当：小G品尝的寿司种类中存在一种美味度为x的寿司，小W品尝的寿司中存在一种美味度为y的寿司，而x与y不互质。现在小G和小W希望统计一共有多少种和谐的品尝寿司的方案（对给定的正整数p取模）。注意一个人可以不吃任何寿司。【输入格式】第1行包含2个正整数n，p中间用单个空格隔开，表示共有n种寿司，最终和谐的方案数要对p取模。【输出格式】输出一行包含1个整数，表示所求的方案模p的结果。【限定条件】2≤n≤5000&lt;p≤1000000000【输入样例】100 100000000【输出样例】3107203【样例解释】无 刷题记录2h1WA1AC以后有膜数的问题，出现减法一定要小心！可能原本正数，膜完再减就变成负数了！ 分析请先思考后再展开 又膜了题解，还特别不好理解…… 首先明确：选择了一种寿司，其实是选择了一些质因数。那么继续面向数据编程，2~n的数，最多包含一个质因数是大于$\sqrt{n}$的而在这之下的质因数个数只有8个：2,3,5,7,11,13,17,19那么是可以用256个状态表示每个数的组成的（注意！！质因数的数量是完全不重要的，也就是说我们记录的只是集合！）那剩下那个大质因数（没有的话用1表示）怎么处理呢？因为这个质因数只能选择一个人，那么以这个排一次序，相同的这个只能选择一个人，看作是一个块（如果没有，则视为不同的块） 那么开始推公式： 定义（在同一个块中）：$$f[s1][s2]=两个人的这种状态下，合法方案的数量$$$$g1[s1][s2]表示两个人的这种状态下，并且这一块的质因数选择第一个或者不选的合法方案的数量$$$$g2[s1][s2]表示两个人的这种状态下，并且这一块的质因数选择第二个或者不选的合法方案的数量$$ 计算1) 一个新的块开始$$g1[s1][s2]=g2[s1][s2]=f[s1][s2]（相当于不选）$$2) 像采药一样倒着dp来避免后效性$$g[s|j]+=f[s]（状态的包含）$$3) 一个块结束（因为不选的部分两边都重复了）$$f[s1][s2]=g1[s1][s2]+g2[s1][s2]-f[s1][s2]$$ 然后自己注意一下合法状态的判断就好了，都是位运算 这道题最巧妙的地方在于对大质因数的处理，以及对状态压缩的洞察力。 代码请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1131】【Luogu3160】时态同步]]></title>
    <url>%2Fposts%2F2e88.html</url>
    <content type="text"><![CDATA[来源和评测点ZJOI2007Bzoj1060Luogu1131 题目【题目大意】小Q在电子工艺实习课上学习焊接电路板。一块电路板由若干个元件组成，我们不妨称之为节点，并将其用数字1,2,3….进行标号。电路板的各个节点由若干不相交的导线相连接，且对于电路板的任何两个节点，都存在且仅存在一条通路（通路指连接两个元件的导线序列）。在电路板上存在一个特殊的元件称为“激发器”。当激发器工作后，产生一个激励电流，通过导线传向每一个它所连接的节点。而中间节点接收到激励电流后，得到信息，并将该激励电流传向与它连接并且尚未接收到激励电流的节点。最终，激烈电流将到达一些“终止节点”――接收激励电流之后不再转发的节点。激励电流在导线上的传播是需要花费时间的，对于每条边e，激励电流通过它需要的时间为te，而节点接收到激励电流后的转发可以认为是在瞬间完成的。现在这块电路板要求每一个“终止节点”同时得到激励电路――即保持时态同步。由于当前的构造并不符合时态同步的要求，故需要通过改变连接线的构造。目前小Q有一个道具，使用一次该道具，可以使得激励电流通过某条连接导线的时间增加一个单位。请问小Q最少使用多少次道具才可使得所有的“终止节点”时态同步？【输入格式】第一行包含一个正整数N，表示电路板中节点的个数。第二行包含一个整数S，为该电路板的激发器的编号。接下来N-1行，每行三个整数a,b,t。表示该条导线连接节点a与节点b，且激励电流通过这条导线需要t个单位时间【输出格式】仅包含一个整数V，为小Q最少使用的道具次数【限定条件】对于40%的数据，N≤1000对于100%的数据，N≤500000对于所有的数据，te≤1000000【输入样例】311 2 11 3 3【输出样例】2【样例解释】无 刷题记录30min 分析请先思考后再展开 sb题中午睡觉无聊想的 代码请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2064】分裂]]></title>
    <url>%2Fposts%2Fdf4.html</url>
    <content type="text"><![CDATA[来源和评测点和谐社会模拟赛Bzoj2064 题目【题目大意】给定一个初始集合和目标集合，有两种操作：1.合并集合中的两个元素，新元素为两个元素之和 2.分裂集合中的一个元素，得到的两个新元素之和等于原先的元素。要求用最小次数使初始集合变为目标集合，求最小次数。【输入格式】第一行一个数n1，表示当时的元素量，接下来n1个数分别表示各元素的值。 第二行一个数n2，表示现在的元素量，接下来n2个数分别表示各元素的值。【输出格式】一行一个数表示最小次数。【限定条件】对于30%的数据，n1,n2&lt;=6对于100%的数据，n1,n2&lt;=10，每个数&lt;=50【输入样例】1 63 1 2 3【输出样例】2【样例解释】无 刷题记录30min1AC 分析请先思考后再展开 首先，本着面向数据编程的观点，我们发现数据范围灰常小！那么有基本上两种可能： 一般的算法难以解决的问题 状压dp看起来好像后面这个比较靠谱呀，因为这个题目好像不算太恶心但是压什么呢？通常都是选和不选的01但这道题不是选不选的问题呀，元素不是不变的于是我的思路一度卡顿…… 算了，还是先观察题目吧，看看能不能转化模型？ 精简题意（我上面已经精简了） 考虑题目要求的是最小次数，虽然dp和贪心差别很大，但先考虑一下极端情况：1) 最坏情况(n-1)+(m-1)=n+m-2，也就是全部加起来再分开2) 如果稍微好一点，恰好有两部分对应和相等，那么合并和分离就都减少了一次也就是(n-2)+(m-2)=n+m-43) 那么如果有k部分对应相等，显然次数就是n+m-2*k4) 用最好情况验证一下，次数是0,那么k=n=m，n+m-2*k=0 哇这下子就好办了！求出一个最大的k就好了。更好的是，求最大的k，根本就不用真的去合并、分割于是祭出状态压缩大法！用二进制表示选取状态。f[s1][s2]表示集合1和集合2的子集s1和s2的最大ksum[s]表示状态s的和f[s1][s2]=max(f[s1^i][s2^j])+bool(sum[s1]==sum[s2]) 以上就是网上普遍的解法了，然鹅我有幸又看到一篇文章他的方法也挺巧妙的，主要是简化上面的方程（复杂度不变）首先，sum数组要开两个，有点麻烦，因为两个状态都是一起用的，考虑状态全部合二为一（最大长度从10变20）然后集合1是正数，集合2是负数，那么如果sum[s]=0表示和相同然后为了避免冲突，sum不能乱算（挺巧妙的）：sum[s]=sum[lowbit(s)]+sum[s-lowbit(s)]然后f也可以把状态合二为一 代码请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1801】【Luogu2051】中国象棋]]></title>
    <url>%2Fposts%2Fdc53.html</url>
    <content type="text"><![CDATA[来源和评测点Ahoi2009 Day2Bzoj1801Luogu2051 题目【题目大意】在一个N行M列的棋盘上，让你放若干个炮（可以是0个），使得没有一个炮可以攻击到另一个炮，请问有多少种放置方法。中国象棋中炮的行走方式是：一个炮攻击到另一个炮，当且仅当它们在同一行或同一列中，且它们之间恰好有一个棋子。【输入格式】一行包含两个整数N，M，之间由一个空格隔开。【输出格式】总共的方案数，由于该值可能很大，只需给出方案数模9999973的结果。【限定条件】30%的数据中N和M均不超过650%的数据中N和M至少有一个数不超过8100%的数据中N和M均不超过100【输入样例】1 3【输出样例】7【样例解释】除了3个格子里都塞满了炮以外，其它方案都是可行的，所以一共有2*2*2-1=7种方案。 刷题记录1h 分析请先思考后再展开 唉我的dp真的菜，打算多做点这道题的状态表示也不是太好想： 列的顺序是无关紧要的 显然每一行、列只能放0~2个棋子那么什么是重要的呢？0~2，这个状态量好像很少，但怎么表示呢？既然顺序不重要，那重要的自然就是内容了，而且内容只有三种情况那我们可以把每一列分类：0个为一类，1个为一类，2个为一类而且这三类的总和是m 想到了这个，基本上问题就迎刃而解了考虑dp状态的转移，以行来递推，f[i][q][w]表示前i行，有q列是有1个棋子的，w列是有2个棋子的，那么当然1个棋子的有(m-q-w)个 什么也不放，状态量有1个，状态值f[i-1][j][k] 放1个在原本棋子数量为0的列，状态量有m-(j-1)-k个，状态值f[i-1][j-1][k] 放1个在原本棋子数量为1的列，状态量有j+1个，状态值f[i-1][j+1][k-1] 放2个在原本棋子数量为0的列，状态量有C(m-(j-1)-k,2)个，状态值f[i-1][j-2][k] 放2个在原本棋子数量为0、1的列，状态量有(m-j-(k-1))*j个，状态值[i-1][j][k-1] 放2个在原本棋子数量为1的列，状态量有C(j+1,2)个，状态值f[i-1][j+2][k-2]出现了组合数呀！n还算挺大的怎么办?之前就卡这里了发现都是选取2个，所以不需要用阶乘的公式了hh直接n*(n-1)/2，爽 代码请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1827】【Luogu2986】【Bzoj3743】奶牛大集会]]></title>
    <url>%2Fposts%2F4b22.html</url>
    <content type="text"><![CDATA[来源和评测点USACO2010 MAR GoldGreat Cow GatheringBzoj1827Luogu2986 双倍经验：Coci2015 KampBzoj3743 题目【题目大意】给出n个点，由n-1条边连接ai和bi，长度为li，形成一棵树，每个点有ci个奶牛。现在要选一个点，使其他点的奶牛到这里距离×数量之和最小。【输入格式】第一行：一个整数N。第二到N+1行：第i+1行有一个整数Ci第N+2到2*N行：第i+N+1行有3个整数：Ai,Bi和Li。【输出格式】最小的距离×数量之和【限定条件】1&lt;=N&lt;=100,0001&lt;=Ai&lt;=N1&lt;=Bi&lt;=N0&lt;=Ci&lt;=1,0001&lt;=Li&lt;=1,000【输入样例】5110021 3 12 3 23 4 34 5 3【输出样例】15【样例解释】 刷题记录30min忘记开long long，WA了一发 分析请先思考后再展开 这道题真心水啊，给之前被dp虐惨的我找回一点点信心……首先一看就是一棵树，那除了树形dp还能是什么~然后用a表示来自父亲的费用，b表示来自儿子的费用a还要容斥一下，还好有样例……$$a_top=(size[rt]-size[x])\times L_fa$$ $$a_brother=b[fa]-b[x]-size[b]\times L_son$$ $$a[x]=a[fa]+a_top+a_brother$$ $$b[x]=\sum b[son]+size[x]\times L_son$$ 然后就是因为方向不同，所以要dfs两次复杂度O(2n)，这n比较小，主要是这出题人把边搞大了 代码请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj1904】King's Quest]]></title>
    <url>%2Fposts%2Ffc.html</url>
    <content type="text"><![CDATA[来源和评测点Poj1904Caioj1149 题目【题目大意】给出n个男生（2000以内），在保证存在完备匹配的条件下，给出一些男生喜欢的女生的信息（20w以内），那么本着有福同享的观点，求出每个男生“应该喜欢”的女生的编号。“应该喜欢”的定义：任选其中一个来与对应男生匹配，其他的男生依然能够找到匹配对象。（可以理解为，每一个都能作为一条强制匹配的边）【输入格式】第一行一个整数n(1&lt;=n&lt;=2000).下来n行，每行第一个数ki表示第i只男生喜欢的女生数目，下来ki只女生的编号。所有ki的总和不超过 200000。【输出格式】输出每个男生可以匹配的女生的编号（从小到大输出），且其他男生和女生依然能一一匹配。【输入样例】42 1 22 1 22 2 32 3 4【输出样例】1 21 234 刷题记录30min 分析题目相当于求所有可能在完美匹配中的边 CommonAnts的解释：建（二分图的）增广路DAG 同一侧的两个点i,j，从i到j连一条有向边，当且仅当存在另一侧的点k使得ik在匹配上,kj不在 那么一条当前不在最大匹配上的边可能在最大匹配上，当且仅当它在一条以某个未匹配点为终点的路径上（这个题是完美匹配，不存在这种情况），或者对应的某条边在增广路图的环上 所以只要判这条未匹配边对应的边是不是在某个SCC里就好了 代码1（CommonAnts版）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=2100,MAXM=210000;//*******************全局定义*******************struct nod&#123; int hou; int belg,dfn,low; bool v; nod() &#123; v=dfn=hou=0; &#125;&#125;p[2*MAXN];struct edge&#123; int x,y,g; int fs; edge() &#123; fs=0; &#125;&#125;e[MAXM*3];int ln=0;void ins(int x,int y)&#123; ln++; e[ln].x=x; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************强连通*******************int n;int cnt,id;int sta[3*MAXN],top;void tarjan(int x)&#123; p[x].dfn=p[x].low=++id; sta[++top]=x;p[x].v=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y&gt;n) continue;//debug if(p[y].dfn==0) tarjan(y),p[x].low=mymin(p[x].low,p[y].low); else if(p[y].v) p[x].low=mymin(p[x].low,p[y].dfn); &#125; if(p[x].low==p[x].dfn) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].v=0;p[t].belg=cnt; if(t==x) break; &#125; &#125;&#125;//*******************匈牙利*******************int chw[MAXN],match[MAXN];int ti;bool findmatch(int x)&#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y-n; if(chw[y]&lt;ti) &#123; chw[y]=ti; if(match[y]==0 or findmatch(match[y])) &#123; match[y]=x; return 1; &#125; &#125; &#125; return 0;&#125;//*******************主函数*******************int ans[MAXN],as;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); while(t--) &#123; int y;scanf("%d",&amp;y); ins(i,n+y); &#125; &#125; memset(chw,0,sizeof(chw)); for(ti=1;ti&lt;=n;ti++) findmatch(ti); for(int i=1;i&lt;=n;i++) &#123; for(int k=p[i].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y-n; if(y&lt;=0) continue;//debug if(match[y]!=i)//失败的边 &#123; ins(match[y],i); e[k].fs=ln; &#125; &#125; &#125; cnt=0;id=0;top=0; for(int i=1;i&lt;=n;i++) if(p[i].dfn==0) tarjan(i); for(int i=1;i&lt;=n;i++) &#123; as=0; for(int k=p[i].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y-n; if(e[k].fs&gt;0)//失败的边 &#123; int xx=e[e[k].fs].x,yy=e[e[k].fs].y; if(p[xx].belg==p[yy].belg) ans[++as]=y; &#125; if(y&gt;0 and match[y]==i) ans[++as]=y;//成功的边 &#125; sort(ans+1,ans+as+1); printf("%d ",as);for(int j=1;j&lt;=as;j++) printf("%d ",ans[j]); printf("\n"); &#125;&#125; 代码2（自己版）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=2100,MAXM=210000;//*******************全局定义*******************struct nod&#123; int hou; int belg,dfn,low; bool v; nod() &#123; v=dfn=hou=0; &#125;&#125;p[2*MAXN];struct edge&#123; int x,y,g;&#125;e[MAXM];int ln=0;void ins(int x,int y)&#123; ln++; e[ln].x=x; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************强连通*******************int cnt,id;int sta[2*MAXN],top;void tarjan(int x)&#123; p[x].dfn=p[x].low=++id; sta[++top]=x;p[x].v=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y),p[x].low=mymin(p[x].low,p[y].low); else if(p[y].v) p[x].low=mymin(p[x].low,p[y].dfn); &#125; if(p[x].low==p[x].dfn) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].v=0;p[t].belg=cnt; if(t==x) break; &#125; &#125;&#125;//*******************匈牙利*******************int n;int chw[MAXN],match[MAXN];int ti;bool findmatch(int x)&#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y-n; if(chw[y]&lt;ti) &#123; chw[y]=ti; if(match[y]==0 or findmatch(match[y])) &#123; match[y]=x; return 1; &#125; &#125; &#125; return 0;&#125;//*******************主函数*******************int ans[MAXN],as;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); while(t--) &#123; int y;scanf("%d",&amp;y); ins(i,n+y); &#125; &#125; memset(chw,0,sizeof(chw)); for(ti=1;ti&lt;=n;ti++) findmatch(ti); for(int i=1;i&lt;=n;i++) ins(n+i,match[i]); cnt=0;id=0;top=0; for(int i=1;i&lt;=2*n;i++) if(p[i].dfn==0) tarjan(i); for(int i=1;i&lt;=n;i++) &#123; as=0; for(int k=p[i].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[i].belg==p[y].belg) ans[++as]=y-n; &#125; sort(ans+1,ans+as+1); printf("%d ",as);for(int j=1;j&lt;=as;j++) printf("%d ",ans[j]); printf("\n"); &#125;&#125; 更新于2018.9.10今天是教师节，然而完全不想去看初中的老师…… 说正事，这道题现在看来就是求可行边相关的介绍，请前往oi之路中的二分图一章，有对lyd的做法的注解]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>二分图</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3679】数字之积]]></title>
    <url>%2Fposts%2F304d.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj3679 题目【题目大意】一个数x各个数位上的数之积记为f(x) （不含前导零）求[L,R)中满足0&lt;f(x)&lt;=n的数的个数。【输入格式】第一行一个数n第二行两个数L、R【输出格式】一个数，即满足条件的数的个数【限定条件】0&lt;L&lt;R&lt;10^18,n&lt;=10^9【输入样例】519 22【输出样例】1【样例解释】无 刷题记录30min 分析请先思考后再展开 首先，按照题解的说法以2、3、5、7这些质因数组成的，int范围内的大概只有几千个，所以可以记录下来，排个序，搞个前缀和，然后用这个乘积来递推。 然后就是经典的套路了：先不考虑前导零的问题预处理然后处理位数&lt;M的情况，然后再一位位处理位数=M的情况即可 注意这一题因为是乘积，碰到0就要退出。 代码请先思考后再展开 网上很多奇奇怪怪的代码呀反正我这次尽全力优化了时间并且清晰易懂undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>数位dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1833】【Luogu2602】数字计数]]></title>
    <url>%2Fposts%2F9f3.html</url>
    <content type="text"><![CDATA[来源和评测点ZJOI2010 Day1Bzoj1833Luogu2602 题目【题目大意】给定两个正整数a和b，求在[a,b]中的所有整数中，每个数码(digit)各出现了多少次。【输入格式】输入文件中仅包含一行两个整数a、b，含义如上所述。【输出格式】输出文件中包含一行10个整数，分别表示0-9在[a,b]中出现了多少次。【限定条件】30%的数据中，a&lt;=b&lt;=10^6；100%的数据中，a&lt;=b&lt;=10^12。【输入样例】1 99【输出样例】9 20 20 20 20 20 20 20 20 20【样例解释】无 刷题记录1h 分析请先思考后再展开 暴力好像30吧虽然数位dp的特征还是很明显的感觉这题还是挺难的，特别不好想当然核心思想依然是忽略前导零来预处理dp，最后分类讨论得出结果。f[i]表示0~10^{i-1}的出现次数（不忽略前导零，所以都一样） 好像计算“包含i”的数字量会更难？总而言之，这道题理解容易，写出来难，很多细节所以最好看完题解，打完一次后全部删掉再打一次哦 代码请先思考后再展开 undefined]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>数位dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1026】【Luogu2657】windy数]]></title>
    <url>%2Fposts%2F4670.html</url>
    <content type="text"><![CDATA[来源和评测点SCOI2009 Day1Bzoj1026Luogu2657 题目【题目大意】windy定义了一种windy数。不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。windy想知道，在A和B之间，包括A和B，总共有多少个windy数？【输入格式】包含两个整数，A B。【输出格式】一个整数【限定条件】1&lt;=A&lt;=B&lt;=2000000000【输入样例】25 50【输出样例】20【样例解释】无 刷题记录20min1AC 分析数位dp入门题分类讨论即可 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************//*******************全局定义*******************int c[11],ln;int f[11][10];//*******************实现*******************int dp()&#123; int ans=0; for(int i=1;i&lt;=ln-1;i++)//首位0 for(int j=1;j&lt;=9;j++)//非首位 ans+=f[i][j]; for(int i=1;i&lt;=c[ln]-1;i++) ans+=f[ln][i];//首位1 for(int i=ln-1;i&gt;=1;i--)//首位2的次位 &#123; for(int j=0;j&lt;=c[i]-1;j++) &#123; if(myabs(c[i+1]-j)&gt;=2) ans+=f[i][j]; &#125; if(myabs(c[i+1]-c[i])&lt;2) break;//剪枝，后面都是0 if(i==1) ans++;//b &#125; return ans;&#125;int solve(int x)&#123; ln=0; while(x&gt;0) &#123; c[++ln]=x%10; x/=10; &#125; return dp();&#125;//*******************主函数*******************int main()&#123; memset(f,0,sizeof(f)); int a,b;scanf("%d%d",&amp;a,&amp;b); for(int i=0;i&lt;=9;i++) f[1][i]=1; for(int i=2;i&lt;=10;i++) for(int x=0;x&lt;=9;x++) for(int y=0;y&lt;=9;y++) if(myabs(x-y)&gt;=2) f[i][x]+=f[i-1][y]; printf("%d",solve(b)-solve(a-1));&#125; UP 2018.8.28:写了个记忆化搜索的版本好写好理解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=30; const int INF=0x3f3f3f3f; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int f[15][10]; bool v[15][10]; int num[15]; int calc(int ln,int lst,bool prezero,bool mask) &#123; if(ln==0) return 1; if(!mask and !prezero and v[ln][lst]) return f[ln][lst]; int tot=0,mx=mask?num[ln]:9; for(int now=0;now&lt;=mx;now++) if(prezero or myabs(lst-now)&gt;=2) tot+=calc(ln-1,now,prezero and now==0,mask and now==mx); if(!mask and !prezero) v[ln][lst]=1,f[ln][lst]=tot; return tot; &#125; int solve(int x) &#123; int n=0;while(x&gt;0) num[++n]=x%10,x/=10; return calc(n,0,1,1); &#125; void main() &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); printf("%d",solve(b)-solve(a-1)); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>数位dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1087】【Luogu1896】互不侵犯]]></title>
    <url>%2Fposts%2Ff44c.html</url>
    <content type="text"><![CDATA[来源和评测点SCOI2005Bzoj1087Luogu1896 题目【题目大意】在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。【输入格式】只有一行，包含两个数N，K【输出格式】方案数【限定条件】1&lt;=N&lt;=9,0&lt;=K&lt;=N*N【输入样例】3 2【输出样例】16【样例解释】无 刷题记录1h记得开long long 分析状态dp，虽然看起来打表也可以拿不少分？压缩每一行的状态，合法性：(s&amp;(s&gt;&gt;1))==0行转移合法性：(s1&amp;(s2&gt;&gt;1))==0 and (s1&amp;(s2&lt;&lt;1))==0 and (s1&amp;s2)==0 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量*******************//*******************全局定义*******************ll f[10][1000][100];//debugint state[1000],stc[1000];//*******************实现*******************int calc(int s)&#123; int t=0; while(s&gt;0) &#123; if( (s&amp;1)==1 ) t++; s=s&gt;&gt;1; &#125; return t;&#125;//*******************主函数*******************int main()&#123; int n,k;scanf("%d%d",&amp;n,&amp;k); int st=0; for(int i=0;i&lt;=(1&lt;&lt;n)-1;i++) if( (i&amp;(i&lt;&lt;1))==0 ) &#123; state[++st]=i; stc[st]=calc(i); f[1][i][stc[st]]=1; &#125; for(int i=2;i&lt;=n;i++)//行数 for(int j1=1;j1&lt;=st;j1++)//前状态 for(int j2=1;j2&lt;=st;j2++)//后状态 &#123; int s1=state[j1],s2=state[j2]; if( (s2&amp;s1)==0 and (s2&amp;(s1&lt;&lt;1))==0 and (s2&amp;(s1&gt;&gt;1))==0 )//转移合法性 &#123; int k1=stc[j1],k2=stc[j2]; for(int b=k1;b+k2&lt;=k;b++)//前棋子总数 f[i][s2][b+k2]+=f[i-1][s1][b]; &#125; &#125; ll ans=0; for(int i=1;i&lt;=st;i++) ans+=f[n][state[i]][k]; printf(BIGN,ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1911】【Luogu3628】特别行动队]]></title>
    <url>%2Fposts%2F8530.html</url>
    <content type="text"><![CDATA[来源和评测点APIO2010Bzoj1911Luogu3628 题目【题目大意】【输入格式】【输出格式】【限定条件】【输入样例】4-1 10 -202 2 3 4【输出样例】9【样例解释】无 刷题记录1h1AC 分析不等式一定要注意负数的时候要变号！ 1.化简dp公式f[i]=f[j]+a×sqr(sum[i]-sum[j])+b×(sum[i]-sum[j])+c 2.证明决策单调性假设j1&lt;j2&lt;i已知对于i，j2优于j1，本题追求大，所以f[j1]+a×sqr(sum[i]-sum[j1])+b×(sum[i]-sum[j1])&lt;=f[j2]+a×sqr(sum[i]-sum[j2])+b×(sum[i]-sum[j2])——-①现在要证明对于t(t&gt;i)，j2同样优于j1即证明f[j1]+a×sqr(sum[t]-sum[j1])+b×(sum[t]-sum[j1])&lt;=f[j2]+a×sqr(sum[t]-sum[j2])+b×(sum[t]-sum[j2])——-① 为了从①证明②，两式取差（注意a&lt;0）即 sqr(sum[t]-sum[j1])-sqr(sum[i]-sum[j1])&gt;=sqr(sum[t]-sum[j2])-sqr(sum[i]-sum[j2])即 -2×sum[t]×sum[j1]-2×sum[i]×sum[j1]&gt;=-2×sum[t]×sum[j1]-2×sum[i]×sum[j1]即 (sum[i]+sum[t])×sum[j1]&lt;=(sum[i]+sum[t])×sum[j2]即 sum[j1]&lt;=sum[j2]这是显而易见的，故②得证 所以这次如果选了j2，j1将没有任何用处，可淘汰 3.确定比较状态优劣的斜率方程只能用于相邻的状态比较斜率=(y1-y2)/(x1-x2) f[j1]-2a×sum[i]×sum[j1]+a×sqr(sum[j1])-b×sum[j1]&lt;=f[j2]-2a×sum[i]×sum[j2]+a×sqr(sum[j2])-b×sum[j2]f[j1]-f[j2]+a×sqr(sum[j1])-b×sum[j1]-a×sqr(sum[j2])+b×sum[j2]&lt;=2×a×sum[i]×(sum[j1]-sum[j2])(f[j1]-f[j2])+a×sqr(sum[j1])-a×sqr(sum[j2])-b×sum[j1]+b×sum[j2]&lt;=2×a×sum[i]×(sum[j1]-sum[j2])((f[j1]-f[j2])+a×sqr(sum[j1])-a×sqr(sum[j2])-b×sum[j1]+b×sum[j2]) / (sum[j1]-sum[j2]) &gt;= 2×a×sum[i]满足则j2更优 那么把状态变成点( sum[j],f[j]+a×sqr(sum[j])-b×sum[j] ) 4.单调队列维护满足: 相邻斜率不递减故形状为一个向下的凸壳（形如丿字） 一、去头（两者比较）将2×a×sum[i]理解为i给出的标杆，假如“头与头后一个斜率”小于标杆，意味着后一个更优秀，将头剔除 二、继承从当前最优秀的头继承 三、铺垫与维护（三者比较）将当前状态放入队列，并两两比较删除无用状态，保证相邻斜率不递减删除正确性证明：对于a和b的斜率x&lt;=b和c的斜率y被删除的末尾，在（末尾前一个，末尾，当前状态）中必定不是最优状态，因为斜率必定不如他们哪怕是这种极端情况： ○ ○○斜率越大，则越靠近标杆，也就意味着后面这个越优秀（虽然在小于标杆的时候依然是前面的优秀，但我这里的意思是同样的前者下，后者1会比后者2更优秀）斜率为0意味着同样优秀，那么当然是后面的更好了总而言之，斜率越小越优秀 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;double mysqr(double x) &#123;return x*x;&#125;//*******************全局常量*******************const int MAXN=1000010;const int INF=0x3f3f3f3f;const double eps=1e-7;//*******************全局定义*******************int n;double a,b,c;double sum[MAXN];double f[MAXN];//*******************实现*******************double X(int x)&#123; return 2.0*a*sum[x];&#125;double Y(int x)&#123; return f[x]+a*mysqr(sum[x])-b*sum[x];&#125;double slop(int x,int y)&#123; return ( Y(x)-Y(y) )/( X(x)-X(y) );&#125;int g[MAXN];void solve()&#123; int tou=1,wei=1; for(int i=1;i&lt;=n;i++) &#123; while(tou&lt;wei and slop(g[tou],g[tou+1])&lt;=sum[i]) tou++; int j=g[tou]; f[i]=f[j]+a*mysqr(sum[i]-sum[j])+b*(sum[i]-sum[j])+c; while(tou&lt;wei and slop(g[wei-1],g[wei])&gt;slop(g[wei],i)) wei--; g[++wei]=i; &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%d%lf%lf%lf",&amp;n,&amp;a,&amp;b,&amp;c); for(int i=1;i&lt;=n;i++) &#123; double t;scanf("%lf",&amp;t); sum[i]=sum[i-1]+t; &#125; solve(); printf("%.0lf",f[n]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1835】【Luogu2605】基站选址]]></title>
    <url>%2Fposts%2Fedb5.html</url>
    <content type="text"><![CDATA[来源和评测点ZJOI2010 Day1Bzoj1835Luogu2605 题目【题目大意】有N个村庄坐落在一条直线上，第i(i&gt;1)个村庄距离第1个村庄的距离为Di。需要在这些村庄中建立不超过K个通讯基站，在第i个村庄建立基站的费用为Ci。如果在距离第i个村庄不超过Si的范围内建立了一个通讯基站，那么就村庄被基站覆盖了。如果第i个村庄没有被覆盖，则需要向他们补偿，费用为Wi。现在的问题是，选择基站的位置，使得总费用最小。【输入格式】第一行包含两个整数N,K，含义如上所述。第二行包含N-1个整数，分别表示D2,D3,…,DN ，这N-1个数是递增的。第三行包含N个整数，表示C1,C2,…CN。第四行包含N个整数，表示S1,S2,…,SN。第五行包含N个整数，表示W1,W2,…,WN。【限定条件】40%的数据中，N&lt;=500；100%的数据中，K&lt;=N，K&lt;=100，N&lt;=20000，Wi&lt;=10000，Ci&lt;=10000Di&lt;=1000000000，Si&lt;=1000000000【输出格式】仅一个整数，表示最小的总费用。【输入样例】3 21 22 3 21 1 010 20 30【输出样例】4【样例解释】无 刷题记录2h1AC 分析不得不说，这道题的思路灰常神 F[m][i]表示已经放置了m个基站，第m个基站放置在第i个村庄第i个村庄及之前的村庄的总最少花费(包括建立基站的花费和赔偿的花费),转移的时候,F[m][i]=min(F[m-1][j]+cost(j,i))+c[i]cost(j,i)表示在点j和点i各建立一个基站，j和i之间不建立基站时，j和i之间需要的总赔偿。 省空间首选vector，用于存储每个点被哪些点依赖，用于更新外层枚举m，然后每次循环才重构，避免后效性 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=21000;const int INF=0x3f3f3f3f;//*******************全局定义*******************int d[MAXN],c[MAXN],s[MAXN],w[MAXN];int st[MAXN],ed[MAXN];int f[MAXN];vector&lt;int&gt; fd[MAXN];//快速查找，省空间首选//*******************线段树*******************struct nod&#123; int l,r; int lc,rc; int mi,lz;&#125;m[2*MAXN];int cnt;int build(int l,int r)&#123; int t=++cnt; m[t].l=l;m[t].r=r;m[t].lz=0; if(l==r) m[t].mi=f[l];//初始cost=0 else &#123; int mid=(l+r)&gt;&gt;1; m[t].lc=build(l,mid); m[t].rc=build(mid+1,r); m[t].mi=mymin(m[m[t].lc].mi,m[m[t].rc].mi); &#125; return t;&#125;void update(int x)&#123; if(m[x].lz==0) return; int lc=m[x].lc,rc=m[x].rc; m[lc].mi+=m[x].lz;m[lc].lz+=m[x].lz; m[rc].mi+=m[x].lz;m[rc].lz+=m[x].lz; m[x].lz=0;&#125;void change(int x,int l,int r,int c)&#123; if(l&gt;r) return;//debug if(m[x].l==l and m[x].r==r) &#123; m[x].mi+=c; m[x].lz+=c; return; &#125; update(x); int mid=(m[x].l+m[x].r)/2,lc=m[x].lc,rc=m[x].rc; if(r&lt;=mid) change(lc,l,r,c); else if(l&gt;mid) change(rc,l,r,c); else change(lc,l,mid,c),change(rc,mid+1,r,c); m[x].mi=mymin(m[m[x].lc].mi,m[m[x].rc].mi);//debug&#125;int ask(int x,int l,int r)&#123; if(l&gt;r) return 0;//debug if(m[x].l==l and m[x].r==r) return m[x].mi; update(x); int mid=(m[x].l+m[x].r)/2,lc=m[x].lc,rc=m[x].rc; if(r&lt;=mid) return ask(lc,l,r); if(l&gt;mid) return ask(rc,l,r); return mymin(ask(lc,l,mid),ask(rc,mid+1,r)); &#125;//*******************实现*******************int n,k;void dp()&#123; int tmp=0; for(int i=1;i&lt;=n;i++)//prepare &#123; f[i]=tmp+c[i]; for(int j=0;j&lt;fd[i].size();j++) tmp+=w[fd[i][j]]; //现在刚刚好，那么以后就成了负担 &#125; int ans=f[n]; for(int i=2;i&lt;=k;i++) &#123; cnt=0;build(1,n); for(int i=1;i&lt;=n;i++) &#123; f[i]=ask(1,1,i-1)+c[i];//最优继承 for(int k=0;k&lt;fd[i].size();k++) &#123; int x=fd[i][k]; change(1,1,st[x]-1,w[x]); //现在刚刚好，那么以后就成了负担 &#125; &#125; ans=mymin(ans,f[n]); &#125; printf("%d",ans);&#125;//*******************主函数*******************int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=2;i&lt;=n;i++) scanf("%d",&amp;d[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;c[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;s[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]); n++;k++;//此点必选，用于统计答案 d[n]=INF;w[n]=INF;c[n]=0; for(int i=1;i&lt;=n;i++) &#123; int l=lower_bound(d+1,d+1+n,d[i]-s[i])-d; int r=lower_bound(d+1,d+1+n,d[i]+s[i])-d; if(d[r]&gt;d[i]+s[i]) r--; st[i]=l;ed[i]=r; fd[ed[i]].push_back(i); &#125; dp();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>dp</tag>
        <tag>好题</tag>
        <tag>难度3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1597】【Luogu1010】土地购买]]></title>
    <url>%2Fposts%2Fc717.html</url>
    <content type="text"><![CDATA[来源和评测点Usaco2008 Mar GoldBzoj1597LuogucCaioj1140 题目【题目大意】有N块长方形的土地，每块土地的价格是它的面积，但FJ可以同时购买多块土地。这些土地的价格是它们最大的长乘以它们最大的宽, 但是土地的长宽不能交换。如果FJ买一块3×5的地和一块5×3的地，则他需要付5×5=25。FJ希望买下所有的土地，但是他发现分组来买这些土地可以节省经费。他需要你帮助他找到最小的经费。【输入格式】第1行一个整数N。下来N行。第i+1行包含两个数，分别为第i块土地的长和宽。【限定条件】(1 &lt;= N &lt;= 50,000每块土地的长宽满足1&lt;=宽&lt;=1,000,000;1&lt;=长&lt;=1,000,000)【输出格式】求最小的可行费用。【输入样例】4100 115 1520 51 100【输出样例】500【样例解释】FJ分3组买这些土地:第一组:100×1,第二组1×100,第三组20×5 和 15×15。每组的价格分别为100,100,300, 总共500 刷题记录30min 分析灰常妙的一点：使用排序进行除杂（被完全覆盖的土地可以被忽略）神奇的一幕出现了，可以实现长递增，宽递减（主要是题目特性）于是就可以瞬间获得区间打包的费用！ 想通这个以后接下来就甚至比上一题还简单了部分省略 1.化简dp公式a[i]=长 b[i]=宽f[i]=min(f[j]+a[i]*b[j+1]) 2.证明决策单调性假设j1&lt;j2&lt;i已知对于i，j2优于j1，本题追求小，所以假设f[j2]+a[i]*b[j2+1]&lt;=f[j1]+a[i]*b[j1+1]——————-①是否f[j2]+a[t]*b[j2+1]&lt;=f[j1]+a[t]*b[j1+1]——————-②为了从①证明②，两式取差得证所以这次如果选了j2，j1将没有任何用处，可淘汰 3.确定比较状态优劣的斜率方程只能用于相邻的状态比较斜率=(y1-y2)/(x1-x2) f[j2]+a[i]*b[j2+1]&lt;=f[j1]+a[i]*b[j1+1](f[j2]-f[j1])/(b[j1+1]-b[j2+1])&lt;=a[i]满足则j2更优 那么把状态变成点( b[j],f[j] ) 4.单调队列维护满足: 相邻斜率不递减故形状为一个向下的凸壳（形如丿字） 一、去头（两者比较）将a[]理解为i给出的标杆，假如“头与头后一个斜率”小于标杆，意味着后一个更优秀，将头剔除 二、继承从当前最优秀的头继承 三、铺垫与维护（三者比较）将当前状态放入队列，并两两比较删除无用状态，保证相邻斜率不递减删除正确性证明：对于a和b的斜率x&lt;=b和c的斜率y被删除的末尾，在（末尾前一个，末尾，当前状态）中必定不是最优状态，因为斜率必定不如他们哪怕是这种极端情况： ○ ○○斜率越大，则越靠近标杆，也就意味着后面这个越优秀（虽然在小于标杆的时候依然是前面的优秀，但我这里的意思是同样的前者下，后者1会比后者2更优秀）斜率为0意味着同样优秀，那么当然是后面的更好了总而言之，斜率越小越优秀 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量*******************const int MAXN=51000;//*******************全局定义*******************struct nod&#123; double a,b;&#125;p[MAXN];bool cmp(nod a,nod b)&#123; return (a.a&lt;b.a) or (a.a==b.a and a.b&lt;b.b);&#125;double f[MAXN];//*******************实现*******************double X(int x)&#123; return p[x].b;&#125;double Y(int x)&#123; return f[x];&#125;double slop(int x,int y)&#123; return ( Y(y)-Y(x) )/( X(x+1)-X(y+1) );&#125;int tp;int g[MAXN];void solve()&#123; int tou=1,wei=1; for(int i=1;i&lt;=tp;i++) &#123; while(tou&lt;wei and slop(g[tou+1],g[tou])&lt;=p[i].a) tou++; int j=g[tou]; f[i]=f[j]+p[i].a*p[j+1].b; while(tou&lt;wei and slop(g[wei-1],g[wei])&gt;=slop(g[wei],i)) wei--; g[++wei]=i; &#125;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lf%lf",&amp;p[i].a,&amp;p[i].b); sort(p+1,p+1+n,cmp); tp=1; for(int i=2;i&lt;=n;i++) &#123; while(tp&gt;0 and p[tp].b&lt;=p[i].b) tp--; p[++tp]=p[i]; &#125; solve(); printf("%.0lf",f[tp]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>斜率优化</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1010】【Luogu3195】玩具装箱]]></title>
    <url>%2Fposts%2Fdae0.html</url>
    <content type="text"><![CDATA[来源和评测点HNOI2008Bzoj1010Luogu3195Caioj1138 题目【题目大意】P教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。P教授有编号为1…N的N件玩具，第i件玩具经过压缩后变成一维长度为Ci。为了方便整理，P教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第i件玩具到第j个玩具放到一个容器中，那么容器的长度将为 x=j-i+Sigma(Ck) i&lt;=K&lt;=j制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为x,其制作费用为(X-L)^2.其中L是一个常量。P教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过L。但他希望费用最小.【输入格式】第一行输入两个整数N，L.接下来N行输入Ci.【限定条件】1&lt;=N&lt;=50000,1&lt;=L,Ci&lt;=10^7【输出格式】输出最小费用【输入样例】5 434214【输出样例】1【样例解释】无 刷题记录1h 分析1.化简dp公式sum[i]=sum[i-1]+c[i]f[i]=选择物品i后1~i最小花费f[i]=f[j]+sqr(sum[i]-sum[j]+i-(j+1)-l)f[i]=f[j]+sqr(sum[i]+i-sum[j]-j-1-l)设s[i]=sum[i]+i,L=l+1f[i]=f[j]+sqr(s[i]-s[j]-L) 2.证明决策单调性假设j1&lt;j2&lt;i已知对于i，j2优于j1，本题追求小，所以f[j2]+sqr(s[i]-s[j2]-L)&lt;f[j1]+sqr(s[i]-s[j1]-L)——————-①现在要证明对于t(t&gt;i)，j2同样优于j1，易得s[t]=s[i]+v即证明f[j2]+sqr(s[i]-s[j2]-L+v)&lt;f[j1]+sqr(s[i]-s[j1]-L+v)———② 为了从①证明②，两式取差证明 2*(s[i]-s[j2]-L)*v+v*v&lt;=2*(s[i]-s[j1]-L)*v+v*v 即可即 -2*s[j2]*v&lt;=-2*s[j1]*v即 s[j2]&gt;=s[j1]这是显而易见的，故②得证 所以这次如果选了j2，j1将没有任何用处，可淘汰 3.确定比较状态优劣的斜率方程只能用于相邻的状态比较斜率=(y1-y2)/(x1-x2) f[j2]+sqr(s[i]-s[j2]-L)&lt;f[j1]+sqr(s[i]-s[j1]-L)[ (f[j2]+s[j2]*s[j2])-(f[j1]+s[j1]*s[j1]) ]/[ s[j2]-s[j1] ] &lt; 2*(s[i]-L)满足则j2更优 那么把状态变成点( s[j],f[j]+sqr(s[j]) ) 4.单调队列维护满足: 相邻斜率不递减故形状为一个向下的凸壳（形如丿字） 一、去头（两者比较）将2*(s[i]-L)理解为i给出的标杆，假如“头与头后一个斜率”小于标杆，意味着后一个更优秀，将头剔除 二、继承从当前最优秀的头继承 三、铺垫与维护（三者比较）将当前状态放入队列，并两两比较删除无用状态，保证相邻斜率不递减删除正确性证明：对于a和b的斜率x&lt;=b和c的斜率y被删除的末尾，在（末尾前一个，末尾，当前状态）中必定不是最优状态，因为斜率必定不如他们哪怕是这种极端情况： ○ ○○斜率越大，则越靠近标杆，也就意味着后面这个越优秀（虽然在小于标杆的时候依然是前面的优秀，但我这里的意思是同样的前者下，后者1会比后者2更优秀）斜率为0意味着同样优秀，那么当然是后面的更好了总而言之，斜率越小越优秀 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;ll mysqr(ll x) &#123;return x*x;&#125;//*******************全局常量*******************const int MAXN=51000;//*******************全局定义*******************int n;double L;double sum[MAXN],s[MAXN];double f[MAXN];//*******************实现*******************double X(int x)&#123; return s[x];&#125;double Y(int x)&#123; return f[x]+mysqr(s[x]);&#125;double slop(int x,int y)&#123; return ( Y(x)-Y(y) )/( X(x)-X(y) );&#125;int g[MAXN];void solve()&#123; int tou=1,wei=1;g[1]=0;f[0]=0; for(int i=1;i&lt;=n;i++) &#123; while(tou&lt;wei and slop(g[tou],g[tou+1])&lt;=2*(s[i]-L)) tou++; int j=g[tou];f[i]=f[j]+mysqr(s[i]-s[j]-L); while(tou&lt;wei and slop(g[wei-1],g[wei])&gt;slop(g[wei],i)) wei--; g[++wei]=i; &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%d%lf",&amp;n,&amp;L);L+=1.0; for(int i=1;i&lt;=n;i++) &#123; double t;scanf("%lf",&amp;t); sum[i]=sum[i-1]+t; s[i]=sum[i]+i; &#125; solve(); printf("%.0lf",f[n]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>斜率优化</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj2823】Sliding Window]]></title>
    <url>%2Fposts%2Fe1c7.html</url>
    <content type="text"><![CDATA[来源和评测点POJ Monthly–2006.04.28, IkkiPoj2823Caioj1172 题目【题目大意】给定一个n个数的数列，从左至右输出每个长度为m的数列段内的最大数何最小数。【输入格式】第一行两个整数n和m，下来给出n个整数。【限定条件】1&lt;=n&lt;=200000,m&lt;=n【输出格式】第一行表示每连续m个数的最大值。第二行表示每连续m个数的最小值。【输入样例】8 31 3 -1 -3 5 3 6 7【输出样例】-1 -3 -3 -3 3 33 3 5 5 6 7【样例解释】无 刷题记录30min5WA1AC 分析裸题 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll; //*******************全局常量*******************const int MAXN=1100000;//*******************全局定义*******************int n,k;int a[MAXN];struct nod&#123; int s,p;&#125;g1[MAXN],g2[MAXN];//*******************实现*******************int f1[MAXN],f2[MAXN];void dp()&#123; int tou1=1,wei1=0; int tou2=1,wei2=0; for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); while(tou1&lt;=wei1 and g1[wei1].s&gt;=t) wei1--; while(tou2&lt;=wei2 and g2[wei2].s&lt;=t) wei2--; g1[++wei1].s=t;g1[wei1].p=i; g2[++wei2].s=t;g2[wei2].p=i; while(tou1&lt;=wei1 and g1[tou1].p+k-1&lt;i) tou1++; while(tou2&lt;=wei2 and g2[tou2].p+k-1&lt;i) tou2++; if(i&gt;=k) &#123; f1[i]=g1[tou1].s; f2[i]=g2[tou2].s; &#125; &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%d%d",&amp;n,&amp;k); dp(); for(int i=k;i&lt;=n;i++) printf("%d ",f1[i]);printf("\n"); for(int i=k;i&lt;=n;i++) printf("%d ",f2[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1079】【Luogu2476】着色方案]]></title>
    <url>%2Fposts%2F968.html</url>
    <content type="text"><![CDATA[来源和评测点SCOI2008 Day2Bzoj1079Luogu2476 题目【题目大意】有n个木块排成一行，从左到右依次编号为1~n。你有k种颜色的油漆，其中第i种颜色的油漆足够涂ci个木块。所有油漆刚好足够涂满所有木块，即c1+c2+…+ck=n。相邻两个木块涂相同色显得很难看，所以你希望统计任意两个相邻木块颜色不同的着色方案。【输入格式】第一行为一个正整数k，第二行包含k个整数c1, c2, … , ck。【限定条件】50%的数据满足：1&lt;=k&lt;=5,1&lt;=ci&lt;=3100%的数据满足：1&lt;=k&lt;=15,1&lt;=ci&lt;=5【输出格式】输出一个整数，即方案总数模1,000,000,007的结果。【输入样例】101 1 2 2 3 3 4 4 5 5【输出样例】85937576【样例解释】无 刷题记录2h 分析1不愧是十年前的题目，连暴力分都给50 代码11234567891011121314151617181920212223242526272829303132333435363738394041//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MOD=1000000007;//*******************全局定义*******************int a[76];int n,k;int c[20];//*******************实现*******************int ans=0;void dfs(int x)&#123; if(x&gt;n) &#123; ans=(ans+1)%MOD; return; &#125; for(int i=1;i&lt;=k;i++) &#123; if(a[x-1]==i or c[i]&lt;=0) continue; a[x]=i; c[i]--; dfs(x+1); c[i]++; &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%d",&amp;k); for(int i=1;i&lt;=k;i++) scanf("%d",&amp;c[i]),n+=c[i]; dfs(1); printf("%d",ans);&#125; 分析2不得不说这道题灰常好想设i是现在的颜色，从j颜色而来$$F[x][i]=\sum_{j=1}^{k} F[x-1][j] (i!=j)$$那么通常而言，上面的这个约束条件要转化为一个操作矩阵然后把F[x]变成一个矩阵，m[i][1]表示用颜色i的方案数那么$$ANS=\sum_{i=1}^{k} F[n].m[i][1]$$是不是找到窍门了？ 老规矩，F[].m[i][1]=A[][]*F[].m[j][1]所以A[i][j]，也就是说当j可以到i的时候，A[i][j]=1 那么A^t表示跳转了t次，长度为t+1，最后变成颜色j的方案量 我说的有没有道理？ 有个屁！第i种颜色的油漆足够涂ci个木块？？？？？我真的是做矩阵做疯了，居然还自以为找到了感觉……这种限制显然是矩阵乘法无法解决的事实证明省选题不能小瞧啊，连续两次了 重新写dp方程f[a][b][c][d][e][f][g][h][i][j][k][l][m][n][o]这是一个5^15的dp，显然是不可行的，空间、代码复杂度都过大那么观察题目的特性：既然只要求方案数，那么在不考虑“不相邻”的条件下，对于剩余t次的两种颜色其实是等效的，于是就从5^15变成了15^5：f[a][b][c][d][e]接下来考虑特殊条件其实也很简单：多开一维，记录这一段的前一个是什么类型的颜色当前一个是b，那么现在它变成了a，用a的时候-1即可然后可以理解为从前往后确定 代码21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll; //*******************全局常量*******************const int MOD=1000000007;//*******************全局定义*******************ll f[6][16][16][16][16][16];bool bk[6][16][16][16][16][16];//*******************实现*******************ll dp(int first,int a,int b,int c,int d,int e)&#123; if(bk[first][a][b][c][d][e]) return f[first][a][b][c][d][e]; if(a+b+c+d+e==0) return 1; ll t=0; if(a&gt;0) t+=(a-(first==2))*dp(1,a-1,b,c,d,e)%MOD; if(b&gt;0) t+=(b-(first==3))*dp(2,a+1,b-1,c,d,e)%MOD; if(c&gt;0) t+=(c-(first==4))*dp(3,a,b+1,c-1,d,e)%MOD; if(d&gt;0) t+=(d-(first==5))*dp(4,a,b,c+1,d-1,e)%MOD; if(e&gt;0) t+=e*dp(5,a,b,c,d+1,e-1)%MOD; bk[first][a][b][c][d][e]=1; return f[first][a][b][c][d][e]=t%MOD;&#125;//*******************主函数*******************int s[6];int main()&#123; memset(bk,0,sizeof(bk)); int k;scanf("%d",&amp;k); for(int i=1;i&lt;=k;i++) &#123; int t; scanf("%d",&amp;t); s[t]++; &#125; printf(BIGN,dp(0,s[1],s[2],s[3],s[4],s[5]));&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1875】【Luogu2151】HH去散步]]></title>
    <url>%2Fposts%2F3469.html</url>
    <content type="text"><![CDATA[来源和评测点SDOI2009 Day1Bzoj1875Luogu2151 题目【题目大意】HH有个一成不变的习惯，喜欢饭后百步走。所谓百步走，就是散步，就是在一定的时间内，走过一定的距离。但是同时HH又是个喜欢变化的人，所以他不会立刻沿着刚刚走来的路走回。 又因为HH是个喜欢变化的人，所以他每天走过的路径都不完全一样，他想知道他究竟有多少种散步的方法。现在给你学校的地图（假设每条路的长度都是一样的都是1），问长度为t，从给定地点A走到给定地点B共有多少条符合条件的路径【输入格式】第一行：五个整数N，M，t，A，B。N表示学校里的路口的个数M表示学校里的 路的条数t表示HH想要散步的距离A表示散步的出发点B则表示散步的终点。接下来M行每行一组Ai，Bi，表示从路口Ai到路口Bi有一条路。数据保证Ai ！= Bi,但不保证任意两个路口之间至多只有一条路相连接。路口编号从0到N -1。同一行内所有数据均由一个空格隔开，行首行尾没有多余空格。没有多余空行。答案模45989。【限定条件】N≤20，M≤60，t≤2^30，0≤A,B【输出格式】一行，表示答案。【输入样例】4 5 3 0 00 10 20 32 13 2【输出样例】4【样例解释】无 刷题记录30min3WA1AC 分析不能立刻走回头路!没理解这句话还以为是煞笔题…… 首先，考虑dp方程，用边去推导（主要是因为不能立刻走回头路，而且有重边，这都主要跟边有关系）$f[i][k]=\sum f[j][k2] (k:j=&gt;i,k!=oth[k2])$那么因为t灰常大，但是这个【上一条边】是与以后决策无关的所以引入矩阵乘法，利用快速幂加速 设起始边i，终止边j构造t=1的初始矩阵A当$y[i]=x[j]$,i连接j,且$i!=oth[j]$则$A[j][i]=1$ 为什么是反的？考虑矩阵乘法的定义，以及我们通常用的列向量：$A[][]\times st[i][1]=ed[j][1]$发现必须是$A[j][i]$ 这个判断矩乘的方法是我自己想的，好像网上也没人这样用。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;//*******************全局常量*******************const int MAXN=150;const int MOD=45989;//*******************全局定义*******************struct Martix&#123; int row,col; int m[MAXN][MAXN]; Martix(int r=0,int c=0) &#123; row=r;col=c; memset(m,0,sizeof(m)); &#125;&#125;;//*******************实现*******************Martix one(int row)&#123; Martix ans(row,row); for(int i=1;i&lt;=row;i++) ans.m[i][i]=1; return ans;&#125;Martix mul(Martix a,Martix b)&#123; Martix c(a.row,b.col); for(int i=1;i&lt;=c.row;i++) for(int j=1;j&lt;=c.col;j++) for(int k=1;k&lt;=a.col;k++) c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]%MOD)%MOD; return c;&#125;Martix power(Martix a,int e)&#123; Martix ans=one(a.row); while(e&gt;0) &#123; if(e&amp;1) ans=mul(ans,a); a=mul(a,a);e&gt;&gt;=1; &#125; return ans;&#125;struct Edge&#123; int x,y,oth;&#125;e[MAXN];int ln=0;void ins(int x,int y)&#123; e[++ln]=(Edge)&#123;x,y,ln+1&#125;; e[++ln]=(Edge)&#123;y,x,ln-1&#125;;&#125;//*******************主函数*******************int main()&#123; int n,m,t,st,ed;scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;t,&amp;st,&amp;ed); for(int i=1;i&lt;=m;i++) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); ins(x,y); &#125; Martix stm(ln,1);for(int k=1;k&lt;=ln;k++) stm.m[k][1]=(e[k].x==st); Martix A(ln,ln); for(int k1=1;k1&lt;=ln;k1++) for(int k2=1;k2&lt;=ln;k2++) A.m[k2][k1]=(e[k1].oth!=k2 and e[k1].y==e[k2].x); Martix edm=mul(power(A,t-1),stm); int ans=0; for(int k=1;k&lt;=ln;k++) if(e[k].y==ed) ans=(ans+edm.m[k][1])%MOD; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC092-D】Two Sequences]]></title>
    <url>%2Fposts%2F77c7.html</url>
    <content type="text"><![CDATA[来源和评测点ARC092-D 题目【题目大意】给出两个长度为N的整数序列Ai和Bi，共有N^2个(Ai+Bi)，求他们的XOR值。【输入格式】Na1 a2 … aNb1 b2 … bN【限定条件】所有输入都是整数1≤N≤200,0000≤ai,bi&lt;2^28【输出格式】结果【输入样例】64 6 0 0 3 30 5 6 5 0 3【输出样例】8【样例解释】无 刷题记录2h3TLE1AC 分析被卡常了……记住，少点%啊 这道题还是很有意思的首先呢，直接枚举显然是不行的那么找找特殊性质异或，当然就跟奇偶性有关了然后？嗯我比赛的时候就是想到这里就不会了这个复杂度看起来就像是nlogn我们先按照位来处理。但a+b这种东西很烦啊，因为会有进位不过至少，我们处理第i位的时候i前面的就不用考虑了，%掉就好 然后，我们统计第i位是1的数量，判断奇偶性就好了。显然我们可以得到一个结果的有效范围$$[2^i,2^{i+1}-1] （不进位）$$和$$[2^{i+1}+2^i,2^{i+2}-1] （进位）$$那么枚举n个数字作为加数，不就得到了另一个加数的有效范围了吗nlogn排序后二分查找就好了（事实证明我的查找还是打得不熟练）假设第j个数字的对应数量有tj个，那么答案就是$$ANS=\sum_{i=0}^{29} ( ( (\sum_{j=1}^{n} tj) \&amp; 1)&lt;&lt;i )$$ 好久没有给卡常了……总时间$O(nlog^2n)$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;//*******************全局常量*******************const int MAXN=210000;//*******************全局定义*******************ll q[MAXN],w[MAXN];ll bin[35];int n;//*******************实现*******************/*debugbool cmp(ll a,ll b)&#123; return (a%bin[f+1])&lt;(b%bin[f+1]);&#125;*///*******************主函数*******************ll w2[MAXN];int main()&#123; bin[0]=1;for(int i=1;i&lt;=32;i++) bin[i]=bin[i-1]&lt;&lt;1; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;q[i]); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;w[i]); ll ans=0; for(int f=0;f&lt;=29;f++) &#123; for(int i=1;i&lt;=n;i++) w2[i]=w[i]%bin[f+1]; sort(w2+1,w2+1+n); ll t=0; for(int i=1;i&lt;=n;i++) &#123; ll now=q[i]%bin[f+1],ss=0; ll l,r; int bf; l=bin[f];r=bin[f+1]-1; l=lower_bound(w2+1,w2+n+1,l-now)-w2; r=upper_bound(w2+1,w2+n+1,r-now)-w2-1; bf=r-l+1;if(bf&gt;0) ss+=bf; l=bin[f+1]+bin[f];r=bin[f+2]-1; l=lower_bound(w2+1,w2+n+1,l-now)-w2; r=upper_bound(w2+1,w2+n+1,r-now)-w2-1; bf=r-l+1;if(bf&gt;0) ss+=bf; t=(t+ (ss&amp;1) )&amp;1; &#125; ans+=(t&lt;&lt;f); &#125; printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2330】【Luogu3275】糖果]]></title>
    <url>%2Fposts%2Fcc92.html</url>
    <content type="text"><![CDATA[来源和评测点SCOI2011 Day1Bzoj2330Luogu3275 题目【题目大意】幼儿园里有N个小朋友，lxhgww老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候，lxhgww需要满足小朋友们的K个要求。幼儿园的糖果总是有限的，lxhgww想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。【输入格式】输入的第一行是两个整数N，K。接下来K行，表示这些点需要满足的关系，每行3个数字X，A，B。如果X=1，表示第A个小朋友分到的糖果必须和第B个小朋友分到的糖果一样多；如果X=2，表示第A个小朋友分到的糖果必须少于第B个小朋友分到的糖果；如果X=3，表示第A个小朋友分到的糖果必须不少于第B个小朋友分到的糖果；如果X=4，表示第A个小朋友分到的糖果必须多于第B个小朋友分到的糖果；如果X=5，表示第A个小朋友分到的糖果必须不多于第B个小朋友分到的糖果；【限定条件】N&lt;=100000,K&lt;=100000，1&lt;=X&lt;=5，1&lt;=A, B&lt;=N【输出格式】输出一行，表示lxhgww老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，就输出-1。【输入样例】5 71 1 22 3 24 4 13 4 55 4 52 3 54 5 1【输出样例】11【样例解释】d[1]=d[2]d[3]&lt;d[2]d[4]&gt;d[1]d[4]&gt;=d[5]d[4]&lt;=d[5]d[3]&lt;d[5]d[5]&gt;d[1] 刷题记录1.5h吃了屎一样难受！居然输出的时候忘记打else了！ 分析具体跑最长路还是最短路，其实都没有问题下文以最长路为例 a=ba&gt;=b+0,ins(b,a,0)a&lt;=b+0,b&gt;=a+0,ins(a,b,0) aa,b&gt;=a+1,ins(a,b,1) a&gt;=ba&gt;=b+0,ins(b,a,0) a&gt;ba&gt;=b+1,ins(b,a,1) a&lt;=bb&gt;=a+0,ins(a,b,0)为了判断是否存在正环，不得不用spfa最后，我们找到了满足不等式组的一组解为了求出答案要求的最小，将最小值平移到1即可 up 2018.9.1其实有可能，数据强行卡spfa可以自己加上酸辣粉优化 正规做法是找题目性质，发现边权都是0或者1所以可以考虑直接判断是否存在正环（用tarjan，累加环总长度即可）没有的话，可以在缩点后的dag上直接拓扑来最短路 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=110000,MAXM=210000;//*******************全局定义*******************struct nod&#123; int hou; int ru,d; bool v; nod() &#123; hou=0; &#125;&#125;p[MAXN];struct edge&#123; int y,c,g;&#125;e[MAXM];int ln=0;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y; e[ln].c=c; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************queue&lt;int&gt; lst;bool spfa(int st,int n)&#123; for(int i=1;i&lt;=n;i++)//debug &#123; p[i].v=1; p[i].ru=1; p[i].d=1; lst.push(i); &#125; while(!lst.empty()) &#123; int x=lst.front();lst.pop();p[x].v=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].d&lt;p[x].d+e[k].c) &#123; p[y].d=p[x].d+e[k].c; if(p[y].v==0) &#123; p[y].v=1; lst.push(y); p[y].ru++; if(p[y].ru&gt;n) return 0; &#125; &#125; &#125; &#125; return 1;&#125;//*******************主函数*******************int main()&#123; int n,k;scanf("%d%d",&amp;n,&amp;k); bool bk=0; while(k--) &#123; int op,a,b;scanf("%d%d%d",&amp;op,&amp;a,&amp;b); if(op==1) ins(a,b,0),ins(b,a,0); if(op==2) &#123;ins(a,b,1);if(a==b) bk=1;&#125; if(op==3) ins(b,a,0); if(op==4) &#123;ins(b,a,1);if(a==b) bk=1;&#125; if(op==5) ins(a,b,0); &#125; if(bk or !spfa(0,n)) printf("-1"); else//debug &#123; long long all=0; for(int i=1;i&lt;=n;i++) all+=p[i].d; printf("%lld",all); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3683】Priest John's Busiest Day]]></title>
    <url>%2Fposts%2F632.html</url>
    <content type="text"><![CDATA[来源和评测点POJ Founder Monthly Contest – 2008.08.31, Dagger and FacerPoj3683 题目【题目大意】John是小镇唯一的牧师，他希望参加n个婚礼，每个婚礼计划在Si~Ti举行婚礼。婚礼有个仪式必须要John参加，但他不能同时参加两个仪式。仪式时间是Si~Si+Di或者Ti-Di~Ti。请替John安排他的日程表题意强调：一个仪式8:30结束，另一个8:30开始，不算冲突【输入格式】第一行整数n(1≤n≤1000)接下来n行，表示Si,Ti和Di（Si&lt;=Ti，Di&lt;=Ti-Si）Si和Ti的格式是hh:mm【输出格式】如果无解，输出NO否则输出YES,并且接下来n行，每行表示他参加的仪式时间。要按照每个婚礼的输入的顺序输出！（因为这是spj嘛）本题有特判。【输入样例】208:00 09:00 3008:15 09:00 20【输出样例】YES08:00 08:3008:40 09:00 刷题记录2h1AC做题 做得好慢啊本来抱着MLE的想法提交的，结果很小嘛~ 分析第一次做要输出方案的2-SAT，感觉好繁琐就是跟着伟大的神教程做得：csdn-jarjingx 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************//*******************全局定义*******************int cnt;//*******************强连通*******************struct nod&#123; int dfn,low; int belg; bool v; int hou; int st,ed;&#125;p[2100];struct edge&#123; int x,y,g;&#125;e[4100000];int ln;void ins(int x,int y)&#123; ln++; e[ln].x=x; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;int sta[2100],top;int id;void tarjan(int x)&#123; sta[++top]=x;p[x].v=1; p[x].dfn=p[x].low=++id; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y); if(p[y].v==1) p[x].low=mymin(p[x].low,p[y].low); &#125; if(p[x].dfn==p[x].low) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].v=0; p[t].belg=cnt; if(t==x) break; &#125; &#125;&#125;//*******************实现定义*******************int hread(void)&#123; int h,m; scanf("%d:%d",&amp;h,&amp;m); return h*60+m;&#125;void hwrite(int tm)&#123; int a=tm/60; if(a&lt;10) printf("0%d:",a); else printf("%d:",a); int b=tm%60; if(b&lt;10) printf("0%d ",b); else printf("%d ",b);&#125;struct nod2&#123; int hou; int ru; int oth; int tag;&#125;pt[2100];struct edge2&#123; int y,g;&#125;eg[4100000];int ln2;void ins2(int x,int y)&#123; ln2++; eg[ln2].y=y; eg[ln2].g=pt[x].hou; pt[x].hou=ln2;&#125;//*******************拓扑*******************int fs,ss[2100];void topsort(int x)&#123; ss[++fs]=x;pt[x].ru=-1; for(int k=pt[x].hou;k&gt;0;k=eg[k].g) &#123; int y=eg[k].y; pt[y].ru--; if(pt[y].ru==0) topsort(y); &#125;&#125;//*******************实现*******************bool okay(int x,int y)&#123; if(p[x].st&gt;p[y].st) swap(x,y); return p[x].ed&lt;=p[y].st;&#125;int getoth(int x) &#123;return x&amp;1?x+1:x-1;&#125;void dfs(int x)&#123; pt[x].tag=-1; for(int k=pt[x].hou;k&gt;0;k=eg[k].g) &#123; int y=eg[k].y; if(pt[y].tag==0) dfs(y); &#125;&#125;bool solve(int n)&#123; ln=cnt=top=id=0; for(int i=1;i&lt;=2*n;i++) &#123; p[i].dfn=0; p[i].v=0; p[i].hou=0; &#125; for(int i=1;i&lt;=2*n;i++) for(int j=i+1;j&lt;=2*n;j++) if(!okay(i,j)) &#123; ins(i,getoth(j)); ins(j,getoth(i)); &#125; for(int i=1;i&lt;=2*n;i++) if(p[i].dfn==0) tarjan(i); ln2=0; for(int i=1;i&lt;=cnt;i++) &#123; pt[i].hou=0; pt[i].ru=0; pt[i].tag=0; &#125; for(int i=1;i&lt;=n;i++) &#123; int fx=p[2*i-1].belg,fy=p[2*i].belg; if(fx==fy) return 0; else &#123; pt[fx].oth=fy; pt[fy].oth=fx; &#125; &#125; for(int i=1;i&lt;=ln;i++) &#123; int x=e[i].x,y=e[i].y; int fx=p[x].belg,fy=p[y].belg; if(fx!=fy) ins2(fy,fx),pt[fx].ru++;//反边 &#125; fs=0; for(int i=1;i&lt;=cnt;i++) if(pt[i].ru==0) topsort(i); for(int i=1;i&lt;=cnt;i++) &#123; int x=ss[i]; if(pt[x].tag==0) &#123; pt[x].tag=1; dfs(pt[x].oth); &#125; &#125; printf("YES\n"); for(int i=1;i&lt;=2*n;i++) if(pt[p[i].belg].tag==1) hwrite(p[i].st),hwrite(p[i].ed),printf("\n"); return 1;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int s=hread(),t=hread(),d;scanf("%d",&amp;d); p[2*i-1].st=s;p[2*i-1].ed=s+d; p[2*i].st=t-d;p[2*i].ed=t; &#125; if(!solve(n)) printf("NO");&#125; other solution from lydUP 2018.9.6:具体方法参考更新后的2-sat教程]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>难度2</tag>
        <tag>拓扑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3207】Panda's Trick]]></title>
    <url>%2Fposts%2F9ebb.html</url>
    <content type="text"><![CDATA[来源和评测点Poj3207 题目【题目大意】在一个圆上，有n个点（0~n-1），m条边，边可以在圆内或圆外（圆内即线段）保证每个点最多和一条边相连判断能否每条边不相交【输入格式】第一行n和m（n≤1000, m≤500）接下来m行，a和b表示连边【输出格式】如果不重合，输出panda is telling the truth…否则输出the evil panda is lying again【输入样例】4 20 13 2【输出样例】panda is telling the truth… 刷题记录20min 分析2-SAT显然：如果两条边在圆内相交，则在圆外也一定相交于是就产生了两种情况，并且会有互斥关系，套上模板即可对了，因为建图出来的是双向边，用并查集也是没毛病的。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=1100,MAXM=1100000;//*******************全局定义*******************int cnt;struct nod&#123; int dfn,low; int belg; bool v; int hou;&#125;p[MAXN];struct edge&#123; int y,g;&#125;e[MAXM];int ln;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int sta[MAXN],top;int id;void tarjan(int x)&#123; sta[++top]=x;p[x].v=1; p[x].dfn=p[x].low=++id; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y); if(p[y].v==1) p[x].low=mymin(p[x].low,p[y].dfn); &#125; if(p[x].dfn==p[x].low) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].v=0; p[t].belg=cnt; if(t==x) break; &#125; &#125;&#125;//*******************主函数*******************int st[MAXM],ed[MAXM];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); ln=id=top=cnt=0; for(int i=1;i&lt;=m;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y);x++,y++; st[i]=mymin(x,y);ed[i]=mymax(x,y); &#125; for(int i=1;i&lt;=2*m;i++) &#123; p[i].dfn=0; p[i].hou=0; p[i].belg=0; p[i].v=0; &#125; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=m;j++) if(st[i]&lt;st[j] and st[j]&lt;ed[i] and ed[i]&lt;ed[j]) &#123; ins(2*i,2*j-1); ins(2*j-1,2*i); ins(2*j,2*i-1); ins(2*i-1,2*j); &#125; for(int i=1;i&lt;=2*m;i++) if(p[i].dfn==0) tarjan(i); bool bk=0; for(int i=1;i&lt;=m;i++) if(p[2*i-1].belg==p[2*i].belg) bk=1; if(bk) printf("the evil panda is lying again"); else printf("panda is telling the truth...");&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1405】聚会]]></title>
    <url>%2Fposts%2F46fd.html</url>
    <content type="text"><![CDATA[来源和评测点Caioj1405 题目【题目大意】n对夫妻参加一个聚会，每对夫妻只有1人可以列席。在2n个人中，某些人之间有矛盾,夫妻之间不会有矛盾。有矛盾的2个人不会同时出现在聚会上。问有没有可能会有n个人同时列席？【输入格式】第一行：一个正整数n(1&lt;=n&lt;=1000)，表示有n对夫妻被邀请第一行：一个正整数m(m&lt;(n-1)*(n-1))，表示有m对矛盾关系接下来的m行，每行四个正整数A1,A2,C1,C2。A1,A2分别表示夫妻的编号。C1,C2表示矛盾者是妻子还是丈夫，0表示妻子，1表示丈夫多组数据，当n=0时结束【输出格式】如果存在这种情况，输出YES；否则输出NO【输入样例】210 1 1 10【输出样例】YES 刷题记录20min1WA1AC 分析2-SAT裸题 代码12]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1997】Planar]]></title>
    <url>%2Fposts%2Fc3c1.html</url>
    <content type="text"><![CDATA[来源和评测点Hnoi2010Bzoj1997 题目【题目大意】【输入格式】【输出格式】【输入样例】26 91 41 51 62 42 52 63 43 53 61 4 2 5 3 65 51 22 33 44 55 11 2 3 4 5【输出样例】NOYES 刷题记录30min2TLE(空间开小)2AC(有bug) 分析神奇的平面图定理：m&lt;=3*n+6（不然空间会爆的，其他就很简单啦）之前说过，如果两条边在圆内相交，则在圆外也一定相交那么哈密顿回路是可以拉成一个圆的 对了，因为建图出来的是双向边，用并查集也是没毛病的。 嗯这题除了空间上的问题，也算是独立完成了吧…… UP 2018.9.10:这里用到的公式可以前往oi之路的定理杂烩查看详细信息 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=1300,MAXM=1500000;//*******************全局定义*******************int cnt;struct nod&#123; int dfn,low; int belg; bool v; int hou;&#125;p[MAXN];struct edge&#123; int y,g;&#125;e[MAXM];int ln;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int sta[MAXN],top;int id;void tarjan(int x)&#123; sta[++top]=x;p[x].v=1; p[x].dfn=p[x].low=++id; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y); if(p[y].v==1) p[x].low=mymin(p[x].low,p[y].low); &#125; if(p[x].dfn==p[x].low) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].v=0; p[t].belg=cnt; if(t==x) break; &#125; &#125;&#125;//*******************主函数*******************int st[MAXM],ed[MAXM];int ptd[MAXN];bool solve(int n,int m)&#123; if(m&gt;3*n+6) return 1; memset(p,0,sizeof(p)); ln=id=top=cnt=0; for(int i=1;i&lt;=m;i++) &#123; st[i]=ptd[st[i]]; ed[i]=ptd[ed[i]]; if(st[i]&gt;ed[i]) swap(st[i],ed[i]); if( st[i]+1==ed[i] or (st[i]==n and ed[i]==1)) &#123; st[i]=st[m]; ed[i]=ed[m]; m--; i--; &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; for(int j=i+1;j&lt;=m;j++) &#123; if( (st[i]&lt;st[j] and st[j]&lt;ed[i] and ed[i]&lt;ed[j])or (st[j]&lt;st[i] and st[i]&lt;ed[j] and ed[j]&lt;ed[i]) ) &#123; ins(2*i,2*j-1); ins(2*j-1,2*i); ins(2*j,2*i-1); ins(2*i-1,2*j); &#125; &#125; &#125; for(int i=1;i&lt;=2*m;i++) if(p[i].dfn==0) tarjan(i); for(int i=1;i&lt;=m;i++) if(p[2*i-1].belg==p[2*i].belg) return 1; return 0;&#125;int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf("%d%d",&amp;st[i],&amp;ed[i]); for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); ptd[t]=i; &#125; if(solve(n,m)) printf("NO\n"); else printf("YES\n"); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF19E】【Bzoj4424】Fairy]]></title>
    <url>%2Fposts%2F59cc.html</url>
    <content type="text"><![CDATA[来源和评测点CF19EBzoj4424 题目【题目大意】给定n个点，m条边的无向图，可以从图中删除一条边，问删除哪些边可以使图变成一个二分图。（补充：只能是每次一条）【输入格式】第1行包含两个整数n，m。分别表示点数和边数。第2到m+1行每行两个数x，y表示有一条（x,y）的边。【输出格式】输出第一行一个整数，表示能删除的边的个数。接下来一行按照从小到大的顺序输出边的序号。【输入样例】4 41 21 32 43 4【输出样例】41 2 3 4 刷题记录3h 分析首先，确保理解题意无误后，各种画图探究二分图的性质发现所谓二分图，就是不能有奇数环 长姿势：对于一个图，可以考虑建立dfs序树，将边分为生成树边和返祖边（回边）从而对于环或者之类的东西一目了然（因为树是没有环的） 然后在这里：DaD3zZ它提到了单返祖边，但我并不觉得返祖边数量有任何影响所以他的意思应该是，程序设计的时候，因为是建立dfs序树，所以只能处理单返祖边？ 说说我的看法：1.如果没有奇数环，那么输出所有边，因为这样都可以符合要求2.1)必须删除的是奇数环的公共边，否则还会有奇数环剩余2.2)不能是任何一个偶环的部分，否则会产生新的奇数环引用几张图片，大家思考一下：呃外站图片，懒得下载下来了，如果哪天csdn炸了(其实几率不大)或者文章删除了，评论即可。 打上标记输出即可注意可能会有重边和负环，而且不一定联通。负环：看作奇数环即可重边：看作返祖边即可联通：没进入过的进入即可反正就是别太操心特殊情况，然后排除掉，要一视同仁~ 写下来详细说说怎么dp吧（开始涉及细节了，想独立思考的请跳过）先区分树边和返祖边，然后枚举返祖边判断环的奇偶性（有返祖边就有环）如果奇数环个数=0，直接输出全部然后结束程序。否则，如果是返祖边，如果奇数环=1，那么可以，否则显然就不是奇数环的公公共边了。然后计算每条树边被多少个奇数环包含，从而判断是否是公共边接下来用点来标记网上好像没人说，但想半天后忽然发现，接下来这个其实类似于树上差分！（解释一下，树上差分大概就是其他位置的树上前缀和不变）每个点上面的odd、ever分别表示它的父亲树边在多少个偶数、奇数环中回溯的时候再转移到边上，这样避免了处理双向边的繁琐，最后按顺序枚举输出。 最后的最后，补充一个降低代码复杂的方法，因为我们在建树的时候建立的是双向边，令ln=1，然后这样建边的时候同一条边的编号一个是奇数一个是偶数，可以用异或处理了，而且除以2后就合并了。 真的是最后了，因为是双向建边，可以向下的时候不能是（标记为不是返祖边），而是（标记为树边）应该挺好理解的~ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=1000010;//*******************全局定义*******************struct road&#123; int x,y; int odd,even;//奇、偶 bool sb;//树边&#125;rd[MAXN];struct nod&#123; int hou; int dep; int odd,even;//奇、偶&#125;p[MAXN];struct edge&#123; int y,g;&#125;e[MAXN*2];int ln=1;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************bool v[MAXN];void dfs1(int x,int dep)&#123; p[x].dep=dep;v[x]=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(v[y]==0) &#123; dfs1(y,dep+1); rd[k/2].sb=1; &#125; &#125;&#125;void dfs2(int x)&#123; v[x]=1;//debug for(int k=p[x].hou;k&gt;0;k=e[k].g) if(rd[k/2].sb=1) &#123; int y=e[k].y; if(v[y]==1) continue;//debug dfs2(y); p[x].odd+=p[y].odd; p[x].even+=p[y].even;//树上前缀和 rd[k/2].odd=p[y].odd; rd[k/2].even=p[y].even; &#125;&#125;//*******************主函数*******************int ans[MAXN];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;rd[i].x,&amp;rd[i].y); rd[i].odd=rd[i].even=rd[i].sb=0; ins(rd[i].x,rd[i].y);ins(rd[i].y,rd[i].x); &#125; memset(v,0,sizeof(v)); for(int i=1;i&lt;=n;i++) if(v[i]==0) dfs1(i,1); int cnt=0;//奇数环个数 for(int i=1;i&lt;=m;i++) if(rd[i].sb==0) &#123; int x=rd[i].x,y=rd[i].y; if(p[x].dep&gt;p[y].dep) swap(x,y); if( (p[y].dep-p[x].dep)%2==1 ) p[x].even--,p[y].even++;//偶数环 else p[x].odd--,p[y].odd++,cnt++,rd[i].odd=1;//奇数环，特别处理一下返祖边 &#125; if(cnt==0) &#123; printf("%d\n",m); for(int i=1;i&lt;=m;i++) if(i&lt;m) printf("%d ",i); else printf("%d\n",i); return 0; &#125; memset(v,0,sizeof(v)); for(int i=1;i&lt;=n;i++) if(v[i]==0) dfs2(i); int ansn=0; for(int i=1;i&lt;=m;i++) &#123; if(rd[i].sb)//树边 &#123; if(rd[i].even==0 and rd[i].odd==cnt) ans[++ansn]=i; &#125; else//返祖边特判 &#123; if(rd[i].odd==cnt) ans[++ansn]=i; &#125; &#125; printf("%d\n",ansn); for(int i=1;i&lt;=ansn;i++) if(i&lt;ansn) printf("%d ",ans[i]); else printf("%d\n",ans[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj4520】K远点对]]></title>
    <url>%2Fposts%2F673d.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj4520 题目【题目大意】已知平面内N个点的坐标，求欧氏距离下的第K远点对。【输入格式】输入文件第一行为用空格隔开的两个整数N，K。接下来N行，每行两个整数X,Y，表示一个点的坐标。1&lt;=N&lt;=100000，1&lt;=K&lt;=100，K&lt;=N*(N−1)/2，0&lt;=X,Y&lt;2^31。【输出格式】出文件第一行为一个整数，表示第K远点对的距离的平方（一定是个整数）。【输入样例】10 50 00 11 01 12 02 11 20 23 03 1【输出样例】9 刷题记录20min 分析kdtree，k固定因为每个距离维护了两次，用2*k大小的小根堆维护，相当于维护了前k个值，并且堆顶正是第k个 长姿势：对于k确定的第k大，用一个堆维护会灰常方便 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;typedef unsigned long long ll;//严格来说这样才对ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;ll mymax(ll x,ll y) &#123;return x&gt;y?x:y;&#125;ll myabs(ll x) &#123;return x&gt;0?x:-x;&#125;ll mysqr(ll x) &#123;return x*x;&#125;//*******************全局常量*******************const int MAXN=110000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; ll d[2];//自己 ll mi[2],mx[2];//管理区间 int son[2];//左右区间 nod() &#123; son[0]=son[1]=0; &#125;&#125;p[MAXN];//*******************kdtree*******************int D;bool cmp(nod a,nod b)&#123; return (a.d[D]&lt;b.d[D]) or (a.d[D]==b.d[D] and a.d[1-D]&lt;b.d[1-D]);&#125;void update(int f,int x)&#123; p[f].mi[0]=mymin(p[f].mi[0],p[x].mi[0]);p[f].mx[0]=mymax(p[f].mx[0],p[x].mx[0]); p[f].mi[1]=mymin(p[f].mi[1],p[x].mi[1]);p[f].mx[1]=mymax(p[f].mx[1],p[x].mx[1]);&#125;ll getdis(int t,ll x,ll y)//估价最好情况&#123; return mymax(mysqr(p[t].mi[0]-x),mysqr(p[t].mx[0]-x))+ mymax(mysqr(p[t].mi[1]-y),mysqr(p[t].mx[1]-y));&#125;//*******************实现*******************int root;int build(int l,int r,int d)&#123; if(l&gt;r) return 0; int mid=(l+r)/2; D=d;nth_element(p+l,p+mid,p+r+1,cmp);//尽量平衡 p[mid].mi[0]=p[mid].mx[0]=p[mid].d[0]; p[mid].mi[1]=p[mid].mx[1]=p[mid].d[1]; if(l&lt;=mid-1) p[mid].son[0]=build(l,mid-1,1-d),update(mid,p[mid].son[0]); if(mid+1&lt;=r) p[mid].son[1]=build(mid+1,r,1-d),update(mid,p[mid].son[1]); return mid;&#125;int cnt;void insert(ll x,ll y)&#123; int t=++cnt; p[t].d[0]=p[t].mi[0]=p[t].mx[0]=x; p[t].d[1]=p[t].mi[1]=p[t].mx[1]=y; if(root==0) root=t; else &#123; int f=root; for(D=0;1;D=1-D) &#123; update(f,t); int tmp=cmp(p[f],p[t]); if(p[f].son[tmp]==0) &#123; p[f].son[tmp]=t; break; &#125; f=p[f].son[tmp]; &#125; &#125;&#125;priority_queue&lt; ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt; q;void ask(int t,ll x,ll y)&#123; ll dis=mysqr(p[t].d[0]-x)+mysqr(p[t].d[1]-y); if(dis!=0 and dis&gt;q.top()) q.pop(),q.push(dis); int lc=p[t].son[0],rc=p[t].son[1]; ll f[2]; f[0]=(lc&gt;0)?getdis(lc,x,y):0; f[1]=(rc&gt;0)?getdis(rc,x,y):0; bool tmp=(f[1]&lt;=f[0]); if(f[tmp]&gt;q.top()) ask(p[t].son[tmp],x,y); if(f[1-tmp]&gt;q.top()) ask(p[t].son[1-tmp],x,y);&#125;//*******************主函数*******************int main()&#123; int n,k;scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%lld%lld",&amp;p[i].d[0],&amp;p[i].d[1]); root=build(1,n,0); while(q.size()&lt;2*k) q.push(0); for(int i=1;i&lt;=n;i++) ask(root,p[i].d[0],p[i].d[1]); printf("%lld",q.top());&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>kdtree</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1941】Hide and Seek]]></title>
    <url>%2Fposts%2F87ed.html</url>
    <content type="text"><![CDATA[来源和评测点Sdoi2010Bzoj1941 题目【题目大意】小猪iPig在PKU刚上完了无聊的猪性代数课，天资聪慧的iPig被这门对他来说无比简单的课弄得灰常寂寞。为了消除寂寞感，他决定和他的好朋友giPi（鸡皮）玩一个更加寂寞的游戏—捉迷藏。但是，他们觉得，玩普通的捉迷藏没什么意思，还是不够寂寞，于是，他们决定玩寂寞无比的螃蟹版捉迷藏，顾名思义，就是说他们在玩游戏的时候只能沿水平或垂直方向走。一番寂寞的剪刀石头布后，他们决定iPig去捉giPi。由于他们都很熟悉PKU的地形了，所以giPi只会躲在PKU内n个隐秘地点，显然iPig也只会在那n个地点内找giPi。游戏一开始，他们选定一个地点，iPig保持不动，然后giPi用30秒的时间逃离现场（显然，giPi不会呆在原地）。然后iPig会随机地去找giPi，直到找到为止。由于iPig很懒，所以他到总是走最短的路径，而且，他选择起始点不是随便选的，他想找一个地点，使得该地点到最远的地点和最近的地点的距离差最小。iPig现在想知道这个距离差最小是多少。由于iPig现在手上没有电脑，所以不能编程解决这个如此简单的问题，所以他马上打了个电话，要求你帮他解决这个问题。iPig告诉了你PKU的n个隐秘地点的坐标，请你编程求出iPig的问题。【输入格式】第一行输入一个整数N 第2~N+1行，每行两个整数X，Y，表示第i个地点的坐标【输出格式】一个整数，为距离差的最小值。【输入样例】40 01 00 11 1【输出样例】1 刷题记录30min1AC 分析kdtree暴力枚举即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=510000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int d[2];//自己 int son[2];//左右区间 int mi[2],mx[2];//管理区间 nod() &#123; son[0]=son[1]=0; &#125;&#125;p[MAXN];int root;//*******************kdtree*******************int D;bool cmp(nod a,nod b)&#123; return (a.d[D]&lt;b.d[D]) or (a.d[D]==b.d[D] and a.d[1-D]&lt;b.d[1-D]);&#125;void update(int f,int x)&#123; p[f].mi[0]=mymin(p[f].mi[0],p[x].mi[0]);p[f].mx[0]=mymax(p[f].mx[0],p[x].mx[0]); p[f].mi[1]=mymin(p[f].mi[1],p[x].mi[1]);p[f].mx[1]=mymax(p[f].mx[1],p[x].mx[1]);&#125;int getdis(int t,int x,int y,int op)//最近&#123; if(op==0) &#123; int ans=0;//在内部 if(x&lt;p[t].mi[0]) ans+=p[t].mi[0]-x;//左 if(p[t].mx[0]&lt;x) ans+=x-p[t].mx[0];//右 if(p[t].mx[1]&lt;y) ans+=y-p[t].mx[1];//上 if(y&lt;p[t].mi[1]) ans+=p[t].mi[1]-y;//下 return ans; &#125; else &#123; return mymax(myabs(x-p[t].mx[0]),myabs(x-p[t].mi[0]))+ mymax(myabs(y-p[t].mx[1]),myabs(y-p[t].mi[1])); &#125; &#125;//*******************实现*******************int build(int l,int r,int d)&#123; if(l&gt;r) return 0; int mid=(l+r)/2;D=d; nth_element(p+l,p+mid,p+r+1,cmp);//尽量平衡 p[mid].mi[0]=p[mid].mx[0]=p[mid].d[0]; p[mid].mi[1]=p[mid].mx[1]=p[mid].d[1]; if(l&lt;=mid-1) p[mid].son[0]=build(l,mid-1,1-d),update(mid,p[mid].son[0]); if(mid+1&lt;=r) p[mid].son[1]=build(mid+1,r,1-d),update(mid,p[mid].son[1]); return mid;&#125;int ans;void ask(int now,int x,int y,int op)&#123; int dis=myabs(p[now].d[0]-x)+myabs(p[now].d[1]-y);//自身 if(dis!=0) &#123; if(op==0) ans=mymin(ans,dis); else ans=mymax(ans,dis); &#125; int f[2],lc=p[now].son[0],rc=p[now].son[1]; if(op==0) &#123; f[0]=lc?getdis(lc,x,y,op):INF; f[1]=rc?getdis(rc,x,y,op):INF; bool tmp=(f[1]&lt;=f[0]); if(f[tmp]&lt;ans) ask(p[now].son[tmp],x,y,op); if(f[1-tmp]&lt;ans) ask(p[now].son[1-tmp],x,y,op); &#125; else &#123; f[0]=lc?getdis(lc,x,y,op):0; f[1]=rc?getdis(rc,x,y,op):0; bool tmp=(f[1]&gt;=f[0]); if(f[tmp]&gt;ans) ask(p[now].son[tmp],x,y,op); if(f[1-tmp]&gt;ans) ask(p[now].son[1-tmp],x,y,op); &#125;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].d[0],&amp;p[i].d[1]); root=build(1,n,0); int mi=INF; for(int i=1;i&lt;=n;i++) &#123; ans=0; ask(root,p[i].d[0],p[i].d[1],1); int t=ans;ans=INF; ask(root,p[i].d[0],p[i].d[1],0); mi=mymin(mi,t-ans); &#125; printf("%d",mi);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>kdtree</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1206】最近点对]]></title>
    <url>%2Fposts%2Fa1d3.html</url>
    <content type="text"><![CDATA[来源和评测点Caioj1206 题目【题目大意】给出n个点的坐标，求最近两点间的距离。【输入格式】第一行一个整数n(2≤n≤50000)。下来n行，每行两个实数x和y表示点坐标。【输出格式】一行一个实数，表示最近两点间的距离（保留4位小数）。【输入样例】50 00 55 05 52 0【输出样例】2.0000 刷题记录30min1WA1AC 分析kdtree记得开long long 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;ll mymax(ll x,ll y) &#123;return x&gt;y?x:y;&#125;ll myabs(ll x) &#123;return x&gt;0?x:-x;&#125;ll mysqr(ll x) &#123;return x*x;&#125;//*******************全局常量*******************const int MAXN=51000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; ll d[2];//自己 ll mi[2],mx[2];//管理区间 int son[2];//左右区间 nod() &#123; son[0]=son[1]=0; &#125;&#125;p[MAXN];//*******************kdtree*******************int D;bool cmp(nod a,nod b)&#123; return (a.d[D]&lt;b.d[D]) or (a.d[D]==b.d[D] and a.d[1-D]&lt;b.d[1-D]);&#125;void update(int f,int x)&#123; p[f].mi[0]=mymin(p[f].mi[0],p[x].mi[0]);p[f].mx[0]=mymax(p[f].mx[0],p[x].mx[0]); p[f].mi[1]=mymin(p[f].mi[1],p[x].mi[1]);p[f].mx[1]=mymax(p[f].mx[1],p[x].mx[1]);&#125;ll getdis(int t,ll x,ll y)//估价最好情况&#123; ll xx=mymax(0,p[t].mi[0]-x)+mymax(0,x-p[t].mx[0]); ll yy=mymax(0,y-p[t].mx[1])+mymax(0,p[t].mi[1]-y); return xx*xx+yy*yy;&#125;//*******************实现*******************int root;int build(int l,int r,int d)&#123; if(l&gt;r) return 0; int mid=(l+r)/2; D=d;nth_element(p+l,p+mid,p+r+1,cmp);//尽量平衡 p[mid].mi[0]=p[mid].mx[0]=p[mid].d[0]; p[mid].mi[1]=p[mid].mx[1]=p[mid].d[1]; if(l&lt;=mid-1) p[mid].son[0]=build(l,mid-1,1-d),update(mid,p[mid].son[0]); if(mid+1&lt;=r) p[mid].son[1]=build(mid+1,r,1-d),update(mid,p[mid].son[1]); return mid;&#125;int cnt;void insert(ll x,ll y)&#123; int t=++cnt; p[t].d[0]=p[t].mi[0]=p[t].mx[0]=x; p[t].d[1]=p[t].mi[1]=p[t].mx[1]=y; if(root==0) root=t; else &#123; int f=root; for(D=0;1;D=1-D) &#123; update(f,t); int tmp=cmp(p[f],p[t]); if(p[f].son[tmp]==0) &#123; p[f].son[tmp]=t; break; &#125; f=p[f].son[tmp]; &#125; &#125;&#125;ll ans;void ask(int t,ll x,ll y)&#123; ll dis=mysqr(p[t].d[0]-x)+mysqr(p[t].d[1]-y); /*if(dis==0) return;//自身 ans=mymin(ans,dis);*/ if(dis!=0) ans=mymin(ans,dis); //UP: caioj神水数据，一看就是错的 int lc=p[t].son[0],rc=p[t].son[1]; ll f[2]; f[0]=(lc&gt;0)?getdis(lc,x,y):INF; f[1]=(rc&gt;0)?getdis(rc,x,y):INF; bool tmp=(f[1]&lt;=f[0]); if(f[tmp]&lt;ans) ask(p[t].son[tmp],x,y); if(f[1-tmp]&lt;ans) ask(p[t].son[1-tmp],x,y);&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld%lld",&amp;p[i].d[0],&amp;p[i].d[1]); root=build(1,n,0); ans=INF; for(int i=1;i&lt;=n;i++) ask(root,p[i].d[0],p[i].d[1]); printf("%.4lf",sqrt(double(ans)));&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>kdtree</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1051】受欢迎的牛]]></title>
    <url>%2Fposts%2Fc794.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj1051 题目【题目大意】每一头牛的愿望就是变成一头最受欢迎的牛。现在有N头牛，给你M对整数(A,B)，表示牛A认为牛B受欢迎。这种关系是具有传递性的，如果A认为B受欢迎，B认为C受欢迎，那么牛A也认为牛C受欢迎。你的任务是求出有多少头牛被所有的牛认为是受欢迎的。【输入格式】第一行两个数N,M。接下来M行，每行两个数A,B，意思是A认为B是受欢迎的（给出的信息有可能重复，即有可能出现多个A,B）N&lt;=10000,M&lt;=50000【输出格式】一个数，即有多少头牛被所有的牛认为是受欢迎的。【输入样例】3 31 22 12 3【输出样例】1 刷题记录30min1WA1AC 分析一开始还乱想到差分约束…… 引用1：由题可得，受欢迎的奶牛只有可能是图中唯一的出度为零的强连通分量中的所有奶牛，所以若出现两个以上出度为0的强连通分量则不存在明星奶牛，因为那几个出度为零的分量的爱慕无法传递出去。那唯一的分量能受到其他分量的爱慕同时在分量内相互传递，所以该分量中的所有奶牛都是明星 引用2：在有向图中，如果有且仅有一个点的出度为0 （没有指向其他点的边），那么该点可以被所有点遍历到；反之，该图中没有可以被所有点遍历到的点。在有向图中，如果一个点可以被所有点遍历到，那么这个点的出度为0。可用反证法证明。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=21000,MAXM=51000;//*******************全局定义*******************int size[MAXN];int cnt;struct nod&#123; int hou; int dfn,low; bool v; int belg;&#125;p[MAXN];struct edge&#123; int x,y,g;&#125;e[MAXM];int ln;void ins(int x,int y)&#123; ln++; e[ln].x=x; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int sta[MAXN],top;int id;void tarjan(int x)&#123; sta[++top]=x;p[x].v=1; p[x].dfn=p[x].low=++id; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y),p[x].low=mymin(p[x].low,p[y].low); else if(p[y].v) p[x].low=mymin(p[x].low,p[y].dfn); &#125; if(p[x].dfn==p[x].low) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].belg=cnt; size[cnt]++; p[t].v=0; if(t==x) break; &#125; &#125;&#125;//*******************主函数*******************int out[MAXN];int main()&#123; int T=1;//scanf("%d",&amp;T); while(T--) &#123; memset(p,0,sizeof(p)); memset(size,0,sizeof(size)); cnt=ln=id=0; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); ins(x,y); &#125; top=0; for(int i=1;i&lt;=n;i++) if(p[i].dfn==0) tarjan(i); memset(out,0,sizeof(out)); for(int i=1;i&lt;=ln;i++) &#123; int x=p[e[i].x].belg,y=p[e[i].y].belg; if(x!=y) out[x]++; &#125; int b=0,ans; for(int i=1;i&lt;=cnt;i++) if(out[i]==0) b++,ans=size[i]; if(b!=1) printf("0\n"); else printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2648】【Bzoj2716】SJY摆棋子]]></title>
    <url>%2Fposts%2F5728.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj2648Bzoj2716 题目【题目大意】在一个棋盘上，有N个黑色棋子。他每次要么放到棋盘上一个黑色棋子，要么放上一个白色棋子。如果是白色棋子，他会找出距离这个白色棋子最近的黑色棋子。此处的距离是 曼哈顿距离 即(|x1-x2|+|y1-y2|) 。现在给出N&lt;=500000个初始棋子和M&lt;=500000个操作。对于每个白色棋子，输出距离这个白色棋子最近的黑色棋子的距离。同一个格子可能有多个棋子。【输入格式】第一行两个数 N M以后N行，每行两个数x y（原题面错误）以后M行，每行3个数 t x y如果t=1 那么放下一个黑色棋子如果t=2 那么放下一个白色棋子【输出格式】对于每个T=2 输出一个最小距离【输入样例】2 31 12 32 1 21 3 32 4 2【输出样例】12 刷题记录1h4WA1AC 分析kdtree 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=1100000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int d[2];//自己 int son[2];//左右区间 int mi[2],mx[2];//管理区间 nod() &#123; son[0]=son[1]=0; &#125;&#125;p[MAXN];int root;//*******************kdtree*******************int D;bool cmp(nod a,nod b)&#123; return (a.d[D]&lt;b.d[D]) or (a.d[D]==b.d[D] and a.d[1-D]&lt;b.d[1-D]);&#125;void update(int f,int x)&#123; p[f].mi[0]=mymin(p[f].mi[0],p[x].mi[0]);p[f].mx[0]=mymax(p[f].mx[0],p[x].mx[0]); p[f].mi[1]=mymin(p[f].mi[1],p[x].mi[1]);p[f].mx[1]=mymax(p[f].mx[1],p[x].mx[1]);&#125;int getdis(int t,int x,int y)//估价最好情况&#123; int ans=0;//在内部 if(x&lt;p[t].mi[0]) ans+=p[t].mi[0]-x;//左 if(p[t].mx[0]&lt;x) ans+=x-p[t].mx[0];//右 if(p[t].mx[1]&lt;y) ans+=y-p[t].mx[1];//上 if(y&lt;p[t].mi[1]) ans+=p[t].mi[1]-y;//下 /* 神TM复制的时候忘记改x为y，然后居然水了无数点 ans=mymax(p[t].mi[0]-x,0)+mymax(x-p[t].mx[0],0)+ mymax(p[t].mi[1]-y,0)+mymax(y-p[t].mx[1],0);*/ return ans;&#125;//*******************实现*******************int build(int l,int r,int d)&#123; if(l&gt;r) return 0;//debug int mid=(l+r)/2;D=d;//debug nth_element(p+l,p+mid,p+r+1,cmp);//尽量平衡 p[mid].mi[0]=p[mid].mx[0]=p[mid].d[0]; p[mid].mi[1]=p[mid].mx[1]=p[mid].d[1]; if(l&lt;=mid-1) p[mid].son[0]=build(l,mid-1,1-d),update(mid,p[mid].son[0]); if(mid+1&lt;=r) p[mid].son[1]=build(mid+1,r,1-d),update(mid,p[mid].son[1]); return mid;&#125;int cnt;void insert(int x,int y)&#123; int t=++cnt; p[t].d[0]=p[t].mi[0]=p[t].mx[0]=x; p[t].d[1]=p[t].mi[1]=p[t].mx[1]=y; if(root==0) root=t; else &#123; int f=root; for(D=0;1;D=1-D) &#123; update(f,t); int tx=!cmp(p[t],p[f]); if(p[f].son[tx]==0) &#123; p[f].son[tx]=t; break; &#125; f=p[f].son[tx]; &#125; &#125;&#125;int ans;void ask(int now,int x,int y)&#123; ans=mymin(ans,myabs(p[now].d[0]-x)+myabs(p[now].d[1]-y));//自身 int f[2],lc=p[now].son[0],rc=p[now].son[1]; f[0]=lc?getdis(lc,x,y):INF; f[1]=rc?getdis(rc,x,y):INF; bool tmp=!(f[0]&lt;=f[1]); if(f[tmp]&lt;ans) ask(p[now].son[tmp],x,y); if(f[1-tmp]&lt;ans) ask(p[now].son[1-tmp],x,y);&#125;//*******************主函数*******************int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].d[0],&amp;p[i].d[1]); root=build(1,n,0);cnt=n; while(m--) &#123; int op,x,y;scanf("%d%d%d",&amp;op,&amp;x,&amp;y); if(op==1) insert(x,y); else ans=INF,ask(root,x,y),printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>kdtree</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hdu2767】Proving Equivalences]]></title>
    <url>%2Fposts%2F1075.html</url>
    <content type="text"><![CDATA[来源和评测点Hdu2767显然我没看懂原题目……Caioj1148 题目【题目大意】给出一个有向图有n个点和m条有向边，问加上最少的边，使它成为一个强连通图。（什么是强连通图：任意两个点都能连通的）【输入格式】第一行一个整数N（1≤N≤100）表示下来有N组数据。每组数据第一行为两个整数n(1≤n≤20000)和m(0≤m≤50000)，表示n个点和m条有向边。下来m行，每行两个整数x和y，表示一条x到y的有向边(1≤x,y≤n且x!=y)。【输出格式】每组数据输出一行，一个整数，表示最少需要添加的有向边的数目。【输入样例】24 03 21 21 3【输出样例】42 刷题记录30min1RE7WA2AC 分析缩点后，统计max（入度=0，出度=0）即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=21000,MAXM=51000;//*******************全局定义*******************int cnt;struct nod&#123; int hou; int dfn,low; bool v; int belg;&#125;p[MAXN];struct edge&#123; int x,y,g;&#125;e[MAXM];int ln;void ins(int x,int y)&#123; ln++; e[ln].x=x; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int sta[MAXN],top;int id;void tarjan(int x)&#123; sta[++top]=x;p[x].v=1; p[x].dfn=p[x].low=++id; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y),p[x].low=mymin(p[x].low,p[y].low); else if(p[y].v) p[x].low=mymin(p[x].low,p[y].dfn); &#125; if(p[x].dfn==p[x].low) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].belg=cnt; p[t].v=0; if(t==x) break; &#125; &#125;&#125;//*******************主函数*******************int in[MAXN],out[MAXN];int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; memset(p,0,sizeof(p)); cnt=ln=id=0; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); ins(x,y); &#125; top=0; for(int i=1;i&lt;=n;i++) if(p[i].dfn==0) tarjan(i); if(cnt==1)//debug &#123; printf("0\n"); continue; &#125; memset(in,0,sizeof(in)); memset(out,0,sizeof(out)); for(int i=1;i&lt;=ln;i++) &#123; int x=p[e[i].x].belg,y=p[e[i].y].belg; if(x!=y) &#123; out[x]++; in[y]++; &#125; &#125; int a=0,b=0; for(int i=1;i&lt;=cnt;i++) &#123; if(in[i]==0) a++; if(out[i]==0) b++; &#125; printf("%d\n",mymax(a,b)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Vijos1023】Victoria的舞会3]]></title>
    <url>%2Fposts%2Fa373.html</url>
    <content type="text"><![CDATA[来源和评测点Vijos1023 题目【题目大意】Victoria准备邀请n个已经确定的人，可是问题来了：这n个人每一个人都有一个小花名册，名册里面写着他能够通知到的人的名字。比如说在A的人名单里写了B，那么表示A能够通知到B；但是B的名单里不见的有A，也就是说B不见得通知到A。Victoria觉得需要确定自己需要通知多少个人m，能够实际将所有人n都通知到。并求出一种方案以确定m的最小值是多少。注意：自己的名单里面不会有自己的名字。Victoria可以自身通知到所有n个人。【输入格式】第一行一个数n。接下来n行，每i+1行表示编号为i的人的小花名册名单，名单以0结束。1&lt;=n&lt;=200。【输出格式】仅一行，如无解则输出‘NO’；否则输出最小的k的值。【输入样例】18011 000016 014 00002 13 0011 07 006 000【输出样例】14 刷题记录30min1WA1AC 分析强连通分量裸题缩点后，统计入度=0即可 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=210,MAXM=41000;//*******************全局定义*******************int cnt=0;int ru[MAXN];struct nod&#123; int hou; int dfn,low; bool v; int belg; nod() &#123; hou=0; dfn=0; v=0; &#125;&#125;p[MAXN];struct edge&#123; int x,y,g;&#125;e[MAXM];int ln=0;void ins(int x,int y)&#123; ln++; e[ln].x=x; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int sta[MAXN],top=0;int id=0;void tarjan(int x)&#123; sta[++top]=x;p[x].v=1; p[x].dfn=p[x].low=++id; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y),p[x].low=mymin(p[x].low,p[y].low); else if(p[y].v) p[x].low=mymin(p[x].low,p[y].dfn); &#125; if(p[x].dfn==p[x].low) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].belg=cnt; p[t].v=0; if(t==x) break; &#125; &#125;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; while(1) &#123; int x;scanf("%d",&amp;x); if(x==0) break; ins(i,x); &#125; &#125; for(int i=1;i&lt;=n;i++) if(p[i].dfn==0) tarjan(i); for(int i=1;i&lt;=ln;i++) &#123; int x=e[i].x,y=e[i].y; if(p[x].belg==p[y].belg) continue; ru[p[y].belg]++; &#125; int ans=0; for(int i=1;i&lt;=cnt;i++) if(ru[i]==0) ans++;//debug printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Vijos1094】关系运算图]]></title>
    <url>%2Fposts%2Fe843.html</url>
    <content type="text"><![CDATA[来源和评测点Vijos1094 题目【题目大意】给出一有向图，图中每条边都被标上了关系运算符‘&lt;’,‘&gt;’,‘=’。现在要给图中每个顶点标上一个大于等于0,小于等于k的某个整数使所有边上的符号得到满足。若存在这样的k，则求最小的k，若任何k都无法满足则输出NO。例如下表中最小的k为2。结点1&gt;结点2结点2&gt;结点3结点2&gt;结点4结点3=结点4如果存在这样的k，输出最小的k值；否则输出‘NO’。【输入格式】共二行，第一行有二个空格隔开的整数n和m。n表示G的结点个数，m表示G的边数，其中1&lt;=n&lt;=1000, 0&lt;=m&lt;=10000。全部结点用1到n标出，图中任何二点之间最多只有一条边，且不存在自环。第二行共有3m个用空格隔开的整数，第3i-2和第3i-1（1&lt;=i&lt;=m）个数表示第i条边的顶点。第3i个数表示第i条边上的符号，其值用集合{-1，0，1}中的数表示：-1表示‘&lt;’, 0 表示‘=’, 1表示‘&gt;’。【输出格式】仅一行，如无解则输出‘NO’；否则输出最小的k的值。【输入样例】4 41 2 -1 2 3 0 2 4 -1 3 4 -1【输出样例】2 刷题记录30min4WA2AC 分析d[i]&lt;d[j]d[i]&lt;=d[j]-1ins(j,i,-1) d[i]=d[j]ins(j,i,0)ins(j,i,0) d[i]&gt;d[j]d[i]&gt;=d[j]+1d[j]&lt;=d[i]-1ins(i,j,-1) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=1100,MAXM=21000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int hou; int v; int r; int d; nod() &#123; hou=v=r=0; d=INF; &#125;&#125;p[MAXN];struct edge&#123; int y,c,g;&#125;e[MAXM];int ln=0;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y; e[ln].c=c; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int n,m;int mx=0,mi=0;int lst[MAXN];bool spfa(int st)&#123; int top=0; lst[++top]=st; p[st].v=1;p[st].r=1;p[st].d=0; while(top&gt;0) &#123; int x=lst[top--]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].d&gt;p[x].d+e[k].c) &#123; p[y].d=p[x].d+e[k].c; if(p[y].v==0) &#123; p[y].v=1; p[y].r++; if(p[y].r&gt;n) return 0; lst[++top]=y; &#125; &#125; &#125; p[x].v=0; &#125; return 1;&#125;bool check()&#123; for(int i=1;i&lt;=n;i++) if(p[i].r==0) if(!spfa(i)) return 0; for(int i=1;i&lt;=n;i++) mi=mymin(mi,p[i].d); return 1;&#125;//*******************主函数*******************int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); if(c&lt;0) ins(y,x,-1); if(c==0) ins(x,y,0),ins(y,x,0); if(c&gt;0) ins(x,y,-1); &#125; if(!check()) printf("NO"); else printf("%d",-mi);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj1716】差分约束4整数区间]]></title>
    <url>%2Fposts%2F75d0.html</url>
    <content type="text"><![CDATA[来源和评测点Poj1716Caioj1403 题目【题目大意】给出n个区间，每个区间内至少有两个数被选中，问最少需要选出多少个数【输入格式】第一行：一个整数n(1&lt;=n&lt;=10000)接下来n行：每行两个数a,b(0&lt;=a&lt;b&lt;=10000)，表示一个区间的开始点和结束点【输出格式】第一行：一个整数，表示最少选出多少个数若出现了负环，只需要输出”-1”（不包含括号）【输入样例】43 62 40 24 7【输出样例】4 刷题记录30min无数TLE caioj真的恶心不用栈并且全部放入而是用队列或者spfa全优化都过不了-1的一个点 分析s[b]-s[a-1]&gt;=22&lt;=s[b]-s[a-1]s[a-1]&lt;=s[b]-2 s[i]-s[i-1]&lt;=1s[i]&lt;=s[i-1]+1 s[i]-s[i-1]&gt;=0s[i-1]&lt;=s[i] ans:s[mx]-s[mi] 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=51000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int hou; bool v; int r; int s;&#125;p[MAXN];struct edge&#123; int y,c,g;&#125;e[MAXN*3];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y; e[ln].c=c; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int lst[MAXN];bool spfa(int st,int n)&#123; int tou=1,wei=2; p[st].s=0;p[st].v=1; lst[tou]=st;//边是从高往低建的 while(tou!=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].s&gt;p[x].s+e[k].c) &#123; p[y].s=p[x].s+e[k].c; if(p[y].v==0) &#123; p[y].v=1; p[y].r++; if(p[y].r&gt;n-1) return 0; lst[wei++]=y;if(wei==MAXN) wei=1; &#125; &#125; &#125; p[x].v=0; tou++;if(tou==MAXN) tou=1; &#125; return 1;&#125;int mi,mx;bool check()&#123; for(int i=mi;i&lt;=mx;i++) if(p[i].r==0) if(!spfa(i,mx-mi+1)) return 0; return 1;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); mx=-INF;mi=INF;ln=0; for(int i=0;i&lt;=MAXN-1;i++) &#123; p[i].hou=0; p[i].r=p[i].v=0; p[i].s=INF; &#125; for(int i=1;i&lt;=n;i++) &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); a++;b++;//debug ins(b,a-1,-2); mi=mymin(mi,a-1);mx=mymax(mx,b); &#125; for(int i=mi+1;i&lt;=mx;i++) &#123; ins(i-1,i,1); ins(i,i-1,0); &#125; if(spfa(mx,mx-mi+1)) printf("%d",p[mx].s-p[mi].s); else printf("-1");&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1402】差分约束3消息可靠吗]]></title>
    <url>%2Fposts%2F3a06.html</url>
    <content type="text"><![CDATA[来源和评测点Caioj1402 题目【题目大意】给出n个点和m条约束信息。信息表述为(P a b c)表示a在b北方距离c单位的位置，或者(V a b)表示a在b的北方。问是否可能存在符合以上m个要求的点【输入格式】第一行：两个整数n和m,(0&lt;n&lt;=1000),(1&lt;=M&lt;=100000)接下来m行：每行输入(P a b c)或者(V a b)，意思如上所示多组数据，当n=0时结束【输出格式】若存在这样的点则输出”Reliable”（不包含括号），不存在输出”Unreliable”（不包含括号）【输入样例】3 4P 1 2 1P 2 3 1V 1 3P 1 3 15 5V 1 2V 2 3V 3 4V 4 5V 3 50【输出样例】UnreliableReliable 刷题记录30min6TLE1WA1AC 分析p1s[a]-s[b]&lt;=cs[a]&lt;=s[b]+cp2s[a]-s[b]&gt;=cc&lt;=s[a]-s[b]s[b]&lt;=s[a]-cvs[a]&gt;s[b]s[a]&gt;=s[b]+1s[b]&lt;=s[a]-1 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=51000,MAXM=310000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int hou; bool v; int r; int s;&#125;p[MAXN];struct edge&#123; int y,c,g;&#125;e[MAXM];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y; e[ln].c=c; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int lst[MAXN];bool spfa(int st,int n)&#123; int tou=1,wei=2; p[st].s=0;p[st].v=1; lst[tou]=st;//边是从高往低建的 while(tou!=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].s&gt;p[x].s+e[k].c) &#123; p[y].s=p[x].s+e[k].c; if(p[y].v==0) &#123; p[y].v=1; p[y].r++; if(p[y].r&gt;n-1) return 0; lst[wei++]=y;if(wei==MAXN) wei=1; &#125; &#125; &#125; p[x].v=0; tou++;if(tou==MAXN) tou=1; &#125; return 1;&#125;int mi,mx;bool check()&#123; for(int i=mi;i&lt;=mx;i++) if(p[i].r==0) if(!spfa(i,mx-mi+1)) return 0; return 1;&#125;//*******************主函数*******************char s[20];int main()&#123; int n,m; while(scanf("%d",&amp;n) and n&gt;0) &#123; scanf("%d",&amp;m); mx=-INF;mi=INF;ln=0; for(int i=0;i&lt;=MAXN-1;i++) &#123; p[i].hou=0; p[i].r=p[i].v=0; p[i].s=INF; &#125; bool bk=1; for(int i=1;i&lt;=m;i++) &#123; int a,b;scanf("%s%d%d",s,&amp;a,&amp;b); if(s[0]=='P') &#123; int c;scanf("%d",&amp;c); if(a==b and c&gt;0) bk=0; ins(b,a,c);ins(a,b,-c); &#125; else &#123; if(a==b) bk=0; ins(a,b,-1); &#125; mi=mymin(mi,mymin(a,b)); mx=mymax(mx,mymax(a,b)); &#125; if(bk and check()) printf("Reliable\n"); else printf("Unreliable\n"); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF#469Div2-C】Zebras]]></title>
    <url>%2Fposts%2F8404.html</url>
    <content type="text"><![CDATA[来源和评测点Codeforces Round #469 (Div.2)CF#469Div2-C 题目【题目大意】Zebra:0和1交替出现，开头结尾都是0。给出字符串，分割成子序列（不一定连续），必须每一个都是Zebra【输入格式】只有一行，01字符串无解输出-1【约束条件】长度不超过200000【输出格式】有spj第一行子序列个数每行开头，当前子序列长度，然后是由哪些位置组成以上按照从小到大排序【输入样例】0010100【输出样例】33 1 3 43 2 5 61 7 刷题记录1h1WA1TLE比完赛后1RE1AC 分析我打了个很丑的暴力，然后是一个个子序列寻找的，超慢然后根本没考虑过可以跑一遍过重点是STL的妙用，确保正确性，同时动态空间 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;using namespace std;//*******************全局常量*******************//*******************全局定义*******************char s[200010];vector&lt;int&gt; f[200010];set&lt;int&gt; s0,s1;int n,m;//*******************实现*******************bool solve()&#123; for(int i=1;i&lt;=n;i++) &#123; if(s[i]=='0') &#123; if(s1.empty()) &#123; f[++m].push_back(i); s0.insert(m); &#125; else &#123; int x=*s1.begin(); f[x].push_back(i); s1.erase(x); s0.insert(x); &#125; &#125; else &#123; if(s0.empty()) return 0; int x=*s0.begin(); f[x].push_back(i); s0.erase(x); s1.insert(x); &#125; &#125; if(!s1.empty()) return 0; return 1;&#125;void output()&#123; printf("%d\n",m); for(int i=1;i&lt;=m;i++) &#123; printf("%d ",f[i].size()); for(int j=0;j&lt;=f[i].size()-1;j++) printf("%d ",f[i][j]); printf("\n"); &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%s",s+1); n=strlen(s+1);m=0; if(solve()) output(); else printf("-1\n");&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj1364】差分约束2国王]]></title>
    <url>%2Fposts%2F34e8.html</url>
    <content type="text"><![CDATA[来源和评测点Poj1364Caioj1401 题目【题目大意】给出不超过n的数和m个关系。然后给出ai,bi，接着输入gt或者lt，最后给出di。它们分别表示从a[ai]开始a[ai]+a[ai+1]+…+a[ai+bi]这些数的和小于(lt)di或大于(gt)di。问是否存在满足m个关系的数列【输入格式】第一行：两个整数n和m(0&lt;n&lt;=100),(0&lt;m&lt;=100)接下来m行：每行输入ai,bi,gt或者lt,di多组数据，当n=0时结束【输出格式】若存在这样的数列则输出”lamentable kingdom”（不包含引号），否则输出”successful conspiracy”（不包含引号）。【输入样例】4 21 2 gt 02 2 lt 21 21 0 gt 01 0 lt 00【输出样例】lamentable kingdomsuccessful conspiracy 刷题记录20min 分析lt:s[a+b]-s[a-1]&lt;ds[a+b]-s[a-1]&lt;=d-1s[a+b]&lt;=s[a-1]+d-1gt:s[a+b]-s[a-1]&gt;ds[a+b]-s[a-1]&gt;=d+1d+1&lt;=s[a+b]-s[a-1]s[a-1]&lt;=s[a+b]-d-1 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=51000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int hou; bool v; int r; int s;&#125;p[MAXN];struct edge&#123; int y,c,g;&#125;e[MAXN*3];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y; e[ln].c=c; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int lst[MAXN];bool spfa(int st,int n)&#123; int tou=1,wei=2; p[st].s=0;p[st].v=1; lst[tou]=st;//边是从高往低建的 while(tou!=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].s&gt;p[x].s+e[k].c) &#123; p[y].s=p[x].s+e[k].c; if(p[y].v==0) &#123; p[y].v=1; p[y].r++; if(p[y].r&gt;n-1) return 0; lst[wei++]=y;if(wei==MAXN) wei=1; &#125; &#125; &#125; p[x].v=0; tou++;if(tou==MAXN) tou=1; &#125; return 1;&#125;int mi,mx;bool check()&#123; for(int i=mi;i&lt;=mx;i++) if(p[i].r==0) if(!spfa(i,mx-mi+1)) return 0; return 1;&#125;//*******************主函数*******************char s[20];int main()&#123; int n,m; while(scanf("%d",&amp;n) and n&gt;0) &#123; scanf("%d",&amp;m); mx=-INF;mi=INF;ln=0; for(int i=0;i&lt;=n;i++) &#123; p[i].hou=0; p[i].r=p[i].v=0; p[i].s=INF; &#125; for(int i=1;i&lt;=m;i++) &#123; int a,b,d;scanf("%d%d%s%d",&amp;a,&amp;b,s,&amp;d); if(s[0]=='l') ins(a-1,a+b,d-1); else ins(a+b,a-1,-d-1); mi=mymin(mi,a-1);mx=mymax(mx,a+b); &#125; if(check()) printf("lamentable kingdom\n"); else printf("successful conspiracy\n"); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1400】差分约束1区间]]></title>
    <url>%2Fposts%2Fa10d.html</url>
    <content type="text"><![CDATA[来源和评测点Caioj1400 题目【题目大意】给出n个区间，每个整数区间ai~bi中至少有ci个点。求整个区间中最少的点数【输入格式】第一行：一个整数n(1&lt;=n&lt;=50000)接下来n行每行三个整数ai,bi,ci（0&lt;=ai&lt;=bi&lt;=50000）,（1&lt;=ci&lt;=bi-ai+1）【输出格式】一个整数，表示整个区间中最少有多少个点【输入样例】53 7 38 10 36 8 11 3 110 11 1【输出样例】6 刷题记录20min 分析令s[i]=1~i的数量约束条件：s[i]-s[i-1]&gt;=0s[i]-s[i-1]&lt;=1s[b]-s[a-1]&gt;=c对应最短路中的松弛操作即d[j]&lt;=d[i]+c[k] ins(i,j,c[k])现在条件变成s[i-1]&lt;=s[i] ins(i,i-1,0)s[i]&lt;=s[i-1]+1 ins(i-1,i,1)s[a-1]&lt;=s[b]-c ins(b,a-1,-c)以前让d[i]最小现在让s[i]最小 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=51000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int hou; bool v; int r; int s; nod() &#123; hou=r=v=0; s=INF; &#125;&#125;p[MAXN];struct edge&#123; int y,c,g;&#125;e[MAXN*3];int ln=0;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y; e[ln].c=c; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int mi=INF,mx=-INF;int lst[MAXN];bool spfa()&#123; int tou=1,wei=2; p[mx].s=0;p[mx].v=1; lst[tou]=mx;//边是从高往低建的 while(tou!=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].s&gt;p[x].s+e[k].c) &#123; p[y].s=p[x].s+e[k].c; if(p[y].v==0) &#123; p[y].v=1; p[y].r++; if(p[y].r&gt;mx-mi) return 0;//n-1=mx-mi+1-1 lst[wei++]=y; if(wei==MAXN) wei=1; &#125; &#125; &#125; tou++;p[x].v=0; if(tou==MAXN) tou=1; &#125; return 1;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int a,b,c;scanf("%d%d%d",&amp;a,&amp;b,&amp;c); ins(b,a-1,-c); mi=mymin(mi,a-1);mx=mymax(mx,b); &#125; for(int i=mi+1;i&lt;=mx;i++) &#123; ins(i-1,i,1); ins(i,i-1,0); &#125; if(spfa()) printf("%d\n",p[mx].s-p[mi].s);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3932】【Luogu3168】任务查询系统]]></title>
    <url>%2Fposts%2F9028.html</url>
    <content type="text"><![CDATA[来源和评测点CQOI2015Bzoj3932Luogu3168 题目【题目大意】电脑有n个任务需要执行，任务i在si到ei时正在工作，优先级为p给m个询问，每个询问给出一个时间点xi和一个数ki。问在xi这个时间点时，所有正在工作的任务中优先级从小到大排列，前ki个的优先级之和是多少【输入格式】输入文件第一行包含两个空格分开的正整数m和n，分别表示任务总数和时间范围。接下来m行，每行包含三个空格分开的正整数Si、Ei和Pi(Si&lt;=Ei)，描述一个任务。接下来n行，每行包含四个空格分开的整数Xi、Ai、Bi和Ci，描述一次查询。查询的参数Ki需要由公式 Ki=1+(Ai*Pre+Bi) mod Ci计算得到。其中Pre表示上一次查询的结果，对于第一次查询，Pre=1。1&lt;=m,n,Si,Ei,Ci&lt;=100000，0&lt;=Ai,Bi&lt;=100000，1&lt;=Pi&lt;=10000000，Xi为1到n的一个排列【输出格式】输出共n行，每行一个整数，表示查询结果。【输入样例】4 31 2 62 3 31 3 23 3 43 1 3 21 1 3 42 2 4 3【输出样例】2811 刷题记录分析把每一秒看作一个操作来可持续化好吧其实就是有着权值线段树的前缀和 然鹅，这题居然不卡暴力……基于【面向数据编程】和【以题目为导向】，暂时就不写正解了，精A飘过 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int qread1(void)&#123; char c=getchar();int d=0; while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') d=d*10+c-'0',c=getchar(); return d;&#125;ll qread2(void)&#123; char c=getchar();ll d=0; while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') d=d*10+c-'0',c=getchar(); return d;&#125;//*******************全局常量*******************const int MAXN=110000;//*******************全局定义*******************struct nod&#123; int a,b; ll c;&#125;p[MAXN];bool operator &lt; (nod x,nod y)&#123; return x.c&lt;y.c;&#125;//*******************实现*******************//*******************主函数*******************int main()&#123; int m,n;scanf("%d%d",&amp;m,&amp;n); for(int i=1;i&lt;=m;i++) p[i].a=qread1(),p[i].b=qread1(),p[i].c=qread2(); sort(p+1,p+1+m); ll pre=1; for(int i=1;i&lt;=n;i++) &#123; int x=qread1();ll a=qread2(),b=qread2(),c=qread2(); ll k=1+(a*pre+b)%c;pre=0; for(int i=1,j=0;i&lt;=m and j&lt;k;i++) if(p[i].a&lt;=x and x&lt;=p[i].b) pre+=p[i].c,j++; printf("%lld\n",pre); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj5072】小A的树]]></title>
    <url>%2Fposts%2F8843.html</url>
    <content type="text"><![CDATA[来源和评测点Lydsy十月月赛Bzoj5072 题目【题目大意】给出一棵n个点的树，每个点有黑白两种颜色。q次询问，每次询问给出x和y，问能否选出一个x个点的联通子图，使得其中黑点数目为y。【输入格式】第一行一个正整数T 表示数据组数。对于每一组数据，第一行有两个用空格隔开的正整数，分别是n 和q，表示树的节点数和询问次数。接下来n-1 行，每行两个用空格隔开的正整数ui和vi，表示ui和vi间有一条边相连。接下来一行有n 个用空格隔开的整数b1,b2,…bn，其中若bi=0，则表示第i个点为白色，否则为黑色。接下来q 行，每行两个用空格隔开的整数和，意义如Problem Statement中描述的x和y。T&lt;=5,n&lt;=5000,q&lt;=10^51&lt;=ui,vi&lt;=n,1&lt;=xi&lt;=n,0&lt;=yi&lt;=n,yi&lt;=xi【输出格式】对于每一组数据，输出q行，每行为“YES”或者“NO”（不含双引号），表示对于给定的和，能否满足小A 的要求。每相邻两组数据的输出之间空一行。【输入样例】19 44 11 51 23 23 66 76 89 60 1 0 1 0 0 1 0 13 27 34 09 5【输出样例】YESYESNONO第一组数据中，可以取子图{6,7,9}。第一组数据中，可以取子图{1,2,3,4,5,6,7,8}。而在第三、四组数据中，不存在符合题意的子图。 刷题记录1h2WA1AC 分析首先，我不会算时间复杂度，别人说是N^2然后有一个结论，我也不会证明，但随便举了个栗子，自以为是比较坏的情况就是：给出一棵树，在某个固定大小的联通块中，如果可以有最少L,最大R个黑点，则之间的也一定可以实现。栗子：R=L+2,m=L+1然后减少2白，增加2黑（删除2白和1黑+添加3黑=减少2白，增加2黑）那么也可以减少1白，增加1黑（删除1白和1黑+添加2黑=减少1白，增加1黑）那我觉得应该结论是对的……然后dp的时候注意一下后效性就好了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=5100;//*******************全局定义*******************struct nod&#123; int hou; bool cl; int tot;&#125;p[MAXN];int l[MAXN][MAXN],r[MAXN][MAXN];struct edge&#123; int y,g;&#125;e[MAXN*2];int ln;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************void dfs(int x,int fa)&#123; p[x].tot=1;l[x][1]=r[x][1]=p[x].cl; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y==fa) continue; dfs(y,x); for(int i=p[x].tot;i&gt;=1;i--)//debug后效性 &#123; for(int j=p[y].tot;j&gt;=1;j--)//debug后效性 &#123; l[x][i+j]=mymin(l[x][i+j],l[x][i]+l[y][j]); r[x][i+j]=mymax(r[x][i+j],r[x][i]+r[y][j]); &#125; &#125; p[x].tot+=p[y].tot; &#125; for(int i=1;i&lt;=p[x].tot;i++) &#123; l[0][i]=mymin(l[0][i],l[x][i]); r[0][i]=mymax(r[0][i],r[x][i]); &#125;&#125;//*******************主函数*******************int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; memset(l,63,sizeof(l)); memset(r,-63,sizeof(r)); int n,q;scanf("%d%d",&amp;n,&amp;q); ln=0;for(int i=1;i&lt;=n;i++) p[i].hou=0; for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i].cl); dfs(1,0); while(q--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); if(l[0][x]&lt;=y and y&lt;=r[0][x]) printf("YES\n"); else printf("NO\n"); &#125; printf("\n"); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC063-E】木と整数]]></title>
    <url>%2Fposts%2Fe20b.html</url>
    <content type="text"><![CDATA[来源和评测点ARC063-E 题目【题目大意】给出一棵N个节点的数，标号从1到N，第i(1≦i≦N−1)条边连接Ai和Bi。Takahashi给K个节点填上数字，其它节点留空。Aoki想把剩下的节点填好，并满足以下条件：任意两个由一条边直接连接的节点，上面的数字差是1。如果有多个解，输出一个即可。Aoki填上的数字可能是负数或者比10^6大。【输入格式】NA1 B1A2 B2:AN−1 BN−1KV1 P1V2 P2:VK PK【约束条件】1≦N≦10^51≦K≦N1≦Ai,Bi≦N (1≦i≦N−1)1≦Vj≦N (1≦j≦K)0≦Pj≦10^5 (1≦j≦K)给出的图一定是树。所有vj不重复。【输出格式】用Yes或No表示是否有解。如果有，输出N行，表示那个节点的某个合法值。【输入样例】51 23 14 33 522 65 7【输出样例】Yes56657 刷题记录1h2RE1AC 分析维护一个有效的范围和奇偶性，树形dp即可然后数组漏了个0是什么鬼…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=110000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int hou; int val; int mi,mx; int jo;//-1,0,1&#125;p[MAXN];struct edge&#123; int y,g;&#125;e[2*MAXN];//*******************实现*******************int ln=0;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;bool bk=1;void dfs(int x,int fa)&#123; if(bk==0) return; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y==fa) continue; dfs(y,x); if(p[x].jo!=-1 and p[x].jo==p[y].jo) &#123; bk=0; return; &#125;//本来相邻或者递推得来 p[x].mi=mymax(p[x].mi,p[y].mi-1); p[x].mx=mymin(p[x].mx,p[y].mx+1); if(p[y].jo!=-1) p[x].jo=p[y].jo^1;//信息的合并 &#125; if(p[x].jo!=-1 and p[x].mi==p[x].mx and p[x].mi%2!=p[x].jo) &#123; bk=0; return; &#125;//检查 if(p[x].mi&gt;p[x].mx) &#123; bk=0; return; &#125;&#125;void dfs2(int x,int fa)&#123; if(p[x].val==-1) &#123; if(fa==0) &#123; if(p[x].mi%2==p[x].jo) p[x].val=p[x].mi; else p[x].val=p[x].mi+1; &#125; else &#123; if(p[x].mi&lt;=p[fa].val-1 and p[fa].val-1&lt;=p[x].mx) p[x].val=p[fa].val-1;//debug else p[x].val=p[fa].val+1; &#125; &#125; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y==fa) continue; dfs2(y,x); &#125;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; p[i].hou=0; p[i].val=-1; p[i].mi=-INF;p[i].mx=INF; p[i].jo=-1; &#125; for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; int k;scanf("%d",&amp;k); for(int i=1;i&lt;=k;i++) &#123; int a,b; scanf("%d%d",&amp;a,&amp;b); p[a].val=p[a].mi=p[a].mx=b; p[a].jo=b%2; &#125; dfs(1,0);//自下而上 if(bk==0) printf("No\n"); else &#123; printf("Yes\n"); dfs2(1,0);//自上而下 for(int i=1;i&lt;=n;i++) printf("%d\n",p[i].val); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3226】校门外的区间]]></title>
    <url>%2Fposts%2Fef13.html</url>
    <content type="text"><![CDATA[来源和评测点Sdoi2008Bzoj3226 从小白的角度解释本题 题目【题目大意】5种运算维护集合S(S初始为空)并最终输出S5种运算如下：U T：S、T并集I T：S、T交集D T：S独有C T：T独有S T：S独有 交 T独有【输入格式】输入共M行。每行的格式为X T，用一个空格隔开，X表示运算的种类，T为一个区间123450≤a≤b≤65535，1≤M≤70000**【输出格式】**共一行，即集合S，每个区间后面带一个空格。若S为空则输出&quot;empty set&quot;。**【输入样例】** U [1,5]D [3,3]S [2,4]C (1,5)I (2,3]12345678910111213141516**【输出样例】**(2,3) &lt;/p&gt;## 刷题记录1h3WA1PE1AC## 分析挺考验逻辑关系能力的首先，区间都是连续的。然后先消除区间表达法的多样性，可以考虑用t表示t/2，这样把区间统一转化，例如(2,5)变成```[2.5,4.5]```也就是```[5,9] 然后各种操作逐个击破U 区间1I 独有0D 区间0C 区间取反，其余0S 区间取反 各种max，min乱搞线段树维护就好了 格式错误的话，是因为我以为打空格的同时换行，当时就想为什么这么奇怪，原来不用换行。 然后WA的话，就是【可能我的方式太古怪了】除了打修改的时候删掉翻转外，【因为我是用父亲c更新儿子c的】，所以如果翻转之前有修改标记而且是统一的（不是-1），那么就不用往下打标记了 然后我的答案统计方式好像很独特啊，网上那些方法我看不懂…… 最后最后就是，无数次忘记，翻转标记要用异或更新。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;//*******************全局常量*******************//*******************全局定义*******************struct seg&#123; int l,r; int lc,rc; int c;//-1,0,1 bool tg1,tg2;&#125;p[310000];//*******************实现*******************int ln=0;int build(int l,int r)&#123; int t=++ln; p[t].l=l;p[t].r=r;p[t].c=0; p[t].tg1=p[t].tg2=0; if(l&lt;r) &#123; int mid=(l+r)/2; p[t].lc=build(l,mid); p[t].rc=build(mid+1,r); &#125; else p[t].lc=p[t].rc=0; return t;&#125;void update(int x)&#123; int lc=p[x].lc,rc=p[x].rc; if(p[lc].c==p[rc].c) p[x].c=p[lc].c; else p[x].c=-1;&#125;void maketg1(int x,int c)&#123; p[x].c=c; p[x].tg1=1; p[x].tg2=0;&#125;void maketg2(int x)&#123; if(p[x].c&gt;=0) p[x].c=1-p[x].c; if( !(p[x].tg1==1 and p[x].c&gt;=0) ) p[x].tg2^=1;//debug&#125;void pushdown(int x)&#123; int lc=p[x].lc,rc=p[x].rc; if(p[x].tg1&gt;0) &#123; p[x].tg1=0; if(lc&gt;0) maketg1(lc,p[x].c); if(rc&gt;0) maketg1(rc,p[x].c); &#125; if(p[x].tg2&gt;0) &#123; p[x].tg2=0; if(lc&gt;0) maketg2(lc); if(rc&gt;0) maketg2(rc); &#125;&#125;void change1(int x,int l,int r,int c)&#123; if(x==0 or l&gt;r) return; if(p[x].l==l and p[x].r==r) &#123; maketg1(x,c); return; &#125; pushdown(x); int mid=(p[x].l+p[x].r)/2; int lc=p[x].lc,rc=p[x].rc; if(r&lt;=mid) change1(lc,l,r,c); else if(l&gt;mid) change1(rc,l,r,c); else change1(lc,l,mid,c),change1(rc,mid+1,r,c); update(x);&#125;void change2(int x,int l,int r)&#123; if(x==0 or l&gt;r) return; pushdown(x);//debug if(p[x].l==l and p[x].r==r) &#123; maketg2(x); return; &#125; int mid=(p[x].l+p[x].r)/2; int lc=p[x].lc,rc=p[x].rc; if(r&lt;=mid) change2(lc,l,r); else if(l&gt;mid) change2(rc,l,r); else change2(lc,l,mid),change2(rc,mid+1,r); update(x);&#125;bool bk=0;void output(int a,int b)&#123; bk=1; if(a%2==0) printf("[%d,",a/2); else printf("(%d,",a/2); if(b%2==0) printf("%d] ",b/2); else printf("%d) ",b/2+1);&#125;int ll=-2,rr=-2;void ask(int x)&#123; if(x==0) return; if(p[x].c==1) &#123; int a=p[x].l,b=p[x].r; if(a&gt;rr+1) &#123; if(ll&gt;=0) output(ll,rr); ll=a; &#125; rr=b; &#125; if(p[x].c==-1) &#123; pushdown(x); ask(p[x].lc); ask(p[x].rc); &#125;&#125;//*******************主函数*******************int main()&#123; build(0,140000); //build(0,10); char s[5],c1,c2;int a,b; while(scanf("%s %c%d,%d%c",s,&amp;c1,&amp;a,&amp;b,&amp;c2)!=EOF and s[0]!='e') &#123; a*=2;if(c1=='(') a++; b*=2;if(c2==')') b--; if(s[0]=='U') &#123; change1(1,a,b,1); &#125; if(s[0]=='I') &#123; change1(1,0,a-1,0); change1(1,b+1,140000,0); //change1(1,b+1,10,0); &#125; if(s[0]=='D') &#123; change1(1,a,b,0); &#125; if(s[0]=='C') &#123; change1(1,0,a-1,0); change2(1,a,b); change1(1,b+1,140000,0); //change1(1,b+1,10,0); &#125; if(s[0]=='S') &#123; change2(1,a,b); &#125; &#125; ask(1);if(ll&gt;=0) output(ll,rr); if(bk==0) printf("empty set");&#125;/*U 区间1I 其余0D 区间0C 区间取反，其余0S 区间取反*/]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2733】【Luogu3224】永无乡]]></title>
    <url>%2Fposts%2F6053.html</url>
    <content type="text"><![CDATA[来源和评测点HNOI2012Bzoj2733Luogu3224 题目【题目大意】永无乡包含n座岛，编号从1到n，每座岛都有自己的独一无二的重要度，按照重要度可以将这n座岛排名，名次用1到n来表示。某些岛之间由巨大的桥连接，通过桥可以从一个岛到达另一个岛。如果从岛a出发经过若干座（含0座）桥可以到达岛b，则称岛a和岛b是连通的。现在有两种操作：B x y 表示在岛x与岛y之间修建一座新桥。Q x k 表示询问当前与岛x连通的所有岛中第k重要的是哪座岛，即所有与岛x连通的岛中重要度排名第k小的岛是哪座，请你输出那个岛的编号。【输入格式】输入文件第一行是用空格隔开的两个正整数 n 和 m，分别 表示岛的个数以及一开始存在的桥数。接下来的一行是用空格隔开的 n 个数，依次描述从岛 1 到岛 n 的重要度排名。随后的 m 行每行是用空格隔开的两个正整数 ai 和 bi，表示一开始就存 在一座连接岛 ai 和岛 bi 的桥。后面剩下的部分描述操作，该部分的第一行是一个正整数 q，表示一共有 q 个操作，接下来的 q 行依次描述每个操作，操作的格式如上所述，以大写字母 Q 或B 开始，后面跟两个不超过 n 的正整数，字母与数字以及两个数字之间用空格隔开。对于 20%的数据 n≤1000,q≤1000对于 100%的数据 n≤100000,m≤n，q≤300000【输出格式】对于每个 Q x k 操作都要依次输出一行，其中包含一个整数，表示所询问岛屿的编号。如果该岛屿不存在，则输出-1。【输入样例】5 14 3 2 5 11 27Q 3 2Q 2 1B 2 3B 1 5Q 2 1Q 2 4Q 2 3【输出样例】-12512 刷题记录1h1AC 分析并查集维护连通性权值线段树维护数量来找大小注意类似主席树的合并跑得还是很快的，至于别的解法，不管了就算被卡，在考场上也是很优秀的算法，因为代码复杂度很低 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;//*******************全局常量*******************const int MAXN=110000;//*******************全局定义*******************struct nod&#123; int lc,rc; int c;&#125;p[21*MAXN];int rt[MAXN];//*******************线段树*******************int ln=0;void change(int &amp;x,int l,int r,int pos)&#123; if(x==0) &#123; x=++ln; p[x].c=0; p[x].lc=p[x].rc=0; &#125; p[x].c++; if(l==r) return; int mid=(l+r)/2; if(pos&lt;=mid) change(p[x].lc,l,mid,pos); else change(p[x].rc,mid+1,r,pos);&#125;void merg(int x,int &amp;y)&#123; if(x==0) return; if(y==0) &#123;y=x;return;&#125; p[y].c+=p[x].c; merg(p[x].lc,p[y].lc); merg(p[x].rc,p[y].rc);&#125;int find(int x,int l,int r,int k)&#123; if(k==0 or k&gt;p[x].c) return 0; if(l==r) return l; int mid=(l+r)/2,lc=p[x].lc; if(k&lt;=p[lc].c) return find(p[x].lc,l,mid,k); return find(p[x].rc,mid+1,r,k-p[lc].c);&#125;//*******************并查集*******************int fa[MAXN];int findfa(int x)&#123; if(fa[x]==x) return x; return fa[x]=findfa(fa[x]);&#125;void join(int x,int y)&#123; int fx=findfa(x),fy=findfa(y); if(fx!=fy) &#123; fa[fx]=fy; merg(rt[fx],rt[fy]); &#125;&#125;//*******************主函数*******************int id[MAXN],id2[MAXN];int main()&#123; memset(rt,0,sizeof(rt)); int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;id[i]); fa[i]=i;id2[id[i]]=i; change(rt[i],1,n,id[i]); &#125; id2[0]=-1; while(m--) &#123; int a,b; scanf("%d%d",&amp;a,&amp;b); join(a,b); &#125; int q;scanf("%d",&amp;q); while(q--) &#123; char s[20];int a,b; scanf("%s%d%d",s,&amp;a,&amp;b); if(s[0]=='B') join(a,b); else printf("%d\n",id2[ find(rt[ findfa(a) ],1,n,b) ]); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1500】【Luogu2042】维修数列]]></title>
    <url>%2Fposts%2Fd303.html</url>
    <content type="text"><![CDATA[来源和评测点NOI2005Bzoj1500Luogu2042Caioj1136 题目【题目大意】请写一个程序，要求维护一个数列，支持以下 6 种操作：请注意，格式栏 中的下划线‘_’表示实际输入文件中的空格【输入格式】输入的第1 行包含两个数N 和M(M ≤20000)，N 表示初始时数列中数的个数，M表示要进行的操作数目。第2行包含N个数字，描述初始时的数列。以下M行，每行一条命令，格式参见问题描述中的表格。任何时刻数列中最多含有500000个数，数列中任何一个数字均在[-1000,1000]内。插入的数字总数不超过4000000个，输入文件大小不超过20MBytes。【输出格式】对于输入数据中的GET-SUM和MAX-SUM操作，向输出文件依次打印结果，每个答案（数字）占一行。【输入样例】9 82 -6 3 5 1 -5 -3 6 3GET-SUM 5 4MAX-SUMINSERT 8 3 -5 7 2DELETE 12 1MAKE-SAME 3 3 2REVERSE 3 6GET-SUM 5 4MAX-SUM【输出样例】-110110 刷题记录9h12WA1AC 分析https://www.luogu.org/blog/IAmHellWord/solution-p2042 总结而言，这道题比序列操作相比多了添加、翻转和删除，于是也就从线段树变成了伸展树如果不会翻转的话可以看看文艺平衡树 这次依然是刚开始没有头绪，去膜了上面那个题解，但其实也不过如此，优化一下空间复杂度就好了。 或许是综合性强吧，然后年份也比较早，也是一道比较骚的数据结构题具体做法我就不造轮子了，上面那个真的不错，我重写也不过如此 代码1无语了答案正确但灰常慢的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=510000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int son[2],f; int d;//debug int lmx,rmx;//用于更新 int mx; int sum; int c; int tg1,tg1n; int tg2; nod() &#123; son[0]=son[1]=f=0; lmx=rmx=mx=0; sum=d=0;c=0; tg1=tg2=0; &#125;&#125;p[MAXN];void clear(int x)&#123; p[x].son[0]=p[x].son[1]=p[x].f=0; p[x].lmx=p[x].rmx=p[x].mx=0; p[x].sum=p[x].d=0; p[x].c=0; p[x].tg1=p[x].tg2=0;&#125;//*******************Splay*******************void pushdown(int x)&#123; if(x==0) return; int lc=p[x].son[0],rc=p[x].son[1]; if(p[x].tg1) &#123; p[x].tg1=0;p[x].tg2=0; p[x].d=p[x].tg1n; p[x].sum=p[x].c*p[x].tg1n; if(p[x].tg1n&lt;0) &#123; p[x].mx=p[x].tg1n; p[x].lmx=p[x].rmx=0;//debug &#125; else p[x].lmx=p[x].rmx=p[x].mx=p[x].sum; p[lc].tg1=p[rc].tg1=1; p[lc].tg1n=p[rc].tg1n=p[x].tg1n; p[lc].tg2=p[rc].tg2=0; &#125; if(p[x].tg2) &#123; p[x].tg2=0; swap(p[x].lmx,p[x].rmx); swap(p[x].son[0],p[x].son[1]); pushdown(lc);pushdown(rc); p[lc].tg2^=1;p[rc].tg2^=1;//debug &#125;&#125;void update(int x)//关键debug&#123; if(x==0) return; if(p[0].mx!=0 or p[0].sum!=0) printf("error!"); int lc=p[x].son[0],rc=p[x].son[1]; pushdown(lc);pushdown(rc); p[x].c=p[lc].c+1+p[rc].c; p[x].sum=p[lc].sum+p[x].d+p[rc].sum; p[x].lmx=mymax(p[lc].lmx,p[lc].sum+p[x].d); if(rc&gt;0) p[x].lmx=mymax(p[x].lmx,p[lc].sum+p[x].d+p[rc].lmx); p[x].rmx=mymax(p[rc].rmx,p[x].d+p[rc].sum); if(lc&gt;0) p[x].rmx=mymax(p[x].rmx,p[lc].rmx+p[x].d+p[rc].sum); p[x].mx=p[x].d; if(lc&gt;0) p[x].mx=mymax( mymax(p[x].mx,p[lc].mx),p[lc].rmx+p[x].d ); if(rc&gt;0) p[x].mx=mymax( mymax(p[x].mx,p[rc].mx),p[x].d+p[rc].lmx ); if(lc&gt;0 and rc&gt;0) p[x].mx=mymax( p[x].mx,p[lc].rmx+p[x].d+p[rc].lmx );&#125;void rotate(int x,int w)&#123; int f=p[x].f,ff=p[f].f; if(p[ff].son[0]==f) p[ff].son[0]=x; else p[ff].son[1]=x; p[x].f=ff; int xson=p[x].son[w]; p[f].son[1-w]=xson; if(xson&gt;0) p[xson].f=f; p[x].son[w]=f; p[f].f=x; update(f); update(x);&#125;int root;int lst[MAXN];void splay(int x,int rt)&#123; int t=0,i=x; while(p[i].f!=rt) lst[++t]=i,i=p[i].f; lst[++t]=rt; while(t&gt;0) pushdown(lst[t--]); while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(rt==ff) &#123; if(p[f].son[0]==x) rotate(x,1); else rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==0) root=x;&#125;int findbyrk(int rk)&#123; int x=root; while(1) &#123; pushdown(x);//!!! int lc=p[x].son[0]; if(rk&lt;=p[lc].c) x=lc; else if(rk&gt;p[lc].c+1) rk-=p[lc].c+1,x=p[x].son[1];//debug else break; &#125; splay(x,0); return x;&#125;//*******************动态分配*******************queue&lt;int&gt; q;int cnt;int getid()&#123; int t; if(!q.empty()) t=q.front(),q.pop(); else t=++cnt; return t;&#125;void del(int x)&#123; if(x==0) return; del(p[x].son[0]); del(p[x].son[1]); q.push(x);clear(x);&#125;//*******************建树*******************int nm[MAXN];int build(int l,int r,int f)//借鉴线段树&#123; if(l&gt;r) return 0; int t=getid(); p[t].f=f;p[t].tg1=p[t].tg2=0; if(l==r) &#123; p[t].son[0]=p[t].son[1]=0;p[t].c=1; p[t].d=p[t].lmx=p[t].rmx=p[t].mx=p[t].sum=nm[l];//debug &#125; else &#123; int mid=(l+r)/2; p[t].d=nm[mid];//debug p[t].son[0]=build(l,mid-1,t); p[t].son[1]=build(mid+1,r,t); update(t); &#125; return t;&#125;//*******************主函数*******************char s[20];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=2;i&lt;=n+1;i++) scanf("%d",&amp;nm[i]); nm[1]=0;nm[n+2]=0;//!!! p[0].lmx=p[0].rmx=-INF;//debug cnt=0;root=build(1,n+2,0); while(m--) &#123; scanf("%s",s); if(s[0]=='I')//INSERT &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1后 for(int i=1;i&lt;=ct;i++) scanf("%d",&amp;nm[i]); int l=findbyrk(k+1),r=findbyrk(k+2); splay(l,r);//debug p[l].son[1]=build(1,ct,l); update(l);update(r); &#125; if(s[0]=='D')//DELETE &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1~k+ct int l=findbyrk(k),r=findbyrk(k+ct+1); splay(l,r);//debug del(p[l].son[1]);//debug p[l].son[1]=0; update(l);update(r); &#125; if(s[2]=='K')//MAKE-SAME &#123; int k,ct,num;scanf("%d%d%d",&amp;k,&amp;ct,&amp;num);//k+1~k+ct int l=findbyrk(k),r=findbyrk(k+ct+1); splay(l,r);//debug p[p[l].son[1]].tg1=1;p[p[l].son[1]].tg1n=num; splay(p[l].son[1],0); &#125; if(s[0]=='R')//REVERSE &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1~k+ct int l=findbyrk(k),r=findbyrk(k+ct+1); splay(l,r);//debug if(p[p[l].son[1]].tg1==0) &#123; p[p[l].son[1]].tg2=1; splay(p[l].son[1],0); &#125; &#125; if(s[0]=='G')//GET-SUM &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1~k+ct if(ct==0) &#123;printf("0\n");continue;&#125; int l=findbyrk(k),r=findbyrk(k+ct+1);//debug splay(l,r);//debug pushdown(p[l].son[1]); printf("%d\n",p[p[l].son[1]].sum); &#125; if(s[2]=='X')//MAX-SUM &#123; int l=findbyrk(1),r=findbyrk(p[root].c);//debug splay(l,r);//debug pushdown(p[l].son[1]); printf("%d\n",p[ p[l].son[1] ].mx); &#125; &#125;&#125; 代码2AC代码，改了标记原本是自己也没有更新现在是自己已经更新其实也不是太快啦洛谷3896ms大视野7128 ms123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=510000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int son[2],f; int d;//debug int lmx,rmx;//用于更新 int mx; int sum; int c; bool tg1,tg2; nod() &#123; son[0]=son[1]=f=0; lmx=rmx=mx=0; sum=d=0;c=0; tg1=tg2=0; &#125;&#125;p[MAXN];void clear(int x)&#123; p[x].son[0]=p[x].son[1]=p[x].f=0; p[x].lmx=p[x].rmx=p[x].mx=0; p[x].sum=p[x].d=0; p[x].c=0; p[x].tg1=p[x].tg2=0;&#125;//*******************Splay*******************void maketg1(int x,int d)&#123; p[x].d=d;p[x].sum=p[x].c*d; if(p[x].d&lt;0) p[x].lmx=p[x].rmx=p[x].mx=d; else p[x].lmx=p[x].rmx=p[x].mx=p[x].sum; p[x].tg1=1;&#125;void maketg2(int x)//debug&#123; swap(p[x].lmx,p[x].rmx); swap(p[x].son[0],p[x].son[1]); p[x].tg2^=1;&#125;void pushdown(int x)&#123; if(x==0) return; int lc=p[x].son[0],rc=p[x].son[1]; if(p[x].tg1) &#123; p[x].tg1=0; if(lc&gt;0) maketg1(lc,p[x].d); if(rc&gt;0) maketg1(rc,p[x].d); &#125; if(p[x].tg2) &#123; p[x].tg2=0; if(lc&gt;0) maketg2(lc); if(rc&gt;0) maketg2(rc); &#125;&#125;void update(int x)//关键debug&#123; if(x==0) return; if(p[0].mx!=0 or p[0].sum!=0) printf("error!"); int lc=p[x].son[0],rc=p[x].son[1]; p[x].c=p[lc].c+1+p[rc].c; p[x].sum=p[lc].sum+p[x].d+p[rc].sum; p[x].lmx=mymax(p[lc].lmx,p[lc].sum+p[x].d); if(rc&gt;0) p[x].lmx=mymax(p[x].lmx,p[lc].sum+p[x].d+p[rc].lmx); p[x].rmx=mymax(p[rc].rmx,p[x].d+p[rc].sum); if(lc&gt;0) p[x].rmx=mymax(p[x].rmx,p[lc].rmx+p[x].d+p[rc].sum); p[x].mx=p[x].d; if(lc&gt;0) p[x].mx=mymax( mymax(p[x].mx,p[lc].mx),p[lc].rmx+p[x].d ); if(rc&gt;0) p[x].mx=mymax( mymax(p[x].mx,p[rc].mx),p[x].d+p[rc].lmx ); if(lc&gt;0 and rc&gt;0) p[x].mx=mymax( p[x].mx,p[lc].rmx+p[x].d+p[rc].lmx );&#125;void rotate(int x,int w)&#123; int f=p[x].f,ff=p[f].f; if(p[ff].son[0]==f) p[ff].son[0]=x; else p[ff].son[1]=x; p[x].f=ff; int xson=p[x].son[w]; p[f].son[1-w]=xson; if(xson&gt;0) p[xson].f=f; p[x].son[w]=f; p[f].f=x; update(f); update(x);&#125;int root;int lst[MAXN];void splay(int x,int rt)&#123; int t=0,i=x; while(p[i].f!=rt) lst[++t]=i,i=p[i].f; lst[++t]=rt; while(t&gt;0) pushdown(lst[t--]); while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(rt==ff) &#123; if(p[f].son[0]==x) rotate(x,1); else rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==0) root=x;&#125;int findbyrk(int rk)&#123; int x=root; while(1) &#123; pushdown(x);//!!! int lc=p[x].son[0]; if(rk&lt;=p[lc].c) x=lc; else if(rk&gt;p[lc].c+1) rk-=p[lc].c+1,x=p[x].son[1];//debug else break; &#125; splay(x,0); return x;&#125;//*******************动态分配*******************queue&lt;int&gt; q;int cnt;int getid()&#123; int t; if(!q.empty()) t=q.front(),q.pop(); else t=++cnt; return t;&#125;void del(int x)&#123; if(x==0) return; del(p[x].son[0]); del(p[x].son[1]); q.push(x);clear(x);&#125;//*******************建树*******************int nm[MAXN];int build(int l,int r,int f)//借鉴线段树&#123; if(l&gt;r) return 0; int t=getid(); p[t].f=f;p[t].tg1=p[t].tg2=0; if(l==r) &#123; p[t].son[0]=p[t].son[1]=0;p[t].c=1; p[t].d=p[t].lmx=p[t].rmx=p[t].mx=p[t].sum=nm[l];//debug &#125; else &#123; int mid=(l+r)/2; p[t].d=nm[mid];//debug p[t].son[0]=build(l,mid-1,t); p[t].son[1]=build(mid+1,r,t); update(t); &#125; return t;&#125;//*******************主函数*******************char s[20];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=2;i&lt;=n+1;i++) scanf("%d",&amp;nm[i]); nm[1]=0;nm[n+2]=0;//!!! p[0].lmx=p[0].rmx=-INF;//debug cnt=0;root=build(1,n+2,0); while(m--) &#123; scanf("%s",s); if(s[0]=='I')//INSERT &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1后 for(int i=1;i&lt;=ct;i++) scanf("%d",&amp;nm[i]); int l=findbyrk(k+1),r=findbyrk(k+2); splay(l,r);//debug p[l].son[1]=build(1,ct,l); update(l);update(r); &#125; if(s[0]=='D')//DELETE &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1~k+ct int l=findbyrk(k),r=findbyrk(k+ct+1); splay(l,r);//debug del(p[l].son[1]);//debug p[l].son[1]=0; update(l);update(r); &#125; if(s[2]=='K')//MAKE-SAME &#123; int k,ct,num;scanf("%d%d%d",&amp;k,&amp;ct,&amp;num);//k+1~k+ct int l=findbyrk(k),r=findbyrk(k+ct+1); splay(l,r);//debug maketg1(p[l].son[1],num); splay(p[l].son[1],0); &#125; if(s[0]=='R')//REVERSE &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1~k+ct int l=findbyrk(k),r=findbyrk(k+ct+1); splay(l,r);//debug maketg2(p[l].son[1]); splay(p[l].son[1],0); &#125; if(s[0]=='G')//GET-SUM &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1~k+ct if(ct==0) &#123;printf("0\n");continue;&#125; int l=findbyrk(k),r=findbyrk(k+ct+1); splay(l,r);//debug printf("%d\n",p[p[l].son[1]].sum); &#125; if(s[2]=='X')//MAX-SUM &#123; int l=findbyrk(1),r=findbyrk(p[root].c);//debug splay(l,r);//debug printf("%d\n",p[ p[l].son[1] ].mx); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1858】【Luogu2572】序列操作]]></title>
    <url>%2Fposts%2Fcf34.html</url>
    <content type="text"><![CDATA[来源和评测点SCOI2010Bzoj1858Luogu2572 题目【题目大意】lxhgww最近收到了一个01序列，序列里面包含了n个数，这些数要么是0，要么是1，现在对于这个序列有五种变换操作和询问操作：0 a b 把[a,b]区间内的所有数全变成01 a b 把[a,b]区间内的所有数全变成12 a b 把[a,b]区间内的所有数全部取反，也就是说把所有的0变成1，把所有的1变成03 a b 询问[a,b]区间内总共有多少个14 a b 询问[a,b]区间内最多有多少个连续的1对于每一种询问操作，lxhgww都需要给出回答，聪明的程序员们，你们能帮助他吗？【输入格式】输入数据第一行包括2个数，n和m，分别表示序列的长度和操作数目第二行包括n个数，表示序列的初始状态接下来m行，每行3个数，op, a, b，（0&lt;=op&lt;=4，0&lt;=a&lt;=b&lt;n）表示对于区间[a, b]执行标号为op的操作【输出格式】对于每一个询问操作，输出一行，包括1个数，表示其对应的答案【输入样例】10 100 0 0 1 1 0 1 0 1 11 0 23 0 52 2 24 0 40 3 62 3 74 2 81 0 50 5 63 3 9【输出样例】5265 分析本题最重要的只有一点，相通了这个，再注意一下细节就好了。这也是难点：如何解决最长连续的问题呢？考虑用线段树维护区间信息：lmx,rmx,mx,sumlmx和rmx用于在区间合并的时候更新mx，保证正确性。然后就是一些细节问题了，例如标记的传递与先后处理顺序。 最后提醒一句，因为本人老是忘记：反转标记是用xor来修改的还有就是我居然忘记要双倍空间了…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=210000;//debug//*******************全局定义*******************struct info&#123; int sum;//个数 int lmx,rmx;//边缘最长连续，合并用 int mx;//最长连续 int all;//长度 info() &#123; lmx=mx=rmx=0; sum=all=0; &#125;&#125;;struct seg&#123; int l,r,mid; int lc,rc; bool tg1,tg1n,tg2; info f[2];&#125;p[MAXN];//*******************info*******************info merg(info a,info b)&#123; info c; c.sum=a.sum+b.sum;c.all=a.all+b.all; c.lmx=a.lmx;if(c.lmx==a.all) c.lmx+=b.lmx; c.rmx=b.rmx;if(c.rmx==b.all) c.rmx+=a.rmx; c.mx=mymax(a.mx,b.mx);c.mx=mymax(c.mx,a.rmx+b.lmx); return c;&#125;void setall(info &amp;a)&#123; a.mx=a.lmx=a.rmx=a.sum=a.all;&#125;void setno(info &amp;a)&#123; a.mx=a.lmx=a.rmx=a.sum=0;&#125;//*******************接口*******************void update(int x)&#123; int lc=p[x].lc,rc=p[x].rc; if(p[x].tg1) &#123; p[x].tg1=0; bool b=p[x].tg1n; setall(p[x].f[b]); setno(p[x].f[!b]); p[lc].tg1=p[rc].tg1=1; p[lc].tg1n=p[rc].tg1n=b; p[lc].tg2=p[rc].tg2=0; &#125; if(p[x].tg2) &#123; p[x].tg2=0; swap(p[x].f[0],p[x].f[1]); update(lc);update(rc);//确保不冲突 p[lc].tg2^=1;p[rc].tg2^=1;//debug,总是忘记 &#125;&#125;int cnt;bool cl[MAXN];int build(int l,int r)&#123; int t=++cnt; p[t].l=l;p[t].r=r; if(l&lt;r) &#123; p[t].mid=(l+r)/2; p[t].lc=build(l,p[t].mid); p[t].rc=build(p[t].mid+1,r); p[t].f[0]=merg(p[p[t].lc].f[0],p[p[t].rc].f[0]); p[t].f[1]=merg(p[p[t].lc].f[1],p[p[t].rc].f[1]); &#125; else &#123; bool b=cl[l]; p[t].f[0].all=p[t].f[1].all=1; setall(p[t].f[b]);setno(p[t].f[!b]); &#125; p[t].tg1=p[t].tg2=0; return t;&#125;void change(int x,int l,int r,bool b)&#123; if(p[x].l==l and p[x].r==r) &#123; p[x].tg1=1; p[x].tg1n=b; p[x].tg2=0; return; &#125; update(x); int lc=p[x].lc,rc=p[x].rc,mid=(p[x].l+p[x].r)/2; if(r&lt;=mid) change(lc,l,r,b); else if(l&gt;mid) change(rc,l,r,b); else change(lc,l,mid,b),change(rc,mid+1,r,b); update(lc);update(rc);//debug p[x].f[0]=merg(p[lc].f[0],p[rc].f[0]); p[x].f[1]=merg(p[lc].f[1],p[rc].f[1]);&#125;void opposite(int x,int l,int r)&#123; update(x); if(p[x].l==l and p[x].r==r) &#123; p[x].tg2=1; return; &#125; int lc=p[x].lc,rc=p[x].rc,mid=(p[x].l+p[x].r)/2; if(r&lt;=mid) opposite(lc,l,r); else if(l&gt;mid) opposite(rc,l,r); else opposite(lc,l,mid),opposite(rc,mid+1,r); update(lc);update(rc);//debug p[x].f[0]=merg(p[lc].f[0],p[rc].f[0]); p[x].f[1]=merg(p[lc].f[1],p[rc].f[1]);&#125;info ask(int x,int l,int r)&#123; update(x); if(p[x].l==l and p[x].r==r) return p[x].f[1]; int lc=p[x].lc,rc=p[x].rc,mid=(p[x].l+p[x].r)/2; if(r&lt;=mid) return ask(lc,l,r); if(l&gt;mid) return ask(rc,l,r); return merg( ask(lc,l,mid),ask(rc,mid+1,r) );&#125;//*******************主函数*******************int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;cl[i]); cnt=0;build(1,n); while(m--) &#123; int op,a,b;scanf("%d%d%d",&amp;op,&amp;a,&amp;b); a++;b++; if(op==0) change(1,a,b,0); if(op==1) change(1,a,b,1); if(op==2) opposite(1,a,b); if(op==3) &#123; info t=ask(1,a,b); printf("%d\n",t.sum); &#125; if(op==4) &#123; info t=ask(1,a,b); printf("%d\n",t.mx); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3343】教主的魔法]]></title>
    <url>%2Fposts%2Fc57c.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj3343 题目【题目大意】教主最近学会了一种神奇的魔法，能够使人长高。于是他准备演示给XMYZ信息组每个英雄看。于是N个英雄们又一次聚集在了一起，这次他们排成了一列，被编号为1、2、……、N。每个人的身高一开始都是不超过1000的正整数。教主的魔法每次可以把闭区间[L,R]（1≤L≤R≤N）内的英雄的身高全部加上一个整数W。（虽然L=R时并不符合区间的书写规范，但我们可以认为是单独增加第L（R）个英雄的身高）CYZ、光哥和ZJQ等人不信教主的邪，于是他们有时候会问WD闭区间 [L, R] 内有多少英雄身高大于等于C，以验证教主的魔法是否真的有效。WD巨懒，于是他把这个回答的任务交给了你。【输入格式】第1行为两个整数N、Q。Q为问题数与教主的施法数总和。第2行有N个正整数，第i个数代表第i个英雄的身高。第3到第Q+2行每行有一个操作：（1）若第一个字母为“M”，则紧接着有三个数字L、R、W。表示对闭区间 [L, R] 内所有英雄的身高加上W。（2）若第一个字母为“A”，则紧接着有三个数字L、R、C。询问闭区间 [L, R] 内有多少英雄的身高大于等于C。对30%的数据，N≤1000，Q≤1000。对100%的数据，N≤1000000，Q≤3000，1≤W≤1000，1≤C≤1,000,000,000。【输出格式】对每个“A”询问输出一行，仅含一个整数，表示闭区间 [L, R] 内身高大于等于C的英雄数。【输入样例】5 31 2 3 4 5A 1 5 4M 3 5 1A 1 5 4【输出样例】23【样例解释】原先5个英雄身高为1、2、3、4、5，此时[1, 5]间有2个英雄的身高大于等于4。教主施法后变为1、2、4、5、6，此时[1, 5]间有3个英雄的身高大于等于4。 分析普普通通的分块，该说的代码里面有。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;//*******************定义*******************int a[1100000],b[1100000],ad[1100000],bk[1100000];//a是原本，b是有序int bl[11000],br[11000];int n,m;//*******************实现*******************void reset(int x)&#123; int ll=bl[x],rr=br[x]; for(int i=ll;i&lt;=rr;i++) b[i]=a[i]; sort(b+ll,b+rr+1);&#125;int find(int x,int c)&#123; int l=bl[x],r=br[x],ans=bl[x]-1;//ans表示最后一个比w小的 while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(b[mid]&lt;c) l=mid+1,ans=mid; else r=mid-1; &#125; return br[x]-ans;&#125;void change(int x,int y,int c)&#123; int ex=bk[x],ey=bk[y]; if(ex==ey) &#123; for(int i=x;i&lt;=y;i++) a[i]+=c; reset(ex); return; &#125; for(int i=x;i&lt;=br[ex];i++) a[i]+=c;reset(ex); for(int i=bl[ey];i&lt;=y;i++) a[i]+=c;reset(ey); //修改完后立即重构，从而降低时间复杂度 //每次两个，即使很多次也胜过一次查询时更新 for(int i=ex+1;i&lt;=ey-1;i++) ad[i]+=c;&#125;int ask(int x,int y,int c)&#123; int ex=bk[x],ey=bk[y],ans=0; if(ex==ey) &#123; for(int i=x;i&lt;=y;i++) if(a[i]+ad[ex]&gt;=c) ans++; return ans; &#125; for(int i=x;i&lt;=br[ex];i++) if(a[i]+ad[ex]&gt;=c) ans++; for(int i=bl[ey];i&lt;=y;i++) if(a[i]+ad[ey]&gt;=c) ans++; for(int i=ex+1;i&lt;=ey-1;i++) ans+=find(i,c-ad[i]); return ans;&#125;//*******************主函数*******************char s[10];int main(int argc, char *argv[])&#123; int q;scanf("%d%d",&amp;n,&amp;q); m=sqrt(n)*2.0; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); bk[i]=(i-1)/m+1; &#125; int cnt=n/m; for(int i=1;i&lt;=cnt;i++) &#123; bl[i]=(i-1)*m+1; br[i]=i*m; reset(i); &#125; if(n%m&gt;0) &#123; cnt++; bl[cnt]=br[cnt-1]+1; br[cnt]=n; reset(cnt); &#125; while(q--) &#123; int a,b,c;scanf("%s%d%d%d",s,&amp;a,&amp;b,&amp;c); if(s[0]=='M') change(a,b,c); else printf("%d\n",ask(a,b,c)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1018】【Luogu4246】堵塞的交通]]></title>
    <url>%2Fposts%2F184e.html</url>
    <content type="text"><![CDATA[来源和评测点SHOI2008Bzoj1018Luogu4246 题目【题目大意】给定一张2*n的网格图，多次改变某条边是否可用，多次查询某两个点是否联通【输入格式】第一行只有一个整数C，表示网格的列数。接下来若干行，每行为一条交通信息，以单独的一行“Exit”作为结束。我们假设在一开始所有的道路都是堵塞的。我们保证 C小于等于100000，信息条数小于等于100000。【输出格式】对于每个查询，输出一个“Y”或“N”。【输入样例】2Open 1 1 1 2Open 1 2 2 2Ask 1 1 2 2Ask 2 1 2 2Exit【输出样例】YN 分析其实刚看到这题就觉得LCT然鹅，这并不是树，只好放弃看到行数是2，但一直想不到好办法于是背着良心膜了波题解 居然是线段树！首先假设询问的时候，只和两个点之间的边有关搞一个结构体，里面存有以下信息：h[2][2]表示四个端点的连通性（横、斜着）lb,rb表示上下节点的连通性（竖着）合并的话自己想，常数级别然后考虑两边，如果[1,L]两个右端点联通，等效于[L,R]两个左端点联通如果[R+1,c]两个左端点联通，等效于[L,R]两个右端点联通 目前见过最有意思的线段树题目。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************//*******************全局定义*******************struct nod//连通性信息&#123; bool lb,rb;//竖 bool h[2][2];//横、斜 nod() &#123; lb=rb=0; memset(h,0,sizeof(h)); &#125;&#125;;struct seg//线段树节点&#123; int l,r; int lc,rc; nod f; bool tp,bm;//mid和mid+1之间的信息&#125;p[410000];//*******************接口*******************nod merg(nod a,int tp,int bm,nod b)&#123; nod c; c.lb=a.lb or (a.h[0][0] and tp and b.lb and bm and a.h[1][1]); c.rb=b.rb or (b.h[0][0] and tp and a.rb and bm and b.h[1][1]); for(int i=0;i&lt;=1;i++) for(int j=0;j&lt;=1;j++) &#123; c.h[i][j] =a.h[i][0] and tp and b.h[0][j];//上面走 c.h[i][j]|=a.h[i][1] and bm and b.h[1][j];//下面走 &#125; return c;&#125;int cnt;int build(int l,int r)&#123; int t=++cnt; p[t].l=l;p[t].r=r; p[t].tp=p[t].bm=0; if(l&lt;r) &#123; int mid=(l+r)/2; p[t].lc=build(l,mid); p[t].rc=build(mid+1,r); &#125; else p[t].f.h[0][0]=p[t].f.h[1][1]=1;//单点横向必定可以 return t;&#125;void change(int x,int x1,int y1,int x2,int y2,bool b)&#123; int lc=p[x].lc,rc=p[x].rc,mid=(p[x].l+p[x].r)/2; if(x1==x2 and y1==mid)//横着，正好中间 &#123; if(x1==0) p[x].tp=b; else p[x].bm=b; p[x].f=merg(p[lc].f,p[x].tp,p[x].bm,p[rc].f); return; &#125; if(p[x].l==p[x].r)//其他单点 &#123; p[x].f.h[0][1]=p[x].f.h[1][0]=p[x].f.lb=p[x].f.rb=b; //tp、bm不需要，作为单点用不到 return; &#125; if(y1&lt;=mid) change(lc,x1,y1,x2,y2,b); else change(rc,x1,y1,x2,y2,b); p[x].f=merg(p[lc].f,p[x].tp,p[x].bm,p[rc].f);&#125;nod ask(int x,int L,int R)&#123; int lc=p[x].lc,rc=p[x].rc,mid=(p[x].l+p[x].r)/2; if(p[x].l==L and p[x].r==R) return p[x].f; if(R&lt;=mid) return ask(lc,L,R); if(L&gt;mid) return ask(rc,L,R); return merg(ask(lc,L,mid),p[x].tp,p[x].bm,ask(rc,mid+1,R));&#125;//*******************主函数*******************char s[20];int main()&#123; int n;scanf("%d",&amp;n); cnt=0;build(1,n); while(1) &#123; scanf("%s",s);if(s[0]=='E') break; int x1,y1,x2,y2;scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); if(y1&gt;y2) swap(x1,x2),swap(y1,y2);x1--;x2--; if(s[0]=='A') &#123; nod a,b,c; a=ask(1,1,y1);b=ask(1,y1,y2);c=ask(1,y2,n); if(a.rb) b.lb=1;if(c.lb) b.rb=1; bool bk=0; for(int i=0;i&lt;=1;i++) for(int j=0;j&lt;=1;j++) if(b.h[i][j]) if( (i==x1 or b.lb)and(j==x2 or b.rb) ) bk=1; if(bk) printf("Y\n"); else printf("N\n"); &#125; if(s[0]=='O') change(1,x1,y1,x2,y2,1); if(s[0]=='C') change(1,x1,y1,x2,y2,0); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3897】【Vijos1194】Domino]]></title>
    <url>%2Fposts%2F9f71.html</url>
    <content type="text"><![CDATA[来源和评测点Poj2663Vijos1194Caioj1487 题目【题目大意】问用1*2的多米诺骨牌填满m*n的矩阵有多少种方案，结果需要mod p。【输入格式】仅一行，有三个整数，m(m&lt;=5)，n(n&lt;2^31)，p(p&lt;=10^9+7)。【输出格式】输出方案数，结果需要mod p。【输入样例】3 2 5【输出样例】3 分析以下内容在参考网上题解后手打，补充了很多网上题解根本没有提及或者含糊不清的问题，有疑问可评论。 我们先从m=3入手，找到普遍解考虑用二进制表示一列的状态，然后从右往左填充，每次填充一列可以发现问题恰好转化为了：从111开始恰好n步回到111的方案数（显然考场上我是想不出来的，构思的时候细节很多）这时候只要找到方案间的边到底是怎么建立的，然后套上矩阵乘法即可，参考之前的多少条路呢 规则一：不能在第二列竖着放实现：前后方案的状态值，或操作的结果=111解释：因为假如有一个位置或结果是0，而又成功填充了一列，那么显然是竖着放了 规则二：能达到实现：前后方案的状态值，与操作的结果，不会有“连续奇数个”1解释：连续奇数个1意味着非法，因为原本状态值中连续奇数个1，不能添加竖着的domino，也没有其他办法，所以无法达到。 注意，我们构造边的时候其实有个原则（依然想不到）：如果面对某种局面只有一个地方能放置，也就是方案数不变，那么要将它压缩起来 至于为啥全都是双向边，逻辑上我讲不清，但从实现上看，两个状态的先后对得到可达矩阵结果没有影响，所以有对称性（m[i][j]==m[j][i]）不过因为状态太少，没有剪枝的必要 然后规则二的可行结果比较少，手工枚举后如下：00000 000011 300110 601100 1201111 1511000 2411011 2711110 30搞一个常量数组就好，就8个 然后，来个遗言：看到pascal用longint没问题，然后调试了一个小时……珍惜生命，请用longlong 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;//*******************全局常量*******************//*******************全局定义*******************struct martix&#123; ll m[40][40]; martix() &#123; memset(m,0,sizeof(m)); &#125;&#125;;//这次的矩阵从0开始int mx;ll MOD;//*******************接口*******************martix cheng(martix a,martix b)&#123; martix c; for(int i=0;i&lt;=mx;i++) for(int j=0;j&lt;=mx;j++) for(int k=0;k&lt;=mx;k++) c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]%MOD)%MOD; return c;&#125;martix power(martix a,int e)&#123; martix ans;for(int i=0;i&lt;=mx;i++) ans.m[i][i]=1; while(e&gt;0) &#123; if(e%2==1) ans=cheng(ans,a); a=cheng(a,a);e/=2; &#125; return ans;&#125;//*******************主函数*******************bool f[40];int main()&#123; f[0]=f[3]=f[6]=f[12]=f[15]=f[24]=f[27]=f[30]=1; int m,n;scanf("%d%d%lld",&amp;m,&amp;n,&amp;MOD);mx=(1&lt;&lt;m)-1; martix a; for(int i=0;i&lt;=mx;i++) for(int j=0;j&lt;=mx;j++) a.m[i][j]=( (i|j)==mx ) and f[i&amp;j]; printf("%lld",power(a,n).m[mx][mx]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>好题</tag>
        <tag>难度3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打鼹鼠]]></title>
    <url>%2Fposts%2F554a.html</url>
    <content type="text"><![CDATA[来源和评测点毒瘤出题人不一定能用的luogu链接 题目【题目大意】鼹鼠一共在仓库中打了n个洞（用1至n编号），在这n个洞中，有些洞之间是连通的，你可以花费一定的时间从连通的一个洞口处跑到另一个洞口处，然鹅有些洞之间由于货物的堆放等原因并不是连通的，也就是你并不能直接从不连通的一个洞口处跑到另一个洞口处。（但所有的连通关系都是双向的）当你在某一时刻正好在某个洞旁时，如果正好这个洞中有一只出现在洞口处，你就可以用手中的武器（一把大锤）消灭这支鼹鼠，当你在某一时刻停留在某个洞穴处并使用大锤时，该洞当前出现的所有鼹鼠都将被消灭。你有t秒的时间来进行消灭鼹鼠的战斗，你也知道在这t秒内鼹鼠每次出现的时间和位置。那么，你最多能消灭多少只鼹鼠呢？为了尽可能多的消灭鼹鼠，dd_engi为你提供了一种超级武器：如果你在某个特定时刻在某个洞口处使用这个超级武器的话，那么这个洞以及与它直接有边相连的所有洞中此刻出现的鼹鼠都会被消灭掉。然鹅，这个超级武器只能使用一次。你需要编程求出的就是：用或者不用这个超级武器，你分别能消灭多少只鼹鼠？注意：你可以不用完你所给的时间，而且可以有一些时间你并没有来回跑动而是仅仅停在某个洞的旁边。一些题目没有将清楚的要点：1.注意是用超级武器杀死直接相连的，我看错然后从100=&gt;02.只要你某个时刻在那里，就可以杀死所有当时在那里的鼹鼠3.时间可能有0，坐标编号没有04.一开始在哪里任意【输入格式】第一行为三个用空格隔开的整数n、m、t，分别表示鼹鼠洞的个数和连通的边数以及你的时间t。以下m行，每行有三个用空格隔开的整数i、j、k，表示编号i、j的两个鼹鼠洞是双向连通的，从一个运动到另一个需要花费的时间为k。以下每行有三个用空格隔开的整数，第一个整数表示描述的这些鼹鼠将于第几秒末出现，第二个整数表示描述的这些鼹鼠出现的洞的编号，第三个整数表示这次将会出现的鼹鼠的数量。以三个整数0表示输入的结束。输入文件的结尾是一个回车/换行符。【输出格式】只需输出两个用空格隔开的整数，分别表示用和不用超级武器能消灭的最多鼹鼠数。最后以一个回车/换行符结尾。【输入样例】3 2 101 2 12 3 21 1 12 2 23 3 34 1 42 3 34 2 26 1 48 2 310 2 29 1 17 1 53 2 28 1 80 0 0【输出样例】32 29 分析其实是一道灰常简单的dp一开始写了个dfs，我不确定时间复杂度是否相同注意我上面说的要点就好了然后被第一条坑惨了，还用了并查集沾沾自喜…… 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************实现*******************struct pt&#123; int f[1100]; int hou; pt() &#123; memset(f,0,sizeof(f)); hou=0; &#125;&#125;p[110];struct rod&#123; int y,c,g;&#125;e[21000];int ln=0;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln;&#125;//*******************主函数*******************int f[1100][110][2];int ff[1100][110];int main()&#123; int n,m,T;scanf("%d%d%d",&amp;n,&amp;m,&amp;T); for(int i=1;i&lt;=n;i++) ins(i,i,1); while(m--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);ins(y,x,c); join(x,y); &#125; int a,b,c; while(scanf("%d%d%d",&amp;a,&amp;b,&amp;c)!=EOF) &#123; if(a==0 and b==0 and c==0) break; p[b].f[a]+=c; fal[fa[b]][a]+=c; &#125; int mx1=0,mx2=0; memset(f,0,sizeof(f)); memset(ff,0,sizeof(ff)); for(int t=1;t&lt;=T;t++) &#123; for(int x=1;x&lt;=n;x++) &#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) ff[t][x]+=p[e[k].y].f[t];//包括自己 for(int k=p[x].hou;k&gt;0;k=e[k].g)//包括自己 &#123; int y=e[k].y,c=e[k].c; if(t-c&lt;0) continue; f[t][x][0]=mymax(f[t][x][0],f[t-c][y][0]+p[x].f[t]); f[t][x][1]=mymax(f[t][x][1],f[t-c][y][1]+p[x].f[t]); //f[t][x][1]=mymax(f[t][x][1],f[t-c][y][0]+ff[t][x]); f[t][x][1]=mymax(f[t][x][1],f[t-c][y][0]+fal[fa[x]][t]); &#125; mx1=mymax(mx1,f[t][x][1]),mx2=mymax(mx2,f[t][x][0]); &#125; &#125; printf("%d %d\n",mx1,mx2);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3897】【Bzoj2709】迷宫花园]]></title>
    <url>%2Fposts%2Fab3c.html</url>
    <content type="text"><![CDATA[来源和评测点Poj3897Bzoj2709Bzoj的在分析1，Poj的在分析2 题目【题目大意】普通得甚至有些二逼的矮穷挫少年——Dios，不可避免地遇到了他生命中的劫数，白富美少女 Nyution。但是按照正常的校园故事的发展，Nyution 是无论如何不会喜欢上各方面条件都差到不行的 Dios 的。不过，Dios 还是面对 Nyution 颤抖着说出了那三个字。Nyution既不想过分地让 Dios 伤心，又不想接受她根本看不上的 Dios，于是决定让 Dios 走一个建在她家后院里的迷宫花园——如果 Dios 能很快地从起点走到终点，证明他的聪明才智，Nyution就答应他的表白。当然 Nyution 敢这么说肯定是有准备的。Nyution 的花园可以看做一个迷宫，在迷宫内部有起点和终点。Dios 要从起点走到终点，并且他只能选择前后左右四个方向行走，而且显然不能走到篱笆上，也不能走出迷宫的边界。Nyution 经过仔细的调查发现，Dios 移动到相邻格子的耗时肯定是 1。同时，Nyution 将在 Dios 的挑战开始前，通过进行适当的路面调整，使 Dios 在南北方向（数据中的上下方向）的移动时间由 1 变成实数v 。首先，Nyution不能让 Dios 过快地到达终点，这样她就得接受表白；其次，Nyution 也不想让 Dios 开了小宇宙之后还是过慢地到达终点，这样显得她在刁难 Dios。最后她确定了一个实数 L ——就是最坏情况（也就是 Dios 最神勇威武耗时最短的情况）下，Dios 将花费 L 的时间由起点到达终点。但是 Nyution 显然不会求此时的v 值，于是她找到了一向以算法达人著称的你。你当然不会拒绝白富美 Nyution 的请求，决定帮她算出此时的v 。由于 Nyution 不仅是白富美同时也是三好学生，所以她肯定不会给你一个无解的任务。并且，Nyution 的迷宫中一定没有水平的从起点到终点的通路。【输入格式】输入文件包含多个测试点。第一行包含一个整数，表示测试点的数目。每个测试点的第一行包含实数 L 和两个整数 R ,C 。 L 的含义如上， R 表示 Nyution 的花园南北方向的长度，C 表示花园东西方向的长度。之后 R 行为花园的描述，每行包含C 个字符。其中空格（ASCII 码为 32）代表空地，S 代表起点，E 代表终点，# 代表篱笆。显然，起点和终点都是空地。对于 20% 的数据，满足1&lt;=R,C&lt;=10对于另外 20% 的数据，保证答案v 的小数部分为 0对于 100% 的数据，满足1&lt;=R,C&lt;=100 ，保证0&lt;=v&lt;10【输出格式】对于每组测试数据，在单独的一行内输出v 的值，保留 5 位小数。【输入样例】22.5 4 5######S ## E######21 13 12#############S## #E## ## # # ## # # # #### # # # ## # # # ## ## # # ### # # # #### # # # ### # # # ## ## # ## # #############【输出样例】0.500000.21053 分析1然后是好题，这是因为这道题把最短路拓展了，希望大家和我一样，经过这个学会灵活变化，而不要太死脑筋因为这道题可以不去建边的，一开始我还想着把所有边dfs建好，边值自己变化，后来akc提醒才发现没必要 代码11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;//*******************全局常量*******************const double eps=1e-8;//*******************全局定义*******************struct nod&#123; int x,y; nod() &#123;&#125; nod(int xx,int yy) &#123;x=xx,y=yy;&#125;&#125;;//*******************接口*******************double midv;int n,m;int stx,sty;int edx,edy;bool mp[110][110];double d[110][110];queue&lt;nod&gt; q;bool b[110][110];double spfa()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) d[i][j]=0x3f3f3f3f,b[i][j]=0; while(!q.empty()) q.pop(); d[stx][sty]=0;b[stx][sty]=1;q.push( nod(stx,sty) ); while(!q.empty()) &#123; nod tp=q.front();int xx=tp.x,yy=tp.y; for(int i=0;i&lt;=3;i++) &#123; int tx,ty; if(i==0) tx=xx-1,ty=yy;if(i==1) tx=xx+1,ty=yy; if(i==2) tx=xx,ty=yy-1;if(i==3) tx=xx,ty=yy+1; if(tx&lt;1 or tx&gt;n or ty&lt;1 or ty&gt;m or !mp[tx][ty]) continue; double rc=(i&lt;2)?midv:1; if(d[tx][ty]&gt;d[xx][yy]+rc) &#123; d[tx][ty]=d[xx][yy]+rc; if(b[tx][ty]==0) &#123; b[tx][ty]=1; q.push( nod(tx,ty) ); &#125; &#125; &#125; q.pop();b[xx][yy]=0; &#125; return d[edx][edy];&#125;//*******************主函数*******************char s[110];int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; double L;scanf("%lf%d%d",&amp;L,&amp;n,&amp;m);gets(s+1);//debug for(int i=1;i&lt;=n;i++) &#123; gets(s+1);//debug for(int j=1;j&lt;=m;j++) &#123; if(s[j]=='#') mp[i][j]=0; else mp[i][j]=1; if(s[j]=='S') stx=i,sty=j; if(s[j]=='E') edx=i,edy=j; &#125; &#125; double l=0,r=10,ans=0;//debug -1 while(r-l&gt;eps)//最后l==r即r-l==0 &#123; midv=(l+r)/2; if(spfa()&lt;=L+eps) ans=midv,l=midv+eps;//spfa()&lt;=L else r=midv-eps; &#125; printf("%.5lf\n",ans); &#125;&#125; 分析2POJ也差不多。。已经用注释表明区别了 代码212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;//*******************全局常量*******************const double eps=1e-8;//*******************全局定义*******************struct nod&#123; int x,y; nod() &#123;&#125; nod(int xx,int yy) &#123;x=xx,y=yy;&#125;&#125;;//*******************接口*******************double midv;int n,m;int stx,sty;int edx,edy;bool mp[110][110];double d[110][110];queue&lt;nod&gt; q;bool b[110][110];double spfa()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) d[i][j]=0x3f3f3f3f,b[i][j]=0; while(!q.empty()) q.pop(); d[stx][sty]=0;b[stx][sty]=1;q.push( nod(stx,sty) ); while(!q.empty()) &#123; nod tp=q.front();int xx=tp.x,yy=tp.y; for(int i=0;i&lt;=3;i++) &#123; int tx,ty; if(i==0) tx=xx-1,ty=yy;if(i==1) tx=xx+1,ty=yy; if(i==2) tx=xx,ty=yy-1;if(i==3) tx=xx,ty=yy+1; if(tx&lt;1 or tx&gt;n or ty&lt;1 or ty&gt;m or !mp[tx][ty]) continue; double rc=(i&lt;2)?midv:1; if(d[tx][ty]&gt;d[xx][yy]+rc) &#123; d[tx][ty]=d[xx][yy]+rc; if(b[tx][ty]==0) &#123; b[tx][ty]=1; q.push( nod(tx,ty) ); &#125; &#125; &#125; q.pop();b[xx][yy]=0; &#125; return d[edx][edy];&#125;//*******************主函数*******************char s[110];int main()&#123; int T;scanf("%d",&amp;T); for(int tt=1;tt&lt;=T;tt++) &#123; double L; //scanf("%lf%d%d",&amp;L,&amp;n,&amp;m); scanf("%lf%d",&amp;L,&amp;n); gets(s+1);//debug for(int i=1;i&lt;=n;i++) &#123; gets(s+1);//debug m=strlen(s+1); for(int j=1;j&lt;=m;j++) &#123; if(s[j]=='#') mp[i][j]=0; else mp[i][j]=1; if(s[j]=='S') stx=i,sty=j; if(s[j]=='E') edx=i,edy=j; &#125; &#125; double l=0,r=10,ans=0;//debug -1 while(r-l&gt;eps)//最后l==r即r-l==0 &#123; midv=(l+r)/2.0; if(spfa()&lt;=L+eps) ans=midv,l=midv+eps;//spfa()&lt;=L else r=midv-eps; &#125; printf("Case #%d: %.3lf%%\n",tt,ans*100.0); //printf("%.5lf\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[花园]]></title>
    <url>%2Fposts%2Fb112.html</url>
    <content type="text"><![CDATA[来源和评测点某场比赛，没拿到数据意会吧 题目【题目大意】【输入格式】【输入样例】5 810 20 30 40 501 21 33 43 5Q 2 5 10C 2 21Q 3 4 21C 6 22Q 1 7 28C 5 20Q 2 5 20Q 2 0 9【输出样例】12031 分析1这是加密前的操作Q 2 5 10C 3 20Q 2 5 20C 4 20Q 3 5 30C 5 20Q 2 5 20Q 1 3 10咳咳先来个清新脱俗的暴力（50分）主要是因为T太大，想不到好方法 代码1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//Zory-2018//*******************头文件*******************#pragma once#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=110000,MAXM=210000;//*******************全局定义*******************struct pt&#123; int cl; int hou; int dep; int fa; pt() &#123; hou=0; &#125;&#125;p[MAXN];struct rod&#123; int y,g;&#125;e[MAXM];int ln=0;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************接口*******************void dfs(int x)&#123; p[x].dep=p[ p[x].fa ].dep+1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y!=p[x].fa) p[y].fa=x,dfs(y); &#125;&#125;//*******************主函数*******************char s[10];int main()&#123; int n,q;scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i].cl); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; dfs(1); int lans=0; while(q--) &#123; int x,y,t;scanf("%s%d",s,&amp;x);x=x^lans; if(s[0]=='C') &#123; scanf("%d",&amp;t); t=t^lans; p[x].cl=t; &#125; else &#123; scanf("%d%d",&amp;y,&amp;t); y=y^lans;t=t^lans; int ans=0; if(p[x].dep&lt;p[y].dep) swap(x,y); while(p[x].dep!=p[y].dep) &#123; if(p[x].cl==t) ans++; x=p[x].fa; &#125; while(x!=y) &#123; if(p[x].cl==t) ans++; if(p[y].cl==t) ans++; x=p[x].fa;y=p[y].fa; &#125; if(p[x].cl==t) ans++; lans=ans; printf("%d\n",ans); &#125; &#125;&#125; 分析2那么有请Rose大佬登场……对于离散化，我也想到了map，但之后就不会了他一语点醒了我，先%%% 先对颜色进行离散化，最坏情况下100000树链剖分维护结构，然后线段树动态开点，最坏情况下就一条链，然后不存在的节点点值就是0，修改操作的时候维护线段树，询问操作的时候就调用对应线段树查询，空间理论上最坏情况下100000*20，最好情况下也是100000*20但因为删除等，还是会有损耗 以上就是大致思路了嗯因为这道题算比较难的数据结构了，我加上了大量注释 代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;map&gt;using namespace std;//*******************全局常量*******************const int MAXN=110000,MAXM=210000;//*******************全局定义*******************struct pt&#123; int cl;//离散化后的值 int hou; int dep,tot; int fa,son,tp;&#125; p[MAXN];//逻辑上 很多棵线段树//实际上 为了动态开点 只有一个下标 用rt分配struct rod&#123; int y,g;&#125; e[MAXM];int ln=0;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************线段树*******************int rt[MAXN];//rt[经过离散化的值]=根节点struct mg&#123; int lc,rc; int c;&#125; sf[MAXN*30];int len=0;//类似于主席树，每次都是增加删除一条链void change(int &amp;x,int l,int r,int p,int z)&#123; if(x==0) x=++len;//新节点 sf[x].c+=z; if(l==r) return; int mid=(l+r)/2; if(p&lt;=mid) change(sf[x].lc,l,mid,p,z); else change(sf[x].rc,mid+1,r,p,z);&#125;int ask(int x,int l,int r,int fl,int fr)&#123; if(x==0) return 0;//减少空间支出 if(l==fl and r==fr) return sf[x].c; int mid=(l+r)/2; if(fr&lt;=mid) return ask(sf[x].lc,l,mid,fl,fr); if(fl&gt;mid) return ask(sf[x].rc,mid+1,r,fl,fr); return ask(sf[x].lc,l,mid,fl,mid)+ask(sf[x].rc,mid+1,r,mid+1,fr);&#125;//*******************树链剖分*******************void dfs(int x)&#123; p[x].tot=1;p[x].son=0; p[x].dep=p[ p[x].fa ].dep+1; for(int k=p[x].hou; k&gt;0; k=e[k].g) &#123; int y=e[k].y; if(y!=p[x].fa) &#123; p[y].fa=x; dfs(y); p[x].tot+=p[y].tot; if(p[y].tot&gt;p[p[x].son].tot) p[x].son=y; &#125; &#125;&#125;int nln=0;int nb[MAXN];void dfs2(int x,int tp)&#123; nb[x]=++nln;p[x].tp=tp; if(p[x].son&gt;0) dfs2(p[x].son,tp);//debug for(int k=p[x].hou; k&gt;0; k=e[k].g) &#123; int y=e[k].y; if(y!=p[x].fa and y!=p[x].son) dfs2(y,y);//debug &#125;&#125;//*******************接口*******************int n;map&lt;int,int&gt; mp;//key=大数字 元素=离散化后的值int cnt=0;int newcol(int col)&#123; if(mp[col]==0) return mp[col]=++cnt; return mp[col];&#125;//*******************主函数*******************char s[10];int main()&#123; int q;scanf("%d%d",&amp;n,&amp;q); for(int i=1; i&lt;=n; i++) &#123; int tc;scanf("%d",&amp;tc); p[i].cl=newcol(tc); &#125; for(int i=1; i&lt;=n-1; i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; p[1].fa=0;dfs(1); dfs2(1,1); for(int i=1;i&lt;=n;i++) change(rt[ p[i].cl ],1,n,nb[i],1); int lans=0; while(q--) &#123; int x,y,col; scanf("%s%d",s,&amp;x);x=x^lans; if(s[0]=='C') &#123; scanf("%d",&amp;col);col=col^lans; change(rt[ p[x].cl ],1,n,nb[x],-1); p[x].cl=newcol(col); change(rt[ p[x].cl ],1,n,nb[x],1); &#125; else &#123; scanf("%d%d",&amp;y,&amp;col); y=y^lans;col=mp[col^lans]; int ans=0; while(p[x].tp!=p[y].tp) &#123; if(p[p[x].tp].dep&lt;p[p[y].tp].dep) swap(x,y); ans+=ask(rt[col],1,n,nb[ p[x].tp ],nb[ x ]); x=p[p[x].tp].fa; &#125; if(p[x].dep&lt;p[y].dep) swap(x,y); lans=ans+ask(rt[col],1,n,nb[y],nb[x]); printf("%d\n",lans); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>线段树</tag>
        <tag>好题</tag>
        <tag>难度3</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hdu2157】多少条路呢]]></title>
    <url>%2Fposts%2Fc65d.html</url>
    <content type="text"><![CDATA[来源和评测点小黑2008信息工程学院集训队——选拔赛Hdu2157Caioj1485 题目【题目大意】给定一个有向图，有n个点，m条边。求A点到B点恰好经过k条边的方案数（可走重复边）【输入格式】输入数据有多组，每组第一行有两个整数，n（1&lt;=n&lt;=20)，m(m&lt;=100)，表示有n个点，m条边，点的编号为0~n-1。接下来m行，每行有两个整数，x，y，表示x点能到y点。接下的一行有一个整数，t(1&lt;=t&lt;=100)，表示有t组询问。接着的t行，每行有三个整数，A，B，k(k&lt;20)，表示问你从A点到B点恰好经过k条边的方案数，由于可能方案数灰常大，所以只要计算方案数mod 1000.当n，m为0时，输入结束。【输出格式】输出每次询问的方案数(记得要对1000取模)【输入样例】4 40 10 21 32 320 3 20 3 33 60 11 00 22 01 22 121 2 10 1 30 0【输出样例】2013 分析这道题还是灰常有趣的考虑邻接矩阵的自乘因为有0的话必定无法对结果矩阵作出贡献，所以结果矩阵f[i,j]的值必定是f[i,k]后f[k,j]的总方案数（也就是k=2的情况）那么同理，k的其他情况就是邻接矩阵的k次幂 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;//*******************全局常量*******************const int MAXN=35;//*******************全局定义*******************struct matrix&#123; int row,col; int p[MAXN][MAXN]; matrix() &#123; memset(p,0,sizeof(p)); &#125;&#125;;//*******************全局变量*******************int mod=1000;//*******************实现*******************matrix cheng(matrix a,matrix b)&#123; matrix c; int n=a.row,m=a.col,p=b.col; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) c.p[i][j]=(c.p[i][j]+a.p[i][k]*b.p[k][j])%mod; c.row=n;c.col=p; return c;&#125;//*******************主函数*******************int main()&#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)!=EOF) &#123; if(n==0 and m==0) break; matrix f[20];f[1].row=f[1].col=n; for(int i=1;i&lt;=m;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); f[1].p[x+1][y+1]=1; &#125; for(int i=2;i&lt;=19;i++) f[i]=cheng(f[1],f[i-1]); for(int i=1;i&lt;=n;i++) f[0].p[i][i]=1;//debug int t;scanf("%d",&amp;t); while(t--) &#123; int x,y,k;scanf("%d%d%d",&amp;x,&amp;y,&amp;k); printf("%d\n",f[k].p[x+1][y+1]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Vijos1067】守望者的烦恼]]></title>
    <url>%2Fposts%2Fc439.html</url>
    <content type="text"><![CDATA[来源和评测点杜杜我爱你Vijos1067Caioj1485 题目【题目大意】有n个格子，从入口出发（注意，入口不是第一个格子，要另外计算),需要走到最后一个格子（即出口，第n个格子）。每走一步可选择走过1~k个格子，求能走到出口的方案数。【输入格式】仅一行，含有两个整数k(1&lt;=k&lt;=10)，n(1&lt;=n&lt;=2^31-1)【输出格式】输出方案数mod 7777777的值【输入样例】2 4【输出样例】5 分析首先想dp,f[i]=sigma(p=i-k~i-1)[f[p]]然后因为n太大，考虑加速列向量(k+1)/*1,表示近几个f的值，然后推导出一个操作矩阵表示把列向量往前推并计算出最后一个值，然后把这个操作矩阵快速幂n-k-1次即可 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=20;//*******************全局定义*******************typedef long long ll;struct matrix&#123; int row,col; ll p[MAXN][MAXN]; matrix() &#123; memset(p,0,sizeof(p)); &#125;&#125;;//*******************全局变量*******************ll mod=7777777;//*******************实现*******************matrix cheng(matrix a,matrix b)&#123; matrix c; int n=a.row,m=a.col,p=b.col; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) c.p[i][j]=(c.p[i][j]%mod+a.p[i][k]*b.p[k][j]%mod)%mod; c.row=n;c.col=p; return c;&#125;matrix pre(int fn)&#123; matrix c;c.row=c.col=fn; for(int i=1;i&lt;=fn;i++) c.p[i][i]=1; return c;&#125;matrix power(matrix a,int e)&#123; matrix c=pre(a.row); while(e&gt;0) &#123; if(e%2==1) --e,c=cheng(c,a);//a*c也行 a=cheng(a,a);e/=2; &#125; return c;&#125;//*******************主函数*******************int main()&#123; int k,n;scanf("%d%d",&amp;k,&amp;n); matrix f;f.row=k+1;f.col=k+1; for(int i=1;i&lt;=k;i++) f.p[i][i+1]=1; for(int i=2;i&lt;=k+1;i++) f.p[k+1][i]=1; matrix ans;ans.row=k+1;ans.col=1; for(int i=1;i&lt;=k+1;i++) &#123; if(i&lt;=k) ans.p[i][1]=1;//一步跳过来 for(int j=1;j&lt;=i-1;j++) ans.p[i][1]=(ans.p[i][1]+ans.p[j][1])%mod; &#125; if(n&lt;=k)//debug &#123; printf("%lld",ans.p[n][1]); return 0; &#125; ans=cheng(power(f,n-k-1),ans); printf("%lld",ans.p[k+1][1]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1962】Fibonacci数列]]></title>
    <url>%2Fposts%2F53d.html</url>
    <content type="text"><![CDATA[来源和评测点Luogu1962Caioj1484 题目【题目大意】给定n，求第n个Fibonacci数mod 10^9+7的值。注意第一个Fibonacci数为1【输入格式】仅一个整数n【输出格式】输出结果【输入样例】10【输出样例】5 分析一题比一题水 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;//*******************全局常量*******************const int MAXN=110;//*******************全局定义*******************typedef long long ll;struct matrix&#123; int row,col; ll p[MAXN][MAXN]; matrix() &#123; memset(p,0,sizeof(p)); &#125;&#125;;//*******************全局变量*******************ll mod=1000000007;//*******************实现*******************matrix cheng(matrix a,matrix b)&#123; matrix c; int n=a.row,m=a.col,p=b.col; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) c.p[i][j]=(c.p[i][j]+a.p[i][k]*b.p[k][j]%mod)%mod; c.row=n;c.col=p; return c;&#125;matrix jia(matrix a,matrix b)&#123; matrix c;c.row=a.row;c.col=a.col; for(int i=1;i&lt;=c.row;i++) for(int j=1;j&lt;=c.col;j++) c.p[i][j]=(a.p[i][j]+b.p[i][j])%mod; return c;&#125;matrix pre(int fn)&#123; matrix c; for(int i=1;i&lt;=fn;i++) c.p[i][i]=1; c.row=c.col=fn; return c;&#125;matrix power(matrix a,ll e)&#123; matrix c=pre(a.row); while(e&gt;0) &#123; if(e%2==1) --e,c=cheng(c,a);//a*c也行 a=cheng(a,a);e/=2; &#125; return c;&#125;//*******************主函数*******************int main()&#123; ll n;scanf("%lld",&amp;n); if(n==1) &#123; printf("1");return 0; &#125; if(n==2) &#123; printf("1");return 0; &#125; matrix f;f.row=2;f.col=2; f.p[1][2]=1;f.p[2][1]=1;f.p[2][2]=1; f=power(f,n-2); matrix ans;ans.row=2;ans.col=1; ans.p[1][1]=1;ans.p[2][1]=1; ans=cheng(f,ans); printf("%lld",ans.p[2][1]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1483】成群的细菌]]></title>
    <url>%2Fposts%2F34dd.html</url>
    <content type="text"><![CDATA[来源和评测点IPSC 2003 Problem H《算法艺术与信息学竞赛》207页（2.1代数方法和模型，[例题5]细菌，版次不同可能页码有偏差）Caioj1483 题目【题目大意】n个培养皿排成一个圈，每个里面都有一些细菌。培养皿逆时针编号为1,2,…,n，第i个培养皿里有许多个细菌。细菌不停地活动着，它们有可能会进行六种操作：d i 0，表示第i个培养皿的所有细菌都死亡。r i k，表示第i个培养皿的每个细菌分裂成k个。c i j，表示把第j个培养皿的所有细菌复制到第i个培养皿。t i j，表示把第j个培养皿的所有细菌转移到第i个培养皿。s i j，表示交换第i和第j两个培养皿的细菌。m 0 0，表示每个培养皿的细菌都同时转移到它逆时针的下一个培养皿。一旦某个培养皿里有超过s个细菌，每s个细菌会合在一起进化成一个高级组织而脱离培养皿，这些细菌重复的执行着m条命令（编号为0,1,…,m-1），即第X时刻执行第X mod m条命令。问在第t时刻执行命令后，每个培养皿各有多少个细菌？已知初始的时候每个培养皿恰好有一个细菌。【输入格式】第一行，有四个整数，n(n&lt;=100),m(m&lt;=20),t(t&lt;=10^9),s(s&lt;=10^9+7)。接下来m行，每行包括一个字符和两个整数，表示命令的详细信息。【输出格式】仅一行，输出第t时刻时，每个培养皿的细菌个数。末尾没有空格，但有回车。【输入样例】8 6 11 7r 3 5c 5 3d 2 0m 0 0t 6 4s 1 3【输出样例】1 0 0 0 0 4 4 1 分析和上一题差不多，没什么好说的 代码12]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3233】Matrix_Power_Series]]></title>
    <url>%2Fposts%2Ffb98.html</url>
    <content type="text"><![CDATA[来源和评测点POJ Monthly–2007.06.03, Huang, JinsongPoj3233Caioj1481 题目【题目大意】给定一个n行n列的矩阵A，求A+A^2+A^3+…+A^k的结果，并且输出的每个数都mod m【输入格式】第一行含有3个整数n(n≤30),k(k≤10^9) and m(m&lt;10^4)接下来n行表示输入的矩阵。【输出格式】输出结果矩阵【输入样例】2 2 40 11 1【输出样例】1 22 3 分析k灰常大，暴力显然会T设P(t)=A+A^2+….+A^t而P(t*2)=P(t)+A^t/*P(t)也就是说可以二分求解，一下变成O(logk)，灰常快 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct matrix&#123; int row,col; int p[40][40]; matrix() &#123; memset(p,0,sizeof(p)); &#125;&#125;;//*******************全局变量*******************int MOD;//*******************实现*******************matrix cheng(matrix a,matrix b)&#123; matrix c; int n=a.row,m=a.col,p=b.col; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) c.p[i][j]=(c.p[i][j]+(a.p[i][k]*b.p[k][j])%MOD)%MOD; c.row=n;c.col=p; return c;&#125;matrix jia(matrix a,matrix b)&#123; matrix c;c.row=a.row;c.col=a.col; for(int i=1;i&lt;=c.row;i++) for(int j=1;j&lt;=c.col;j++) c.p[i][j]=(a.p[i][j]+b.p[i][j])%MOD; return c;&#125;matrix pre(int fn)&#123; matrix c; for(int i=1;i&lt;=fn;i++) c.p[i][i]=1; c.row=c.col=fn; return c;&#125;matrix power(matrix a,int e)&#123; matrix c=pre(a.row); while(e&gt;0) &#123; if(e%2==1) --e,c=cheng(c,a);//a*c也行 a=cheng(a,a);e/=2; &#125; return c;&#125;matrix powsum(matrix a,int e)&#123; if(e==1) return a; if(e%2==1) return jia(powsum(a,e-1),power(a,e)); matrix t=powsum(a,e/2); return jia(t,cheng(power(a,e/2),t));&#125;//*******************主函数*******************int main()&#123; int n,k;scanf("%d%d%d",&amp;n,&amp;k,&amp;MOD); matrix s;s.row=s.col=n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;s.p[i][j]); matrix ans=powsum(s,k); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) printf("%d ",ans.p[i][j]); printf("\n"); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Vijos1049】送给圣诞夜的礼品]]></title>
    <url>%2Fposts%2Fe353.html</url>
    <content type="text"><![CDATA[来源和评测点Vivian SnowVijos1049Caioj1482 题目【题目大意】有n个数，也就是说初始序列为1,2,3…nm种置换方式（有m行），每行有n个数字，这些数字互不相同而且每个数字都在1到n之间。置换操作方式为设这一行操作的第i个数字为a[i],那么就把原来序列中的第a[i]个数放到新的序列的第i的位置上，然后组成一个新的序列。从第一种置换方式开始操作，一直到最后一种操作，重复上面的操作方式。当最后一种操作结束后，组成了的序列又按照第一种来操作，一直循环下去，直到一共操作了k次为止【输入格式】第一行三个数，n（1&lt;=n&lt;=100)，m(1&lt;=m&lt;=10)和k(1&lt;=k&lt;=2^31-1)接下来m行，每行有n个数【输出格式】一行，一共有n个数，表示最终序列。n个数之间用一个空格隔开，行尾没有空格，需要回车。【输入样例】7 5 86 1 3 7 5 2 43 2 4 5 6 7 17 1 3 4 5 2 65 6 7 3 1 2 42 7 3 4 6 1 5【输出样例】2 4 6 3 5 1 7 分析真心简单把m个操作的每个操作变成一个操作矩阵这m个矩阵相乘，然后快速幂k次，与原始矩阵相乘即可 哦对了，记得因为不满足交换律，结合顺序必须依照原本的顺序如果是列向量的话，就是越左越晚 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;//*******************全局常量*******************const int MAXN=110;//*******************全局定义*******************struct matrix&#123; int row,col; int p[MAXN][MAXN]; matrix() &#123; memset(p,0,sizeof(p)); &#125;&#125;;//*******************全局变量*******************matrix c[20];//*******************实现*******************matrix cheng(matrix a,matrix b)&#123; matrix c; int n=a.row,m=a.col,p=b.col; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) c.p[i][j]+=a.p[i][k]*b.p[k][j]; c.row=n;c.col=p; return c;&#125;matrix jia(matrix a,matrix b)&#123; matrix c;c.row=a.row;c.col=a.col; for(int i=1;i&lt;=c.row;i++) for(int j=1;j&lt;=c.col;j++) c.p[i][j]=a.p[i][j]+b.p[i][j]; return c;&#125;matrix pre(int fn)&#123; matrix c; for(int i=1;i&lt;=fn;i++) c.p[i][i]=1; c.row=c.col=fn; return c;&#125;matrix power(matrix a,int e)&#123; matrix c=pre(a.row); while(e&gt;0) &#123; if(e%2==1) --e,c=cheng(c,a);//a*c也行 a=cheng(a,a);e/=2; &#125; return c;&#125;//*******************主函数*******************int main()&#123; int n,m,k;scanf("%d%d%d",&amp;n,&amp;m,&amp;k); matrix s;s.row=n;s.col=1;for(int i=1;i&lt;=n;i++) s.p[i][1]=i; matrix f=pre(n); for(int i=1;i&lt;=m;i++) &#123; c[i].row=c[i].col=n; for(int j=1;j&lt;=n;j++) &#123; int t; scanf("%d",&amp;t); c[i].p[j][t]=1; &#125; f=cheng(c[i],f); &#125; int a=k/m,b=k%m; matrix ans=power(f,a); for(int i=1;i&lt;=b;i++) ans=cheng(c[i],ans);//补上多余 ans=cheng(ans,s);//注意顺序 for(int i=1;i&lt;=n;i++) printf("%d ",ans.p[i][1]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1480】矩阵无限方]]></title>
    <url>%2Fposts%2Fbfe0.html</url>
    <content type="text"><![CDATA[来源和评测点Caioj1480 题目【题目大意】给定一个n行n列的矩阵A，求出A^x的结果，输出的每个数都mod 10^9+7【输入格式】第一行含有两个整数n(1&lt;=n&lt;=10),x(x&lt;=2^31-1)。接下来n行表示这个矩阵。【输出格式】输出结果矩阵，每行n个数之间用一个空格隔开，行尾没有空格，需要回车【输入样例】2 31 35 2【输出样例】61 66110 83 分析显而易见的裸题 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;typedef long long ll;//*******************全局常量*******************const ll MOD=1000000007;//*******************全局定义*******************struct matrix&#123; int row,col; ll p[20][20]; matrix() &#123; memset(p,0,sizeof(p)); &#125;&#125;;//*******************实现*******************matrix cheng(matrix a,matrix b)&#123; matrix c; int n=a.row,m=a.col,p=b.col; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) c.p[i][j]=(c.p[i][j]+(a.p[i][k]*b.p[k][j])%MOD)%MOD; c.row=n;c.col=p; return c;&#125;matrix pre(int fn)&#123; matrix c; for(int i=1;i&lt;=fn;i++) c.p[i][i]=1; c.row=c.col=fn; return c;&#125;matrix power(matrix a,int e)&#123; matrix c=pre(a.row); while(e&gt;0) &#123; if(e%2==1) --e,c=cheng(c,a); //a*c也行，有的博客误导人啊 //因为快速幂中c其实只是好几个a，再多个a罢了 a=cheng(a,a);e/=2; &#125; return c;&#125;//*******************主函数*******************int main()&#123; int n,x;scanf("%d%d",&amp;n,&amp;x); matrix s;s.row=s.col=n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%lld",&amp;s.p[i][j]); matrix ans=power(s,x); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) printf("%lld ",ans.p[i][j]); printf("\n"); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Nyoj298】点的变换]]></title>
    <url>%2Fposts%2Fe629.html</url>
    <content type="text"><![CDATA[来源和评测点Nyoj298Caioj1479 题目【题目大意】平面上有不超过10000个点，坐标都是已知的现在可能对所有的点做以下几种操作：详见输入格式操作的次数不超过1000000次，求最终所有点的坐标。提示：如果程序中用到PI的值，可以用acos(-1.0)获得。【输入格式】测试数据的第一行是两个整数N,M，分别表示点的个数与操作的个数(N&lt;=10000,M&lt;=1000000)随后的一行有N对数对，每个数对的第一个数表示一个点的x坐标，第二个数表示y坐标，这些点初始坐标大小绝对值不超过100。随后的M行，每行代表一种操作，行首是一个字符：首字符如果是M,则表示平移操作，该行后面将跟两个数x,y，表示把所有点按向量(x,y)平移;首字符如果是X，则表示把所有点相对于X轴进行上下翻转;首字符如果是Y，则表示把所有点相对于Y轴进行左右翻转;首字符如果是S，则随后将跟一个数P,表示坐标放大P倍;首字符如果是R，则随后将跟一个数A,表示所有点相对坐标原点逆时针旋转一定的角度A(单位是度)【输出格式】每行输出两个数，表示一个点的坐标(对结果四舍五入到小数点后1位，输出一位小数位）点的输出顺序应与输入顺序保持一致【输入样例】2 51.0 2.0 2.0 3.0XYM 2.0 3.0S 2.0R 180【输出样例】-2.0 -2.00.0 0.0 分析首先，假如对每个点一个个进行操作的话，O(NM)显然会超时那怎么办呢？题目中每个操作都是对所有点而言的，也就是所有点都要经过各种操作那么考虑用矩阵乘法加速，把每个操作对应的矩阵推导出来就好了这样有什么好处呢？矩阵乘法不是更慢吗？答案：可以先将所有操作化为一个灰常复杂的操作O(M)，再每个点乘一次就好O(N)，共计O(M+N)提示：由于不满足交换律，所以顺序不能变 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;//*******************全局常量*******************const int MAXN=11000;const double PI=acos(-1.0);//*******************全局定义*******************struct matrix&#123; int row,col; double p[5][5]; matrix() &#123; memset(p,0,sizeof(p)); &#125;&#125;;//*******************全局变量*******************matrix pt[MAXN],c[5],ss;//*******************实现*******************matrix cheng(matrix a,matrix b)&#123; matrix c; int n=a.row,m=a.col,p=b.col; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) c.p[i][j]+=a.p[i][k]*b.p[k][j]; c.row=n;c.col=p; return c;&#125;matrix pre(int fn)&#123; matrix c; for(int i=1;i&lt;=fn;i++) c.p[i][i]=1; c.row=c.col=fn; return c;&#125;//*******************主函数*******************char s[5];int main()&#123; //横坐标加a，纵坐标加b c[0].p[1][1]=1;c[0].p[2][2]=1; c[0].p[3][3]=1;c[0].row=c[0].col=3; //把所有点相对于X轴进行上下翻转 c[1].p[1][1]=1;c[1].p[2][2]=-1; c[1].p[3][3]=1;c[1].row=c[1].col=3; //把所有点相对于Y轴进行左右翻转 c[2].p[1][1]=-1;c[2].p[2][2]=1; c[2].p[3][3]=1;c[2].row=c[2].col=3; //坐标放大P倍 c[3].p[3][3]=1;c[3].row=c[3].col=3; //所有点相对坐标原点逆时针旋转一定的角度A(单位是度) c[4].p[3][3]=1;c[4].row=c[4].col=3; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; pt[i].row=3;pt[i].col=1;pt[i].p[3][1]=1; scanf("%lf%lf",&amp;pt[i].p[1][1],&amp;pt[i].p[2][1]); &#125; ss=pre(3); while(m--) &#123; scanf("%s",s); if(s[0]=='M') &#123; double a,b;scanf("%lf%lf",&amp;a,&amp;b); c[0].p[1][3]=a;c[0].p[2][3]=b; ss=cheng(c[0],ss);//不可调换，操作越晚越左 &#125; if(s[0]=='X') ss=cheng(c[1],ss); if(s[0]=='Y') ss=cheng(c[2],ss); if(s[0]=='S') &#123; double p;scanf("%lf",&amp;p); c[3].p[1][1]=p;c[3].p[2][2]=p; ss=cheng(c[3],ss); &#125; if(s[0]=='R') &#123; double a;scanf("%lf",&amp;a); double rad=PI/180.0*a;//转弧度 c[4].p[1][1]=cos(rad);c[4].p[1][2]=-sin(rad); c[4].p[2][1]=sin(rad);c[4].p[2][2]=cos(rad); ss=cheng(c[4],ss); &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; pt[i]=cheng(ss,pt[i]); printf("%.1lf %.1lf\n",pt[i].p[1][1],pt[i].p[2][1]); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDKOI2018日志&游记]]></title>
    <url>%2Fposts%2F676d.html</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>竞赛历程</category>
      </categories>
      <tags>
        <tag>赛事</tag>
        <tag>GDKOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj1325】Machine Schedule]]></title>
    <url>%2Fposts%2F7392.html</url>
    <content type="text"><![CDATA[来源和评测点Beijing 2002Poj1325 题目【题目大意】有两部机器A和B。A机器有n种工作模式0，1，2，3，……n-1，总共n种。B机器有m种工作模式0，1，2，3，……m-1，总共m种。有k个任务，每个任务可以在 A机器的某个模式 或者 B机器的某个模式中完成。A和B机器开始时都默认在0模式，要选择其他模式就要重启一次。求完成k个任务至少需要重启多少次机器。最后以0结束。输出最少重启机器的次数。【输入格式】第一行三个整数n,m,k(0&lt;n,m&lt;100,0&lt;k&lt;1000），下来k行，每行三个数p，x，y，第一个表示第p个任务，后面两个，表示该任务可以在A机器的x模式完成，或者可以选择B机器的y模式完成该任务。【输出格式】一个整数，为最少重启机器的次数。【输入样例】5 5 100 1 11 1 22 1 33 1 44 2 15 2 26 2 37 2 48 3 39 4 30【输出样例】3 分析请先仔细看题，然后思考。 其实数据的输入形式很多时候就给出了提示，例如这道题中，每个任务与A、B分别有两个可能，与点、边之间的关系灰常像。而要求最少的重启机器次数，显然最好能一个模式做多几个任务，使用过的模式数量之和就是答案。而机器只有两个，又可以联想到二分图匹配。 综上所述，构图如下：把A、B看作两个集合，模式看作点，任务看作边，每个任务连接两个点，最后通过匈牙利算法计算出最大匹配对数，根据定理得到最小点覆盖。 不过……这题目是卡邻接表的么？TLE了改成邻接矩阵就0ms了怀疑数据有超级多重边。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=100,MAXM=1000;//*******************全局定义*******************/*struct pt&#123; int hou;&#125;p[2*MAXN];struct rod&#123; int y,g;&#125;e[MAXM];*///*******************实现*******************/*int ln;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;*///*******************接口*******************int n,m,k;int ask[MAXN];int match[MAXN];bool mp[MAXN][MAXN];int t;bool findmuniu(int x)&#123; //for(int k=p[x].hou;k&gt;0;k=e[k].g) for(int i=1;i&lt;=m;i++) &#123; if(mp[x][i]==0) continue; //int i=e[k].y; if(ask[i]&lt;t) &#123; ask[i]=t; if(match[i]==0 or findmuniu(match[i])) //C++中的or逻辑关系，左边true则不会执行右边的语句 &#123; match[i]=x; return 1; &#125; &#125; &#125; return 0;&#125;//*******************主函数*******************int main()&#123; while(scanf("%d",&amp;n) and n!=0) &#123; memset(ask,0,sizeof(ask)); memset(match,0,sizeof(match)); //ln=0;for(int i=1;i&lt;=n+m;i++) p[i].hou=0; memset(mp,0,sizeof(mp)); scanf("%d%d",&amp;m,&amp;k); for(int i=1;i&lt;=k;i++) &#123; int t,a,b; scanf("%d%d%d",&amp;t,&amp;a,&amp;b); //ins(a,n+b); mp[a][b]=1; &#125; int ans=0; for(t=1;t&lt;=n;t++) ans+=findmuniu(t); printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>匈牙利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1901】Dynamic Rankings]]></title>
    <url>%2Fposts%2F8705.html</url>
    <content type="text"><![CDATA[来源和评测点Author: XIN, TaoSource: Online Contest of Christopher’s AdventureBzoj1901Zju2112 多组数据Luogu2617Caioj1442 题目【题目大意】给n(1&lt;=n&lt;=50000)个数字，进行m(1&lt;=m&lt;=10000)次操作，有两种操作：Q l r k：询问l到r第k小的数。C x k：改变第x个数的值为k。【输入格式】第一行为n和m。接下来一行n个数。接下来m行为m个操作。【输出格式】遇到Q操作就输出。【输入样例】25 33 2 1 4 7Q 1 4 3C 2 6Q 2 5 35 33 2 1 4 7Q 1 4 3C 2 6Q 2 5 3【输出样例】3636 分析建议先阅读本文：【OI之路】06树-6主席树 可持续线段树（主席树）套树状数组 修改操作：原本的add是直接+1，现在考虑添加参数o，表示c要加上o然后先把原本数字删掉，添加新数字即可。但这样修改一个就要修改后面的全部，所以像许多其他题目一样，经典的带修改时用树状数组代替前缀和。 询问操作：也有些不同，因为统计左边部分时，用的只是某一层的值，所以用getsum时，引入函数turn来转向效果更佳~ 然鹅，Zoj死都SF，调了一整天，狂对拍，狂检查，都无济于事，又放弃了…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162//Zory-2018//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量*******************const int MAXN=51000,MAXM=11000;//*******************全局定义*******************int n;int ust[MAXN];int rx;//离散化后最大值//*******************主席树*******************struct nod&#123; int c; int lc,rc;&#125;p[MAXN*17];int rt[MAXN];int cnt;void add(int &amp;x,int l,int r,int pos,int c)&#123; if(x==0) x=++cnt; p[x].c+=c; if(l==r) return;//debug int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) add(p[x].lc,l,mid,pos,c); else add(p[x].rc,mid+1,r,pos,c);&#125;//*******************树状数组*******************int lowbit(int x) &#123;return x&amp;(-x);&#125;void change(int x,int p,int c)&#123; while(x&lt;=n) &#123; add(rt[x],1,rx,p,c); x+=lowbit(x); &#125;&#125;int lsum(int x)&#123; int sum=0; while(x&gt;=1) &#123; sum+=p[ p[ust[x]].lc ].c; x-=lowbit(x); &#125; return sum;&#125;//*******************实现******************int now[MAXN];void solve1(int x,int k)&#123; change(x,now[x],-1); now[x]=k; change(x,now[x],1);&#125;void turn(int x,int tn)&#123; while(x&gt;=1) &#123; if(tn==0) ust[x]=rt[x]; if(tn&lt;0) ust[x]=p[ ust[x] ].lc; if(tn&gt;0) ust[x]=p[ ust[x] ].rc; x-=lowbit(x); &#125;&#125;int ask(int x,int y,int l,int r,int k)//l、r锁定&#123; if(l==r) return l; int lm=lsum(y)-lsum(x); int mid=(l+r)/2; if(k&lt;=lm) &#123; turn(x,-1);turn(y,-1); return ask(x,y,l,mid,k); &#125; else &#123; turn(x,1);turn(y,1); return ask(x,y,mid+1,r,k-lm); &#125;&#125;int solve2(int x,int y,int k)&#123; turn(x-1,0);turn(y,0);//初始化 return ask(x-1,y,1,rx,k);&#125;//*******************离散化*******************struct Qes&#123; int op; int x,y,k;&#125;q[MAXM];int num[MAXN+MAXM];//原值struct Lsh&#123; int x,id,z;&#125;a[MAXN+MAXM];bool cmp(Lsh a,Lsh b) &#123;return a.x&lt;b.x;&#125;void lsh(int all)&#123; sort(a+1,a+all+1,cmp); rx=0;a[0].x=-666;//debug for(int i=1;i&lt;=all;i++) &#123; if(a[i-1].x!=a[i].x) num[++rx]=a[i].x; if(a[i].id&lt;=n) a[a[i].id].z=rx; else q[a[i].id-n].k=rx; &#125;&#125;//*******************主函数******************char s[5];int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; memset(rt,0,sizeof(rt)); int m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=cnt;i++) p[i].c=p[i].lc=p[i].rc=0; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i].x),a[i].id=i; int qs=0; for(int i=1;i&lt;=m;i++) &#123; scanf("%s",s); if(s[0]=='C') &#123; q[i].op=0; scanf("%d%d",&amp;q[i].x,&amp;q[i].k); qs++; a[n+qs].x=q[i].k; a[n+qs].id=n+i; &#125; else &#123; q[i].op=1; scanf("%d%d%d",&amp;q[i].x,&amp;q[i].y,&amp;q[i].k); &#125; &#125; lsh(n+qs); cnt=0; for(int i=1;i&lt;=n;i++) change(i,a[i].z,1),now[i]=a[i].z; for(int i=1;i&lt;=m;i++) &#123; if(q[i].op==0) solve1(q[i].x,q[i].k); else printf("%d\n",num[ solve2(q[i].x,q[i].y,q[i].k) ]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>主席树</tag>
        <tag>难度2</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3196】【Luogu3380】二逼平衡树]]></title>
    <url>%2Fposts%2Fd7e9.html</url>
    <content type="text"><![CDATA[来源和评测点Tyvj1730Bzoj3196Luogu3380Caioj1135 题目【题目大意】您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：1.查询k在区间内的排名2.查询区间内排名为k的值3.修改某一位值上的数值4.查询k在区间内的前驱(前驱定义为小于x，且最大的数)5.查询k在区间内的后继(后继定义为大于x，且最小的数)【输入格式】第一行两个数 n,m 表示长度为n的有序序列和m个操作第二行有n个数，表示有序序列下面有m行，opt表示操作标号若opt=1 则为操作1，之后有三个数l,r,k 表示查询k在区间[l,r]的排名若opt=2 则为操作2，之后有三个数l,r,k 表示查询区间[l,r]内排名为k的数若opt=3 则为操作3，之后有两个数pos,k 表示将pos位置的数修改为k若opt=4 则为操作4，之后有三个数l,r,k 表示查询区间[l,r]内k的前驱若opt=5 则为操作5，之后有三个数l,r,k 表示查询区间[l,r]内k的后继【输出格式】对于操作1,2,4,5各输出一行，表示查询结果【输入样例】9 64 2 2 1 9 4 0 1 12 1 4 33 4 102 1 4 31 2 5 94 3 9 55 2 8 5【输出样例】24349 分析1其他伸展树 第一次树套树，第一次代码行数300+ 线段树关键字：位置关系伸展树关键字：大小关系 n=m=50000，num=100000000logn=16，lognum=27建树2n颗，nlogn个节点，时间nlogn 接下来分析几个操作：1.查排名，(区间logn)*(前驱logn)=256，（每个完整子区间中k的排名-1）之和+12.找数字，(二分lognum)*(区间logn)*(后继logn)=6912，调用操作1，二分数字，验证3.改数字，2*(深度logn)*(伸展操作logn)=512，删除，添加4.5.前驱后继，(区间logn)*(前驱后继logn)=256，每个完整子区间中k的前驱后继的极值总时间：极限200000000即3s 从线段树的角度看：每个区间一个线段树从Splay的角度看：所有的Splay都挂在超级根节点Root上，注意我采取某些手段避免了Root向下认儿子 代码1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=50000+10;const int NUL=-1;const int Root=0;const int INF=0x7fffffff;//*******************Splay1-基础操作*******************struct pt&#123; int son[2],f; int d; int n,c; pt() &#123; son[0]=son[1]=f=NUL; &#125;&#125;p[30*MAXN];int ln=0;void update(int x)&#123; p[x].c=p[x].n; int lc=p[x].son[0],rc=p[x].son[1]; if(lc!=NUL) p[x].c+=p[lc].c; if(rc!=NUL) p[x].c+=p[rc].c;&#125;void rotate(int x,int w)&#123; int f=p[x].f,ff=p[f].f; if(ff!=Root) &#123; if(p[ff].son[0]==f) p[ff].son[0]=x; else p[ff].son[1]=x; &#125; p[x].f=ff; int xson=p[x].son[w]; if(xson!=NUL) p[xson].f=f; p[f].son[1-w]=xson; p[x].son[w]=f; p[f].f=x; update(f); update(x);&#125;void add(int d,int f)&#123; ln++; p[ln].d=d;p[ln].f=f; p[ln].n=p[ln].c=1; p[ln].son[0]=p[ln].son[1]=NUL; if(f!=Root) &#123; if(d&lt;p[f].d) p[f].son[0]=ln; else p[f].son[1]=ln; &#125;&#125;//*******************Splay2-与根有关*******************int root[2*MAXN];void splay(int r,int x,int rt)&#123; while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(ff==rt) &#123; if(p[f].son[0]==x) rotate(x,1); else rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==Root) root[r]=x;&#125;int findip(int r,int d)&#123; int x=root[r]; while(p[x].d!=d) &#123; int lc=p[x].son[0],rc=p[x].son[1]; if(d&lt;p[x].d) &#123; if(lc!=NUL) x=lc; else break; &#125; else &#123; if(rc!=NUL) x=rc; else break; &#125; &#125; return x;&#125;void ins(int r,int d)&#123; if(root[r]==NUL) &#123; add(d,Root); root[r]=ln; &#125; else &#123; int x=findip(r,d); if(p[x].d==d) &#123; p[x].n++; splay(r,x,Root); &#125; else &#123; add(d,x); splay(r,ln,Root); &#125; &#125;&#125;void del(int r,int d)&#123; int x=findip(r,d); if(p[x].d!=d) return; splay(r,x,Root); if(p[x].n&gt;1) &#123; p[x].n--; update(x); &#125; else &#123; int lc=p[x].son[0],rc=p[x].son[1]; if(lc==NUL and rc==NUL) &#123; root[r]=NUL; &#125; else if(lc!=NUL and rc==NUL) &#123; root[r]=lc; p[lc].f=Root; &#125; else if(lc==NUL and rc!=NUL) &#123; root[r]=rc; p[rc].f=Root; &#125; else &#123; int w=lc;while(p[w].son[1]&gt;0) w=p[w].son[1]; splay(r,w,x);root[r]=w;p[w].f=Root; p[w].son[1]=rc;p[rc].f=w; update(w); &#125; &#125;&#125;int findQ(int r,int d)&#123; int x=findip(r,d);splay(r,x,Root); if(p[x].d&gt;=d and p[x].son[0]!=NUL) &#123; x=p[x].son[0]; while(p[x].son[1]!=NUL) x=p[x].son[1]; &#125; if(p[x].d&lt;d) return p[x].d; return -INF;&#125;int findH(int r,int d)&#123; int x=findip(r,d);splay(r,x,Root); if(p[x].d&lt;=d and p[x].son[1]!=NUL) &#123; x=p[x].son[1]; while(p[x].son[0]!=NUL) x=p[x].son[0]; &#125; if(p[x].d&gt;d) return p[x].d; return INF;&#125;int findbf(int r,int d)//更小的&#123; int x=findip(r,d);splay(r,x,Root); int lc=p[x].son[0]; if(p[x].d==d) return p[ (lc==NUL)?0:lc ].c; if(p[x].d&gt;d and lc!=NUL) &#123; x=lc; while(p[x].son[1]!=NUL) x=p[x].son[1]; &#125; if(p[x].d&lt;d) &#123; splay(r,x,Root);lc=p[x].son[0]; return p[ (lc==NUL)?0:lc ].c+p[x].n; &#125; else return 0;&#125;//*******************线段树*******************int num[MAXN];struct mg&#123; int l,r; int lc,rc;&#125;s[2*MAXN];int len=0;int build(int l,int r)&#123; int t=++len;s[t].l=l;s[t].r=r; for(int i=l;i&lt;=r;i++) ins(t,num[i]); //把t作为根节点的下标 if(l==r) s[t].lc=s[t].rc=NUL; else &#123; int mid=(l+r)/2; s[t].lc=build(l,mid); s[t].rc=build(mid+1,r); &#125; return t;&#125;void change(int x,int pos,int yd,int d)//改数字&#123; del(x,yd);ins(x,d); if(s[x].l==s[x].r) return; int mid=(s[x].l+s[x].r)/2; if( pos&lt;=mid ) change(s[x].lc,pos,yd,d); else change(s[x].rc,pos,yd,d);&#125;//*******************接口*******************int solve1(int x,int l,int r,int d)//查排名&#123; if(s[x].l==l and s[x].r==r) return findbf(x,d); int lc=s[x].lc,rc=s[x].rc,mid=(s[x].l+s[x].r)/2; if(r&lt;=mid) return solve1(lc,l,r,d); if(l&gt;mid) return solve1(rc,l,r,d); return solve1(lc,l,mid,d)+solve1(rc,mid+1,r,d);&#125;int solve2(int l,int r,int k)//找数字&#123; int ll=0,rr=100000000,ans=-1; //满足运用二分的条件，因为数字与排名成正比 while(ll&lt;=rr) &#123; int mid=(ll+rr)/2,rk=solve1(1,l,r,mid)+1; if(rk&lt;=k) ans=mid,ll=mid+1; else rr=mid-1; &#125; return ans;&#125;int solve4(int x,int l,int r,int d)//前驱&#123; if(s[x].l==l and s[x].r==r) &#123; int t=findQ(x,d); return (t==NUL)?0:t; &#125; int lc=s[x].lc,rc=s[x].rc,mid=mid=(s[x].l+s[x].r)/2; if(r&lt;=mid) return solve4(lc,l,r,d); if(l&gt;mid) return solve4(rc,l,r,d); return mymax( solve4(lc,l,mid,d),solve4(rc,mid+1,r,d) );&#125;int solve5(int x,int l,int r,int d)//后继&#123; if(s[x].l==l and s[x].r==r) &#123; int t=findH(x,d); return (t==NUL)?0x3f3f3f3f:t; &#125; int lc=s[x].lc,rc=s[x].rc,mid=(s[x].l+s[x].r)/2; if(r&lt;=mid) return solve5(lc,l,r,d); if(l&gt;mid) return solve5(rc,l,r,d); return mymin( solve5(lc,l,mid,d),solve5(rc,mid+1,r,d) );&#125;//*******************主函数*******************int main()&#123; memset(root,NUL,sizeof(root)); int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;num[i]); build(1,n); while(m--) &#123; int op;scanf("%d",&amp;op); if(op==3) &#123; int pos,d;scanf("%d%d",&amp;pos,&amp;d); change(1,pos,num[pos],d);num[pos]=d; &#125; else &#123; int l,r,k;scanf("%d%d%d",&amp;l,&amp;r,&amp;k); if(op==1) printf("%d\n",solve1(1,l,r,k)+1); if(op==2) printf("%d\n",solve2(l,r,k)); if(op==4) printf("%d\n",solve4(1,l,r,k)); if(op==5) printf("%d\n",solve5(1,l,r,k)); &#125; &#125;&#125; 分析2然鹅Bzoj的评论里面有这样几句话：“用平衡树的都是二逼青年”“有智慧的长者都写主席树”so，依旧被D飞赶紧复习一波主席树 哦补充一下，我在打的时候突然想到一个问题：假如r的lowbit覆盖了l-1,那么它不就会turn两次了？后来经提醒发现，这种turn两次的情况理论上虽然是错的，但因为他们都是被覆盖两次的，所以求前缀和的时候刚好抵消了…… 优点就是少了一百行……，速度还快了三倍！ 代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207//Zory-2018//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量*******************const int MAXN=50010,MAXM=50010;const int INF=0x7fffffff;//*******************全局定义*******************int n;int rx;int num[MAXN+MAXM];int now[MAXN];//*******************主席树******************struct Nod&#123; int c; int lc,rc; Nod() &#123;c=lc=rc=0;&#125;&#125;p[MAXN*20*10];int rt[MAXN];int ust[MAXN];int cnt=0;void add(int &amp;x,int l,int r,int pos,int c)&#123; if(!x) x=++cnt; p[x].c+=c; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) add(p[x].lc,l,mid,pos,c); else add(p[x].rc,mid+1,r,pos,c);&#125;//*******************树状数组******************int lowbit(int x) &#123;return x&amp;(-x);&#125;void change(int x,int pos,int c)&#123; while(x&lt;=n) &#123; add(rt[x],1,rx,pos,c); x+=lowbit(x); &#125;&#125;int getlsum(int x)&#123; int s=0; while(x&gt;=1) &#123; s+=p[ p[ust[x]].lc ].c; x-=lowbit(x); &#125; return s;&#125;int getsum(int x)&#123; int s=0; while(x&gt;=1) &#123; s+=p[ust[x]].c; x-=lowbit(x); &#125; return s;&#125;int getrsum(int x)&#123; int s=0; while(x&gt;=1) &#123; s+=p[ p[ust[x]].rc ].c; x-=lowbit(x); &#125; return s;&#125;void turn(int x,int tn)&#123; while(x&gt;=1) &#123; if(tn==0) ust[x]=rt[x]; if(tn==-1) ust[x]=p[ ust[x] ].lc; if(tn==1) ust[x]=p[ ust[x] ].rc; x-=lowbit(x); &#125;&#125;//*******************实现******************struct Qes&#123; int op; int x,y,k;&#125;q[MAXM];int qian;int ask1(int x,int y,int l,int r,int k)&#123; if(l==r) return qian; int mid=(l+r)&gt;&gt;1; if(k&lt;=mid) &#123; turn(x-1,-1);turn(y,-1); return ask1(x,y,l,mid,k); &#125; else &#123; qian+=getlsum(y)-getlsum(x-1); turn(x-1,1);turn(y,1); return ask1(x,y,mid+1,r,k); &#125;&#125;int solve1(int l,int r,int k)//k在区间内的排名&#123; turn(l-1,0);turn(r,0); qian=0; return ask1(l,r,1,rx,k)+1;&#125;int ask2(int x,int y,int l,int r,int k)&#123; if(l==r) return num[l]; int ls=getlsum(y)-getlsum(x-1); int mid=(l+r)&gt;&gt;1; if(k&lt;=ls) &#123; turn(x-1,-1);turn(y,-1); return ask2(x,y,l,mid,k); &#125; else &#123; turn(x-1,1);turn(y,1); return ask2(x,y,mid+1,r,k-ls); &#125;&#125;int solve2(int l,int r,int k)//区间内排名为k的值&#123; turn(l-1,0);turn(r,0); return ask2(l,r,1,rx,k);&#125;void solve3(int pos,int k)//修改&#123; change(pos,now[pos],-1); now[pos]=k; change(pos,now[pos],1);&#125;int solve4(int l,int r,int k)//查询k在区间内的前驱，没有则-INF&#123; int t=solve1(l,r,k)-1; if(t==0) return -INF; return solve2(l,r,t);&#125;int solve5(int l,int r,int k)//查询k在区间内的后继，没有则INF&#123; int t=solve1(l,r,k+1)-1; if(t==(r-l+1)) return INF; return solve2(l,r,t+1);&#125;//*******************离散化******************struct Lsh&#123; int x,id,z;&#125;a[MAXN+MAXM];bool cmp(Lsh a,Lsh b) &#123;return a.x&lt;b.x;&#125;void lsh(int all)&#123; sort(a+1,a+all+1,cmp); rx=0;a[0].x=-INF; for(int i=1;i&lt;=all;i++) &#123; if(a[i-1].x!=a[i].x) num[++rx]=a[i].x;//debug if(a[i].id&lt;=n) a[a[i].id].z=rx; else q[a[i].id-n].k=rx; &#125;&#125;//*******************主函数******************int main()&#123; int m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i].x),a[i].id=i; int all=n; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;q[i].op,&amp;q[i].x); if(q[i].op==2) scanf("%d%d",&amp;q[i].y,&amp;q[i].k); else &#123; all++; if(q[i].op!=3) scanf("%d",&amp;q[i].y); scanf("%d",&amp;a[all].x); a[all].id=n+i; &#125; &#125; lsh(all); for(int i=1;i&lt;=n;i++) now[i]=a[i].z,change(i,now[i],1); for(int i=1;i&lt;=m;i++) &#123; if(q[i].op==1) printf("%d\n",solve1(q[i].x,q[i].y,q[i].k)); if(q[i].op==2) printf("%d\n",solve2(q[i].x,q[i].y,q[i].k)); if(q[i].op==3) solve3(q[i].x,q[i].k); if(q[i].op==4) printf("%d\n",solve4(q[i].x,q[i].y,q[i].k)); if(q[i].op==5) printf("%d\n",solve5(q[i].x,q[i].y,q[i].k)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
        <tag>主席树</tag>
        <tag>线段树</tag>
        <tag>难度3</tag>
        <tag>莫队</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WZK的减肥计划]]></title>
    <url>%2Fposts%2Ff8f3.html</url>
    <content type="text"><![CDATA[来源和评测点NOIP2009 赛前集训（CZYZ2009 暑假集训提高组 5） 题目【题目大意】有 n 种食品可供 WZK 选择，每种物品都有给定的价格，卡路里和拥有数量，选出一些食品使得总卡路里大于要求量且最小，如果有多种组合满足条件， 则取价格最小的。【输入格式】第一行为两个整数 n(0&lt;n&lt;=100)，k（0&lt;k&lt;=10^5）分别表示物品个数和一天消耗的最少卡路里。接下来n行每行 3 个整数，costi，mi，cali（0&lt; costi,1&lt;=mi&lt;=100,cali&lt;10^6）分别表示价格，数量和所含卡路里。输入数据保证合法、有解。【输出格式】满足条件的总卡路里和总价格，中间用一个空格隔开。注意：保证答案的总卡路里小于 10^5，总价格小于 10^8。【输入样例】5 1010 2 65 1 96 1 69 1 65 1 9【输出样例】12 15 分析话说今天生日耶，刷个卡~ 注意，逻辑上答案应该是可以何要求值（原题为WZK的需求量）一样的，但题目确实要求大于，机房许多大佬都错了，就是因为这个，暴0时间复杂度nk，应该这个才是正解，虽然数据水体现不出来注意现在更像多重背包了重点：c也就是使用量只跟物品有关，考试时以为实现不出来 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int mymin(int a,int b) &#123;return a&lt;b?a:b;&#125;int f[100010],c[100010];int main()&#123; freopen("plan.in","r",stdin); freopen("plan.out","w",stdout); memset(f,63,sizeof(f)); f[0]=0;int mi=100000; int n,k;scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++)//100 &#123; memset(c,0,sizeof(c));//c=在这个物品下，f对应的物品使用量 int cost,m,cal;scanf("%d%d%d",&amp;cost,&amp;m,&amp;cal); for(int j=0;j&lt;=k;j++)//100000 &#123; if(c[j]&lt;m) &#123; int ca=j+cal; if(ca&gt;k and ca&lt;mi) mi=ca; if(f[j]+cost&lt;f[ca]) &#123; c[ca]=c[j]+1; f[ca]=f[j]+cost; &#125; &#125; &#125; &#125; printf("%d %d\n",mi,f[mi]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3224】普通平衡树]]></title>
    <url>%2Fposts%2Fe070.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj3224Codevs4543Caioj1130 题目【题目大意】写一种数据结构来维护一些数，其中需要提供以下操作：1. 插入数字x2. 删除数字x(若有多个相同的数，应只删除一个)3. 查询数字x的排名(若有多个相同的数，因输出最小的排名)4. 查询排名为x的数5. 求数字x的前驱(前驱定义为小于x，且最大的数)6. 求数字x的后继(后继定义为大于x，且最小的数)【输入格式】第一行为n，表示操作的个数,下面n行每行有两个数opt和x，opt表示操作的序号1&lt;=opt&lt;=6 n&lt;=100000 所有数字均在-210^9到210^9内【输出格式】对于操作3,4,5,6每行输出一个数，表示对应答案【输入样例】81 101 201 303 204 22 105 256 -1【输出样例】2202020 分析【OI之路】06树-4伸展树的模版 核心思路在于：对于某节点，左子树是关键字（在这道题中是大小关系）比该节点大的，右子树比该节点小接着在保证这个平衡（中序遍历保持不变）的情况下，进行各种操作 旋转Rotate 旋转到某节点下Splay网上的一段话: 在实际情况中，90%的访问发生在10%的数据上。因此，我们可以重构树的结构，使得被经常访问的节点朝树根的方向移动。尽管这会引入额外的操作，但是经常被访问的节点被移动到了靠近根的位置，因此，对于这部分节点，我们可以很快的访问。这样，就能使得平摊复杂度为logN。伸展树就是基于这一原理。 很多细节可以考虑大量注释 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=100000;const int Nul=-1;//空节点const int Root=0;//超级根//**********************定义*************************struct pt&#123; int son[2],f; int d;//值 int c,n;//n是同值个数，c是管理节点数（包括自己） pt() &#123; son[0]=son[1]=f=Nul;//debug &#125;&#125;p[2*MAXN];//***********************基本操作***********************void update(int x)&#123; p[x].c=p[x].n; int lc=p[x].son[0],rc=p[x].son[1]; if(lc!=Nul) p[x].c+=p[lc].c; if(rc!=Nul) p[x].c+=p[rc].c;&#125;int ln=0;void add(int d,int f)&#123; ln++; p[ln].d=d;p[ln].f=f; p[ln].c=p[ln].n=1; p[ln].son[0]=p[ln].son[1]=Nul; if(f&gt;0)//debug &#123; if(d&lt;p[f].d) p[f].son[0]=ln; else p[f].son[1]=ln; &#125;&#125;int root=Nul;//真实根int findip(int d)&#123; int x=root; while(p[x].d!=d) &#123; int lc=p[x].son[0],rc=p[x].son[1]; if(d&lt;p[x].d) &#123; if(lc!=Nul) x=lc; else break; &#125; else &#123; if(rc!=Nul) x=rc; else break; &#125; &#125; return x;&#125;//有同值返回该点，否则某叶子节点void rotate(int x,int w)//w=0 x的父亲成为x的左孩子&#123; int f=p[x].f,ff=p[f].f; if(ff&gt;0)//debug &#123; if(p[ff].son[0]==f) p[ff].son[0]=x; else if(p[ff].son[1]==f) p[ff].son[1]=x; &#125; p[x].f=ff; int xson=p[x].son[w]; p[f].son[1-w]=xson; if(xson!=Nul) p[xson].f=f; p[x].son[w]=f; p[f].f=x; update(f); update(x);&#125;void splay(int x,int rt)//x成为rt的孩子&#123; while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(ff==rt) &#123; if(p[f].son[0]==x) rotate(x,1); else if(p[f].son[1]==x) rotate(x,0); &#125; else &#123; //x不能连续跳两次，灰常容易变成链（由树退化成链表） if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==Root) root=x;&#125;//***********************功能************************void inc(int d)&#123; if(root==Nul) &#123; add(d,Root); root=ln; &#125; else &#123; int x=findip(d); if(p[x].d==d) &#123; p[x].n++; splay(x,Root); //在里面自动进行了update //询问前n不重要 &#125; else &#123; add(d,x); splay(ln,Root); //据说：90%的访问发生在10%的数据上 &#125; &#125;&#125;void del(int d)&#123; int x=findip(d); if(p[x].d!=d) return; splay(x,Root); if(p[x].n&gt;1) &#123; p[x].n--; update(x); &#125; else &#123; int lc=p[x].son[0],rc=p[x].son[1]; if(lc==Nul and rc==Nul) &#123; ln=0;root=Nul; &#125; else if(lc==Nul and rc!=Nul) &#123; root=rc; p[root].f=Root; &#125; else if(lc!=Nul and rc==Nul) &#123; root=lc; p[root].f=Root; &#125; else &#123; int k=lc; while(p[k].son[1]!=Nul) k=p[k].son[1]; splay(k,x);root=k;p[k].f=Root; p[k].son[1]=rc;p[p[x].son[1]].f=k; update(k);//debug &#125; &#125;&#125;int askrank(int d)&#123; int x=findip(d); if(p[x].d!=d) return -1; splay(x,Root); int lc=p[x].son[0],lcc=(lc==Nul)?0:p[lc].c;//debug return lcc+1;&#125;int asknum(int rk)&#123; int x=root; while(1) &#123; if(rk&gt;p[x].c) return -1; int lc=p[x].son[0],lcc=(lc==Nul)?0:p[lc].c; if(rk&lt;=lcc) x=lc; else if(rk&gt;lcc+p[x].n) rk-=lcc+p[x].n,x=p[x].son[1]; else break; &#125; splay(x,Root); return p[x].d;&#125;int findQ(int d)&#123; int x=findip(d);splay(x,Root); if(p[x].d&gt;=d and p[x].son[0]!=Nul) &#123; x=p[x].son[0]; while(p[x].son[1]&gt;0) x=p[x].son[1]; &#125; if(p[x].d&lt;d) return p[x].d; return -1;&#125;int findH(int d)&#123; int x=findip(d);splay(x,Root); if(p[x].d&lt;=d and p[x].son[1]!=Nul) &#123; x=p[x].son[1]; while(p[x].son[0]&gt;0) x=p[x].son[0]; &#125; if(p[x].d&gt;d) return p[x].d; return -1;&#125;//***********************************************int main()&#123; int n;scanf("%d",&amp;n); while(n--) &#123; int opx,x;scanf("%d%d",&amp;opx,&amp;x); if(opx==1) inc(x); if(opx==2) del(x); if(opx==3) printf("%d\n",askrank(x)); if(opx==4) printf("%d\n",asknum(x)); if(opx==5) printf("%d\n",findQ(x)); if(opx==6) printf("%d\n",findH(x)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Ural1028】【Vijos1066】弱弱的战壕]]></title>
    <url>%2Fposts%2F5d1d.html</url>
    <content type="text"><![CDATA[来源和评测点Problem Author: Pavel ZaletskyProblem Source: Ural Collegiate Programming Contest ‘99Ural1028Vijos1066 题目【题目大意】永恒和mx正在玩一个即时战略游戏，名字嘛~~恕本人记性不好，忘了。mx在他的基地附近建立了n个战壕，每个战壕都是一个独立的作战单位，射程可以达到无限。但是，战壕有一个弱点，就是只能攻击它的左下方，说白了就是横纵坐标都不大于它的点（mx：“我的战壕为什么这么菜”ToT）。这样，永恒就可以从别的地方进攻摧毁战壕，从而消灭mx的部队。战壕都有一个保护范围，同它的攻击范围一样，它可以保护处在它左下方的战壕。所有处于它保护范围的战壕都叫做它的保护对象。这样，永恒就必须找到mx的战壕中保护对象最多的点，从而优先消灭它。现在，由于永恒没有时间来计算，所以拜托你来完成这个任务：给出这n个战壕的坐标xi、yi，要你求出保护对象个数为0，1，2……n-1的战壕的个数。【输入格式】第一行，一个正整数n（1&lt;=n&lt;=15000）接下来n行，每行两个数xi,yi，代表第i个点的坐标（1&lt;=xi,yi&lt;=32000）注意：可能包含多重战壕的情况（即有数个点在同一坐标）【输出格式】输出n行，分别代表保护对象为0，1，2……n-1的战壕的个数。【输入样例】51 15 17 13 35 5【输出样例】12110 分析做做难度不大但有所创新的题目还是挺好的先排序一遍确保形如这样123* - **** ****** ***** *** 按顺序处理就保证了y更小接着用树状数组维护x的前缀和即可 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//Zory-2017//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=15000;//*******************全局定义*******************struct pt&#123; int x,y;&#125;p[MAXN+10];//*******************接口*******************int lowbit(int x) &#123;return x&amp;-x;&#125;int s[32000+10];void add(int f)&#123; while(f&lt;=32001) &#123; s[f]+=1; f+=lowbit(f); &#125;&#125;int ask(int r)&#123; int sum=0; while(r&gt;0) &#123; sum+=s[r]; r-=lowbit(r); &#125; return sum;&#125;//*******************主函数*******************bool cmp(pt a,pt b)&#123; if(a.y==b.y) return a.x&lt;=b.x; return a.y&lt;=b.y; /* * - **** ***** * ***** *** */&#125;int ans[MAXN+10];int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].x,&amp;p[i].y); sort(p+1,p+1+n,cmp); for(int i=1;i&lt;=n;i++) &#123; ans[ask(p[i].x+1)]++; add(p[i].x+1); &#125; for(int i=0;i&lt;=n-1;i++) printf("%d\n",ans[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1012】最大数]]></title>
    <url>%2Fposts%2F5f48.html</url>
    <content type="text"><![CDATA[来源和评测点JSOI2008数据Bzoj1012 题目【题目大意】现在请求你维护一个数列，要求提供以下两种操作：1、 查询操作。语法：Q L 功能：查询当前数列中末尾L个数中的最大的数，并输出这个数的值。限制：L不超过当前数列的长度。2、 插入操作。语法：A n 功能：将n加上t，其中t是最近一次查询操作的答案（如果还未执行过查询操作，则t=0)，并将所得结果对一个固定的常数D取模，将所得答案插入到数列的末尾。限制：n是非负整数并且在长整范围内。注意：初始时数列是空的，没有一个数。【输入格式】第一行两个整数，M和D，其中M表示操作的个数(M &lt;= 200,000)，D如上文中所述，满足D在longint内。接下来M行，查询操作或者插入操作。【输出格式】对于每一个询问操作，输出一行。该行只有一个数，即序列中最后L个数的最大数。【输入样例】5 100A 96Q 1A 97Q 1Q 2【输出样例】969396 分析1看似插入是Splay，其实结构并没有变化。加上区间查询，考虑线段树，建树的时候保留空位就好了。 代码11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/************************************************************** Problem: 1012 User: Zory Language: C++ Result: Accepted Time:1076 ms Memory:10196 kb****************************************************************/ //Zory-2017//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=200000;//*******************全局定义*******************struct pt&#123; int l,r,mid; int lc,rc; int mx;&#125;p[MAXN*2+10];//*******************线段树*******************void change(int x,int pf,int c)&#123; if(p[x].l==p[x].r) &#123; p[x].mx=c; return; &#125; int lc=p[x].lc,rc=p[x].rc; if(pf&lt;=p[x].mid) change(lc,pf,c); else change(rc,pf,c); p[x].mx=mymax(p[lc].mx,p[rc].mx);&#125;int ask(int x,int l,int r)&#123; if(p[x].l==l and p[x].r==r) return p[x].mx; int lc=p[x].lc,rc=p[x].rc; int mid=p[x].mid; if(r&lt;=mid) return ask(lc,l,r); else if(l&gt;mid) return ask(rc,l,r); else return mymax( ask(lc,l,mid),ask(rc,mid+1,r) );&#125;//*******************接口*******************int ln=0;int build(int l,int r)&#123; int t=++ln; p[t].l=l;p[t].r=r;p[t].mid=(l+r)/2; p[t].mx=0; if(l==r) p[t].lc=p[t].rc=-1; else &#123; p[t].lc=build(l,p[t].mid); p[t].rc=build(p[t].mid+1,r); &#125; return t;&#125;//*******************主函数*******************char s[5];int main()&#123; int m,D;scanf("%d%d",&amp;m,&amp;D); build(1,m);int len=0,t=0; while(m--) &#123; int a;scanf("%s%d",s,&amp;a); if(s[0]=='Q') &#123; t=ask(1,len-a+1,len); printf("%d\n",t); &#125; else change(1,++len,(a+t)%D); &#125;&#125; 分析2然后看到了六个月前的代码，原来暴力还更快…… 代码21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/************************************************************** Problem: 1012 User: Zory Language: C++ Result: Accepted Time:468 ms Memory:2384 kb****************************************************************/ #include&lt;cstdio&gt;//#include&lt;cstdlib&gt;//#include&lt;cstring&gt;//#include&lt;cctype&gt;//#include&lt;cmath&gt;//#include&lt;ctime&gt;//#include&lt;queue&gt;//#include&lt;iostream&gt;//#include&lt;string&gt;//#include&lt;iomanip&gt;//#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int mymax(int a,int b)&#123; return a&gt;b?a:b;&#125;int mymin(int a,int b)&#123; return a&gt;b?b:a;&#125;//*******************实现*******************char s[5];int a[200010],mx[200010];int main(int argc, char *argv[])&#123; int m,p;scanf("%d%d",&amp;m,&amp;p); int len=0,k=0; for(int i=1;i&lt;=m;i++) &#123; int t; scanf("%s %d",s,&amp;t); if(s[0]=='A') &#123; a[++len]=(t+k)%p; for(int j=len;j;j--) if(mx[j]&lt;a[len]) mx[j]=a[len]; else break;//剪枝 &#125; else printf("%d\n",k=mx[len-t+1]); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CZYZ2009暑假集训提高组6】盟军敢死队]]></title>
    <url>%2Fposts%2F310b.html</url>
    <content type="text"><![CDATA[来源和评测点CZYZ2009暑假集训提高组6 题目【题目大意】仓库是一个 m*n的矩形区域， 每一格用一个字符来描述：“.” 代表空地; “#”代表墙或障碍物;“^”, “v”(小写), “&lt;”, “&gt;”四个字符分别表示正向 NSWE 四个方向看的敌人。敌人总是保持固定不动并朝着一个方向看，从这个方向一直延伸直到边界或障碍物的区域是他的视线范围，如果一个敌人没有在任何人的视线范围之内，敢死队员就可以消灭他。你不能消灭一个正在另一个活着的敌人视线范围内的敌人，否则你就会被发现，后果不堪设想。一个敌人不会成为遮挡视线的障碍物。【输入格式】输入数据的第一行是用空格分开的两个整数 n,m ，分别表示仓库的长和宽。接下来有 n行，每行 m个字符，是仓库的描述。100%的数据中，1&lt;=m, n&lt;=6090%的数据中，敌人数不超过 10100%的数据中，敌人数不超过 15【输出格式】如果能够成功消灭所有敌人，输出消灭所有敌人的不同顺序的数量，否则输出“Impossible” （不含引号）。【输入样例1】2 2&gt;^#^【输出样例1】2【输入样例2】1 3&gt;.&lt;【输出样例2】Impossible 分析挺好的状压题注释很详细“一看数据范围就知道是状压”话说有的人一看就觉得是暴力，其实也有道理事实上时间是压着过去的 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;//**********************************************struct pr&#123; int x,y; int tr;&#125;p[20];int pn;bool rd[20][20];//i能否看到j//**********************************************int mp[100][100];//**********************************************int f[1&lt;&lt;15];//状态方案数bool chw[20][1&lt;&lt;15];//j状态下能否杀i//状态用二进制表示，1就是死了//**********************************************char s[100];int bin[21];int main()&#123; pn=0;memset(rd,0,sizeof(rd));memset(chw,0,sizeof(chw)); bin[1]=1;for(int i=2;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; //稍微改了一下，不是2^i而是对应第i个敌人 int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",s+1); for(int j=1;j&lt;=m;j++) &#123; if(s[j]=='.') mp[i][j]=1; else if(s[j]=='#') mp[i][j]=0; else &#123; pn++;p[pn].x=i;p[pn].y=j; mp[i][j]=10+pn; if(s[j]=='^') p[pn].tr=2; if(s[j]=='v') p[pn].tr=3; if(s[j]=='&lt;') p[pn].tr=4; if(s[j]=='&gt;') p[pn].tr=5; &#125; &#125; &#125; for(int i=1;i&lt;=pn;i++) &#123; int x=p[i].x,y=p[i].y; while(1) &#123; if(p[i].tr==2) x--;if(p[i].tr==3) x++; if(p[i].tr==4) y--;if(p[i].tr==5) y++; if(mp[x][y]==0 or x&lt;=0 or y&lt;=0 or x&gt;n or y&gt;m) break; if(mp[x][y]&gt;10) rd[i][mp[x][y]-10]=1; &#125; &#125; int full=(1&lt;&lt;pn)-1;//圆满状态 for(int i=1;i&lt;=pn;i++)//被看者 &#123; for(int j=0;j&lt;=full;j++)//状态 &#123; if( (j&amp;bin[i])!=0 ) continue;//已经死了 bool bk=1; for(int k=1;k&lt;=pn;k++)//看者 &#123; if( (j&amp;bin[k])==0 and i!=k ) bk=!rd[k][i]; if(!bk) break; &#125; chw[i][j]=bk; &#125; if(chw[i][0]) f[bin[i]]++;//单杀 &#125; for(int i=0;i&lt;=full;i++) for(int j=1;j&lt;=pn;j++) if((i&amp;bin[j])!=0 and chw[j][i^bin[j]]==1)//任杀 f[i]+=f[i^bin[j]]; if(f[full]&gt;0) printf("%d",f[full]); else printf("Impossible");&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CZYZ2009暑假集训提高组6】魔兽争霸]]></title>
    <url>%2Fposts%2Fc201.html</url>
    <content type="text"><![CDATA[来源和评测点CZYZ2009暑假集训提高组6 题目【题目大意】小 x 正在销魂地玩魔兽他正控制着死亡骑士和 n个食尸鬼(编号 1～n)去打猎死亡骑士有个魔法，叫做“死亡缠绕” ，可以给食尸鬼补充 HP战斗过程中敌人会对食尸鬼实施攻击，食尸鬼的 HP 会减少小 x 希望随时知道自己部队的情况， 即 HP 值第 k 多的食尸鬼有多少 HP， 以便决定如何施放魔法请同学们帮助他:)小 x 向你发出 3种信号： （下划线在输入数据中表现为空格）A_i_a 表示敌军向第 i 个食尸鬼发出了攻击，并使第 i 个食尸鬼损失了 a 点 HP，如果它的 HP&lt;=0,那么这个食尸鬼就死了(Undead 也是要死的„„)。敌军不会攻击一个已死的食尸鬼。C_i_a 表示死亡骑士向第i 个食尸鬼放出了死亡缠绕，并使其增加了a点HP。 HP 值没有上限。死亡骑士不会向一个已死的食尸鬼发出死亡缠绕Q_k 表示小 x 向你发出询问【输入格式】第一行，一个正整数 n以后 n个整数 表示 n个食尸鬼的初始 HP 值接着一个正整数 m以下 m行 每行一个小 x 发出的信号40%的数据 n&lt;=3000 m&lt;=500070%的数据 n&lt;=8000 m&lt;=10000100%的数据 n&lt;=30000 m&lt;=5000090%的数据随机生成食尸鬼 HP 没有上限数据保证任意时刻食尸鬼的 HP 值在 longint范围内数据保证 A 和 C 命令中的食尸鬼是活着的输入数据中没有多余空格、换行【输出格式】对于小 x 的每个询问， 输出 HP 第 k 多的食尸鬼有多少 HP，如果食尸鬼总数不足 k 个，输出-1。每个一行数。最后一行输出一个数：战斗结束后剩余的食尸鬼数【输入样例】51 2 34 510Q 2A 4 6C 1 4Q 2A 2 1A 3 3A 1 3Q 4C 2 10Q 1【输出样例】45-1113 分析这道题还是挺有趣的利用了Splay的灵活性当时是比赛吧，写了200+行感觉思路完全是错的因为节点编号会换，差点心态爆炸想放弃冷静一想，毕竟是人发明的东西，那就可以改造我是用了一个数组存储对应的真实编号（后来看别人的代码，其实存着每个HP就好了……） 难度并不算太大，就不讲什么了，看代码吧 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=80000;int hh[MAXN+10];//**********************************************struct pt&#123; int son[2],f; int d,c,n; pt() &#123; son[0]=son[1]=-1; f=0; d=0; c=n=1; &#125;&#125;p[MAXN+10];//**********************************************void update(int x)&#123; p[x].c=p[x].n; int lc=p[x].son[0],rc=p[x].son[1]; if(lc&gt;0) p[x].c+=p[lc].c; if(rc&gt;0) p[x].c+=p[rc].c;&#125;void rotate(int x,int w)&#123; int f=p[x].f,ff=p[f].f; int xson=p[x].son[w]; if(xson&gt;0) p[xson].f=f; p[f].son[1-w]=xson; if(p[ff].son[0]==f) p[ff].son[0]=x; else if(p[ff].son[1]==f) p[ff].son[1]=x; p[x].f=ff; p[x].son[w]=f; p[f].f=x; update(f); update(x);&#125;int root;void splay(int x,int rt)&#123; while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(ff==rt) &#123; if(p[f].son[0]==x) rotate(x,1); else if(p[f].son[1]==x) rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==0) root=x;&#125;int findip(int d)&#123; int x=root; while(p[x].d!=d) &#123; if(d&gt;p[x].d) &#123; int lc=p[x].son[0]; if(lc&lt;0) return x; x=lc; &#125; else &#123; int rc=p[x].son[1]; if(rc&lt;0) return x; x=rc; &#125; &#125; return x;&#125;int len;void add(int f,int d)&#123; len++;p[len].f=f; p[len].son[0]=p[len].son[1]=-1; p[len].c=p[len].n=1;p[len].d=d; if(d&gt;p[f].d) p[f].son[0]=len; else p[f].son[1]=len;&#125;void addnum(int hk,int d)&#123; if(root==0) &#123; root=++len;p[len].f=0; p[len].son[0]=p[len].son[1]=-1; p[len].c=p[len].n=1;p[len].d=d; hh[hk]=len;// &#125; else &#123; int x=findip(d); if(p[x].d==d) &#123; p[x].n++; update(x); hh[hk]=x;// &#125; else &#123; add(x,d); update(x); hh[hk]=len;// &#125; splay(x,0); &#125;&#125;void del(int d)&#123; int x=findip(d); if(p[x].n&gt;1) &#123; p[x].n--; update(x); splay(x,0); &#125; else &#123; splay(x,0); if(p[x].son[0]==-1 and p[x].son[1]==-1) &#123; len=0;root=0; &#125; else if(p[x].son[0]&gt;0 and p[x].son[1]==-1) &#123; root=p[x].son[0]; p[root].f=0; &#125; else if(p[x].son[0]==-1 and p[x].son[1]&gt;0) &#123; root=p[x].son[1]; p[root].f=0; &#125; else &#123; int k=p[x].son[0]; while(p[k].son[1]&gt;0) k=p[k].son[1]; p[k].son[1]=p[x].son[1]; p[p[x].son[0]].f=0; p[p[x].son[1]].f=k; update(k);splay(k,0); &#125; &#125;&#125;//**********************************************int asknum(int k)&#123; int x=root; if(k&gt;p[x].c) return -1; while(x&gt;0) &#123; int lc=p[x].son[0]; int lcc=lc&gt;0?p[lc].c:0; if(k&lt;=lcc) x=lc; else if(k&gt;lcc+p[x].n) k-=lcc+p[x].n,x=p[x].son[1]; else &#123; splay(x,0); return p[x].d; &#125; &#125; return -2;&#125;void solve1(int k,int a)//-&#123; int d=p[ hh[k] ].d; del(d); if(d-a&gt;0) addnum(k,d-a);&#125;void solve2(int k,int a)//+&#123; int d=p[ hh[k] ].d; del(d); addnum(k,d+a);&#125;//**********************************************char s[10];int main()&#123; len=0;root=0; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int t; scanf("%d",&amp;t); addnum(i,t); &#125; int m;scanf("%d",&amp;m); while(m--) &#123; int a;scanf("%s%d",s,&amp;a); if(s[0]=='Q') printf("%d\n",asknum(a)); else &#123; int b;scanf("%d",&amp;b); if(s[0]=='A') solve1(a,b); else solve2(a,b); &#125; &#125; printf("%d",p[root].c);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3223】文艺平衡树]]></title>
    <url>%2Fposts%2F77a.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj3223Codevs3303Caioj1134 题目【题目大意】写一种数据结构，来维护一个有序数列，其中需要提供以下操作：翻转一个区间，例如原有序序列是5 4 3 2 1，翻转区间是[2,4]的话，结果是5 2 3 4 1【输入格式】第一行为n,mn表示初始序列有n个数，这个序列依次是(1,2……n-1,n)m表示翻转操作次数，接下来m行每行两个数[l,r]数据保证 1&lt;=l&lt;=r&lt;=n（n,m &lt; =100000）【输出格式】输出一行n个数字，表示原始序列经过m次变换后的结果【输入样例】5 31 31 31 4【输出样例】4 3 2 1 5 分析这道题建议自己多出几个小数据检验主要就是利用伸展树这种比较灵活的数据结构来维护数列中序遍历就是当前的状态通过标记实现翻转 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157//Zory-2017//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=100000;//*******************全局定义*******************struct pt&#123; int son[2],f; int c; bool fz; pt() &#123; c=0;fz=0; son[0]=son[1]=f=-1; &#125;&#125;p[MAXN+10];//*******************伸展树*******************void update(int x)&#123; p[x].c=1; int lc=p[x].son[0],rc=p[x].son[1]; if(lc&gt;0) p[x].c+=p[lc].c; if(rc&gt;0) p[x].c+=p[rc].c;&#125;void rev(int x)&#123; if(p[x].fz==0) return;p[x].fz=0; swap(p[x].son[0],p[x].son[1]); int lc=p[x].son[0],rc=p[x].son[1]; if(lc&gt;0) p[lc].fz^=1; if(rc&gt;0) p[rc].fz^=1;&#125;void rotate(int x,int w)&#123; int f=p[x].f,ff=p[f].f; int pson=p[x].son[w]; if(pson&gt;0) p[pson].f=f; p[f].son[1-w]=pson; if(p[ff].son[0]==f) p[ff].son[0]=x; else if(p[ff].son[1]==f) p[ff].son[1]=x; p[x].f=ff; p[x].son[w]=f; p[f].f=x; update(f); update(x);&#125;int root;int t[MAXN+10];void splay(int x,int rt)&#123; int s=0,i=x; while(p[i].f!=rt) t[++s]=i,i=p[i].f; t[++s]=rt; while(s&gt;0) rev(t[s--]); while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(p[f].f==rt) &#123; if(p[f].son[0]==x) rotate(x,1); else if(p[f].son[1]==x) rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==0) root=x;&#125;int findrank(int rk)&#123; int x=root; while(x&gt;0) &#123; rev(x); int lcc=p[x].son[0]&lt;0?0:p[p[x].son[0]].c; if(rk&lt;=lcc) x=p[x].son[0]; else if(rk==lcc+1) return x; else x=p[x].son[1],rk-=lcc+1; &#125;&#125;//*******************接口*******************int n;void buildtree()&#123; root=1; p[n].f=n-1;update(n); for(int i=n-1;i&gt;=1;i--) &#123; p[i].f=i-1; p[i].son[1]=i+1; update(i); &#125; p[0].son[1]=1;&#125;void solve(int l,int r)&#123; if(l==1 and r==n) &#123; p[root].fz^=1; &#125; else if(l==1 and r&lt;n) &#123; int y=findrank(r+1); splay(y,0); p[p[y].son[0]].fz^=1; &#125; else if(l&gt;1 and r==n) &#123; int x=findrank(l-1); splay(x,0); p[p[x].son[1]].fz^=1; &#125; else &#123; int x=findrank(l-1); int y=findrank(r+1); splay(x,0); splay(y,x); p[p[y].son[0]].fz^=1; &#125;&#125;void pf(int x)&#123; if(x&lt;0) return; rev(x); pf(p[x].son[0]); printf("%d ",x); pf(p[x].son[1]);&#125;//*******************主函数*******************int main()&#123; int m;scanf("%d%d",&amp;n,&amp;m); buildtree(); while(m--) &#123; int l,r;scanf("%d%d",&amp;l,&amp;r); if(l&gt;r) swap(l,r);solve(l,r); &#125; pf(root);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu2867】大广场Big Square]]></title>
    <url>%2Fposts%2F4b65.html</url>
    <content type="text"><![CDATA[来源和评测点USACO06 NOVLuogu2867 题目【题目大意】农民 John 的牛参加了一次和农民 Bob 的牛的竞赛。他们在区域中画了一个N乘N 的正方形点阵，两个农场的牛各自占据了一些点。当然不能有两头牛处于同一个点。农场的目标是用自己的牛作为4个顶点，形成一个面积最大的正方形(不必须和边界平行) 。除了 Bessie 以外，FJ其他的牛都已经放到点阵中去了，要确定bessie放在哪个位置，能使得农民约翰的农场得到一个最大的正方形(Bessie不是必须参与作为正方形的四个顶点之一)。【输入格式】第一行是N接下来是一个N乘N的矩阵，字符解释:‘J’ John 的牛,‘B’ Bob 的牛,‘*‘ 空点。数据保证至少一个空点【输出格式】面积，如果没有就输出0【输入样例】6J*J*********J***J*********B*********【输出样例】4 分析随便用暴力做，居然过了……难点就是已知对角线上两个点求出正方形另外两个点 膜师兄时大概用了高中向量的知识，但也挺好理解的，就是“固定方向固定距离”？ 假如有两个点$(a,b)和(c,d)$，把他们作为对角线先计算出中点$(mx=\frac{a+c}{2},my=\frac{b+d}{2})$计算出两点间向量$(fx=\frac{a-c}{2},fy=\frac{b-d}{2})$向量反转，另外两点分别为$(qx=mx+(-fy),qy=my+(fx))和(mx+(fy),my+(-fx))$面积则是$( \sqrt{ (a-qx)^2+(b-qy)^2 })^2=(a-qx)^2+(b-qy)^2$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;const int MAXN=150;struct nod&#123; int x,y;&#125;p[MAXN*MAXN];//已经使用的点int ptn=0;//数量int mp[MAXN][MAXN];int n;//判断x是不是整数y，我随便打的。。不是很严谨bool dint(double x,int y)&#123; double ty=y; return ty-0.001&lt;=x and x&lt;=ty+0.001;//在大致区间内&#125;int ans=0;void solve()&#123; for(int i=1;i&lt;=ptn;i++) &#123; for(int j=1;j&lt;=i-1;j++)//枚举互为对角线的点 &#123; double a=p[i].x,b=p[i].y;//点1 double c=p[j].x,d=p[j].y;//点2 double mx=(a+c)/2.0,my=(b+d)/2.0;//中点 double fx=(a-c)/2.0,fy=(b-d)/2.0;//向量 double qx=mx+(-fy),qy=my+(fx); if(qx&lt;1 or qx&gt;n) continue;if(qy&lt;1 or qy&gt;n) continue; double wx=mx+(fy),wy=my+(-fx); if(wx&lt;1 or wx&gt;n) continue;if(wy&lt;1 or wy&gt;n) continue; //理论做法：取中间向量，并应用在中点上 //由于初三还没正式学向量，不严谨 if(qx==wx and qy==wy) continue; int ax=int(qx+0.5),ay=int(qy+0.5);//注意四舍五入 int bx=int(wx+0.5),by=int(wy+0.5); if(!dint(qx,ax)) continue;//不是整点 if(!dint(qy,ay)) continue;//不是整点 if(!dint(wx,bx)) continue;//不是整点 if(!dint(wy,by)) continue;//不是整点 int qm=mp[ax][ay],wm=mp[bx][by];//状态 if(qm==1 or wm==1) continue;//被占用 if(qm==0 and wm==0) continue;//贝西只有一个…… double sq=(a-qx)*(a-qx)+(b-qy)*(b-qy);//面积 ans=mymax(sq,ans); &#125; &#125;&#125;char s[MAXN];int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",s+1); for(int j=1;j&lt;=n;j++) &#123; if(s[j]=='*') mp[i][j]=0; if(s[j]=='B') mp[i][j]=1; if(s[j]=='J') &#123; ptn++; p[ptn].x=i;p[ptn].y=j; mp[i][j]=2; &#125; &#125; &#125; solve(); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu3005】槽的游戏The Trough Game]]></title>
    <url>%2Fposts%2F1444.html</url>
    <content type="text"><![CDATA[来源和评测点USACO10 DECLuogu3005 题目【题目大意】农夫约翰在谷仓里藏起来了N（1&lt;=N&lt;=20）个槽，并且他已经把其中的一些装上了食物。贝西以“在这个表里（表由贝西提供）有多少个槽里有食物？”的形式问了M（1&lt;=M&lt;=100）个问题。现在，贝西想知道，哪几个槽里有食物？【输入格式】第一行是N、M后面M行，每行一个长度为N的01串，表示一个询问是否包含这个槽然后是一个数字，表示回答【输出格式】如果可行，输出长度为N的01串，表示槽的状态如果没有满足的方案，输出’IMPOSSIBLE’如果方案不唯一，输出’NOT UNIQUE’【输入样例】4 41000 10110 11001 10011 1【输出样例】1010 分析1这题一看数据输入输出就想到矩阵乘法提问（m×n）（只有0、1）真实（n×1）（只有0、1）回答（m×1）假如提问*真实=回答，则可行，然后暴力搜索枚举出真实状况，然鹅这只能拿60分 代码1这是TLE的，供参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;struct matrix&#123; int row,col; int a[120][120]; matrix() &#123; memset(a,0,sizeof(a)); &#125;&#125;;matrix cheng(matrix a,matrix b)&#123; matrix c; c.row=a.row;c.col=b.col; for(int i=1;i&lt;=c.row;i++) for(int j=1;j&lt;=c.col;j++) for(int k=1;k&lt;=a.col;k++) c.a[i][j]+=a.a[i][k]*b.a[k][j]; return c;&#125;bool same(matrix a,matrix b)&#123; if(a.row!=b.row) return 0; if(a.col!=b.col) return 0; for(int i=1;i&lt;=a.row;i++) for(int j=1;j&lt;=a.col;j++) if(a.a[i][j]!=b.a[i][j]) return 0; return 1;&#125;int n,m;matrix a,b,c,d,ans;bool ero;void dfs(int x)&#123; if(ero) return; if(x&gt;n) &#123; d=cheng(a,b); if(same(c,d)) &#123; if(ans.row&gt;0) ero=1; else ans=b; &#125; return; &#125; b.a[x][1]=0;dfs(x+1); b.a[x][1]=1;dfs(x+1);&#125;char s[30];int main()&#123; ero=0; scanf("%d%d",&amp;n,&amp;m); a.row=m;a.col=n; b.row=n;b.col=1; c.row=m;c.col=1; for(int i=1;i&lt;=m;i++) &#123; scanf("%s",s+1); for(int j=1;j&lt;=n;j++) a.a[i][j]=s[j]-'0'; scanf("%d",&amp;c.a[i][1]); &#125; dfs(1); if(ero) printf("NOT UNIQUE"); else if(ans.row==0) printf("IMPOSSIBLE"); else for(int i=1;i&lt;=n;i++) printf("%d",ans.a[i][1]);&#125; 分析2接下来考虑剪枝：根据提问中最后一个需要的槽状态排序（所以一旦决定了那个槽，就能验证是否满足这个提问），从而边枚举边乘，达到剪枝目的 注意因为排序内容比较多，我手写了一个二分排序 A了之后忽然想到可以预处理出每添加一个槽状态所能多判断的提问区间，每次判断哪些区间的提问就好了，这样时间复杂度会少灰常多。然鹅我懒得改了，所以代码里面是从1到最后的 至于什么高斯消元……并不会 代码212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int n,m;int a[110][30],b[30],c[110];int lt[110];//提问需要最末尾槽状态int ans[30];bool ha=0;bool ero;bool cheng(int x)//被我改良后的矩阵乘法，x是确定了的槽编号&#123; int i=1; while(lt[i]&lt;=x and i&lt;=m)//区间限制 &#123; int t=0; for(int k=1;k&lt;=x;k++) t+=a[i][k]*b[k]; if(t!=c[i]) return 0; i++; &#125; return 1;&#125;void dfs(int x)&#123; if(ero) return;//多个答案 if(x&gt;1 and !cheng(x-1)) return;//边做边判断 if(x&gt;n) &#123; if(ha&gt;0) ero=1; else &#123;memcpy(ans,b,sizeof(b));ha=1;&#125; return; &#125; b[x]=0;dfs(x+1); b[x]=1;dfs(x+1);&#125;void sort2(int l,int r)//手写二分排序&#123; int x=l,y=r,mid=lt[(l+r)&gt;&gt;1]; while(x&lt;=y) &#123; while(lt[x]&lt;mid and x&lt;m) x++; while(lt[y]&gt;mid and y&gt;1) y--; if(x&gt;y) break; swap(lt[x],lt[y]);//都要交换 swap(a[x],a[y]); swap(c[x],c[y]); x++;y--; &#125; if(l&lt;y) sort2(l,y); if(x&lt;r) sort2(x,r);&#125;char s[30];int main()&#123; ero=0; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; scanf("%s",s+1); for(int j=1;j&lt;=n;j++) &#123; a[i][j]=s[j]-'0'; if(a[i][j]==1) lt[i]=j;//记录 &#125; scanf("%d",&amp;c[i]); &#125; sort2(1,m); dfs(1); if(ero) printf("NOT UNIQUE"); else if(ha==0) printf("IMPOSSIBLE"); else for(int i=1;i&lt;=n;i++) printf("%d",ans[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度2</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1783】【Luogu2975】轮流Taking Turns]]></title>
    <url>%2Fposts%2F5323.html</url>
    <content type="text"><![CDATA[来源和评测点USACO10JANLuogu2975Bzoj1783 题目【题目大意】两头奶牛Bessi和Dessie走过一条路吃草，共n（n&lt;=700,000）个格子，第i个格子有重量为Wi（1&lt;=Wi&lt;=2,000,000,000）的草，两牛轮流走，一旦某头牛走过了一格，那么这格的草再也不可能被任一头奶牛吃，每格的草只能被吃一次，所以两头牛只能往后走。Bessi先走，每头牛每次都往最终自己能吃到最多草的格子走（若有多个格子则选择第一个能吃到最多草的格子），他们都知道对方也想吃到最多的草，问最后Bessi和Dessie各吃到的草的重量。【输入格式】第一行一个正整数n（n&lt;=700,000）接下来有n行，第i+1行是Wi（1&lt;=Wi&lt;=2,000,000,000）【输出格式】答案【输入样例】617591038【输出样例】27 17 分析类似博弈，倒退dpf[i]=从i到n最大收益id[i]=达到f[i]用了的干草堆最后编号 对于干草堆i，存在两种选择：1)用i，id[i]=i,f[i]=w[i]+f[id[i+1]+1] 即本堆干草+舍弃f[i+1]后最大收益2)不用i，id[i]=id[i+1],f[i]=f[i+1] 代码1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;ll w[710000],f[710000],id[710000];int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;w[i]); f[n]=w[n];id[n]=n;f[n+1]=0; for(int i=n-1;i&gt;=1;i--) &#123; if(w[i]+f[id[i+1]+1]&gt;=f[i+1]) &#123; f[i]=w[i]+f[id[i+1]+1]; id[i]=i; &#125; else &#123; f[i]=f[i+1]; id[i]=id[i+1]; &#125; &#125; printf("%lld %lld",f[1],f[id[1]+1]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>博弈</tag>
        <tag>dp</tag>
        <tag>难度1</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu3113】马拉松赛跑Marathon]]></title>
    <url>%2Fposts%2F134e.html</url>
    <content type="text"><![CDATA[来源和评测点USACO14DEC GoldLuogu3113 题目【题目大意】N个点的路线(1&lt;=N&lt;=100,000)，必须按顺序经过。询问特定的子路线需要多长时间才能跑完，其中的子路线是从完整路线的检查点中截取的的连续子序列。牛可能会选择在任何时候跳过一个检查点，但不允许在子路线中跳过第一个或最后一个点可能修改点的坐标由于该课程设置在市中心的街道网络中，两个点之间的距离(x1,y1)和(x2,y2)是由|x1-x2|+|y1-y2|得出的。【输入格式】第一行N和Q (1&lt;=Q&lt;=100,000).下面N行 每个点的坐标(x,y)，大小范围是-1000..1000下面Q行 每行一个操作“U I X Y” 修改 点I (1&lt;=I&lt;= N) 的坐标为(X, Y).“Q I J” 询问从I到J的最短距离（可以跳过除起点、终点外的其他点）(I &lt;= J)【输出格式】每个Q输出距离值【输入样例】5 5-4 4-5 -3-1 5-3 40 5Q 1 5U 4 0 1U 4 -1 1Q 2 4Q 1 4【输出样例】1188 分析使用线段树维护两个完全不同的信息。值1是每个节点到上一个节点的距离值2是每个节点被忽略后的收益（一般是负数）维护值1的和、值2的最小值 每次修改影响两个值1，三个值2 信息的维护用线段树达到log，树状数组则比较麻烦 玄学AC之本来线段树不忽略编号1，wa几个点都是个位数级别差异后来想着顺便加速（因为编号1从来不用），结果AC如果有人知道，可以在讨论区评论一下 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;ll myabs(ll x) &#123;return x&gt;0?x:-x;&#125;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;const int MAXN=110000;int n;struct nod&#123; int l,r,mid,lc,rc; ll s,mi;//分别维护值1的和、值2的最小值&#125;s[MAXN*2];int ln=0;int build(int l,int r)&#123; int t=++ln; s[t].l=l;s[t].r=r;s[t].mid=(l+r)&gt;&gt;1; if(l&lt;r) &#123; s[t].lc=build(l,s[t].mid); s[t].rc=build(s[t].mid+1,r); &#125; return t;&#125;void change1(int w,int x,ll c)&#123; if(s[w].l==s[w].r) &#123; s[w].s=c; return; &#125; int lc=s[w].lc,rc=s[w].rc; if(x&lt;=s[w].mid) change1(lc,x,c); else change1(rc,x,c); s[w].s=s[lc].s+s[rc].s;&#125;void change2(int w,int x,ll c)&#123; if(s[w].l==s[w].r) &#123; s[w].mi=c; return; &#125; int lc=s[w].lc,rc=s[w].rc; if(x&lt;=s[w].mid) change2(lc,x,c); else change2(rc,x,c); s[w].mi=mymin(s[lc].mi,s[rc].mi);&#125;ll ask1(int w,int l,int r)&#123; if(s[w].l==l and s[w].r==r) return s[w].s; int lc=s[w].lc,rc=s[w].rc; if(r&lt;=s[w].mid) return ask1(lc,l,r); if(l&gt;s[w].mid) return ask1(rc,l,r); return ask1(lc,l,s[w].mid)+ask1(rc,s[w].mid+1,r);&#125;ll ask2(int w,int l,int r)&#123; if(l&gt;r) return 0; if(s[w].l==l and s[w].r==r) return s[w].mi; int lc=s[w].lc,rc=s[w].rc; if(r&lt;=s[w].mid) return ask2(lc,l,r); if(l&gt;s[w].mid) return ask2(rc,l,r); return mymin(ask2(lc,l,s[w].mid),ask2(rc,s[w].mid+1,r));&#125;//值1是每个节点到上一个节点的距离//值2是每个节点被忽略后的收益（一般是负数）int xx[MAXN],yy[MAXN];ll get(int x,int sf)//与往前sf个节点的距离&#123; return myabs(xx[x]-xx[x-sf])+myabs(yy[x]-yy[x-sf]);&#125;ll p[MAXN];//顺便存储值char ss[10];int main()&#123; int q;scanf("%d%d",&amp;n,&amp;q); build(1,n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;xx[i],&amp;yy[i]); if(i==1) continue; change1(1,i-1,p[i]=get(i,1)); &#125; for(int i=2;i&lt;=n-1;i++) change2(1,i-1,get(i+1,2)-p[i]-p[i+1]); while(q--) &#123; scanf("%s",ss); if(ss[0]=='Q') &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); printf("%lld\n",ask1(1,x+1-1,y-1)+ask2(1,x+1-1,y-1-1)); &#125; else &#123; int a;scanf("%d",&amp;a); scanf("%d%d",&amp;xx[a],&amp;yy[a]); //修改值1两处 change1(1,a-1,p[a]=get(a,1)); change1(1,a+1-1,p[a+1]=get(a+1,1)); //对应值2三处 change2(1,a-1-1,get(a,2)-p[a-1]-p[a]); change2(1,a-1,get(a+1,2)-p[a]-p[a+1]); change2(1,a+1-1,get(a+2,2)-p[a+1]-p[a+2]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Zjoi2014】力]]></title>
    <url>%2Fposts%2F1db5.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj3527loj2200Caioj1451 题目【题目大意】给出n个数qi，给出Fj的定义如下：令Ei=Fi/qi，求Ei【输入格式】第一行一个整数n接下来n行每行输入一个数，第i行表示qin≤1000000&lt;qi&lt;1000000000【输出格式】n行，第i行输出Ei。与标准答案误差不超过1e-2即可。【输入样例1】3124.44513547.265135789.147852【输出样例1】-1994.552-5664.703578.376【输入样例2】54006373.88518415375036.4357591717456.4691448514941.0049121410681.345880【输出样例2】-16838672.6933439.7937509018.5664595686.88610903040.872 分析其他快速傅里叶变换题目参见：Tag-快速傅里叶变换 这道题还是挺有难度的基本思路：逐步化简公式转化为卷积的形式从而能用FFT解决下标统一从0开始，翻转时也会用到 $$题目要求：F_i=\sum_{i &lt; k} \frac{q_i q_k}{(i-k)^2}-\sum_{i &gt; k} \frac{q_i q_k}{(k-i)^2}$$ $$而E_i=\frac{F_i}{q_i}$$ $$显而易见E_i=\sum_{i &lt; k} \frac{q_k}{(i-k)^2}-\sum_{i &gt; k} \frac{q_k}{(k-i)^2}$$ $$明确界限E_i=\sum_{k=0}^{i-1} \frac{q_k}{(i-k)^2}-\sum_{k=i+1}^{n-1} \frac{q_k}{(k-i)^2}$$ $$设A_t=q_t,B_t=\frac{1}{t^2}(精髓1)$$ $$E_i=\sum_{k=0}^{i-1} A_k B_{i-k}-\sum_{k=i+1}^{n-1} A_k B_{k-i}$$ $$设B_0=0(小细节)，这样前面的柿子就和卷积一样了，重点放后面$$ $$E_i=\sum_{k=0}^{i} A_k B_{i-k}-\sum_{k=i}^{n-1} A_k B_{k-i}$$ 考虑 $A’t=A{n-1-t}$,$B’_t=B_t$(精髓2，看作是倒过来的卷积，所以翻转一下) $$E_i=\sum_{k=0}^{i} A_k B_{i-k}-\sum_{k=0}^{n-i-1} A’k B’{(n-i-1)-i}$$ $$E_i=FFT1(i)-FFT2(n-i-1)$$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const double PI=acos(-1); const int MAX_N=4*110000; struct Cp &#123; double a,b; Cp(double c=0,double d=0) &#123;a=c,b=d;&#125; Cp operator + (Cp t) &#123;return Cp(a+t.a,b+t.b);&#125; Cp operator - (Cp t) &#123;return Cp(a-t.a,b-t.b);&#125; Cp operator * (Cp t) &#123;return Cp(a*t.a-b*t.b,a*t.b+b*t.a);&#125; &#125;; struct Fft &#123; Cp w[MAX_N]; void getw(int n,int f) &#123; w[0]=Cp(1,0);w[1]=Cp(cos(PI*2*f/n),sin(PI*2*f/n)); for(int i=2;i&lt;n;i++) w[i]=w[i-1]*w[1]; &#125; int R[MAX_N]; void pre(int n) &#123; int lg=log2(n); R[0]=0;for(int i=1;i&lt;n;i++) R[i]=(R[i&gt;&gt;1]&gt;&gt;1)+((i&amp;1)&lt;&lt;(lg-1)); &#125; void solve(Cp *a,int n,int f) &#123; for(int i=0;i&lt;n;i++) if(i&lt;R[i]) swap(a[i],a[R[i]]); for(int ln=1;ln&lt;=n/2;ln&lt;&lt;=1)//合并前 &#123; getw(ln*2,f); for(int st=0;st&lt;n;st+=2*ln) for(int k=0;k&lt;ln;k++) &#123; Cp x=a[st+k],y=w[k]*a[st+ln+k]; a[st+k]=x+y;a[st+ln+k]=x-y; &#125; &#125; &#125; &#125;fft; void FFT(Cp *a,Cp *b,Cp *c,int ln) &#123; fft.solve(a,ln,1);fft.solve(b,ln,1); for(int i=0;i&lt;ln;i++) c[i]=a[i]*b[i]; fft.solve(c,ln,-1);for(int i=0;i&lt;ln;i++) c[i].a/=ln; &#125; double q[MAX_N]; Cp A[MAX_N],B[MAX_N],ans[MAX_N]; void main() &#123; int n;scanf("%d",&amp;n);for(int i=0;i&lt;n;i++) scanf("%lf",&amp;q[i]); int ln=1;while(ln&lt;(n-1)+(n-1)+1) ln&lt;&lt;=1; fft.pre(ln); for(int i=0;i&lt;n;i++) A[i]=Cp(q[i],0); B[0]=Cp();for(int i=1;i&lt;n;i++) B[i]=Cp(1.0/i/i,0); FFT(A,B,ans,ln); for(int i=0;i&lt;ln;i++) A[i]=Cp(),B[i]=Cp(); for(int i=0;i&lt;n;i++) A[i]=Cp(q[n-1-i],0); B[0]=Cp(0,0);for(int i=1;i&lt;n;i++) B[i]=Cp(1.0/i/i,0); FFT(A,B,A,ln); for(int i=0;i&lt;n;i++) printf("%.3lf\n",ans[i].a-A[n-i-1].a); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>快速傅里叶变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3771】Triple]]></title>
    <url>%2Fposts%2Fdf74.html</url>
    <content type="text"><![CDATA[来源和评测点Zjoi2014Bzoj3771Caioj1451 题目【题目大意】我们讲一个悲伤的故事。从前有一个贫穷的樵夫在河边砍柴。这时候河里出现了一个水神，夺过了他的斧头，说：“这把斧头，是不是你的？”樵夫一看：“是啊是啊！”水神把斧头扔在一边，又拿起一个东西问：“这把斧头，是不是你的？”樵夫看不清楚，但又怕真的是自己的斧头，只好又答：“是啊是啊！”水神又把手上的东西扔在一边，拿起第三个东西问：“这把斧头，是不是你的？”樵夫还是看不清楚，但是他觉得再这样下去他就没法砍柴了。于是他又一次答：“是啊是啊！真的是！”水神看着他，哈哈大笑道：“你看看你现在的样子，真是丑陋！”之后就消失了。樵夫觉得很坑爹，他今天不仅没有砍到柴，还丢了一把斧头给那个水神。于是他准备回家换一把斧头。回家之后他才发现真正坑爹的事情才刚开始。水神拿着的的确是他的斧头。但是不一定是他拿出去的那把，还有可能是水神不知道怎么偷偷从他家里拿走的。换句话说，水神可能拿走了他的一把，两把或者三把斧头。樵夫觉得今天真是倒霉透了，但不管怎么样日子还得过。他想统计他的损失。樵夫的每一把斧头都有一个价值，不同斧头的价值不同。总损失就是丢掉的斧头价值和。他想对于每个可能的总损失，计算有几种可能的方案。注意：如果水神拿走了两把斧头a和b，(a,b)和(b,a)视为一种方案。拿走三把斧头时，(a,b,c),(b,c,a),(c,a,b),(c,b,a),(b,a,c),(a,c,b)视为一种方案。【输入格式】第一行是整数N，表示有N把斧头。接下来n行升序输入N个数字Ai，表示每把斧头的价值。所有数据满足：Ai&lt;=40000【输出格式】若干行，按升序对于所有可能的总损失输出一行x y，x为损失值，y为方案数。【输入样例】44 5 6 7【输出样例】4 15 16 18 19 110 111 212 113 114 115 117 118 119 1 分析莫比乌斯教程和题目分类参见：【OI之路】11更高级数论-3快速傅里叶变换其他快速傅里叶变换题目参见：Tag-快速傅里叶变换 Triple这道题的精华是容斥先推荐一下同学的博客，相当严谨科学他和我的思路不同，属于两种不同的角度我的思路可能有些乱啊，因为其实是在别人不停点醒才想到的，并不断完善 题意：给出价格各不相同（这很重要）的一些斧头，每次选一、二、三个，将所有方案统计起来，按价格输出，注意选的是组合不是排列。考虑分解成子问题。 选一个先解决选一个的情况。设$q_i$表示第i个斧头的价格。再设$A(q_i)=1$则$Ans[i]+=A(q_i)$原因就是每个斧头选自己，很好理解的 选两个答案是$A^2(q_i)$吗？先想想这个柿子怎么来的：将A想成多项式的系数系数（原本1）相乘就是方案数相乘指数（价格）相加就是花费相加 然鹅，仔细考虑，发现不完整，因为会有违法情况违法1：第i项和第i项相乘，应该被忽略的违法2：第i、j项乘积和第j、i项乘积重复对于违法1，设$B(2q_i)=1$，$A^2(q_i)-B(q_i)$对于违法2，解决违法一后除以2即可综上所述，$Ans[i]+=\frac { A^2(q_i)-B(q_i) }{2}$ 选三个依照选两个的思路，先计算出$A^3(q_i)$违法1：aab aba baa违法2：abc acb bac bca cab cba对于违法1，设$AB()=A() \times B()，C(q_i \times 3)=1$，答案就是$A^3(q_i)-3AB(q_i)+2C(i)$（因为B是相当于选了两个相同的，所有三个中两个相同情况都应去除）但假如b=a，也就是aaa，那就不能减3个而是一个，用C补回差值对于违法2，解决违法一后除以6即可综上所述，$Ans[i]+=\frac { A^3(q_i)-3AB(q_i)+2C(i) }{6}$ 总结与提醒0次项系数是0，所以$A^3(q_i)$必定是选了三个$Ans[i]=A(q_i)+\frac{A^2(q_i)-B(q_i)}{2}+\frac { A^3(q_i)-3AB(q_i)+2C(i) }{6}$ 对于多项式乘积，使用FFT计算，综合复杂度$\Theta(nlogn)$ 嗯我知道我的灰常不严谨啦~总而言之就是这样 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//Zory-2017//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const double PI=acos(-1.0);const int MAXN=300000;//*******************全局定义*******************struct complex&#123; double r,i;//real,imag complex() &#123;r=i=0;&#125; complex(double rr,double ii) &#123;r=rr;i=ii;&#125; complex operator + (complex b) &#123;return complex(r+b.r,i+b.i);&#125; complex operator - (complex b) &#123;return complex(r-b.r,i-b.i);&#125; complex operator * (complex b) &#123;return complex(r*b.r-i*b.i,r*b.i+i*b.r);&#125; //(a+bi)(c+di)=ac+adi+bci+bdi^2=(ac-bd)+(ad+bc)i //baike.baidu.com/item/复数运算法则&#125;;//*******************实现*******************complex omega[MAXN+10];void CalcOmega(int n,int op)&#123; double t=2*PI*op/n; omega[0]=complex(1,0); omega[1]=complex(cos(t),sin(t)); for(int k=2;k&lt;=n/2-1;k++) omega[k]=omega[k-1]*omega[1];&#125;int R[MAXN+10];void fft(complex *a,int n,int op)&#123; for(int i=0;i&lt;=n-1;i++) if(i&lt;R[i]) swap(a[i],a[R[i]]); //注意判断大小不然又换回来了 for(int L=1;L&lt;=n/2;L*=2)//合并前长度 &#123; CalcOmega(L*2,op); for(int j=0;j&lt;=n-1;j+=L*2)//开头,长度=L*2 &#123; for(int k=0;k&lt;=L-1;k++) &#123; complex x=a[j+k]; complex y=omega[k]*a[j+L+k]; a[j+k]=x+y; a[j+L+k]=x-y; //蝴蝶操作 &#125; &#125; &#125; if(op==-1) for(int i=0;i&lt;=n-1;i++) a[i].r=a[i].r/double(n);&#125;//*******************主函数*******************complex A[MAXN+10],B[MAXN+10],C[MAXN+10];complex A2[MAXN+10],AB[MAXN+10],A3[MAXN+10];double ans[MAXN+10];int main()&#123; //-------------读入------------- int n;scanf("%d",&amp;n); int mx=0; for(int i=0;i&lt;=n-1;i++) &#123; int t;scanf("%d",&amp;t);if(t&gt;mx) mx=t; A[t].r=1;B[2*t].r=1;C[3*t].r=1; &#125; //-------------准备------------- int sn=1,lg=0; while(sn&lt;mx*3+1) sn*=2,lg++; for(int i=0;i&lt;=sn-1;i++) R[i]=( R[i&gt;&gt;1]&gt;&gt;1 ) | ( (i&amp;1)&lt;&lt;(lg-1) ); //nlogn翻转二进制 //-------------计算------------- for(int i=0;i&lt;=sn-1;i++) ans[i]=(A[i].r)-(B[i].r/2.0)+(C[i].r/3.0);//先把A、B、C搞定 fft(A,sn,1);fft(B,sn,1); for(int i=0;i&lt;=sn-1;i++) A2[i]=A[i]*A[i],AB[i]=A[i]*B[i],A3[i]=A2[i]*A[i]; fft(A2,sn,-1);fft(AB,sn,-1);fft(A3,sn,-1); //-------------综合------------- for(int i=0;i&lt;=sn-1;i++) &#123; ans[i]+=(A2[i].r/2.0)+(A3[i].r/6.0)-(AB[i].r/2.0); int t2=ans[i]+0.5; if(t2&gt;0) printf("%d %d\n",i,t2); &#125; //ans[i]=A[i]+(A2[i]-B[i])/2+(A3[i]-3*AB[i]+2*C[i])/6&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>好题</tag>
        <tag>快速傅里叶变换</tag>
        <tag>难度3</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3527】3-idiots]]></title>
    <url>%2Fposts%2Fb4ff.html</url>
    <content type="text"><![CDATA[来源和评测点2013 Multi-University Training Contest 1Hdu4609Caioj1454 题目【题目大意】有T组数据每组数据给出n条线段，问任意取三条，可以组成三角形的概率【输入格式】开头一行输入T（T&lt;=100）下来T组数据，每组数据第一行输入一个n（3&lt;=n&lt;=10^5）第二行输入n个数，表示n条线段线段长度（1&lt;=n&lt;=10^5）【输出格式】每组数据输出一个数p表示可以组成三角形的概率保留七位小数【输入样例】241 3 3 442 3 3 4【输出样例】0.50000001.0000000 分析莫比乌斯教程和题目分类参见：【OI之路】11更高级数论-3快速傅里叶变换其他快速傅里叶变换题目参见：Tag-快速傅里叶变换 大致思路：计算出两条边的和，枚举第三边表示能和它搭配的数量，经过去重后，除以总组合数就是概率 两边之和：FFT，参考另外几道简单点的题去重1：两边之和不能是来自同一条边去重2：两边有一条比第三边大，另一个小去重3：两边都比第三边大去重4：两边有任何一条=第三边（去重2、3、4后剩下的就是两边都比第三边小的情况） 输入的是q[i]，$A(q[i])=是q[i]的数量$NUM(i)表示两边之和=i的情况个数，用去重1$$NUM(i)=\frac{ A^2(i)-B(i) }{2}$$ 去重2、3、4利用排序，并用前缀和SUM获得区间和$ ANS(i)=SUM(rn-1)-SUM(q[i]) $$ 去重2：ANS(i)-=i\times (n-i-1) $$ 去重3：ANS(i)-=\frac{ (n-i-2)\times (n-i-1) }{2} $$ 去重4：ANS(i)-=n-1 $ $$tot=\frac{ n\times (n-1)\times (n-2) }{2}$$ 答案就是$$\frac{ \sum_{i=0}^{n-1} ANS(i) }{tot}$$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;struct complex&#123; double r,i; complex() &#123; r=i=0.0; &#125; complex(double rr,double ii) &#123; r=rr;i=ii; &#125; complex operator + (complex b) &#123; return complex(r+b.r,i+b.i); &#125; complex operator - (complex b) &#123; return complex(r-b.r,i-b.i); &#125; complex operator * (complex b) &#123; return complex(r*b.r-i*b.i,r*b.i+i*b.r); &#125;&#125;;const int MAXN=100000*4;const double PI=acos(-1.0);int R[MAXN+10];void FFT(complex *a,int n,int op)&#123; for(int i=0;i&lt;=n-1;i++) if(i&lt;R[i]) swap(a[i],a[R[i]]); for(int l=1;l&lt;=n/2;l*=2) &#123; complex w1( cos(op*PI/l),sin(op*PI/l) ); for(int j=0;j&lt;=n-1;j+=l*2) &#123; complex wk(1.0,0.0); for(int k=0;k&lt;=l-1;k++,wk=wk*w1) &#123; complex x=a[j+k],y=wk*a[j+l+k]; a[j+k]=x+y; a[j+l+k]=x-y; &#125; &#125; &#125; if(op==-1) for(int i=0;i&lt;=n-1;i++) a[i].r=a[i].r/double(n);&#125;//http://www.cnblogs.com/kuangbin/archive/2013/07/24/3210565.html//http://acm.hdu.edu.cn/showproblem.php?pid=4609//http://blog.csdn.net/rose_max/article/details/77370572complex A[MAXN+10],A2[MAXN+10],B[MAXN+10];int q[MAXN+10];double NUM[MAXN+10];double SUM[MAXN+10];int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; memset(A,0,sizeof(A)); memset(B,0,sizeof(B)); memset(SUM,0,sizeof(SUM)); int n;scanf("%d",&amp;n);int mx=0; for(int i=0;i&lt;=n-1;i++) &#123; scanf("%d",&amp;q[i]); A[q[i]].r++; B[q[i]*2].r++; if(q[i]&gt;mx) mx=q[i]; &#125; sort(q,q+n); int rn=1,rm=(mx)+(mx)+1,l=0; while(rn&lt;rm) rn*=2,l++; for(int i=0;i&lt;=rn-1;i++) R[i]=(R[i&gt;&gt;1]&gt;&gt;1) | ( (i&amp;1)&lt;&lt;(l-1) ); FFT(A,rn,1); for(int i=0;i&lt;=rn-1;i++) A2[i]=A[i]*A[i]; FFT(A2,rn,-1); for(int i=0;i&lt;=rn-1;i++) NUM[i]=(A2[i].r-B[i].r)/2.0; for(int i=0;i&lt;=rn-1;i++) SUM[i]=SUM[i-1]+NUM[i]; double ans=0; for(int i=0;i&lt;=n-1;i++)//第三边 &#123; ans+=SUM[rn-1]-SUM[q[i]]; ans-=double(i)*double(n-i-1);//一大一小 ans-=double(n-i-2)*double(n-i-1)/2;//两大 ans-=n-1;//某边=第三边 &#125; double tot=double(n)*double(n-1)*double(n-2)/6.0; printf("%.7lf\n",ans/tot); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>好题</tag>
        <tag>快速傅里叶变换</tag>
        <tag>难度3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2179】超大整数乘法]]></title>
    <url>%2Fposts%2F9654.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj2179Luogu1919Caioj1450Codevs3123 题目【题目大意】给出两个正整数A和B，计算A*B的值。保证A和B的位数不超过100000位。【输入格式】读入两个用空格隔开的正整数【输出格式】输出A*B的值【输入样例1】49【输出样例1】36【输入样例2】5612【输出样例2】672【输入样例3】9999【输出样例3】9801 分析快速傅里叶变换教程和题目分类参见：【OI之路】11更高级数论-4快速傅里叶变换其他快速傅里叶变换题目参见：Tag-快速傅里叶变换 将10看作x就好了注意进位 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=210000;const double PI=acos(-1.0);//*******************全局定义*******************struct Cmplex&#123; double r,i; Cmplex(double a=0,double b=0) &#123;r=a,i=b;&#125; Cmplex operator +(Cmplex a) &#123;return Cmplex(r+a.r,i+a.i);&#125; Cmplex operator -(Cmplex a) &#123;return Cmplex(r-a.r,i-a.i);&#125; Cmplex operator *(Cmplex a) &#123;return Cmplex(r*a.r-i*a.i,r*a.i+i*a.r);&#125;&#125;;//*******************实现*******************Cmplex omega[MAXN];void calc_omega(int n,int op)&#123; omega[0]=Cmplex(1,0); omega[1]=Cmplex( cos(PI*2*op/n),sin(PI*2*op/n) ); for(int i=2;i&lt;=n/2-1;i++) omega[i]=omega[i-1]*omega[1];&#125;int n;int R[MAXN];void FFT(Cmplex *a,int op)&#123; for(int i=0;i&lt;=n-1;i++) if(i&lt;R[i]) swap(a[i],a[R[i]]); for(int L=1;L&lt;n;L&lt;&lt;=1)//合并前长度 &#123; calc_omega(L*2,op); for(int st=0;st&lt;=n-1;st+=L*2) &#123; for(int i=0;i&lt;=L-1;i++) &#123; Cmplex x=a[st+i]; Cmplex y=omega[i]*a[st+i+L]; a[st+i]=x+y; a[st+i+L]=x-y; &#125; &#125; &#125; if(op==-1) for(int i=0;i&lt;=n-1;i++) a[i].r/=double(n);&#125;//*******************主函数*******************char s[MAXN];Cmplex a[MAXN],b[MAXN];int ans[MAXN];int main()&#123; int ln;scanf("%d",&amp;ln); scanf("%s",s+1);for(int i=ln;i&gt;=1;i--) a[ln-i].r=s[i]-'0'; scanf("%s",s+1);for(int i=ln;i&gt;=1;i--) b[ln-i].r=s[i]-'0'; int m=(ln-1)+(ln-1)+1; n=1;int tmp=0; while(n&lt;m) tmp++,n*=2; for(int i=1;i&lt;=n-1;i++) R[i]= (R[i&gt;&gt;1]&gt;&gt;1) | ( (i&amp;1)&lt;&lt;(tmp-1) );//debug //nlogn二进制翻转 FFT(a,1);FFT(b,1);//求值 for(int i=0;i&lt;=n-1;i++) a[i]=a[i]*b[i];//点值乘法 FFT(a,-1);//插值 for(int i=0;i&lt;=m-1;i++) &#123; ans[i]+=round(a[i].r); if(ans[i]&gt;9) &#123; ans[i+1]+=ans[i]/10; ans[i]%=10; if(i==m-1) m++; &#125; &#125; for(int i=m-1;i&gt;=0;i--) putchar('0'+ans[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>快速傅里叶变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2194】快速傅立叶之二]]></title>
    <url>%2Fposts%2Ffb8e.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj2194Caioj1453 题目【题目大意】请计算$C[k]=\sum a[i]*b[i-k] $ 其中k&lt;=i&lt;n,并且有n&lt;=10^5。a,b中的元素均为小于等于100的非负整数。【输入格式】第一行一个整数N,接下来N行，第i+2..i+N-1行，每行两个数，依次表示a[i],bi【输出格式】输出N行，每行一个整数，第i行输出C[i-1]【输入样例】53 12 41 12 41 4【输出样例】24121061 分析莫比乌斯教程和题目分类参见：【OI之路】11更高级数论-3快速傅里叶变换其他快速傅里叶变换题目参见：Tag-快速傅里叶变换 按通常的卷积形式应该是$c[k]=\sum_{i=0}^k a[i]*b[k-i]$但是本题要求的是$c[k]=\sum_{i=k}^{n-1} a[i]*b[i-k]$于是将b上下反转即可另外，将序号看作指数，反转后对于某个c的乘积和，指数和其实是相同的 自己推一推就好了…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//Zory-2017//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const double PI=acos(-1.0);const int MAXN=4*100000;//*******************全局定义*******************struct complex&#123; double r,i;//real,imag complex() &#123;r=i=0;&#125; complex(double rr,double ii) &#123;r=rr;i=ii;&#125; complex operator + (complex b) &#123;return complex(r+b.r,i+b.i);&#125; complex operator - (complex b) &#123;return complex(r-b.r,i-b.i);&#125; complex operator * (complex b) &#123;return complex(r*b.r-i*b.i,r*b.i+i*b.r);&#125; //(a+bi)(c+di)=ac+adi+bci+bdi^2=(ac-bd)+(ad+bc)i //baike.baidu.com/item/复数运算法则&#125;;//*******************实现*******************int R[MAXN+10];complex omega[MAXN+10];void CalcOmega(int n,int op)&#123; double t=2*PI*op/n; omega[0]=complex(1,0); omega[1]=complex(cos(t),sin(t)); for(int k=2;k&lt;=n/2-1;k++) omega[k]=omega[k-1]*omega[1];&#125;void FFT(complex *a,int n,int op)&#123; for(int i=0;i&lt;=n-1;i++) if(i&lt;R[i]) swap(a[i],a[R[i]]); //注意判断大小不然又换回来了 for(int L=1;L&lt;=n/2;L*=2)//合并前长度 &#123; CalcOmega(L*2,op); for(int j=0;j&lt;=n-1;j+=L*2)//开头,长度=L*2 &#123; for(int k=0;k&lt;=L-1;k++) &#123; complex x=a[j+k]; complex y=omega[k]*a[j+L+k]; a[j+k]=x+y; a[j+L+k]=x-y; //蝴蝶操作 &#125; &#125; &#125; if(op==-1) for(int i=0;i&lt;=n-1;i++) a[i].r=a[i].r/double(n);&#125;//*******************主函数*******************complex a[MAXN+10],b[MAXN+10];char s[MAXN+10];int ans[MAXN+10];int main()&#123; int n;scanf("%d",&amp;n);int tn=n; int m=n-1;n=n-1; for(int i=0;i&lt;=n;i++) scanf("%lf%lf",&amp;a[i].r,&amp;b[m-i].r); m=n+m+1;int log=0;n=1; while(n&lt;m) n*=2,log++; for(int i=0;i&lt;=n-1;i++) R[i]=( R[i&gt;&gt;1]&gt;&gt;1 ) | ( (i&amp;1)&lt;&lt;(log-1) ); //nlogn翻转二进制 FFT(a,n,1);FFT(b,n,1);//求值 for(int i=0;i&lt;=n-1;i++) a[i]=a[i]*b[i];//点值乘法 FFT(a,n,-1);//插值 for(int i=0;i&lt;=m-1;i++) &#123; ans[i]+=int(a[i].r+0.5); if(ans[i]&gt;=10) &#123; ans[i+1]+=ans[i]/10; ans[i]%=10; if(i==m-1) m++; &#125; &#125; for(int i=tn-1;i&lt;=2*tn-2;i++) printf("%d\n",int(a[i].r+0.5));&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>快速傅里叶变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2820】YY的GCD]]></title>
    <url>%2Fposts%2F5aa0.html</url>
    <content type="text"><![CDATA[来源和评测点一模一样的题目但数据弱化版：Bzoj2818 GCD-莫比乌斯2Bzoj2820 题目【题目大意】神犇YY虐完数论后给傻kAc出了一题给定N,M,求1≤x≤N, 1≤y≤M且gcd(x,y)为质数的(x,y)有多少对kAc这种傻kAc必然不会了，于是向你来请教……【输入格式】多组输入第一行一个整数T 表述数据组数接下来T行，每行两个正整数，表示N, M【输出格式】T行，每行一个整数表示第i组数据的结果【输入样例】210 10100 100【输出样例】302791 分析1莫比乌斯教程和题目分类参见：【OI之路】11更高级数论-2莫比乌斯其他莫比乌斯题目参见：Tag-莫比乌斯 即使分块也会T！需要优化了，主要是针对素数： 转载并修改自Hzwer $ 假定n&lt;m $$$\sum_{isprime(p)} \sum_{a=1}^n \sum_{b=1}^m gcd(a,b)==p$$ 简化为： $$\sum_{isprime(p)} \sum_{a=1}^{\left \lfloor \frac{n}{p} \right \rfloor} \sum_{b=1}^{\left \lfloor \frac{m}{p} \right \rfloor}gcd(a,b)==1$$ ————在我之前的教程中，下面直接被忽略————$$\sum_{isprime(p)}\sum_{a=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\sum_{b=1}^{\left \lfloor \frac{m}{p} \right \rfloor}\sum_{d|gcd(a,b)}\mu(d)$$ $$\sum_{isprime(p)}\sum_{a=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\sum_{b=1}^{\left \lfloor \frac{m}{p} \right \rfloor}\sum_{d|a \space and \space d|b}\mu(d)$$因为：$$\sum_{d|a \space and \space d|b}1 是等于后边的{\left \lfloor \frac{n}{pd} \right \rfloor}{\left \lfloor \frac{m}{pd} \right \rfloor}的$$所以之前就直接得出了。 ————-在我之前的教程中，上面直接被忽略—————额不妨设n&lt;=m，则可以变成：$$\sum_{isprime(p)}\sum_{d=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\mu(d){\left \lfloor \frac{n}{pd} \right \rfloor}{\left \lfloor \frac{m}{pd} \right \rfloor}$$ 上面的柿子已经很好用了，但可以考虑加速： 将pd设为k $$\sum_{k=1}^{n}\sum_{isprime(p) \space and \space p|k}\mu(\frac{k}{p}){\left \lfloor \frac{n}{k} \right \rfloor}{\left \lfloor \frac{m}{k} \right \rfloor}$$ $$\sum_{k=1}^{n} G(k){\left \lfloor \frac{n}{k} \right \rfloor}{\left \lfloor \frac{m}{k} \right \rfloor}$$ $$G(k)就是\sum_{isprime(p) \space and \space p|k}\mu(\frac{k}{p})$$ $$也就是k的所有质因数的\mu(\frac{k}{质因数})之和$$于是就优化到了可怕的O(N)~ 那么接下来就是要解决G(k)的预处理了简单粗暴的，使用暴力枚举素数来更新，用导数可证明其复杂度的正确性 代码14332 ms1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;typedef long long ll;const int MAXNUM=10000000,MAXPR=1000000;int prime[MAXPR],pr;ll mu[MAXNUM+10];bool v[MAXNUM+10];int G[MAXNUM+10];void getmu()&#123; mu[1]=1;pr=0; memset(v,1,sizeof(v)); for(int i=2;i&lt;=MAXNUM;i++) &#123; if(v[i]==1) prime[++pr]=i,mu[i]=-1; for(int j=1;j&lt;=pr;j++) &#123; ll tt=ll(i)*ll(prime[j]); if(tt&gt;ll(MAXNUM)) break; v[tt]=0; if(i%prime[j]==0) &#123; mu[tt]=0; break; &#125; else mu[tt]=-mu[i]; &#125; &#125; for(int i=1;i&lt;=pr;i++) &#123; int p=prime[i]; for(int j=1;ll(j)*ll(p)&lt;=ll(MAXNUM);j++) G[j*p]+=mu[j]; &#125; for(int i=1;i&lt;=MAXNUM;i++) G[i]+=G[i-1];&#125;ll calc(int n,int m)&#123; ll ans=0; if(n&gt;m) swap(n,m); int t=1; int last; for(int k=1;k&lt;=n;k=last+1) &#123; last=mymin(n/(n/k),m/(m/k)); ans+=(G[last]-G[k-1])*ll(n/k)*ll(m/k); &#125; return ans;&#125;int main()&#123; getmu(); int T;scanf("%d",&amp;T); while(T--) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); printf("%lld\n",calc(n,m)); &#125;&#125; 分析2然鹅，利用莫比乌斯函数的性质和G(k)的性质，可以得到这样的规律(用了足足一节数学课)：if(i%prime[j]==0) G[tt]=mu[i];else G[tt]=-G[i]+mu[i]; 代码23476 ms12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;typedef long long ll;const int MAXNUM=10000000,MAXPR=1000000;int prime[MAXPR],pr;ll mu[MAXNUM+10];bool v[MAXNUM+10];int G[MAXNUM+10];void getmu()&#123; mu[1]=1;pr=0; memset(v,1,sizeof(v)); for(int i=2;i&lt;=MAXNUM;i++) &#123; if(v[i]==1) prime[++pr]=i,mu[i]=-1,G[i]=1; for(int j=1;j&lt;=pr;j++) &#123; ll tt=ll(i)*ll(prime[j]); if(tt&gt;ll(MAXNUM)) break; v[tt]=0; if(i%prime[j]==0) &#123; mu[tt]=0; G[tt]=mu[i]; break; &#125; else &#123; mu[tt]=-mu[i]; G[tt]=-G[i]+mu[i]; &#125; &#125; &#125; for(int i=1;i&lt;=MAXNUM;i++) G[i]+=G[i-1];&#125;ll calc(int n,int m)&#123; ll ans=0; if(n&gt;m) swap(n,m); int t=1; int last; for(int k=1;k&lt;=n;k=last+1) &#123; last=mymin(n/(n/k),m/(m/k)); ans+=(G[last]-G[k-1])*ll(n/k)*ll(m/k); &#125; return ans;&#125;int main()&#123; getmu(); int T;scanf("%d",&amp;T); while(T--) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); printf("%lld\n",calc(n,m)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>莫比乌斯</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Zoj3435】Ideal Puzzle Bobble]]></title>
    <url>%2Fposts%2Fea1.html</url>
    <content type="text"><![CDATA[来源和评测点Author: ZHU, YukeContest: ZOJ Monthly, November 2010Zoj3435Caioj1283 题目【题目大意】给定点(x,y,z)与(1,1,1)确定一个长方体，长方体边上及内部总共有x*y*z个点，问从(1,1,1)总共能看到多少个点【输入格式】多组数据一行三个整数，x,y,z 1&lt;=a,b,c&lt;=1000000【输出格式】共1行，一个整数从(1,1,1)总共能看到多少个点【输入样例】2 2 23 3 3【输出样例】719 分析其他莫比乌斯题目参见：Tag-莫比乌斯 建议先看二维版：仪仗队 用了分块讲(x,y,z)与(1,1,1)变成(x-1,y-1,z-1)与(0,0,0)三个数的gcd是一样的，注意0答案就是：（都不是0）+（一个0）+（两个0也就是3）分别反演结果之和 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;typedef long long ll;//******************定义******************const int MAXNUM=1000000,MAXPR=100000;int mu[MAXNUM+10];//******************莫比乌斯函数******************int prime[MAXPR+10],pr;bool prv[MAXNUM+10];void getmu()&#123; pr=0;memset(prv,1,sizeof(prv)); mu[1]=1; for(int i=2;i&lt;=MAXNUM;i++) &#123; if(prv[i]==1) &#123; prime[++pr]=i; mu[i]=-1; &#125; for(int j=1;j&lt;=pr;j++) &#123; int t=i*prime[j]; if(t&gt;MAXNUM) break; prv[t]=0; if(i%prime[j]==0) &#123; mu[t]=0; break; &#125; else mu[t]=-mu[i]; &#125; mu[i]+=mu[i-1]; &#125;&#125;//******************莫比乌斯******************ll calc1(int a,int b,int c)&#123; //已经不必强调大小了，找到最小值就好了 //其实也就模板题需要去重所以才要交换罢了 int mi=mymin(a,mymin(b,c)); ll ans=0; int last; int t=1; for(int i=1;i&lt;=mi;i=last+1)//d/t &#123; int d=i*t; last=mymin( a/(a/d), mymin( b/(b/d),c/(c/d) ) ); ans+=ll(mu[last]-mu[i-1])*( ll(a/d)*ll(b/d)*ll(c/d) ); &#125; return ans;&#125;ll calc2(int a,int b)&#123; int mi=mymin(a,b); ll ans=0; int last; int t=1; for(int i=1;i&lt;=mi;i=last+1)//d/t &#123; int d=i*t; last=mymin( a/(a/d),b/(b/d) ); ans+=ll(mu[last]-mu[i-1])*( ll(a/d)*ll(b/d) ); &#125; return ans;&#125;//******************主函数******************int main()&#123; getmu(); int x,y,z; while(scanf("%d%d%d",&amp;x,&amp;y,&amp;z)!=EOF) &#123; //都不是0+一个0+两个0 printf("%lld\n",calc1(x-1,y-1,z-1)+calc2(x-1,y-1)+calc2(y-1,z-1)+calc2(x-1,z-1)+3); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>莫比乌斯</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2190】仪仗队]]></title>
    <url>%2Fposts%2F24f8.html</url>
    <content type="text"><![CDATA[来源和评测点SDOI2008Bzoj2190 题目【题目大意】 作为体育委员，C君负责这次运动会仪仗队的训练。仪仗队是由学生组成的N*N的方阵，为了保证队伍在行进中整齐划一，C君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐(如下图)。现在，C君希望你告诉他队伍整齐时能看到的学生人数。【输入格式】共一个数N，1≤N≤40000【输出格式】共一个数，即C君应看到的学生人数。【输入样例】4【输出样例】9 分析莫比乌斯教程和题目分类参见：【OI之路】11更高级数论-2莫比乌斯其他莫比乌斯题目参见：Tag-莫比乌斯 我代码里面用了分块，其实可能不用也可以重点是题目的转换，经别人提醒才想到和点的坐标有关假设C君在(0,0)，那么他能看到的点必须互质（注意0和任何数互质所以+2）原因：假如有点A(ak,bk)的坐标不互质,那么他必定被B(a,b)遮挡 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//************************定义************************typedef long long ll;const int MAXNUM=100000,MAXPR=10000;int mu[MAXNUM+10];//************************线性筛************************bool prv[MAXNUM+10];int prime[MAXPR+10],pr;void getmu()&#123; pr=0;memset(prv,1,sizeof(prv)); mu[1]=1; for(int i=2;i&lt;=MAXNUM;i++) &#123; if(prv[i]==1) &#123; prime[++pr]=i; mu[i]=-1; &#125; for(int j=1;j&lt;=pr;j++) &#123; ll t=ll(i)*ll(prime[j]); if(t&gt;ll(MAXNUM)) break; prv[t]=0; if(i%prime[j]==0) &#123; mu[t]=0; break; &#125; else mu[t]=-mu[i]; &#125; mu[i]+=mu[i-1]; &#125;&#125;//************************主函数************************ll calc(int n,int m)&#123; if(n&gt;m) swap(n,m); ll ans=0; int t=1; //F[d]=sigma[ f(t) ] d|t //f(t)=sigma[ mu(d/t)*F[d] ] t|d int last=0; for(int i=1;i&lt;=n;i=last+1)//d/t &#123; int d=i*t; last=mymin( n/(n/d) , m/(m/d) ); ans+=ll(mu[last]-mu[i-1])*ll(n/d)*ll(m/d); &#125; return ans;&#125;int main()&#123; getmu(); int n;scanf("%d",&amp;n); printf("%lld\n",calc(n-1,n-1)+2);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>莫比乌斯</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2301】【Luogu2522】Problem_b]]></title>
    <url>%2Fposts%2F12b6.html</url>
    <content type="text"><![CDATA[来源和评测点HAOI2011Bzoj2301Luogu2522Caioj1282 题目【题目大意】对于给出的n个询问，每次求有多少个数对(x,y)，满足a≤x≤b，c≤y≤d，且gcd(x,y)=k，gcd(x,y)函数为x和y的最大公约数。【输入格式】第一行一个整数n，接下来n行每行五个整数，分别表示a、b、c、d、k100%的数据满足：1≤n≤50000，1≤a≤b≤50000，1≤c≤d≤50000，1≤k≤50000【输出格式】共n行，每行一个整数表示满足要求的数对(x,y)的个数【输入样例】22 5 1 5 11 5 1 5 2【输出样例】143 分析莫比乌斯教程和题目分类参见：【OI之路】11更高级数论-2莫比乌斯其他莫比乌斯题目参见：Tag-莫比乌斯 嗯这次就不能硬搞了，会超时哒（bzoj上51000+到11000ms），所以要分块了而且还要用到容斥，因为下界也是变量了，画张图就灰常好理解了 至于分块，如下：采用前缀和优化+分块思想因为(n/d)*(m/d)有连续的一段是相等的，所以对莫比乌斯函数计算前缀和 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//************************定义************************typedef long long ll;const int MAXNUM=100000,MAXPR=10000;int mu[MAXNUM+10];//************************线性筛************************bool prv[MAXNUM+10];int prime[MAXPR+10],pr;void getmu()&#123; pr=0;memset(prv,1,sizeof(prv)); mu[1]=1; for(int i=2;i&lt;=MAXNUM;i++) &#123; if(prv[i]==1) &#123; prime[++pr]=i; mu[i]=-1; &#125; for(int j=1;j&lt;=pr;j++) &#123; ll t=ll(i)*ll(prime[j]); if(t&gt;ll(MAXNUM)) break; prv[t]=0; if(i%prime[j]==0) &#123; mu[t]=0; break; &#125; else mu[t]=-mu[i]; &#125; mu[i]+=mu[i-1]; &#125;&#125;//************************主函数************************ll calc(int n,int m)&#123; if(n&gt;m) swap(n,m); ll ans=0; int t=1; //F[d]=sigma[ f(t) ] d|t //f(t)=sigma[ mu(d/t)*F[d] ] t|d int last=0; for(int i=1;i&lt;=n;i=last+1)//i=d/t &#123; int d=i*t; last=mymin( n/(n/d) , m/(m/d) ); ans+=ll(mu[last]-mu[i-1])*ll(n/d)*ll(m/d); &#125; return ans;&#125;int main()&#123; getmu(); int n;scanf("%d",&amp;n); for(int tk=1;tk&lt;=n;tk++) &#123; int a,b,c,d,k;scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d,&amp;k); if(k==0) &#123; printf("0\n"); continue; &#125; a=(a-1)/k,b=b/k,c=(c-1)/k,d=d/k; printf("%lld\n",calc(b,d)-calc(b,c)-calc(a,d)+calc(a,c)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>莫比乌斯</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2818】GCD-莫比乌斯2]]></title>
    <url>%2Fposts%2F9151.html</url>
    <content type="text"><![CDATA[来源和评测点湖北省队互测Bzoj2818Caioj1281 一模一样的题目但数据强化版：Bzoj2820 YY的GCD 题目【题目大意】给定整数N，求1&lt;=x,y&lt;=N且Gcd(x,y)为素数的数对(x,y)有多少对【输入格式】一个整数N【输出格式】对数【输入样例】4【输出样例】4 分析1莫比乌斯教程和题目分类参见：【OI之路】11更高级数论-2莫比乌斯其他莫比乌斯题目参见：Tag-莫比乌斯 数据水到直接硬搞就好就是枚举每个素数p，然后n/p当作m就好了，还不用去重 代码1340 5584 ms123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;typedef long long ll;int prime[1000000],pr;ll mu[11000000];bool v[11000000];void getmu()&#123; mu[1]=1;pr=0; memset(v,1,sizeof(v)); for(int i=2;i&lt;=10000000;i++) &#123; if(v[i]==1) prime[++pr]=i,mu[i]=-1; for(int j=1;j&lt;=pr and ll(i)*ll(prime[j])&lt;=ll(10000000);j++) &#123; v[ i*prime[j] ]=0; if(i%prime[j]==0) &#123; mu[i*prime[j]]=0; break; &#125; mu[i*prime[j]]=-mu[i]; &#125; &#125;&#125;//ll F[10000000],f[11000000];int main()&#123; getmu(); int n;scanf("%d",&amp;n); ll ans=0; for(int pi=1;pi&lt;=pr;pi++) &#123; int p=prime[pi];if(p&gt;n) break; int m=n/p; int t=1; for(int i=1;i&lt;=m;i++)//d/t &#123; int d=i*t; //F[d]=ll( m/d )*ll( m/d ); //ans1+=mu[i]*F[i]; ans+=mu[i]*ll( m/d )*ll( m/d ); &#125; &#125; printf("%lld\n",ans);&#125; 分析2可以采用前缀和优化+分块思想因为（m/d）有连续的一段是相等的，所以对莫比乌斯函数计算前缀和 代码2256 5276 ms123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;typedef long long ll;int prime[1000000],pr;ll mu[11000000];bool v[11000000];void getmu()&#123; mu[1]=1;pr=0; memset(v,1,sizeof(v)); for(int i=2;i&lt;=10000000;i++) &#123; if(v[i]==1) prime[++pr]=i,mu[i]=-1; for(int j=1;j&lt;=pr and ll(i)*ll(prime[j])&lt;=ll(10000000);j++) &#123; v[ i*prime[j] ]=0; if(i%prime[j]==0) &#123; mu[i*prime[j]]=0; break; &#125; else mu[i*prime[j]]=-mu[i]; &#125; mu[i]+=mu[i-1]; &#125;&#125;//ll F[10000000],f[11000000];int main()&#123; getmu(); int n;scanf("%d",&amp;n); ll ans=0; for(int pi=1;pi&lt;=pr;pi++) &#123; int p=prime[pi];if(p&gt;n) break; int m=n/p; int t=1;int last=0; for(int i=1;i&lt;=m;i=last+1)//d/t &#123; int d=i*t; last=mymin(m,m/(m/d)); ans+=(mu[last]-mu[i-1])*ll( m/d )*ll( m/d ); &#125; &#125; printf("%lld\n",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>莫比乌斯</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hdu1695】GCD(莫比乌斯1)]]></title>
    <url>%2Fposts%2Fd395.html</url>
    <content type="text"><![CDATA[来源和评测点2008 “Sunline Cup” National Invitational ContestHdu1695Caioj1280 题目【题目大意】对于给出的n个询问，每次求有多少个数对(x,y)，满足a≤x≤b，c≤y≤d，且gcd(x,y) = k，gcd(x,y)函数为x和y的最大公约数，保证所有数据中a和c一定等于1。 注意：2，3和3，2是一种情况【输入格式】第一行一个整数n，接下来n行每行五个整数，分别表示a、b、c、d、k【输出格式】共n行，每行一个整数表示满足要求的数对(x,y)的个数【输入样例】21 3 1 5 11 11014 1 14409 9【输出样例】9736427 分析莫比乌斯教程和题目分类参见：【OI之路】11更高级数论-2莫比乌斯其他莫比乌斯题目参见：Tag-莫比乌斯 这道题分析在教程，因为是模版题我的代码尽量贴合教程了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;typedef long long ll;const int MAXN=1000000;ll mu[MAXN+100000];bool v[MAXN+100000];int prime[MAXN+100000],pr;void getmu()&#123; mu[1]=1;pr=0; memset(v,1,sizeof(v)); for(int i=2;i&lt;=MAXN;i++) &#123; if(v[i]==1) prime[++pr]=i,mu[i]=-1; for(int j=1;j&lt;=pr and ll(i)*ll(prime[j])&lt;ll(MAXN);j++) &#123; v[ i*prime[j] ]=0; if(i%prime[j]==0) &#123; mu[i*prime[j]]=0; break; &#125; mu[i*prime[j]]=-mu[i]; &#125; &#125;&#125;ll F[MAXN],f[MAXN];int main()&#123; getmu(); int n;scanf("%d",&amp;n); for(int fs=1;fs&lt;=n;fs++) &#123; int a,b,c,d,k;scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d,&amp;k); printf("Case %d: ",fs); if(k==0) &#123; printf("0\n"); continue; &#125; int n=b/k,m=d/k; if(n&gt;m) swap(n,m); ll ans1=0,ans2=0; int t=1; for(int i=1;i&lt;=n;i++)//d/t &#123; int d=i*t; F[d]=ll( n/d )*ll( m/d ); ans1+=mu[i]*F[i]; &#125; for(int i=1;i&lt;=n;i++)//d/t &#123; int d=i*t; F[d]=ll( n/d )*ll( n/d ); ans2+=mu[i]*F[i]; &#125; printf("%lld\n",ans1-ans2/2); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>莫比乌斯</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1001】狼抓兔子]]></title>
    <url>%2Fposts%2F9c9f.html</url>
    <content type="text"><![CDATA[来源和评测点BeiJing2006Bzoj1001 题目【题目大意】现在小朋友们最喜欢的”喜羊羊与灰太狼”,话说灰太狼抓羊不到，但抓兔子还是比较在行的，而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对下面这样一个网格的地形：左上角点为(1,1),右下角点为(N,M)(上图中N=3,M=4)。有以下三种类型的道路：1:(x,y)&lt;==&gt;(x+1,y)2:(x,y)&lt;==&gt;(x,y+1)3:(x,y)&lt;==&gt;(x+1,y+1)道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的。左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角(1,1)的窝里，现在它们要跑到右下解(N,M)的窝中去，狼王开始伏击这些兔子。当然为了保险起见，如果一条道路上最多通过的兔子数为K，狼王需要安排同样数量的K只狼，才能完全封锁这条道路。你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦。【输入格式】第一行为N,M.表示网格的大小，N,M均小于等于1000.接下来分三部分第一部分共N行，每行M-1个数，表示横向道路的权值.第二部分共N-1行，每行M个数，表示纵向道路的权值.第三部分共N-1行，每行M-1个数，表示斜向道路的权值.输入文件保证不超过10M【输出格式】输出一个整数，表示参与伏击的狼的最小数量.【输入样例】3 45 6 44 3 17 5 35 6 7 88 7 6 55 5 56 6 6【输出样例】14 分析1网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他最小割题目参见：Tag-最小割 一看就是最小割 代码1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131/************************************************************** Problem: 1001 User: Zory Language: C++ Result: Accepted Time:1256 ms Memory:85196 kb****************************************************************/ //最小割#include&lt;cstdio&gt;//#include&lt;cstdlib&gt;#include&lt;cstring&gt;//#include&lt;cctype&gt;#include&lt;cmath&gt;//#include&lt;ctime&gt;//#include&lt;queue&gt;#include&lt;set&gt;//#include&lt;stack&gt;//#include&lt;iostream&gt;//#include&lt;string&gt;//#include&lt;iomanip&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int mymax(int a,int b)&#123; return a&gt;b?a:b;&#125;int mymin(int a,int b)&#123; return a&gt;b?b:a;&#125;/*int myabs(int a)&#123; return a&gt;0?a:-a;&#125;void myswap(int &amp;x,int &amp;y)&#123; int t=x;x=y;y=t;&#125;*/int read()&#123; int s=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') s=s*10+c-'0',c=getchar(); return s;&#125;//*******************定义*******************const int Maxn=1100000,Maxm=6100000;int st,ed;int hou[Maxn],h[Maxn];struct nod&#123; int y,c;int gg;&#125;e[Maxm];//*******************实现*******************int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].gg=hou[x];hou[x]=ln;&#125;int getoth(int x) &#123; return (x%2==0)?x-1:x+1; &#125;int q[Maxn];bool bfs()&#123; memset(h,0,sizeof(h)); q[1]=st;h[st]=1; int tou=1,wei=1; while(tou&lt;=wei) &#123; int x=q[tou]; for(int k=hou[x];k&gt;0;k=e[k].gg) &#123; int y=e[k].y; if(h[y]==0 and e[k].c&gt;0 ) &#123; h[y]=h[x]+1; q[++wei]=y; if(y==ed) return 1; &#125; &#125; tou++; &#125; return 0;&#125;int dfs(int x,int s)&#123; if(x==ed) return s; int t=0; for(int k=hou[x];k&gt;0;k=e[k].gg ) &#123; int y=e[k].y; if(h[y]==h[x]+1 and e[k].c&gt;0 and t&lt;s ) &#123; int b=dfs(y,mymin(e[k].c,s-t)); e[k].c-=b;e[getoth(k)].c+=b;t+=b; if(s==t) return s; &#125; &#125; if(t==0) h[x]=0; return t;&#125;//*******************接口*******************int n,m;int pt(int x,int y)&#123; return (x-1)*m+y;&#125;//*******************主函数*******************int tx[3]=&#123;0,1,1&#125;;int ty[3]=&#123;1,0,1&#125;;int main(int argc, char *argv[])&#123; scanf("%d%d",&amp;n,&amp;m); ln=0; for(int k=0;k&lt;=2;k++) for(int i=1;i&lt;=((k==0)?n:n-1);i++) for(int j=1;j&lt;=((k==1)?m:m-1);j++) &#123; int x=pt(i,j),y=pt(i+tx[k],j+ty[k]),c=read(); ins(x,y,c);ins(y,x,c); &#125; st=1;ed=pt(n,m); int ans=0; while(bfs()) ans+=dfs(st,INF); printf("%d\n",ans);&#125; 分析2可以将网格图转化为对偶图可以参考论文：https://wenku.baidu.com/view/8f1fde586edb6f1aff001f7d 代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159/************************************************************** Problem: 1001 User: Zory Language: C++ Result: Accepted Time:1536 ms Memory:126332 kb****************************************************************/ //Dijkstra#include&lt;cstdio&gt;//#include&lt;cstdlib&gt;#include&lt;cstring&gt;//#include&lt;cctype&gt;#include&lt;cmath&gt;//#include&lt;ctime&gt;#include&lt;queue&gt;//#include&lt;set&gt;//#include&lt;stack&gt;//#include&lt;iostream&gt;//#include&lt;string&gt;//#include&lt;iomanip&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int mymax(int a,int b)&#123; return a&gt;b?a:b;&#125;int mymin(int a,int b)&#123; return a&gt;b?b:a;&#125;/*int myabs(int a)&#123; return a&gt;0?a:-a;&#125;void myswap(int &amp;x,int &amp;y)&#123; int t=x;x=y;y=t;&#125;*/int read()&#123; int s=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') s=s*10+c-'0',c=getchar(); return s;&#125;//*******************定义*******************const int Maxn=2100000,Maxm=8100000;struct nod1&#123; int hou,ans;&#125;p[Maxn];struct nod2&#123; int y,c;int gg;&#125;e[Maxm];int st,ed;//*******************实现*******************int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].gg=p[x].hou; p[x].hou=ln; ln++; e[ln].y=x;e[ln].c=c; e[ln].gg=p[y].hou; p[y].hou=ln;&#125;typedef pair&lt;int,int&gt; P;priority_queue&lt; P,vector&lt;P&gt;,greater&lt;P&gt; &gt; q;void Dijkstra()&#123; while(!q.empty()) q.pop(); p[st].ans=0; q.push(make_pair(0,st)); while(!q.empty()) &#123; P s=q.top();q.pop(); int x=s.second; if(s.first&gt;p[x].ans) continue; for(int k=p[x].hou;k&gt;0;k=e[k].gg) &#123; int y=e[k].y; if(p[y].ans&gt;p[x].ans+e[k].c) &#123; p[y].ans=p[x].ans+e[k].c; q.push(make_pair(p[y].ans,y)); &#125; &#125; &#125;&#125;//*******************接口*******************int a,b;int pt(int x,int y)&#123; return (x-1)*b+y;&#125;//*******************主函数*******************int t[3][1100][1100];int main(int argc, char *argv[])&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); if(n==1 or m==1) &#123; if(n&gt;m) swap(n,m); int ans=INF; for(int i=1,a;i&lt;m;i++) &#123; scanf("%d",&amp;a); ans=mymin(ans,a); &#125; printf("%d",ans==INF?0:ans); return 0; &#125; for(int k=0;k&lt;=2;k++) for(int i=1;i&lt;=(k==0?n:n-1);i++) for(int j=1;j&lt;=(k==1?m:m-1);j++) t[k][i][j]=read(); ln=0; a=(n-1)*2,b=m-1; int cnt=a*b; for(int i=1;i&lt;=cnt+2;i++) &#123; p[i].ans=INF; p[i].hou=0; &#125; for(int i=1;i&lt;=a;i++) for(int j=1;j&lt;=b;j++) if(i%2==0) &#123; ins(pt(i,j),pt(i-1,j),t[2][i/2][j]); &#125; else &#123; if(i&gt;1) ins(pt(i,j),pt(i-1,j),t[0][(i+1)/2][j]); if(j&lt;b) ins(pt(i,j),pt(i+1,j+1),t[1][(i+1)/2][j+1]); &#125; st=cnt+1;ed=cnt+2; for(int i=2;i&lt;=a;i+=2) ins(st,pt(i,1),t[1][i/2][1]),//左 ins(pt(i-1,b),ed,t[1][i/2][m]);//右 for(int j=1;j&lt;=b;j++) ins(st,pt(a,j),t[0][n][j]),//下 ins(pt(1,j),ed,t[0][1][j]);//上 Dijkstra(); printf("%d",p[ed].ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>网络流</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>最小割</tag>
        <tag>对偶图</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1645】City Horizon城市地平线]]></title>
    <url>%2Fposts%2Feed1.html</url>
    <content type="text"><![CDATA[来源和评测点USACO 2007 Open SilverBzoj1645 题目【题目大意】约翰带着奶牛去都市观光。在落日的余晖里，他们看到了一幢接一幢的摩天高楼的轮廓在地平线上形成美丽的图案。以地平线为 X 轴，每幢高楼的轮廓是一个位于地平线上的矩形，彼此间可能有重叠的部分。奶牛一共看到了N幢高楼，第i幢楼的高度是Hi，两条边界轮廓在地平线上的坐标是Ai到Bi。请帮助奶牛们计算一下，所有摩天高楼的轮廓覆盖的总面积是多少。【输入格式】第一行：单个整数N，1≤N≤40000第二行到第N+1行：第i+1行有三个整数Ai，Bi和Hi，1≤Ai&lt;Bi≤10^9, 1≤Hi≤10^9【输出格式】单个整数：表示摩天高楼轮廓所覆盖的总面积【输入样例】42 5 19 10 46 8 24 6 3【输出样例】16【样例解释】只有第一幢楼和最后一幢楼有1个单位的重叠面积 分析线段树教程和题目分类参见：【OI之路】06树-1线段树其他线段树题目参见：Tag-线段树 我看到网上有说“扫描线”，并不知道是什么……反正我的做法就是离散化信息，然后使用线段树，区间修改，维护单点最值最后求和即可 具体可参考注释 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;typedef long long ll;struct seg&#123; int l,r,mid; int lc,rc; int mx,lz;&#125;p[200000];int ln;int build(int l,int r)&#123; int t=++ln; p[t].l=l;p[t].r=r;p[t].mid=(l+r)&gt;&gt;1; if(l&lt;r) &#123; p[t].lc=build(l,p[t].mid); p[t].rc=build(p[t].mid+1,r); &#125; return t;&#125;//lz是lazy优化（区间修改一般都有）//定义为某尚未尝试更新的值，且必须下传void pushdown(int x)&#123; if(!p[x].lz) return; p[x].mx=mymax(p[x].mx,p[x].lz); int lc=p[x].lc,rc=p[x].rc; p[lc].lz=mymax(p[lc].lz,p[x].lz); p[rc].lz=mymax(p[rc].lz,p[x].lz); p[x].lz=0;&#125;void change(int x,int l,int r,int c)&#123; if(p[x].l==l and p[x].r==r) &#123; p[x].lz=mymax(p[x].lz,c); return; &#125; pushdown(x); int lc=p[x].lc,rc=p[x].rc; if(r&lt;=p[x].mid) change(lc,l,r,c); else if(l&gt;p[x].mid) change(rc,l,r,c); else change(lc,l,p[x].mid,c),change(rc,p[x].mid+1,r,c);&#125;int ask(int w,int x)&#123; pushdown(w); if(p[w].l==p[w].r) return p[w].mx; if(x&lt;=p[w].mid) return ask(p[w].lc,x); return ask(p[w].rc,x);&#125;int n;int a[81000];int l[41000],r[41000],h[41000];int find(int x)&#123; int l=1,r=2*n; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(a[mid]&lt;x) l=mid+1; else if(a[mid]==x) return mid; else r=mid-1; &#125;&#125;//由于是函数，保证了相同x返回相同的值，具体是什么不重要int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d%d",&amp;l[i],&amp;r[i],&amp;h[i]); if(l[i]==r[i])//特判，防止空信息 &#123; i--;n--; continue; &#125; a[2*i-1]=l[i];a[2*i]=r[i]; &#125; sort(a+1,a+1+2*n); int rx=2*n; //改点区间为段区间，便于维护 ln=0;build(1,rx); for(int i=1;i&lt;=n;i++) change(1,find(l[i])+1,find(r[i]),h[i]); //二分离散化 //为了能够实现同值的结果依然同值并且获得损失的区间信息量 ll s=0; for(int i=2;i&lt;=2*n;i++) s+=ll(ask(1,i))*ll(a[i]-a[i-1]); //记得还原信息 printf("%lld",s);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1934】【Bzoj2768】善意的投票&冠军调查]]></title>
    <url>%2Fposts%2Fa1fb.html</url>
    <content type="text"><![CDATA[来源和评测点这两道题连样例都是一模一样的……下文以1934来分析Bzoj1934Bzoj2768 注意！Bzoj2768冠军调查数据可能和题面不同，网络流边数应开到40万而不是10万 题目【题目大意】幼儿园里有n个小朋友打算通过投票来决定睡不睡午觉。对他们来说，这个问题并不是很重要，于是他们决定发扬谦让精神。虽然每个人都有自己的主见，但是为了照顾一下自己朋友的想法，他们也可以投和自己本来意愿相反的票。我们定义一次投票的冲突数为好朋友之间发生冲突的总数加上和所有和自己本来意愿发生冲突的人数。 我们的问题就是，每位小朋友应该怎样投票，才能使冲突数最小？【输入格式】第一行只有两个整数n，m，保证有2≤n≤300，1≤m≤n(n-1)/2。其中n代表总人数，m代表好朋友的对数。文件第二行有n个整数，第i个整数代表第i个小朋友的意愿，当它为1时表示同意睡觉，当它为0时表示反对睡觉。接下来文件还有m行，每行有两个整数i，j。表示i，j是一对好朋友，我们保证任何两对i，j不会重复。【输出格式】只需要输出一个整数，即可能的最小冲突数。【输入样例】3 31 0 01 21 33 2【输出样例】1【样例解释】所有小朋友都投赞成票就能得到最优解 分析网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他最小割题目参见：Tag-最小割 考验模型转化能力，难度2吧想了十多分钟？当然，已经知道是最小割了 “分配方案”、“强制站队”是我自己的理解方式，因人而异吧 一开始想着“分配方案”最大流，每个人与1、0连接，然后后面朋友间的边权依赖于前面，所以不可行 由于只有睡和不睡两种选择，考虑最小割“强制站队”，源点是睡觉的，汇点是不睡觉的每个人只能选择其中一个，形成了最小割构图：依然要拆点源点到左人、右人到汇点，边权都根据个人意愿决定，是自己意愿就是1，因为拆了就违反意愿，否则为0同理，好朋友之间边权是1 想想特例:1、所有人都不想睡觉，最大流是0好朋友之间也不会有违背，确实是0，没问题2、没有好朋友，最大流是0直接每个人依照自己意愿，确实是0，也没问题 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;const int MAXN=1000,MAXM=410000;struct pt&#123; int h; int hou;&#125;p[MAXN];struct rod&#123; int y,c,g; int oth;&#125;e[MAXM];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; ln++; e[ln].y=x;e[ln].c=0; e[ln].g=p[y].hou;p[y].hou=ln; e[ln].oth=ln-1;e[ln-1].oth=ln;&#125;int st,ed;int lst[MAXN];bool bfs()&#123; for(int i=1;i&lt;=ed;i++) p[i].h=0; lst[1]=st;p[st].h=1; int tou=1,wei=1; while(tou&lt;=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==0 and e[k].c&gt;0) &#123; p[y].h=p[x].h+1; lst[++wei]=y; &#125; &#125; tou++; &#125; return p[ed].h&gt;0;&#125;int dfs(int x,int f)&#123; if(x==ed) return f; int t=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==p[x].h+1 and t&lt;f and e[k].c&gt;0) &#123; int tt=dfs(y,mymin(f-t,e[k].c)); t+=tt;e[k].c-=tt;e[e[k].oth].c+=tt; &#125; &#125; if(t==0) p[x].h=0; return t;&#125;int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); st=n+n+1,ed=n+n+2;ln=0; for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); if(t) ins(st,i,1); else ins(n+i,ed,1); &#125; for(int i=1;i&lt;=m;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,n+y,1);ins(y,n+x,1); &#125; int ans=0; while(bfs()) ans+=dfs(st,INF); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj2112】Optimal Milking]]></title>
    <url>%2Fposts%2F41bc.html</url>
    <content type="text"><![CDATA[来源和评测点USACO 2003 US OpenPoj2112Caioj1119 题目【题目大意】FJ把K个挤奶机搬进了住着C头奶牛的牧场。挤奶机的编号为1~K，奶牛的编号为K+1~K+C。每头奶牛到每台挤奶机距离不同，每台挤奶机每天最多服务M头奶牛。求一种分配方案, 使得走得最远的奶牛走过的距离最小化，输出此距离重点句：Cows can traverse several paths on the way to their milking machine. 路径the distance the furthest-walking cow travels is minimized 走最多的牛的路程最小【输入格式】数据第1行是3个整数K，C，M（1≤K≤30）（1≤C≤200）（1≤M≤15）接下来是一个（K+C）×（K+C）的距离矩阵。矩阵元素为正并不超200。距离为0表示两个点之间无边存在。【输出格式】输出一个整数，即走得最远的奶牛走过的距离的最小化值。【输入样例】2 3 20 3 2 1 13 0 3 2 02 3 0 1 01 2 1 0 21 0 0 2 0【输出样例】2 分析网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他网络流题目参见：Tag-网络流 其实可以尝试着看看英文题 依旧是folyd，然后二分答案(反正最终还是要到达挤奶机的) 构图：从源点到牛建权值为1的边牛到挤奶机建权值为1的边（当满足二分条件时）挤奶机到汇点建权值为m的边 相比上一题Ombrophobic Bovines相当无聊，秒AC 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;const int MAXN=310,MAXM=91000;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;struct pt&#123; int h; int hou;&#125;p[MAXN];struct rod&#123; int y,c,g; int oth;&#125;e[MAXM];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; ln++; e[ln].y=x;e[ln].c=0; e[ln].g=p[y].hou;p[y].hou=ln; e[ln].oth=ln-1;e[ln-1].oth=ln;&#125;int st,ed;int lst[MAXN];bool bfs()&#123; for(int i=1;i&lt;=ed;i++) p[i].h=0; int tou=1,wei=1; lst[1]=st;p[st].h=1; while(tou&lt;=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==0 and e[k].c&gt;0) &#123; p[y].h=p[x].h+1; lst[++wei]=y; &#125; &#125; tou++; &#125; return p[ed].h&gt;0;&#125;int dfs(int x,int f)&#123; if(x==ed) return f; int t=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==p[x].h+1 and e[k].c&gt;0 and t&lt;f) &#123; int tt=dfs(y,mymin(f-t,e[k].c)); t+=tt;e[k].c-=tt;e[e[k].oth].c+=tt; &#125; &#125; if(t==0) p[x].h=0; return t;&#125;//挤奶机的编号为1~K，奶牛的编号为K+1~K+Cint cst[MAXN][MAXN];int nk,nc,m;bool check(int mid)&#123; ln=0;for(int i=1;i&lt;=ed;i++) p[i].hou=0; for(int i=1;i&lt;=nc;i++) ins(st,i,1); for(int i=1;i&lt;=nc;i++) for(int j=1;j&lt;=nk;j++) if(cst[j][nk+i]&lt;=mid) ins(i,nc+j,1); for(int j=1;j&lt;=nk;j++) ins(nc+j,ed,m); int ans=0; while(bfs()) ans+=dfs(st,INF); return ans==nc;&#125;int main()&#123; scanf("%d%d%d",&amp;nk,&amp;nc,&amp;m); st=nc+nk+1,ed=nc+nk+2; int n=nk+nc; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; int c;scanf("%d",&amp;c); cst[i][j]=(c==0)?INF:c; &#125; int l=0,r=0; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; int tt=cst[i][k]+cst[k][j]; if(tt&lt;cst[i][j]) cst[i][j]=tt; if(cst[i][j]!=INF and r&lt;cst[i][j]) r=cst[i][j]; &#125; int ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf("%d",ans);&#125; 分析2然鹅通过改进匈牙利算法实现多重二分图匹配能大幅度加快速度，从而取代网络流思路来自http://blog.csdn.net/leolin_/article/details/7195205 代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;const int INF=0x3f3f3f3f;const int MAXGN=300,MAXMN=50,MAXM=15000;int hou[MAXGN];struct rod&#123; int y,g;&#125;e[MAXM];int ln;void ins(int x,int y)&#123; ln++;e[ln].y=y; e[ln].g=hou[x];hou[x]=ln;&#125;int gn,mn;int mnum[MAXMN];int match[MAXMN][20];int ask[MAXMN];int tnow;int kk,cc,mm;bool find_muniu(int x)&#123; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(ask[y]&lt;tnow) &#123; ask[y]=tnow; if(mnum[y]&lt;mm) &#123; match[y][++mnum[y]]=x; return 1; &#125; else &#123; for(int z=1;z&lt;=mnum[y];z++) &#123; if(find_muniu( match[y][z] )) &#123; match[y][z]=x; return 1; &#125; &#125; &#125; &#125; &#125; return 0;&#125;int cst[MAXGN+MAXMN][MAXGN+MAXMN];bool check(int mid)&#123; ln=0; for(int i=1;i&lt;=gn;i++) &#123; hou[i]=0; for(int j=1;j&lt;=mn;j++) if(cst[kk+i][j]&lt;=mid) ins(i,j); &#125; memset(ask,0,sizeof(ask));//debug memset(mnum,0,sizeof(mnum));//debug for(tnow=1;tnow&lt;=gn;tnow++) if(find_muniu(tnow)==0) return 0; return 1;&#125;int mx;void folyd(int n)&#123; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) cst[i][j]=mymin(cst[i][k]+cst[k][j],cst[i][j]); mx=0; for(int i=1;i&lt;=kk;i++) for(int j=1;j&lt;=cc;j++) if(cst[i][j]&gt;mx and cst[i][j]&lt;INF) mx=cst[i][j];&#125;int main()&#123; scanf("%d%d%d",&amp;kk,&amp;cc,&amp;mm); for(int i=1;i&lt;=kk+cc;i++) for(int j=1;j&lt;=kk+cc;j++) &#123; int t;scanf("%d",&amp;t); cst[i][j]=(t==0)?INF:t; &#125; folyd(kk+cc); gn=cc,mn=kk; int l=0,r=mx,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>难度2</tag>
        <tag>Floyd</tag>
        <tag>二分</tag>
        <tag>匈牙利</tag>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3189】Steady Cow Assignment]]></title>
    <url>%2Fposts%2Fb6a3.html</url>
    <content type="text"><![CDATA[来源和评测点USACO 2006 February GoldPoj3189Caioj1120 题目【题目大意】有N(1&lt;=N&lt;=1000)头牛，B(1&lt;=B&lt;=20)个牛圈每头牛对于牛圈都有不同的喜好程度排名，牛圈有一定的容量对于某种分配方案，假如牛1去了牛圈3，是它的第五志愿，记满意程度=5输出（所有牛的满意程度 最大值到最小值的区间）的最小值相当于 （MAX牛的满意程度）-（MIN牛的满意程度）+1重点句：Your job is to find an assignment of cows to barns such that no barn’s capacity is exceeded and the size of the range (i.e., one more than the positive difference between the the highest-ranked barn chosen and that lowest-ranked barn chosen) of barn rankings the cows give their assigned barns is as small as possible.【输入格式】第一行N和B接下来N行，每行B个数，表示喜欢的牛圈的序号，按喜欢的程度（递减）给出，（比如第一个给出的牛圈的就是最喜欢，最后一个就是最不喜欢的）接下来B个数，每个数表示牛圈最多容纳的牛的数目【输出格式】最小的“满意程度区间”【输入样例】6 41 2 3 42 3 1 44 2 3 13 1 2 41 3 4 21 4 2 32 1 3 2【输出样例】2【样例解释】牛圈1：牛1 牛5牛圈2：牛2牛圈3：牛4牛圈4：牛3 牛6满意程度 1 1 1 1 1 2答案就是 2 分析网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他网络流题目参见：Tag-网络流 其实可以尝试着看看英文题题意我翻译好了，caioj不完整也不好理解，poj全英文 对于区间，枚举下界，在此基础上二分答案O( B*logB*(n^3) )这做法真的狗血，好久没用过枚举了 构图：源点到牛连权值为1的边牛到牛圈连权值为1的边牛圈到汇点连权值为 该牛圈容量 的边 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;const int MAXN=1100,MAXM=61000;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;struct pt&#123; int h; int hou;&#125;p[MAXN];struct rod&#123; int y,c,g; int oth;&#125;e[MAXM];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; ln++; e[ln].y=x;e[ln].c=0; e[ln].g=p[y].hou;p[y].hou=ln; e[ln].oth=ln-1;e[ln-1].oth=ln;&#125;int st,ed;int lst[MAXN];bool bfs()&#123; for(int i=1;i&lt;=ed;i++) p[i].h=0; int tou=1,wei=1; lst[1]=st;p[st].h=1; while(tou&lt;=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==0 and e[k].c&gt;0) &#123; p[y].h=p[x].h+1; lst[++wei]=y; &#125; &#125; tou++; &#125; return p[ed].h&gt;0;&#125;int dfs(int x,int f)&#123; if(x==ed) return f; int t=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==p[x].h+1 and e[k].c&gt;0 and t&lt;f) &#123; int tt=dfs(y,mymin(f-t,e[k].c)); t+=tt;e[k].c-=tt;e[e[k].oth].c+=tt; &#125; &#125; if(t==0) p[x].h=0; return t;&#125;int n,b;int lv[MAXN][30];int ct[30];bool check(int ll,int rr)&#123; ln=0;for(int i=1;i&lt;=ed;i++) p[i].hou=0; for(int i=1;i&lt;=n;i++) &#123; ins(st,i,1); for(int j=ll;j&lt;=rr;j++) ins(i, n+lv[i][j] ,1); &#125; for(int i=1;i&lt;=b;i++) ins(n+i,ed,ct[i]); int ans=0; while( bfs() ) ans+=dfs(st,INF); //printf("-----ll=%d rr=%d ans=%d n=%d\n",ll,rr,ans,n); return ans==n;&#125;int getans(int low)&#123; int l=1,r=b-low+1,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(low,low+mid-1)) ans=mid,r=mid-1; else l=mid+1; &#125; //printf("low=%d ans=%d\n",low,ans); return ans&lt;0?INF:ans;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;b); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=b;j++) scanf("%d",&amp;lv[i][j]); for(int i=1;i&lt;=b;i++) scanf("%d",&amp;ct[i]); st=n+b+1,ed=n+b+2; int mi=INF; for(int i=1;i&lt;=b;i++) mi=mymin(mi, getans(i) ); printf("%d",mi);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>难度2</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Usaco05Mar】Ombrophobic Bovines]]></title>
    <url>%2Fposts%2F44a6.html</url>
    <content type="text"><![CDATA[来源和评测点USACO 2005 March GoldBzoj1738Poj2391Caioj1118 题目【题目大意】下雨了，有F(1&lt;=F&lt;=200)个牛棚，这F个牛棚之间有P(1&lt;=P&lt;=1500)条无向边（有耗时）每个牛棚有两个值A和B（A表示一开始这个牛棚有A头牛，B表示下雨时该牛棚最多可以容纳B头牛躲雨）。问最少需要提前多少时间响“下雨警告”才能让所有牛在下雨前都能够找到可以遮雨的地方。 重点句：The paths are wide,so that any number of cows can traverse a path in either direction. 无向边Fields are small compared to the paths and require no time for cows to traverse. 将牛棚看作点【输入格式】两个整数: F 和 P接下来F行，第i行两个整数A和B（A、B的范围都是:0..1000）描述第i个牛棚接下来P行，每行三个整数。X Y L，表示牛棚X和牛棚Y之间有一条边，耗时是L（1&lt;=L&lt;=1,000,000,000）【输出格式】输出一行，即为最短的时间，如果无法使得所有牛都能够有地方避雨，那么输出 “-1”【输入样例】3 47 20 42 61 2 403 2 702 3 901 3 120【输出样例】110【样例解释】牛棚1安排4头牛到牛棚2，牛棚1再安排1头牛走到牛棚2，再走到牛棚3避雨。 分析网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他网络流题目参见：Tag-网络流本题入选了好题：Tag-好题 这道题建议大家像我一样仔细想想，别急着看题解，虽然你到我这个页面很可能是来膜题解的 由于边比较复杂，但又是无向图考虑Floyd获得两点之间最短耗时然后两点之间只存在一条边了 原问题转化成：选一些边来满足条件并且最长边最小条件为牛跑来跑去后每个牛棚能容纳下 考虑二分答案，从而得到满足的边，跑一遍网络流验证解的可行性 构图：从汇点到各个左牛棚，容量是每个牛棚原本的牛数量拆点，从左牛棚连到右牛棚，表示可以通过去，容量是无限从右牛棚到汇点，容量是牛棚最后的最大容纳 假如最大流=牛的数量F 表示可行 记得自己可以连自己 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;const int MAXN=510,MAXM=110000;struct pt&#123; int h; int hou;&#125;p[MAXN];struct rod&#123; int y,c,g; int oth;&#125;e[MAXM];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; ln++; e[ln].y=x;e[ln].c=0; e[ln].g=p[y].hou;p[y].hou=ln; e[ln-1].oth=ln;e[ln].oth=ln-1;&#125;int st,ed;int lst[MAXN];bool bfs()&#123; for(int i=1;i&lt;=ed;i++) p[i].h=0; int tou=1,wei=1; lst[1]=st;p[st].h=1; while(tou&lt;=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==0 and e[k].c&gt;0) &#123; p[y].h=p[x].h+1; lst[++wei]=y; &#125; &#125; tou++; &#125; return p[ed].h&gt;0;&#125;int dfs(int x,int f)&#123; if(x==ed) return f; int t=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==p[x].h+1 and e[k].c&gt;0 and t&lt;f) &#123; int tt=dfs(y,mymin(f-t,e[k].c)); t+=tt;e[k].c-=tt;e[e[k].oth].c+=tt; &#125; &#125; if(t==0) p[x].h=0; return t;&#125;/*1~n 左牛棚n+1~n+n 右牛棚n+n+1 源点n+n+2 汇点*/int n;int alc;int aa[MAXN],bb[MAXN];ll cst[MAXN][MAXN];bool check(ll mid)&#123; ln=0;for(int i=1;i&lt;=ed;i++) p[i].hou=0; for(int i=1;i&lt;=n;i++) &#123; ins(st,i,aa[i]);ins(i,n+i,INF);ins(n+i,ed,bb[i]); for(int j=1;j&lt;=n;j++) if(cst[i][j]&lt;=mid) ins(i,n+j,INF); &#125; int ans=0; while(bfs()) ans+=dfs(st,INF); //printf("mid=%d ans=%d alc=%d\n",mid,ans,alc); return ans==alc;&#125;int main()&#123; memset(cst,63,sizeof(cst)); int m;scanf("%d%d",&amp;n,&amp;m); st=n+n+1,ed=n+n+2; for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;aa[i],&amp;bb[i]),alc+=aa[i]; for(int i=1;i&lt;=m;i++) &#123; int x,y;ll c;scanf("%d%d%lld",&amp;x,&amp;y,&amp;c); if(c&lt;cst[x][y]) cst[x][y]=cst[y][x]=c; &#125; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; ll nt=cst[i][k]+cst[k][j]; if(nt&lt;cst[i][j]) cst[i][j]=nt; &#125; ll l=0,r=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=i-1;j++) if(cst[i][j]!=cst[0][0] and cst[i][j]&gt;r) r=cst[i][j]; ll ans=-1; while(l&lt;=r) &#123; ll mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>Floyd</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj2455】【Bzoj1733】Secret Milking Machine]]></title>
    <url>%2Fposts%2F7731.html</url>
    <content type="text"><![CDATA[来源和评测点USACO 2005 February GoldPoj2455Bzoj1733Caioj1117 题目【题目大意】给出N(2&lt;=N&lt;=200)个点和P(1&lt;=P&lt;=40000)条双向边，每条边的长度为（0~1000000）现在要求选出T(1&lt;=T&lt;=200)条“1至N”的路径，任意两条路径上的边不能重复并且要求这些路径中的最长边的长度最小注意：两个点之间有可能多条边，出发点是1，终点是N【输入格式】第一行三个整数: N,P,T下来P行,每行三个整数x,y,L,描述一条边：从点x到y的双向边，长度为Li【输出格式】求这T条路径中的的最长边的最小值【输入样例】7 9 21 2 22 3 53 7 51 4 14 3 14 5 75 7 11 6 36 7 3【输出样例】5提示：样例最后选择了两条路径 1-2-3-7 和 1-6-7 最长的路是5. 分析网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他网络流题目参见：Tag-网络流 注意两个概念：边 和 路径（路径是由多条边组成，当然可以是一条边）这题需要建立模型重点是二分，在同学的提醒下想到这个，然后就想通了就是二分最长边长度，满足结果（可行性）有序性因为每条边只能去一次，边权为1即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;const int MAXN=210,MAXM=81000;struct pt&#123; int hou; int h;&#125;p[MAXN];struct rod&#123; int y,c,g; int oth;&#125;e[MAXM];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; ln++; e[ln].y=x;e[ln].c=c; e[ln].g=p[y].hou;p[y].hou=ln; e[ln-1].oth=ln;e[ln].oth=ln-1;&#125;int m,T;int st,ed;int lst[MAXN];bool bfs()&#123; for(int i=st;i&lt;=ed;i++) p[i].h=0; int tou=1,wei=1; lst[1]=st;p[st].h=1; while(tou&lt;=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==0 and e[k].c&gt;0) &#123; p[y].h=p[x].h+1; lst[++wei]=y; &#125; &#125; tou++; &#125; return p[ed].h&gt;0;&#125;int dfs(int x,int f)&#123; //printf("---x=%d f=%d\n",x,f); if(x==ed) return f; int t=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(t&lt;f and e[k].c&gt;0 and p[y].h==p[x].h+1) &#123; int fs=dfs(y,mymin(e[k].c,f-t)); t+=fs;e[k].c-=fs;e[e[k].oth].c+=fs; &#125; &#125; if(t==0) p[x].h=0; return t;&#125;int xx[MAXM],yy[MAXM],cc[MAXM];bool check(int mid)&#123; for(int i=st;i&lt;=ed;i++) p[i].hou=0; ln=0; for(int i=1;i&lt;=m;i++) if(cc[i]&lt;=mid) ins(xx[i],yy[i],1); int ans=0; while(bfs()) ans+=dfs(st,INF); return ans&gt;=T;&#125;int main()&#123; int n;scanf("%d%d%d",&amp;n,&amp;m,&amp;T); int l=INF,r=-INF; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;xx[i],&amp;yy[i],&amp;cc[i]); l=mymin(l,cc[i]);r=mymax(r,cc[i]); &#125; st=1,ed=n; int ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3281】Dining]]></title>
    <url>%2Fposts%2F6d11.html</url>
    <content type="text"><![CDATA[来源和评测点USACO 2007 Open GoldPoj3281Caioj1116 题目【题目大意】有F(1≤F≤1000)块不同的肉（编号1~F）和D(1≤D≤1000)罐不同的饮料（编号1~D），N(1≤N≤1000)头（编号1~N）。每头牛有自己喜欢的肉和饮料。每块肉和每罐饮料只能供给一头牛使用。求最多能满足多少头牛能同时享用到自己喜欢的肉和饮料。（注意某头牛得到满足，不要求享用自己所有喜欢的肉和饮料，只要喜欢的肉的其中一块和自己喜欢的饮料其中一罐就可以算满足）【输入格式】第一行：三个整数N,F,D接下来N行。每行描述一头牛。每行开头两个整数Fi和Di，Fi表示该牛喜欢的肉的数目，Di表示它喜欢的饮料的数目。接下来Fi个数，各表示它喜欢的肉的编号，再来Di个数，表示它喜欢的饮料的编号。（注意Fi和Di有可能为0）【输出格式】一个整数，最大满足的牛的数目【输入样例】4 3 32 2 1 2 3 12 2 2 3 1 22 2 1 3 1 22 1 1 3 3【输出样例】3 分析网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他网络流题目参见：Tag-网络流 类似模板题终极起点连接肉肉连接牛牛连接饮料饮料连接终极终点 但还要拆点，为了让一头牛只能选一种，把一头牛分成两个，自己连自己 所有边权都是1，这样的最大流就是方案数 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; const int MAXN=5000,MAXM=1000000;struct pt&#123; int h; int hou;&#125;p[MAXN];struct edge&#123; int y,c,g; int oth;&#125;e[2*MAXM];int ln;void ins(int x,int y,int c)&#123; e[++ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; e[++ln].y=x;e[ln].c=0; e[ln].g=p[y].hou;p[y].hou=ln; e[ln-1].oth=ln;e[ln].oth=ln-1;&#125;int st,ed;int lst[MAXN];bool bfs()&#123; for(int i=1;i&lt;=ed;i++) p[i].h=0; lst[1]=st;p[st].h=1; int tou=1,wei=1; while(tou&lt;=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==0 and e[k].c&gt;0) &#123; p[y].h=p[x].h+1; lst[++wei]=y; &#125; &#125; tou++; &#125; return p[ed].h&gt;0;&#125;int dfs(int x,int f)&#123; if(x==ed) return f;//debug int t=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[x].h+1==p[y].h and e[k].c&gt;0 and t&lt;f) &#123; int s=dfs(y,mymin(f-t,e[k].c)); t+=s;e[k].c-=s;e[e[k].oth].c+=s; &#125; &#125; if(t==0) p[x].h=0;//debug return t;&#125;/*1~ff+1~f+nf+n+1~f+n+nf+n+n+1~f+n+n+d*/int main()&#123; int n,f,d;scanf("%d%d%d",&amp;n,&amp;f,&amp;d); int cw1=f,cw2=f+n,dk=f+n+n; st=f+n+n+d+1,ed=f+n+n+d+2; ln=0; for(int i=1;i&lt;=n;i++) &#123; int fi,di;scanf("%d%d",&amp;fi,&amp;di); for(int j=1;j&lt;=fi;j++) &#123; int t;scanf("%d",&amp;t); ins(t,cw1+i,1); &#125; for(int j=1;j&lt;=di;j++) &#123; int t;scanf("%d",&amp;t); ins(cw2+i,dk+t,1); &#125; ins(cw1+i,cw2+i,1); &#125; for(int i=1;i&lt;=f;i++) ins(st,i,1); for(int i=1;i&lt;=d;i++) ins(dk+i,ed,1); int ans=0; while(bfs()) ans+=dfs(st,INF); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj1273】网络流模版题Drainage Ditches]]></title>
    <url>%2Fposts%2F9eca.html</url>
    <content type="text"><![CDATA[来源和评测点USACO 1993Poj1273Syzoj11772Hdu1532Caioj1115 题目【题目大意】有N条水渠,及M个池塘给出M条水渠所连接的池塘和所能流过的水量（有向）求水渠1到水渠M中所能流过的水的最大容量 （Caioj上先池塘后水渠）（Hdu上多组数据）【输入格式】第1行:2个整数N(0&lt;=N&lt;=200)和M(2&lt;=M&lt;=200)接下来M行: 每行有三个整数：x,y,c表示一条从点x到点y的有向边，流量为c(0&lt;=c&lt;=10,000,000)【输出格式】输出一个整数，即最大流量。【输入样例1】5 41 2 401 4 202 4 202 3 303 4 10【输出样例1】50 理论上可以卡最短路的数据【输入样例2】4 41 2 102 4 52 3 203 4 10【输出样例2】10 分析网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他网络流题目参见：Tag-网络流 模板题 代码我的代码n是点数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; const int MAXN=210;const int INF=0x3f3f3f3f; struct pt&#123; int h; int hou;&#125;p[MAXN];struct nod&#123; int y,c,g;&#125;e[MAXN*2];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln;&#125; int n;int lst[MAXN];int st,ed;bool bfs()&#123; for(int i=1;i&lt;=n;i++) p[i].h=0; int tou=1,wei=1; lst[1]=st;p[1].h=1; while(tou&lt;=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==0 and e[k].c&gt;0) &#123; p[y].h=p[x].h+1; lst[++wei]=y; &#125; &#125; tou++; &#125; return p[ed].h&gt;0;&#125; int getoth(int k)&#123; return k%2==0?k-1:k+1;&#125; int dfs(int x,int f)&#123; if(x==ed) return f; int t=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==p[x].h+1 and e[k].c&gt;0 and t&lt;f) &#123; int tt=dfs(y,mymin(e[k].c,f-t)); t+=tt;e[k].c-=tt;e[getoth(k)].c+=tt; &#125; &#125; return t;&#125; int main()&#123; int m;scanf("%d%d",&amp;m,&amp;n);ln=0; for(int i=1;i&lt;=m;i++) &#123; int x,y,c; scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);ins(y,x,0);//反向弧 &#125; st=1;ed=n; int ans=0; while(bfs()) ans+=dfs(st,INF); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2017游记]]></title>
    <url>%2Fposts%2Fd1a6.html</url>
    <content type="text"><![CDATA[Zory at NOIP2017 2017.11.10 Friday下午在车上浪（与lhp打农药） 晚上到酒店后去万达广场晚饭在毛家饭店吃，有的人吃不了辣，点得有点多了然后在离开时在电梯处抢拍了众多神犇：接着初三小队逛一逛，买瓶饮料，等我妈送电脑来酒店一个房一个wifi，还算流畅萌萌哒lhp（右）晚上开会也就说说保管好准考证、身份证什么的复习一下同余方程组，caioj和poj一遍AC做了一道单调队列，scy说他押这两个其实还有很虚，晚上十一点睡觉 2017.11.11 Saturday啦啦啦光棍节 上午六点半起床，在酒店吃早餐走十多分钟到二中科学城校区和zzz、zxr同一间电脑室哦好像还有个二中的zjt大佬？之前电脑室听师兄提到过发现忘记带眼镜了特别尴尬，输密码的时候因为看不清借旁边的眼睛死都输错，请监考过来看，原来是一直开着大写ps 赛后才发现是buwangchuxin不忘初心，好密码呀因为输错没心情了或许D1心态不爆炸能做第三题？眼镜这种事…… 第一题 小凯的疑惑大概是数论？因为这些天搞数论搞多了一下想到拓展欧几里德，60分以上好像会超时试着推公式，找规律硬是找不到，感觉这题会比后面两题简单然后就做了一两个小时？可能70分吧 第二题 时间复杂度O(n)模拟吧没多少时间了随便打打然后过了大小样例没有自己出数据，有点虚 第三题 逛公园判0环什么的主要是不会怎么求方案数加上没时间，直接没做 出来以后在升旗台集合，和众大佬讨论第一题正解是O(1) a*b-a-b 有的大佬五分钟想到，无语了我第三题可能是改spfa？听不懂yzh的做法 估分60+60+0=120最坏80，最好180 下午受不了了网络真的不行手机电脑主要用流量了本来想看斜率优化的，很快又去颓废了其实本来没有打游戏的打算的，所以没有带ipad手机玩真的难受，经常借lhp的iphone喉咙特别痛 晚上初三小分队继续万达，吃鸡，因为派了优惠卷开会时因为scy不在，代理人栋老师叫大家过去，五分钟“记住scy说的话”就散了于是在308玩狼人杀到十一点，特别high 2017.11.12 Sunday上午早上起来稍微有点困这次戴好眼镜了密码一遍过 第一题 奶酪N^2建边深搜跑一遍就好过了大小样例，自己也出了几组数据，找回自信100分应该没问题 第二题 宝藏看起来像最小生成树N^4枚举起点跑最小生成树枚举树里面的点和外面的点找最小的加进去样例可以过，但没有出数据或许又可以AC 第三题 列队暴力30分先到手数据范围应该不能开数组，应该有规律找不到以后试图搞20分的部分分就是x=1的情况比如每个位置记录这里的数的编号原位置与这个位置的偏移量然后用差分修改，树状数组维护？反正不会做弃疗了 估分100+100+30=230 出来以后听hz说第二题最小生成树是错的，应该是状压dp有点虚啊现在想来应该打对拍的，检测算法正确性哎自己说的自己却没有做到，其实模拟赛也一直没有这么干 下午车上浪，玩狼人杀回到学校后在竞赛室写退役日记其他人都回家了，就我无家可回喉咙稍微好点了 D2T2 chan老板正好也回来就找他讲讲为什么不能用最小生成树然后就D飞了我：5 51 2 5000002 3 102 4 1003 4 14 5 10000画张图一看，果然错了，安心退役 晚上滚回去文化课了…… 总结一下估分70+50+0+100+30+30=280话说好像scy押的题一个没中以后记得多几种解法，能用对拍检验的不只贪心 出代码以后2017.11.15洛谷自测第一题90，最后一个点TLE第二题幸运地AC了第四题AC第五题幸运地80了，虽然算法是错的第六题列队的暴力分3090+100+0+100+80+30=400 出成绩以后2017.11.21 math complexity park cheese treasure phalanx 65 100 0 100 45 30 treasure那题错误算法果然不稳定，不可寄予希望啊其他就比较贴合我的预估分数了]]></content>
      <categories>
        <category>竞赛历程</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2017训练日记]]></title>
    <url>%2Fposts%2Ff969.html</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>竞赛历程</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AC自动机】地图匹配]]></title>
    <url>%2Fposts%2F4c6e.html</url>
    <content type="text"><![CDATA[评测点Caioj1465 分析这道题数据的话。。好像直接来自hdu，有谁知道原题请留言然后数据中一个单词只会有一次机会，就不用考虑什么“第一个出现”之类了 从边框开始（尽量不重复）地一遍遍做AC自动机，为了方便求起始点，可以考虑倒着搜索（注意add也要倒着建）为了记录答案，s记录的是“假如是单词的开头，就表示单词编号”。因为是倒着的，c也要转向 【话说这道题应该是没有被覆盖的字符串的】 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//*******************定义*******************struct Trie&#123; int s,c[27],fail; bool b;&#125;a[200010];struct tans&#123; int x,y,c;&#125;ans[200010];//*******************实现*******************void clean(int x)&#123; a[x].s=a[x].fail=a[x].b=0; for(int f=1;f&lt;=26;f++) a[x].c[f]=-1;&#125;char s[2010];int len;int k;void add(int id)&#123; len=strlen(s+1); int x=0; for(int i=len;i&gt;=1;i--) &#123; int f=s[i]-'A'+1; if(a[x].c[f]&lt;0) &#123; a[x].c[f]=++k; clean(k); &#125; x=a[x].c[f]; &#125; a[x].s=id;&#125;int list[50010];void getfail()&#123; int tou=1,wei=2;list[1]=0; while(tou!=wei) &#123; int x=list[tou]; for(int f=1;f&lt;=26;f++) &#123; int son=a[x].c[f]; if(son&lt;0) continue; if(x==0) a[son].fail=0; else &#123; int p=a[x].fail; while(p&gt;0 and a[p].c[f]&lt;0) p=a[p].fail;//类似KMP的思想 a[son].fail=mymax(a[p].c[f],0); //可能没有一个匹配，最后出来的c[i]==-1 &#125; list[wei++]=son;if(wei&gt;50000) wei=1; &#125; tou++;if(tou&gt;50000) tou=1; &#125;&#125;int n,m;bool check(int x,int y)&#123; return x&gt;=1 and y&gt;=1 and x&lt;=n and y&lt;=m;&#125;const int tx[8]=&#123;-1,-1,0,1,1, 1, 0,-1&#125;;const int ty[8]=&#123; 0, 1,1,1,0,-1,-1,-1&#125;;char map[1010][1010];int solve(int x,int y,int c)&#123; int p=0; while(check(x,y)) &#123; int f=map[x][y]-'A'+1; while(p&gt;0 and a[p].c[f]&lt;0) p=a[p].fail; if(a[p].c[f]!=-1) p=a[p].c[f]; int k=p; while(k!=0 and a[k].b==0) &#123; if(a[k].s)//到了结尾 &#123; int o=a[k].s; ans[o].x=x; ans[o].y=y; ans[o].c=(c+4)%8;//因为倒着找，要倒过来 &#125; a[k].b=1;//经过 k=a[k].fail; &#125; x+=tx[c];y+=ty[c]; &#125;&#125;//*******************主函数*******************int main(int argc, char *argv[])&#123; int w;scanf("%d%d%d",&amp;n,&amp;m,&amp;w); for(int i=1;i&lt;=n;i++) scanf("%s",map[i]+1); clean(0);k=0; for(int i=1;i&lt;=w;i++) &#123; scanf("%s",s+1); add(i); &#125; //计算fail getfail(); //从边框开始（尽量不重复） for(int i=1;i&lt;=n;i++) &#123; solve(i,1,1);solve(i,1,2);solve(i,1,3);//左边 solve(i,m,5);solve(i,m,6);solve(i,m,7);//右边 &#125; for(int j=1;j&lt;=m;j++) &#123; solve(1,j,3);solve(1,j,4);solve(1,j,5);//上边 solve(n,j,7);solve(n,j,0);solve(n,j,1);//下边 &#125; for(int i=1;i&lt;=w;i++) printf("%d %d %c\n",ans[i].x-1,ans[i].y-1,ans[i].c+'A');&#125; 另外，如果你更喜欢正着搜索，就要正着add，s也放到结尾，c就不用转向了。给出不同的部分:add函数：12345678910111213141516void add(int id)&#123; ans[id].len=strlen(s+1); int x=0; for(int i=1;i&lt;=ans[id].len;i++) &#123; int f=s[i]-'A'+1; if(a[x].c[f]&lt;0) &#123; a[x].c[f]=++k; clean(k); &#125; x=a[x].c[f]; &#125; a[x].s=id;&#125; solve函数：12345678if(a[k].s)//到了结尾 &#123; int o=a[k].s; ans[o].x=x-(ans[o].len-1)*tx[c]; ans[o].y=y-(ans[o].len-1)*ty[c]; ans[o].c=c; //ans[o].c=(c+4)%8;//因为倒着找，要倒过来 &#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qtree3]]></title>
    <url>%2Fposts%2Fa8dd.html</url>
    <content type="text"><![CDATA[评测点Caioj1432Spoj2789 分析第三题终于修改线段树部分了，并且运用到将新编号转换回去那个yzz数组了。 2018.01.24 UP:其实蛮简单的……各位珍惜这种做较简单的中型数据结构的时光吧…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//*******************线段树*******************struct nod1&#123; int lz,rz,l,r,c; //c=0 没有 否则是第一个编号&#125;e[400010];int qq;int build(int l,int r)&#123; int t=++qq; e[t].l=l;e[t].r=r; e[t].lz=e[t].rz=-1; if(l!=r) &#123; int mid=(l+r)&gt;&gt;1; e[t].lz=build(l,mid); e[t].rz=build(mid+1,r); &#125; return t;&#125;void change(int x,int p)&#123; if(e[x].l==e[x].r) &#123; if(e[x].l!=p) printf("error1\n"); e[x].c=(e[x].c&gt;0)?0:e[x].l; return; &#125; int mid=(e[x].l+e[x].r)&gt;&gt;1; int lc=e[x].lz,rc=e[x].rz; if(p&lt;=mid) change(lc,p); else change(rc,p); e[x].c=(e[lc].c&gt;0)?e[lc].c:e[rc].c; //注意，因为树链的编号在线段树中从上往下 //所以编号越小离根节点越近&#125;int ask(int x,int l,int r)&#123; if(e[x].l==l and e[x].r==r) return e[x].c; int mid=(e[x].l+e[x].r)&gt;&gt;1; int lc=e[x].lz,rc=e[x].rz; if(r&lt;=mid) return ask(lc,l,r); if(l&gt;mid) return ask(rc,l,r); int t=ask(lc,l,mid); if(t&gt;0) return t;//同理 return ask(rc,mid+1,r);&#125;//*******************定义*******************struct nod2&#123; int dep,tot,son,fa,tp; int hou;&#125;a[100010];struct nod3&#123; int y,gg;&#125;b[200010];//*******************实现*******************int pp;void ins(int x,int y)&#123; pp++; b[pp].y=y; b[pp].gg=a[x].hou; a[x].hou=pp;&#125;void dfs1(int x)&#123; a[x].tot=1;a[x].son=0; for(int k=a[x].hou;k;k=b[k].gg) &#123; int y=b[k].y; if(y==a[x].fa) continue; a[y].fa=x; //a[y].dep=a[x].dep+1; dfs1(y); a[x].tot+=a[y].tot; if(a[a[x].son].tot&lt;a[y].tot) a[x].son=y; &#125;&#125;int z,yz[100010],yzz[100010];void dfs2(int x,int tp)&#123; yz[x]=++z;yzz[z]=x; a[x].tp=tp; if(a[x].son) dfs2(a[x].son,tp); for(int k=a[x].hou;k;k=b[k].gg) &#123; int y=b[k].y; if(y!=a[x].fa and y!=a[x].son) dfs2(y,y); &#125;&#125;int solve(int x)&#123; int ans=-1; while(a[x].tp!=1)//更简单的跳法 &#123; int t=ask(1,yz[ a[x].tp ],yz[x]); if(t&gt;0) ans=t;//最近的 x=a[ a[x].tp ].fa; &#125; int t=ask(1,yz[1],yz[x]);if(t&gt;0) ans=t; if(ans&gt;0) return yzz[ans];//记得还原 return -1;&#125;//*******************主函数*******************int main(int argc, char *argv[])&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); //for(int i=1;i&lt;=n;i++) a[i].hou=0; for(int i=1;i&lt;n;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; pp=0;a[1].dep=1;a[1].fa=0;dfs1(1); qq=0;dfs2(1,1); z=0;build(1,n); while(m--) &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); if(a==0) change(1,yz[b]); else printf("%d\n",solve(b)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>Qtree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qtree2]]></title>
    <url>%2Fposts%2F681c.html</url>
    <content type="text"><![CDATA[评测点Caioj1431Spoj913 分析第二题没有修改，所以预处理后通过LCA最近公共祖先求解，相对简单如果不熟LCA可以看看这篇文章：【OI之路】06树-5最近公共祖先求距离：dis[i]=第i个点到根的距离求第k个点：很巧妙地利用了dep即深度来获得节点数量 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879int bin[31];void InitBin(void)&#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1;&#125;//*******************定义*******************int hou[100010],dep[100010];int yy[200010],gg[200010],cc[200010];//*******************实现*******************int ln;void ins(int x,int y,int c)&#123; ln++; yy[ln]=y;gg[ln]=hou[x];cc[ln]=c; hou[x]=ln;&#125;int f[100010][30],dis[100010];void dfs(int x,int fa)&#123; dep[x]=dep[fa]+1;f[x][0]=fa; for(int i=1;bin[i]&lt;=dep[x];i++) f[x][i]=f[f[x][i-1]][i-1]; for(int k=hou[x];k;k=gg[k]) &#123; int y=yy[k]; if(y!=fa) &#123; dis[y]=dis[x]+cc[k]; dfs(y,x); &#125; &#125;&#125;int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=30;i&gt;=0;i--) if(dep[x]-dep[y]&gt;=bin[i]) x=f[x][i]; if(x==y) return x; for(int i=30;i&gt;=0;i--) if(dep[x]&gt;=bin[i] and f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0];&#125;int findk(int x,int k)//找x向上（包括自己）的第k个&#123; for(int i=30;i&gt;=0;i--) if(k&gt;bin[i]) k-=bin[i],x=f[x][i]; return x;&#125;//*******************主函数*******************char ss[10];int main(int argc, char *argv[])&#123; InitBin(); int T;scanf("%d",&amp;T); while(T--) &#123; int n;scanf("%d",&amp;n); memset(hou,0,sizeof(hou));ln=0; for(int i=1;i&lt;n;i++) &#123; int a,b,c;scanf("%d%d%d",&amp;a,&amp;b,&amp;c); ins(a,b,c);ins(b,a,c); &#125; dfs(1,0); while(scanf("%s",ss) and ss[1]!='O') &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); if(ss[1]=='I') printf("%d\n",dis[a]+dis[b]-dis[LCA(a,b)]*2); else &#123; int k,t=LCA(a,b);scanf("%d",&amp;k); int dx=dep[a]-dep[t]+1,dy=dep[b]-dep[t]+1; printf("%d\n",(k&lt;=dx)?findk(a,k):findk( b,dy-(k-dx+1)+1 )); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>难度1</tag>
        <tag>Qtree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qtree1]]></title>
    <url>%2Fposts%2F695c.html</url>
    <content type="text"><![CDATA[评测点Caioj1430Spoj375 分析树链剖分（还没写相关文章，自行理解吧哈哈），但与Caioj1162不同的是由点权变成边权，所以稍微有难度（因为太菜），挺适合作为引子。 其实这一点如果想通了，就不难了：把每条边的权值转移为那条边下面的点的权值，这样刚好剩下根节点没有值。接下来就是赤裸裸的树链剖分了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138//*******************线段树*******************struct nod1&#123; int lz,rz,l,r,mx;&#125;e[400010];int qq;int build(int l,int r)&#123; int t=++qq; e[t].l=l;e[t].r=r; e[t].lz=e[t].rz=-1; if(l!=r) &#123; int mid=(l+r)&gt;&gt;1; e[t].lz=build(l,mid); e[t].rz=build(mid+1,r); &#125; return t;&#125;void change(int x,int p,int z)&#123; if(e[x].l==e[x].r) &#123; if(e[x].l!=p) printf("error1\n"); e[x].mx=z; return; &#125; int mid=(e[x].l+e[x].r)&gt;&gt;1; int lc=e[x].lz,rc=e[x].rz; if(p&lt;=mid) change(lc,p,z); else change(rc,p,z); e[x].mx=mymax(e[lc].mx,e[rc].mx);&#125;int ask(int x,int l,int r)&#123; if(e[x].l==l and e[x].r==r) return e[x].mx; int mid=(e[x].l+e[x].r)&gt;&gt;1; int lc=e[x].lz,rc=e[x].rz; if(r&lt;=mid) return ask(lc,l,r); if(l&gt;mid) return ask(rc,l,r); else return mymax(ask(lc,l,mid),ask(rc,mid+1,r));&#125;//*******************定义*******************struct nod2&#123; int dep,tot,son,fa,tp; int hou;&#125;a[10010];struct nod3&#123; int y,gg;&#125;b[20010];struct nod4&#123; int x,y,c;&#125;c[10010];//*******************实现*******************int pp;void ins(int x,int y)&#123; pp++; b[pp].y=y; b[pp].gg=a[x].hou; a[x].hou=pp;&#125;void dfs1(int x)&#123; a[x].tot=1;a[x].son=0; for(int k=a[x].hou;k;k=b[k].gg) &#123; int y=b[k].y; if(y==a[x].fa) continue; a[y].fa=x; a[y].dep=a[x].dep+1; dfs1(y); a[x].tot+=a[y].tot; if(a[a[x].son].tot&lt;a[y].tot) a[x].son=y; &#125;&#125;int z,yz[10010];//,yzz[10010]void dfs2(int x,int tp)&#123; yz[x]=++z;//yzz[z]=x; a[x].tp=tp; if(a[x].son) dfs2(a[x].son,tp); for(int k=a[x].hou;k;k=b[k].gg) &#123; int y=b[k].y; if(y!=a[x].fa and y!=a[x].son) dfs2(y,y); &#125;&#125;int solve(int x,int y)&#123; int tx=a[x].tp,ty=a[y].tp,ans=0; while(tx!=ty) &#123; tx=a[x].tp;ty=a[y].tp; if(a[tx].dep&lt;a[ty].dep) swap(tx,ty),swap(x,y); ans=mymax(ans,ask(1,yz[tx],yz[x])); x=a[tx].fa;tx=a[x].tp; &#125; if(x==y) return ans; if(a[x].dep&lt;a[y].dep) swap(x,y); return mymax(ans,ask(1,yz[a[y].son],yz[x]));&#125;//*******************主函数*******************char ss[10];int main(int argc, char *argv[])&#123; int T;scanf("%d",&amp;T); while(T--) &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) a[i].hou=0; for(int i=1;i&lt;n;i++) &#123; scanf("%d%d%d",&amp;c[i].x,&amp;c[i].y,&amp;c[i].c); ins(c[i].x,c[i].y);ins(c[i].y,c[i].x); &#125; pp=0;a[1].dep=1;a[1].fa=0;dfs1(1); qq=0;dfs2(1,1); z=0;build(1,n); for(int i=1;i&lt;n;i++) if(a[c[i].x].dep&gt;a[c[i].y].dep) swap(c[i].x,c[i].y); for(int i=1;i&lt;n;i++) change(1,yz[c[i].y],c[i].c); while(scanf("%s",ss) and ss[0]!='D') &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); if(ss[0]=='C') change(1,yz[c[a].y],b); else printf("%d\n",solve(a,b)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>Qtree</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1080】乘电梯]]></title>
    <url>%2Fposts%2F2666.html</url>
    <content type="text"><![CDATA[评测点Caioj1080 题目 【输入】第一行是电梯的数量和大楼层数。然后每行是一个电梯服务的最低层和最高层。最多有200个电梯，大楼不超过10000层。显然问题是有解的。不然你是怎么上去的呢？【输出】最短时间，精确到5位小数。【输入样例】6 154 810 141 57 1113 151 13【输出样例】20.32308 分析题解视频推荐（老师的理念是成功的，令人没有翻录的欲望）http://url.cn/5fzRGrj密码：QM2K9q微云找1080 f[i]表示到达第i层的时间 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;using namespace std;const int INF=0x3f3f3f3f;double mymax(double a,double b)&#123; return a&gt;b?a:b;&#125;double mymin(double a,double b)&#123; return a&gt;b?b:a;&#125;//*******************定义*******************struct nod&#123; double jl; int x,y;&#125;p[210];double f[10010];//*******************实现******************double dd(int s,int k)//电梯编号、楼层&#123; int a=p[s].y-k,b=k-p[s].x;//a是上面的层数 return (a*(a+1)+b*(b+1))/2.0/(a+b+1);&#125;//*******************主函数*******************int main(int argc, char *argv[])&#123; int n,h;scanf("%d%d",&amp;n,&amp;h); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].x,&amp;p[i].y),p[i].jl=INF; for(int i=1;i&lt;h;i++) f[i]=INF; f[h]=0; for(int j=h;j&gt;=1;j--) &#123; for(int i=1;i&lt;=n;i++) if(p[i].x&lt;=j and j&lt;=p[i].y)//第j层在第i个电梯的服务范围内 f[j]=mymin(f[j],p[i].jl+double(p[i].y-j));//计算f[j] for(int i=1;i&lt;=n;i++) if(p[i].x&lt;=j and j&lt;=p[i].y)//第j层在第i个电梯的服务范围内 p[i].jl=mymin(p[i].jl,f[j]-double(p[i].y-j)+dd(i,j)); //保证f[j]最小的前提下，更新p[i].jl &#125; printf("%.5lf",f[1]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1086】进攻策略]]></title>
    <url>%2Fposts%2F4a23.html</url>
    <content type="text"><![CDATA[评测点Caioj1086 题目【题意】植物大战僵尸这款游戏中，还有一个特别的玩法；玩家操纵僵尸进攻植物。首先，僵尸有m种（每种僵尸都是无限多的），玩家可以选择何时的僵尸来进攻。使用第i种僵尸需要花费wi资源，可以得到pi的攻击效果。在这里，我们认为多个僵尸总的进攻效果就是他们每个攻击效果的代数和。地图共有n行，对于第i行，最左端有若干植物，这些植物需要至少qi的攻击才能被全部消灭。若一行上的植物全部被消灭，我们认为这一行被攻破。由于资源紧张，你只有总量为k 的资源，不一定能够攻破所有行。但僵尸博士希望攻破相邻的t行，并希望t尽量的大。你能帮他算出t的值吗？【输入】第一行三个非负整数：m n k第二行m 个正整数 第i个数表示wi第三行m个正整数 第i个数表示pi第四行n个非负整数 第i个数表示qi【输出】一个正整数t【输入样例】3 11 395 2 113 1 75 3 6 10 3 2 4 200 1 1 1【输出样例】4【提示】样例说明：打掉 10 3 2 4 这相邻的4行，需要的最小代价是16+5+4+7=32，不超过39数据规模：对于70%的数据 n&lt;=1000对于100%的数据 n&lt;=200000，m&lt;=100，k&lt;=1000，所有pi ,qi&lt;=100000000(lzg PS:pi,qi固然大,可k是小于1000的啊!) 分析先dp计算出i的资源能造成总共f[i]的伤害再计算出攻下第i行的资源花费剩下的就简单了 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;using namespace std;const int INF=0x3f3f3f3f;int mymax(int a,int b)&#123; return a&gt;b?a:b;&#125;//*******************定义*******************int w[110],p[110],q[200010];int f[1010],a[200010];//*******************主函数*******************int main()&#123; int n,m,k;scanf("%d%d%d",&amp;m,&amp;n,&amp;k); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;w[i]); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;p[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;q[i]); for(int i=1;i&lt;=m;i++) for(int j=w[i];j&lt;=k;j++) f[j]=mymax(f[j],f[j-w[i]]+p[i]); f[k+1]=INF; int tou=1,ans=0,s=0; for(int i=1;i&lt;=n;i++) &#123; int l=0,r=k,tans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(f[mid]&gt;=q[i]) tans=mid,r=mid-1; else l=mid+1; &#125; a[i]=tans;//攻下这一行的资源花费 s+=a[i]; while(s&gt;k and tou&lt;=i) s-=a[tou],tou++; ans=mymax(ans,i-tou+1); &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[俄罗斯轮盘]]></title>
    <url>%2Fposts%2Fd3b3.html</url>
    <content type="text"><![CDATA[有人知道来源在评论说一声 题目【背景】游戏需要的器材灰常简单：一支左轮手枪和一颗子弹。通常游戏人数为两人。玩法也灰常简单：把一发子弹填入左轮手枪的弹仓，将枪轮拨转一下，这样就猜不着子弹是否上膛。接着，把枪交给一个玩家，该玩家对准自己的太阳穴扣枪机。规定如果子弹没上膛而打空的话，就换另一个玩家打，再打空就再换第一个玩家打，直到打中为止。【问题描述】小I和小强是一对灰常要好的朋友，他们经常在一起玩俄罗斯轮盘。可是有一天小I有事不能陪小强玩，这令小强很郁闷，于是他决定自己一个人玩。小强拿了一支有N个弹仓的左轮手枪，随机填入了M发子弹，然后对准自己的太阳穴连续打了K枪。他这样玩了几次之后，突然想知道打不中的概率是多少。你能帮他算算吗？ 【输入格式】输入三个整数：N,M,K(1&lt;=N&lt;=1000,1&lt;=M&lt;=N,1&lt;=K&lt;=1000)。【输出格式】输出N个弹仓的左轮手枪，随机填入M发子弹，对准自己的太阳穴打K枪都打不中的概率，保留六位小数。【输入样例1】62 2【输出样例1】0.400000【输入样例2】153 7【输出样例2】0.123077 分析1234等价于M个球放入N个箱子，前K个箱子没有球的概率P=C(N-K,M)/C(N,M)c(n,m)= p(n,m)/m! = n! / ( (n-m)!*m! )[ (N-K)!/( (N-K-M)!*M! ) ] / [ N!/(N-M)!/M! ] 代码12345678910int n,m,k;scanf("%d%d%d",&amp;n,&amp;m,&amp;k);if(n==m or n&lt;m+k) printf("%.6lf",1);else&#123; double s=1; for(int i=0;i&lt;=m-1;i++) s=s*(n-i-k)/(n-i); printf("%.6lf",s);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1159最长公共子序列LCS]]></title>
    <url>%2Fposts%2Fddc4.html</url>
    <content type="text"><![CDATA[评测点HDU1159 题目【题意】求两个字符串最长公共子序列的长度,最长公共子序列强调位置的前后关系不变，但不在乎是否连续,不唯一【输入样例】abbccdss aeebfcaadb【输出样例】4 某解释 代码1234567891011121314char s[1010],s1[1010];int f[1010][1010];int main(int argc, char *argv[])&#123; scanf("%s %s",s+1,s1+1); int l1=strlen(s+1),l2=strlen(s1+1); for(int i=1;i&lt;=l1;i++) for(int j=1;j&lt;=l2;j++) &#123; if(s[i]==s1[j]) f[i][j]=f[i-1][j-1]+1; else f[i][j]=mymax(f[i-1][j],f[i][j-1]); &#125; printf("%d",f[l1][l2]);&#125; 分析：a=abcb=1abcn=3m=4i=2 4//字符串2的位置j=2 3//字符串1的位置s=0 0 0 01 1 1 10 2 2 20 0 3 3]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2528市长的海报Posters]]></title>
    <url>%2Fposts%2F96fc.html</url>
    <content type="text"><![CDATA[来历POJ2528 题目【题意】n（n&lt;=10000)个人依次贴海报,给出每张海报所贴的范围li，ri（1&lt;=li&lt;=ri&lt;=10000000)。求出最后还能看见多少张海报。（注意：没多组数据）【输入样例】51 42 68 103 47 10【输出样例】4 分析关于离散化，可以参考这里 推荐一个好的算法，但我没有这么做：如果更新次数太多的话，可以考虑从后往前更新即如果更新时发现之前已经有一张海报完全覆盖他了就可以不用更新（因为没有必要）这样的算法时间会减少很多 代码不完整，通用部分可以参考这里1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071struct DisNod&#123; int x,p,z;&#125;a[20010],b[20010];void Discretization(int n)//离散化&#123; for(int i=1;i&lt;=n;i+=2) &#123; scanf("%d %d",&amp;a[i].x,&amp;a[i+1].x);a[i+1].x++; a[i].p=i;a[i+1].p=i+1; b[i]=a[i];b[i+1]=a[i+1]; //拷贝 &#125; sort2(1,n);//排序 b[1].z=1; for(int i=2;i&lt;=n;i++) &#123; if(b[i].x==b[i-1].x) b[i].z=b[i-1].z; else b[i].z=b[i-1].z+1; a[b[i].p].z=b[i].z; &#125;&#125;struct Manager&#123; int l,r,tl,tr,c; bool lazy;&#125;f[40010];void update(int x)&#123; f[x].lazy=false; if(f[x].tl&gt;0 and f[x].tr&gt;0) &#123; int tl=f[x].tl,tr=f[x].tr; f[tl].lazy=f[tr].lazy=true; f[tl].c=f[tr].c=f[x].c; &#125;&#125;void change(int now,int l,int r,int c)&#123; if(l==f[now].l and r==f[now].r) &#123; f[now].c=c; f[now].lazy=true; return; &#125; if(f[now].lazy) update(now); ……&#125;int num=0;int build(int l,int r)&#123; …… f[x].lazy=false; ……&#125;char ch[5];bool v[20010]=&#123;0&#125;;int main()&#123; scanf("%d",&amp;n);n*=2; Discretization(n); build(1,b[n].z); for(int i=1;i&lt;=n;i+=2) change(1,a[i].z,a[i+1].z,i); int s=0; for(int i=1;i&lt;=num;i++) &#123; if(f[i].lazy) update(i); if(!f[i].tl and !v[f[i].c]) v[f[i].c]=1,s++; &#125; printf("%d",s);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[糖果自动管理系统]]></title>
    <url>%2Fposts%2F739e.html</url>
    <content type="text"><![CDATA[来历建议这里备用 题目【题意】糖果自动管理系统能管理N堆糖果。初始时，所有堆糖果数目为0。（1）I a b c(1≤a≤b≤N,0 &lt; c≤100)，ACM将在堆a至堆b之间（包含a和b）每堆糖果加c个。（2）C a b(1≤a≤b≤N)，将会选择a到b堆之间糖果数最多的清空。选择编号小的。给出一系列的操作，对于每个C操作，输出堆的糖果数。【输入】第一行为两个整数N，M（0&lt; N，M≤10^5），N表示糖果堆的数目，M表示操作的次数。【输出】对于每个C操作，输出小朋友能得到的糖果的数目。【输入样例】5 4I 1 5 1C 2 3I 2 2 4C 2 3【输出样例】14 代码不完整，通用部分可以参考这里12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576void update(int x)&#123; f[f[x].tl].c+=f[x].lazy; f[f[x].tr].c+=f[x].lazy; f[f[x].tl].lazy+=f[x].lazy; f[f[x].tr].lazy+=f[x].lazy; f[x].lazy=0;&#125;void make(int x,int l,int r,int k)&#123; if(f[x].l==l and r==f[x].r) &#123; f[x].c+=k; f[x].lazy+=k; return; &#125; …… if(r&lt;=mid) make(fl,l,r,k); else if(l&gt;mid) make(fr,l,r,k); else &#123; make(fl,l,mid,k); make(fr,mid+1,r,k); &#125; if(f[fl].c&gt;=f[fr].c) &#123; f[x].mc=f[fl].mc; f[x].c=f[fl].c; &#125; else &#123; f[x].mc=f[fr].mc; f[x].c=f[fr].c; &#125;&#125;int fc,fmc;void qesc(int x,int l,int r)&#123; if(f[x].l==l and f[x].r==r) &#123; fc=f[x].c; fmc=f[x].mc; return; &#125; if(r&lt;=mid) qesc(fl,l,r); else if(l&gt;mid) qesc(fr,l,r); else &#123; qesc(fl,l,mid); int ac=fc,amc=fmc; qesc(fr,mid+1,r); if(ac&gt;=fc) &#123; fc=ac; fmc=amc; &#125; &#125;&#125;int main()&#123; num=0;br(1,n); for(int i=1;i&lt;=m;i++) &#123; scanf("%s%d%d",ch,&amp;a,&amp;b); if(ch[0]=='C') &#123; qesc(1,a,b); printf("%d\n",fc); make(1,fmc,fmc,-fc); &#125; else &#123; scanf("%d",&amp;d);make(1,a,b,d); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016魔法阵]]></title>
    <url>%2Fposts%2F141d.html</url>
    <content type="text"><![CDATA[评测点和题目洛谷2119 分析遇到这种有条件的题，通常把图形画出来比较直观。 如图所示，若把d点确定，设c-d距离为i，则a,b的距离就是2i，则b,c的距离&gt;2×(a-b)也就是&gt;6i，总距离大于9i，那么我们的外层循环就枚举i，再枚举d的位置，d的方案数就等于(前面所有a的方案)×(前面所有b的方案)×(当前c的方案数)，c的方案数=(前面所有a的方案)×(前面所有b的方案)×(当前d的方案数)，同理，枚举a的位置，也可以得到a与b的方案数。 什么意思呢？这可能有点绕。 我们将d不断往后枚举，而在现在的a之前所扫过的ab都符合条件，故而累加在一个变量中，a亦复如是。 注意，同样魔法值的物品，作为abcd物品的次数其实是一样的。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int rn(void)&#123; char c=getchar();int s=0; while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') &#123; s=s*10+c-'0'; c=getchar(); &#125; return s;&#125;struct nod1&#123; int w,a,b,c,d; nod1() &#123;w=a=b=c=d=0;&#125;&#125;f[15010];int h[40010];//第i个物品的魔法值需要保留，输出时要用到int main()&#123; int n,m; n=rn();m=rn(); for(int i=1;i&lt;=m;i++) &#123; h[i]=rn(); f[h[i]].w++;//表示这个值的数增加了一个 &#125; //[d&gt;9*i&lt;=n]==&gt;[9*i&lt;n],边界一定要考虑无误 for(int i=1;9*i&lt;n;i++)//cd &#123; int ab=2*i,bd=7*i+1; int ad=ab+bd;//9*i+1 int ac=ad-i; int s=0;//累加和 for(int j=n-ad;j&gt;=1;j--)//j-&gt;a //注意循环不能顺序，因为s的累加和会改变,a[j]会加上后面的c,d //而不是前面的 &#123; s+=f[j+ac].w*f[j+ad].w;//c*d元素的个数 f[j].a+=s*f[j+ab].w;//b*[c*d]==a(乘在一起，就是可能量) f[j+ab].b+=s*f[j].w;//a*[c*d]==b &#125; s=0; for(int j=ad+1;j&lt;=n;j++)//j-&gt;d &#123; s+=f[j-ad].w*f[j-bd].w;//a*b元素的个数 f[j-i].c+=s*f[j].w;//d*[a*b]==c f[j].d+=s*f[j-i].w;//c*[a*b]==d &#125; //上下两循环可以调换顺序，因为a,b,c,d只与i和w有关 //和a[],b[],c[],d[]无关 &#125; for(int i=1;i&lt;=m;i++) printf("%d %d %d %d\n",f[h[i]].a,f[h[i]].b,f[h[i]].c,f[h[i]].d);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016海港]]></title>
    <url>%2Fposts%2Fafb6.html</url>
    <content type="text"><![CDATA[评测点和题目洛谷2058 分析这道题主要收获是将总量不大的数组降维储存，从而大大减少空间 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445int rn(void)//正整数输入&#123; char c=getchar();int s=0; while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') &#123; s=s*10+c-'0'; c=getchar(); &#125; return s;&#125;int t[100010],k[100010],q[500010],w[500010];//t:每艘船时间 k:每艘船第一个人(类似指针)//q:每个国家人数 w:每人国家int main(int argc,char *argv[])&#123; int n=rn(); int tou=1;//当前状态指针 int ans=0;//当前状态答案 k[1]=1; for(int i=1;i&lt;=n;i++) &#123; t[i]=rn();int rs=rn(); k[i+1]=k[i]+rs; for(int j=0;j&lt;rs;j++) &#123; int p=rn(); w[j+k[i]]=p; if(q[p]==0) ans++;//如果此国家原来没人，ans+1 q[p]++;//输入每个人，并在他的国家处+1 &#125; while(t[tou]+86400&lt;=t[i]) //如果第tou艘船不符合条件，就去掉 &#123; for(int j=k[tou];j&lt;k[tou+1];j++)//枚举每一个人 &#123; q[w[j]]--; if(q[w[j]]==0) ans--; //要是此国家去掉这个人就没了，答案减一 &#125; tou++; &#125; printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016总结]]></title>
    <url>%2Fposts%2Fda68.html</url>
    <content type="text"><![CDATA[NOIP2016总结 2016.11.18【考前篇】明天早9点，我将与学校众多大神们一起去广州，进军NOIP2016普及组。内心还是很忐忑的（呵呵，正是心上下跳动），如能暴力骗分已是极好。 第一次参加比赛，其实初赛能过已经是出乎意料，当然，今年题目水也是原因之一。本来，我们全员要停课一周的，初一的年级主任同意了，初三的也同意了，就只有我们初二的蒋芳周红差点没同意，周二时竟然还要求仅能有十几人停课，其他的只能中午和晚修来，大大扰乱了兴致。【嗯嗯，如果她们真的敢来捉人，就跟她们火拼嘛！】 这周足足进行了五次模拟考试，每一次都有它的特色。题解（怒插广告）：俄罗斯轮盘约瑟夫问题终极装备密室逃脱智捅马蜂窝最后的战犯 这周总体的收获还是极大的，巩固了许多知识，还学习了很多技巧，最重要的是能和大家一起开心地打游戏、一起努力，更是体验了停课的酸爽，故即使这次比赛成绩不好，我亦无悔。 提高组的今天下午三点就已经出发了，加油！ 2016.11.19【Day1】广州一日游结束了，这绝对是一次宝贵的经历。 九点半从一中出发，伴随着大巴上的【第一次用流量玩王者】【互祝爆零】，十一点到了在六中附近的一家中餐厅吃饭（我也不知道为什么会和纪念中学那位差不多），多贵倒是不知道，反正每人交张红色毛爷爷，有多的回去统计后再归还。味道还不算太坏，吃完后一起去六中拍了几张合照，大概是一点钟左右。反正还有时间，和几个朋友出去浪，买了杯贡茶【抹茶奶盖绿茶】，顺便无聊地在手机上看模板。。 到了两点，就上了四楼，找到自己的位置，花半小时搞定了电脑的一切配置。两点半正式开始，密码很长而复杂，呵呵。花十分钟看完了题目。这次竟然没有我擅长的图论，全是模拟、暴力和剪枝什么的，一二题水题，大约一个半小时搞定。在三四题中选了第四题，纯粹排序+暴力，有想过去重，但不知道怎么还原，只好放弃（其实现在也不知道），顶多优化一下常数和公式，不知道能不能拿一半分，最后半小时选择了检查一二四题而第三题只打一个骗分。【好像第三题记录一下最后值就好了，不难，但当时硬是想不到】比赛结束，还是在那家餐厅吃饭，又去买了杯贡茶【金色年华】，回来看到大家都在高举手机，甚是怪异————原来在争信号抢红包。然鹅那个微信群我却硬是没加，听说错过了HY的一个大红包。 归途中继续开嘿，九点回到中山市第一少年看守所。。。 2016.12.1初评成绩公布篇成绩出来了，200分，也还好吧:100,100,0,0,呵呵。 照片：初一:初二:提高组:普及组:hz与akc【镇楼！】: 两个题解：海港魔法阵]]></content>
      <categories>
        <category>竞赛历程</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[星球大战]]></title>
    <url>%2Fposts%2F4cfd.html</url>
    <content type="text"><![CDATA[来源bzoj1015JSOI2008 分析：有一个同学做了PPT，里面的数据演示做得不错，详细做法建议看代码，更清晰下载链接 题目【问题描述】很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治者整个星系。某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通快的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。【问题大意】给你一些点和边，有K次毁灭，每次删掉一条边，输出没毁灭时的连通数以及每次操作后剩余的联通数量【输入格式】第一行包含两个整数，N(1&lt;=N&lt;=2M)和M(1&lt;=M&lt;= 200,000)，分别表示星球的数目和以太隧道的数目。星球用0~N-1的整数编号。接下来的M行，每行包括两个整数X, Y，其中（0&lt;=X&lt;&gt;Y【输出格式】输出文件的第一行是开始时星球的连通块个数。接下来的N行，每行一个整数，表示经过该次打击后现存星球的连通块个数。【输入样例】8 130 11 66 55 00 61 22 33 44 57 17 27 63 65 1 6 3 5 7【输出样例】1 1 1 2 3 3 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899struct nod1&#123; int hou;//最小儿子 int fa;//父亲 bool b;//是否会被炸毁 bool v;//是否存在 nod1() &#123; hou=0;b=false;v=false; &#125;&#125;point[400010];struct nod2&#123; int x; int g;//哥哥&#125;road[400010];/*注意：因为是双向路，所以要开200000*2*/void bulid(int,int);int findfa(int);int add(int);int f[400001];//这些点将被攻击int ans[400001];//答案记录//两个序列↑int roadnum;int sum;//联通块int main(int argc, char *argv[])&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) point[i].fa=i;//初始化每个点的父亲为自己 roadnum=0; for(int i=1;i&lt;=m;i++) &#123; int x,y; cin&gt;&gt;x&gt;&gt;y; bulid(x,y); bulid(y,x);//建边 &#125; int k; cin&gt;&gt;k; for(int i=1;i&lt;=k;i++) &#123; cin&gt;&gt;f[i]; point[f[i]].b=true;//如果不会被炸毁的先标记下来下边可以用上 &#125; //倒推大法↓ sum=0; for(int i=0;i&lt;n;i++)//是0到n-1 &#123; if(point[i].b==false)//没被炸毁的先建边 &#123; sum++; add(i); point[i].v=true;//建了边代表存在的 &#125; &#125; ans[k+1]=sum;//k+1代表最后炸毁的状态 for(int i=k;i&gt;0;i--)//模拟，一个一个把点加上去 &#123; sum++; add(f[i]);//加点 point[f[i]].v=true;//这条边存在 ans[i]=sum;//记录值 &#125; for(int i=1;i&lt;=k+1;i++) printf("%d\n",ans[i]);&#125;int add(int n)&#123; int xf=findfa(n); for(int k=point[n].hou;k&gt;0;k=road[k].g)//这个点应该加在哪里 &#123; int x=road[k].x; if(point[x].v==true)//存在 &#123; int yf=findfa(x); if(xf!=yf) &#123; point[yf].fa=n; sum--;//如果祖先不一样的话，统一祖先，联通块-1 &#125; &#125; &#125;&#125;void bulid(int x,int y)&#123; roadnum++; road[roadnum].x=y; road[roadnum].g=point[x].hou; point[x].hou=roadnum;&#125;int findfa(int x)&#123; if(x!=point[x].fa) point[x].fa=findfa(point[x].fa) return point[x].fa;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>难度1</tag>
        <tag>宽度优先搜索BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codevs1082线段树练习3]]></title>
    <url>%2Fposts%2F9bea.html</url>
    <content type="text"><![CDATA[Codevs1082线段树练习3 评测Codevs1082 题目【问题大意】给你N个数，有两种操作：1：给区间[a,b]的所有数增加X2：询问区间[a,b]的数的和。【输入】第一行一个正整数n，接下来n行n个整数，再接下来一个正整数Q，每行表示操作的个数，如果第一个数是1，后接3个正整数，表示在区间[a,b]内每个数增加X,如果是2，表示操作2询问区间[a,b]的和是多少。pascal选手请不要使用readln读入【输出】对于每个询问输出一行一个答案【样例输入】312321 2 3 22 2 3【样例输出】9【数据范围】(其实这个贴出来没什么用)1&lt;=n&lt;=2000001&lt;=q&lt;=200000 分析用线段树做自然是灰常简单的假如你想学习如何用树状数组实现可以参考这篇文章 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394typedef long long lld; using namespace std; struct Segment &#123; int l,r; int s1,s2; lld c; lld lazy; &#125;a[400001]; int num=0; void build(int l,int r) &#123; num++; int t=num;// a[t].c=0; a[t].l=l; a[t].r=r; a[t].lazy=0; if(l==r) &#123; a[t].s1=-1; a[t].s2=-1; return; &#125; int mid=(l+r)/2; a[t].s1=num+1;build(l,mid); a[t].s2=num+1;build(mid+1,r); &#125; void make(int x,int l,int r,int k) &#123; a[x].c=a[x].c+k*(r-l+1); if(a[x].l==l and a[x].r==r) &#123; a[x].lazy+=k; return; &#125; int mid=(a[x].r+a[x].l)/2; if(r&lt;=mid) make(a[x].s1,l,r,k); else if(l&gt;mid) make(a[x].s2,l,r,k); else &#123; make(a[x].s1,l,mid,k); make(a[x].s2,mid+1,r,k); &#125; &#125; lld qes(int x,int l,int r) &#123; if(a[x].l==l and a[x].r==r) return a[x].c; int mid=(a[x].r+a[x].l)/2; int s1=a[x].s1,s2=a[x].s2; if(a[x].lazy!=0) &#123; a[s1].c=a[s1].c+a[x].lazy*(a[s1].r-a[s1].l+1); a[s2].c=a[s2].c+a[x].lazy*(a[s2].r-a[s2].l+1); a[s1].lazy+=a[x].lazy; a[s2].lazy+=a[x].lazy; a[x].lazy=0; &#125; if(r&lt;=mid) return qes(a[x].s1,l,r); else if(l&gt;mid) return qes(a[x].s2,l,r); else return qes(a[x].s1,l,mid)+qes(a[x].s2,mid+1,r); &#125; int main(int argc, char *argv[]) &#123; int n,m; cin&gt;&gt;n; build(1,n); for(int i=1;i&lt;=n;i++) &#123; int a; scanf("%d",&amp;a); make(1,i,i,a); &#125; cin&gt;&gt;m; for(int i=1;i&lt;=m;i++) &#123; int x,a,b,c; scanf("%d %d %d",&amp;x,&amp;a,&amp;b); if(x==1) &#123; scanf("%d",&amp;c); if(a&gt;b) make(1,b,a,c); else make(1,a,b,c); &#125; else &#123; if(a&gt;b) printf("%lld\n",qes(1,b,a)); else printf("%lld\n",qes(1,a,b)); &#125; &#125; &#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魏总数星星]]></title>
    <url>%2Fposts%2F4672.html</url>
    <content type="text"><![CDATA[声明好像是别人的原创题，感觉不错：来源另外，学习并查集可以参考这个：生动的故事，透彻的分析我的并查集总结 题目【问题大意】魏总，也就是dp魏，灰常喜欢星星，有一天他躺在草坪上数星星。天上共有i颗星星，魏总把天空分成了K个扇形，绕着天空的中心——月亮排布。月亮看见魏总喜欢星星，灰常不爽，她就想考一下魏总。月亮给出n队星星的相互关系，形如a b p表示b星星在a星星所在扇形区域的顺时针方向第p个扇形内（0&lt;=p&lt;=k）（p==0时表示在同一个扇形内）。最后月亮要询问m次，形如a b表示询问a b两星是否在一个扇形内，是则输出“Yes”，不是则输出“No”，不知道则输出“Unknown”。由于月亮看魏总喜欢星星变得心情急躁，可能有一些关系与前面的关系矛盾，则这些关系无效。月亮说如果不能把她的所有询问答对就要发出强光，让魏总看不到星星，而本来是大神的魏总因为想见到星星不能编程，只有把这个艰巨的任务交给你了。【输入格式】第一行四个整数i，k，n，m表示i颗星星，k个扇形，n个关系，m次询问。接下来n行，每行三个整数a b p 表示表示b星星在a星星所在扇形区域的顺时针方向第p个扇形内。接下来m行，每行两个整数a b表示询问a，b是否在同一个扇形内。【输出格式】共m行，每行为“Yes”或“No”或“Unknown”对应每一个询问【输入样例】5 5 3 31 2 12 4 24 5 21 23 41 5【输出样例】NoUnknownYes【数据范围】20%，魏总数不超过100个星星，月亮询问不超过100次，天空被分成不超过10个区域。50%，魏总数不超过4000个星星，月亮询问不超过4000次，天空被分成不超过1000个区域。100%，魏总数不超过100000个星星，月亮询问不超过100000次，天空被分成不超过10000个区域，关系数少于200000。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct star&#123; int fa,len; star() &#123; fa=len=0; &#125;;&#125;st[100010];int mod;int findfa(int now)&#123; if(st[now].fa==now) return now; int f=findfa(st[now].fa); st[now].len=(st[now].len+st[st[now].fa].len)%mod; if (st[now].len==0) st[now].len=mod; st[now].father=f; return f;&#125;void join(int a,int b,int l)&#123; int af=findfa(a),bf=findfa(b); int len=(st[a].len+l)%mod; st[bf].fa=a; if (l&gt;=st[b].len) st[bf].len=l-st[b].len; else st[bf].len=mod+l-st[b].len;&#125;int main()&#123; int n,m,k; cin&gt;&gt;n&gt;&gt;mod&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;=n;i++) st[i].fa=i; for(int i=1;i&lt;=m;i++) &#123; int a,b,p; cin&gt;&gt;a&gt;&gt;b&gt;&gt;p; if(findfa(a)!=findfa(b)) join(a,b,p); &#125; for(int i=1;i&lt;=k;i++) &#123; int a,b; scanf("%d%d",&amp;a,&amp;b); if (findfa(a)!=findfa(b)) printf("Unknown\n"); else &#123; if (st[a].len%mod==st[b].len%mod) printf("Yes\n"); else printf("No\n"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[智捅马蜂窝]]></title>
    <url>%2Fposts%2F76b3.html</url>
    <content type="text"><![CDATA[评测rqnoj86 题目【问题大意】给出一个 N 个节点的无向图，每个节点用坐标（Xi，Yi）来表示，平平要从第1个点爬到第N个点。如果出现两线相交的情况，我们不认为它们是相通的。除了从一个节点爬向另一个相邻的节点以外，他还有一种移动方法，就是从一个节点跳下，到达正下方的某个节点（之间可隔着若干个点和边），下落所用时间满足自由落体公式t=sqrt((Yj-Yi)×2/g) （g取10）。【输入格式】两个整数N,V，N表示节点个数，V表示平平爬树的速度。接下来N行，每行包含3个整数X,Y,F，X,Y是这个点的坐标，F是他的父节点（F一定小于这个点的标号，第一行的F为0）。（1&lt;=N&lt;=100,1&lt;=V&lt;=10,0&lt;=X,Y&lt;=100）【输出格式】输出仅包括一行，从1到N所用的最少所需时间T，保留两位小数。【输入样例】9 15 0 05 5 16 5 27 6 26 9 23 6 24 5 23 2 77 2 3【输出样例】8.13 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879void build(int,int,double);double calc(int,int);struct point&#123; double ans; int hou,x,y; bool v;&#125;a[110];struct road&#123; int x,y,g; double c;&#125;b[310];int n,v,k=0,l[110];int main()&#123; scanf("%d %d",&amp;n,&amp;v); for(int i=1;i&lt;=n;i++) &#123; int x,y,f; scanf("%d %d %d",&amp;x,&amp;y,&amp;f); a[i].x=x;a[i].y=y;a[i].hou=0; a[i].ans=999999;a[i].v=false; double c=calc(f,i)/v; build(i,f,c);build(f,i,c); &#125; for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) if(a[i].x==a[j].x) //能垂直下落就建边 &#123; double c=sqrt(abs(a[i].y-a[j].y)/5.0);//不是5 if(a[i].y&gt;a[j].y) build(i,j,c); else build(j,i,c); &#125; l[1]=1; a[1].v=true; a[1].ans=0; int tou=1,wei=2; while(tou!=wei) &#123; int x=l[tou]; for(int i=a[x].hou;i&gt;0;i=b[i].g) &#123; int y=b[i].y; if(a[y].ans&gt;a[x].ans+b[i].c) &#123; a[y].ans=a[x].ans+b[i].c; if(a[y].v==false) &#123; a[y].v=true; l[wei]=y; wei++; if(wei==n+1) wei=1; &#125; &#125; &#125; a[x].v=false; tou++; if(tou==n+1) tou=1; &#125; printf("%.2lf",a[n].ans);&#125;void build(int x,int y,double t)&#123; k++; b[k].x=x;b[k].y=y;b[k].c=t; b[k].g=a[x].hou;a[x].hou=k;&#125;double calc(int x,int y)&#123; double q=a[x].x-a[y].x,w=a[x].y-a[y].y; return sqrt(q*q+w*w);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>难度1</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最后的战犯]]></title>
    <url>%2Fposts%2F47fc.html</url>
    <content type="text"><![CDATA[题目【问题描述】Feli来到岩洞入口，发现岩洞其实是一个巨大的迷宫。迷宫地形极为复杂，为一个正方形，其中布满了障碍物。迷宫可以分为N乘N（2≤N≤100）个区域，每个区域或者是空地，或者是不可逾越的障碍物。小犬就躲藏在其中某一个区域内。由于小犬已经忍受了几天的饥饿，Feli进入迷宫时他已经失去思维处于迷乱状态。小犬每秒钟只会沿着他的方向直线前进，如果遇到障碍物或者迷宫边界，他会立刻向右转90度（不会花去时间），继续沿直线前进（初始方向向北）。Feli每秒钟可以自主决定往哪个方向走。如果同一时刻Feli与小犬位于同一个区域，或者相邻的区域（非对角线相邻），Feli可以立刻将小犬抓住。Feli本来打算先确定小犬的位置，然后沿最短路线抓住他，但是Feli前进时小犬同时也在移动，就不能采取这种方法了。请你帮助Feli确定一种方案，使Feli抓获小犬所用的时间最短。【输入格式】输入数据第一行是一个整数N。以下N行每行N个字符，星号表示岩洞中的障碍物，“.”表示空地，“J”表示小犬（一开始他会向北走），“F”表示Feli。上北下南左西右东。【输出格式】输出数据仅一行，如果Feli能抓到小犬，那么输出所需的最短时间，如果Feli抓不到小犬，那么这个最后的日本战犯将在岩洞中饿死（因为Feli将在离开的时候封闭岩洞的所有出口），此时输出“No solution.”，不要输出引号。1234567【输入样例】3F*J.*....【输出样例】3 声明找不到来源，保留原题目对不起啦贴着代码先 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586struct pointnode&#123;int x,y,f;&#125;;bool m[110][110],v[110][110];int stx,sty,edx,edy,n,jat=0;int tx[4]=&#123;-1,0,1,0&#125;,ty[4]=&#123;0,1,0,-1&#125;;pointnode q[10010];bool qs(void)//直接被困住&#123; for(int i=0;i&lt;=3;i++) if(m[edx+tx[i]][edy+ty[i]]) return false; return true;&#125;bool check(int x,int y)&#123; if((x==edx and abs(y-edy)&lt;=1)or(y==edy and abs(x-edx)&lt;=1)) return true; return false;&#125;void solve()//走一步&#123; while(1) &#123; int txx=edx+tx[jat],tyy=edy+ty[jat]; if(m[txx][tyy]) &#123; edx=txx; edy=tyy; return; &#125; jat++; jat%=4; &#125;&#125;void bfs(void)&#123; memset(v,0,sizeof(v)); int tou=1,wei=2; q[1].x=stx;q[1].y=sty;q[1].f=0; q[0].f=-1; v[stx][sty]=true; while(tou!=wei) &#123; int nowx=q[tou].x,nowy=q[tou].y; if(q[tou].f&gt;q[tou-1].f) solve(); //进入新的一层 for(int i=0;i&lt;=3;i++) &#123; int fx=nowx+tx[i],fy=nowy+ty[i]; if(m[fx][fy] and !v[fx][fy]) &#123; v[fx][fy]=true; q[wei].x=fx;q[wei].y=fy; q[wei].f=q[tou].f+1; if(check(fx,fy)) &#123; printf("%d",q[wei].f); return; &#125; wei++; &#125; &#125; tou++; &#125; printf("No solution.");&#125;int main()&#123; memset(m,0,sizeof(m)); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; char s[110];scanf("%s",s+1); for(int j=1;j&lt;=n;j++) &#123; m[i][j]=(s[j]!='*'); if(s[j]=='J') &#123;edx=i;edy=j;&#125; if(s[j]=='F') &#123;stx=i;sty=j;&#125; &#125; &#125; if(qs()) printf("No solution."); else if(check(stx,sty)) printf("0"); else bfs();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>宽度优先搜索BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密室逃脱]]></title>
    <url>%2Fposts%2F5ade.html</url>
    <content type="text"><![CDATA[题目来自于某NOIP模拟赛 【问题描述】即使czhou没有派出最强篮球阵容，机房篮球队还是暴虐了校篮球队。为了不打击校篮球队信心，czhou决定改变训练后的活动。近来，江大掌门的徒弟徒孙们纷纷事业有成，回到母校为机房捐钱捐物。财大气粗的机房组收回了五层六层的所有教室。Czhou决定将六层的教室改造为智能密室逃脱活动室。每天傍晚，神牛们可以依次逐个进入游玩。我们简单的将教室分割为n乘n个房间，K是你初始所在房间，T是你最终逃脱的房间。如果你想要逃脱房间，你必须依次找到m把钥匙。我们假定你从一个房间进入另一个房间需要花费1的时间。当然某些房间有些特殊的问题(地图上S表示)需要回答才能通过，对于机智的众牛们来说，这些问题根本不是问题。我们假定众牛们花费1的时间解决问题。（主要是出题的人表述不清，导致众牛理解困难；当然问题只需要回答一次，下次再次进入房间不需要回答了）【问题大意】有一个密室，分割为N乘N个房间，K是初始房间，T是最终逃脱的房间，并且在逃脱前要找齐M把钥匙（要按顺序取，可以经过而不取，地图上可能有多个同一种钥匙，走），“#”为墙壁（一个关闭的房间）即不可走，假定从一个到另一个房间需要1个单位时间，当然某些房间有些特殊的问题(地图上S表示)需要回答才能通过，假定要花费1的时间解决问题（当然每个问题只需要回答一次），问最少时间花费。【输入格式】第一行两个数字n,m，接下来n乘n描述地图【输出格式】逃脱密室需要的最少时间，若无解输出impossible123456789101112131415161718192021【输入样例1】31K.S##11#T【输出样例1】5【输入样例2】3 1K#T.S#1#.【输出样例2】impossible【输入样例3】32K#T.S.21.【输出样例3】8 代码对不起啦贴着代码先123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263struct pos&#123;int x,y,k;&#125;;char map[101][101];int n,m,ans=inf,qesn=0;int f[101][101][10],tx[4]=&#123;0,-1,0,1&#125;,ty[4]=&#123;1,0,-1,0&#125;;pos st,ed,qes[9];int mymin(int a,int b)&#123;return a&gt;b?b:a;&#125;void bfs(void)&#123; memset(f,-1,sizeof(f)); f[st.x][st.y][0]=0; queue&lt;pos&gt; q;//用滚动数组更快 q.push(st); while(q.empty()==false) &#123; pos fr=q.front(); for(int i=0;i&lt;=3;i++) &#123; pos ne; ne.x=fr.x+tx[i]; ne.y=fr.y+ty[i]; ne.k=fr.k; if(map[ne.x][ne.y]==ne.k+1) ne.k++; if(map[ne.x][ne.y]==0 or f[ne.x][ne.y][ne.k]!=-1) continue; f[ne.x][ne.y][ne.k]=f[fr.x][fr.y][fr.k]+1; q.push(ne); &#125; q.pop(); &#125;&#125;void dfs(int k,int l)//枚举每一个S&#123; if(k==qesn+1) &#123; bfs(); if(f[ed.x][ed.y][m]!=-1) ans=mymin(ans,l+f[ed.x][ed.y][m]); return; &#125; map[qes[k].x][qes[k].y]=11; dfs(k+1,l+1); map[qes[k].x][qes[k].y]=0; dfs(k+1,l);&#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; char s[110];scanf("%s",s+1); for(int j=1;j&lt;=n;j++) &#123; map[i][j]=s[j]!='#'?11:0; if(s[j]=='K') &#123;st.x=i;st.y=j;&#125; if(s[j]=='T') &#123;ed.x=i;ed.y=j;&#125; if(s[j]=='S') &#123;qesn++;qes[qesn].x=i;qes[qesn].y=j;&#125; if(s[j]&gt;='0' and s[j]&lt;='9') map[i][j]=s[j]-'0'; &#125; &#125; dfs(1,0); if(ans==inf) printf("impossible"); else printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>dfs</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终极装备]]></title>
    <url>%2Fposts%2F35a8.html</url>
    <content type="text"><![CDATA[题目【问题大意】小明玩游戏时，获得了一些终极装备，但在这之前，他已经获得了一批能和终极装备媲美的装备，并且前后的数量是一致的，但人物的最大负重为M，每个装备可提升人物V[i]力量值，自身重量为W[i]（我们把这两个值称为该装备的属性），现在的目的是让人物更强大【输入】第一行3个数：M，N，T。分别为最大负重、装备数量、人物不带任何装备的能量值。接下来N行，一行4个数，V1[i],W1[i],V2[i],W2[i]（前后两组装备视为同种）【输出】人物能够达到的最大力量值，并且同种装备只能选一个。【样例输入】50 3 2012 18 23 1917 10 30 2420 20 17 20【样例输出】80【数据范围】(其实这个贴出来没什么用)1&lt;=M,T&lt;=10000,1&lt;=N&lt;=2001&lt;=W[i],V[i]&lt;=10000 代码123456789101112131415161718192021int f[10010];//f[I]=当使用I重量时，可以达到的能量int main(int argc,char *argv[])&#123; int m,n,t; scanf("%d %d %d",&amp;m,&amp;n,&amp;t); for(int i=1;i&lt;=n;i++) &#123; int a,b,c,d; scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d); if(b&gt;d) &#123; int t=a;a=c;c=t;t=b;b=d;d=t; &#125; v1[i]=a;v2[i]=c;w1[i]=b;w2[i]=d; &#125; memset(f,0,sizeof(f)); for(int i=1;i&lt;=n;i++) &#123; for(int j=m;j&gt;=w1[i];j--) if(j&gt;=w2[i]) f[j]=max3(f[j],f[j-w1[i]]+v1[i],f[j-w2[i]]+v2[i]); else f[j]=max2(f[j],f[j-w1[i]]+v1[i]); &#125; printf("%d",f[m]+t);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【置顶】About me]]></title>
    <url>%2Fposts%2F367.html</url>
    <content type="text"><![CDATA[I am Zory, an OIer in GD.Welcome to my blog.The suggested url is zory.ink找文章请使用搜索功能，谢谢合作 现高一狗一枚因为博主巨菜，文章可能错漏百出，发现后还请帮忙指正！OI之路算是某些学习笔记吧，但并不是教程，也没有按难度顺序，可以理解为一个框架:)解题报告可能口胡没代码，有需要可叫我填上（应该……没人会需要吧） 邮箱：zorysoftware@qq.com（推荐）QQ：1134430323，最好备注一下学校和名字什么的~如果zory.ink失效，可前往zory.coding.me要转载什么的话麻烦说一声]]></content>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】07其他-6计算几何]]></title>
    <url>%2Fposts%2F7158.html</url>
    <content type="text"><![CDATA[计算几何 点积（向量乘积）： $|a||b| cos \theta=x1x2+y1y2$几何意义为b在a方向上的投影垂直：点积=0 两个向量的叉乘，又叫向量积、外积、叉积是一个向量，与【两个向量所在平面】垂直$x1y2-x2y1$方向：右手法则，四指从a到b，大拇指的朝向几何意义为平行四边形的面积 求多边形（可以凹）的面积：相邻两点（逆时针的话，可以不用绝对值，所以能模了，尽管面积可能是负数，最后总是正数）到坐标原点的叉积和例题：HDU-2036 随机任意多边形的数据：[Wf2017]Airport Construction oth]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】07其他-5哈希]]></title>
    <url>%2Fposts%2F9bde.html</url>
    <content type="text"><![CDATA[哈希Hash 前言这东西主要用来验重而且在字符串领域比较常用但其思想的应用才是其精髓所以没有放在字符串分类 正文123456789101112typedef unsigned long long ull;ull gethash(char *s)&#123; int len=strlen(s+1); ull ans=0,p=1; for(int i=1;i&lt;=len;i++) &#123; ans=ans*p+s[i]; p*=13331; &#125; return ans;&#125; 其他应用1. 字符串匹配-kmp例题：poj3461 Oulipo 2. 字符串匹配-ac自动机等价于用kmp搞ac机，不推荐 3. 字符串匹配-manacherO(nlogn)求最大回文子串其实就是枚举中心点，分情况讨论，然后二分长度 4. 字符串匹配-后缀数组O(n log^2⁡ n )在排序的比较函数中，套一个二分，得到最长公共前缀，比较其下一个字符，就能够比较出大小得出排名后，相邻的再同样地二分一次就好了 练习题Tag-哈希]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】07其他-4哈夫曼树]]></title>
    <url>%2Fposts%2Ff6c6.html</url>
    <content type="text"><![CDATA[哈夫曼树 定义定义树的带权路径长度（wpl）是每个叶子节点，其【权值×节点到根的带权距离】之和 定义“满足国际定义的满k叉树”是每个节点，其孩子个数不是0就是k 相关介绍：百度百科-满二叉树（借鉴一下）这里稍微有提到，省略了“国际”：百度百科-哈夫曼树 因为没有时间，不详细介绍有兴趣的童鞋可以去wiki看看专业文献 哈夫曼树（霍夫曼树）1.给出n个叶子节点，求一个k叉树结构，使得这棵树的带权路径长度和最小 2.先考虑k=2的二叉树情况由定义，可以想到一个贪心：每次取出最小的a和b，累计答案a+b，并构造父亲节点，权值为a+b（其实很多算法都是从贪心开始的，虽然不一定以此结束）必要性证明：不会充分性证明：把（a+b）×深度，拆分成父亲（深度-1）和答案里面的a+b 然后，由于带权路径长度的特殊性如果我们已经限定了k=2，生成的树一定是满足国际定义的满k叉树必要性证明：假设某个非底层位置还剩个“槽”，把某个比这里深的节点（这意味着它比这几个叶子节点小）移到这里，一定能让答案更小 例题：noip2004 合并果子把参与合并次数作为深度就好了 3.当k&gt;2呢？我们能不能改成一次拿出k个？有一个要考虑的细节：再刚才，k=2，总能取到这么多然鹅现在，有可能最后剩下&lt;k个由于上面的证明，我们需要生成满足国际定义的满k叉树，才能确保正确性其实解决办法很简单：补0，直到能生成满足国际定义的满k叉树这样就把本来应该放在顶层（其实就是非顶层里面最大的那些）放到顶层 但是怎么判断能不能生成完全k叉树呢？换句话说，生成满足国际定义的满k叉树对叶子节点数量有什么要求？结论：(n-1)%(k-1)=0充分性证明：假设有n个叶子节点，它们能生成满足国际定义的满k叉树先看根节点，隐去剩下的n-1个节点，倒过来考虑每一次，我们给它k个孩子节点，但同时它自己不再是叶子节点所以每一次，那n-1个节点，按照一次k-1个来出现所以n-1应当是k-1的倍数 哈夫曼Huffman编码哈夫曼有个特性，就是能够解决编码问题把每个字母、单词的出现次数统计起来，给其新的编码，总长度总是最小的（可以把次数看作权值，长度看作深度）而且，这个编码的优秀在于不会有歧义换句话说，一个编码不会是另外一个编码的前缀 做法：生成哈夫曼树，如果编码是k进制的，也就是0~k-1的那么可以理解为是k叉的，然后按照0~k-1给同一个父亲到它孩子的边赋权然后上面说的前缀，原因在于我们把字母、单词看作叶子节点从根节点到达它，经过的权，其排列是独一无二的（后缀就不一定了，但没有关系，因为解码的时候是从前往后的，先入为主） 例题：noi2015 荷马史诗 其他经典Tag-哈夫曼]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>原创精品</tag>
        <tag>经典问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】07其他-3启发式搜索]]></title>
    <url>%2Fposts%2F5f25.html</url>
    <content type="text"><![CDATA[启发式搜索，又称A*算法 基本原则$估价f(x)&lt;=实际代价g(x)$作用：假设有两个状态非最优A，在堆内是$s(A)+f(A)$最优B，在堆内是$s(B)+f(B)$即使A先出来，会拓展出$s(C)+f(C)$也就是$s(A)+g(C)-g(A)+f(C)$既然A不是最优的，那么我们的B一定能出来 但如果违反了基本原则呢？因为$s(A)+f(A)&lt;s(B)+f(B)$所以 有可能 $s(A)+g(A)+f(C)-g(C)&lt;s(B)+f(B)$所以这个状态又要再出来一次（这里的ed不一定是最终状态） 练习题Tag-启发式搜索]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>启发式搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】07其他-2-01分数规划]]></title>
    <url>%2Fposts%2F7705.html</url>
    <content type="text"><![CDATA[01分数规划问题 问题给出数组a和b，求一组解x（只由01组成），使下面的柿子最大化$\frac{ \sum a_i \times x_i }{ \sum b_i \times x_i }$ 二分法二分答案L，转化为判定性问题判定：$\frac{ \sum a_i \times x_i }{ \sum b_i \times x_i } \geq L$$\sum (a_i-L \times b_i) \times x_i \geq 0$而这个问题的判定灰常简单，因为相互之间不影响，只要括号内是正数就是1即可判定 好文章推荐显然他们真的写得比我好、也更详细张天翔PerSeAwe]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>01分数规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】07其他-1约瑟夫问题]]></title>
    <url>%2Fposts%2F6fd3.html</url>
    <content type="text"><![CDATA[不会证明…… 来历（丢个链接就跑）：百科 题目【问题描述】做了上面那题“俄罗斯轮盘”之后，大家肯定很想亲自玩一玩了。不过当人多的时候，俄罗斯轮盘就不怎么好玩了。试想一下，十几个人，一支枪，一颗子弹……那是多么不过瘾啊。因此，我为大家准备了一个更刺激的游戏：约瑟夫轮盘。玩法是这样：N个人站成一圈，按顺时针方向编号1到N。裁判站在圈的中间，手持一把填满了N-1颗子弹的左轮手枪，从1号开始，每顺时针数到第M个人就把他干掉（当然，死了的人就不算人了，且裁判枪法如神，枪枪爆头），最后剩下的一个人就是赢家。比如，N=6,M=5时，依次被干掉的是5号，4号，6号，2号，3号，而1号是赢家。现在假设你也参与了这个游戏（当然不是做裁判），你想知道站在第几号的位置才能赢，请自己编个程序算算吧，你的命运就掌握在自己手里了！ 【输入格式】输入两个整数：N和M (1&lt;=N,M&lt;=10000)。【输出格式】输出一个整数——第几号赢。【输入样例】65【输出样例】1 代码12345int n,m;scanf("%d %d",&amp;n,&amp;m);int s=0;for(int i=2;i&lt;=n;i++) s=(s+m)%i;printf("%d",s+1); 更新如今回头看，感觉这东西没什么应用？？ 有兴趣的可以去这里研究研究]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>经典问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-8最小表示法]]></title>
    <url>%2Fposts%2F8435.html</url>
    <content type="text"><![CDATA[在循环同构的n个字符串中，找出字典序最小的一个，就是最小表示法。 具体做法我们没有必要直接排序（n^2暴力或者nlogn哈希），因为我们的目的只是找到最小那一个所以换个思路，试图找到绝对不可能的部分 举例定义B[i]表示从i开始的字符串（可以通过在后面复制一段来代替）对于任意i和j，一个个比较下去，直到出现i+k和j+k不同为止假设i+k更大，则我们可以排除B[i]的可能性，因为存在更小的B[j] 重点来了！由于这个神奇的位置k，以及我们目的的特殊性可以直接确定对于所有B[i~i+k]，都不是最小表示因为存在一个B[j~j+k]，每当碰到那个i+k，都会有相同结果 所以我们可以直接跳过 具体实现双指针i和j，确保i&lt;j，直接比较，出现不同直接跳过如果i=j，则j++；如果完全没有差别，任何B[i]都是最小表示；如果任何一个到达n之后，意味着另一个是最小表示 复杂度分析比较消耗时间k，但同时也跳过了k那么总时间不变，两个字符串最多2n，所以复杂度是O(n)]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>最小表示法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-7后缀自动机]]></title>
    <url>%2Fposts%2Fd6cf.html</url>
    <content type="text"><![CDATA[后缀自动机（SAM）包含DAWG和前缀树相关定义在算法竞赛入门经典内有少量介绍，也可前往原论文的翻译 menci优质教程Facico优质教程litble优质教程题集 以下是给自己看的学习笔记 目标： 用最少的节点存储S的所有子串 构造出next指针，用于字符串的匹配等应用 定义可接受节点：SAM上运行字符串S的后缀，到达的节点end-pos(v)：节点v中长度最大的子串在母串中所有出现的结束位置的集合，别称right集合后缀链接nxt(u)=v： v的所有串都是u的所有串的后缀，而且集合的大小最小（类似偏序集？），下文也称父亲，别称famin和max：从rt（表示空串，实现的时候用节点1）到此节点的最短和最长路径长度，max别称len、dep 性质 每个节点的end-pos不会相同，否则应该被合并；每个节点表示的子串有着相同的end-pos——也就是说其实节点代表的是end-pos集合 $nxt(u)=v，则|\min(u)|=|\max(v)| + 1$ ， $end-pos(u) ⊆ end-pos(v)$ 构造max在sam中的具体表示为，从rt到当前的最长路径长度dep，min是不需要记录的，只要用性质2即可 我们时刻维护字符串前面部分的sam，然后当前插入字符c（新建节点now），lst为表示前面整个串的节点从lst开始尝试跳nxt，寻找一个节点a（显然a是当前串的后缀）拥有字符c的儿子（用类似ac自动机的方式记录即可）b一、a=0，表示找不到b，则从rt连向now，now的nxt为rt二、存在b① $dep(a)+1=dep(b)$显然end-pos是包含的，而且是其后缀$nxt(now)=b$② $dep(a)+1&lt;dep(b)$这意味着，在原串中a和b之间隔着一些字符，同时前面为了压缩节点数而把两个【加入c后end-pos不同的状态】合并在了一起这导致虽然end-pos包含，但是即将不是所有都是now的后缀现在我们需要拆开，故新建节点tmp，父亲、儿子信息从b继承， $nxt(b)=tmp,nxt(now)=tmp$ 空间复杂度节点数显然，考虑边数（DAWG上的）有一个有趣的证明方法：通过对边到后缀建立单射的映射函数来证明复杂度先对DAWG求一个生成树，对于每条边，沿着生成树到起点+边+终点一直按照最小的那个儿子直到到某个可接受节点（ed）那么每个后缀只会被第一条非树边记录到，所以空间是线性的 那么这个有什么用呢？对于普通的应用（26个字母）是没用的，但可以配合map解决大字符集的问题 时间复杂度总共有两次向上跳第一次，单次的次数是不超过max的，每跳一下，max会-1，然后每次插入字符比前面+1第二次，因为每个节点造成的影响都是连续的一段的，那么我们每次都是精准地修改，所以复杂度相同 应用①不同子串数：dag上dp、用性质4做皆可；得到这个可以用来求第k小子串，贪心即可②最长公共后缀：parent树上两点lca③拓扑序：可以利用性质用dep排序④最小表示：因为包含了所有子串，对S+S建，跑|S|次，贪心找最小的那个⑤最长公共子串：先选一个建好，两串直接跑nxt，多个就对每个节点记录其他串的min，最后选最大的节点⑥回文串（替代manacher）：参见回文串 补充反向前缀树（反串后缀树）=parent树=前缀反串插到trie中故后缀树=反串parent树=后缀插到trie中]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>sam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-6后缀数组]]></title>
    <url>%2Fposts%2Fcc01.html</url>
    <content type="text"><![CDATA[后缀数组入门 sa和rk的计算rk表示第i个后缀（第i个位置后面的元素）的排名sa为其逆函数，即排名i的后缀，所在位置 采用倍增给后缀排序然后多关键字的话，非常巧妙地方法：先第二关键字，然后用稳定排序来第一关键字（类似覆盖） height的计算height[i]=LCP(后缀排名i-1，后缀排名i)如果能计算出这个东西，那么询问任意两个后缀的LCP就是询问区间height最小值 然后现在希望尽量快地计算出height，那和所有字符串算法一样，尽可能地优化总势能考虑定义的特性，字典序的排名有什么性质？通过上面利用height的方式得到启发，任意两个串的LCP能保证中间的LCP的下限 具体性质： $height[rk[i]] \geq height[rk[i-1]]-1$$a=i-1,b=sa[rk[i-1]-1]$$c=i,d=sa[rk[i]-1]$现在要证明 $LCP(c,d) \leq LCP(a,b)-1$然后只考虑 $LCP(a,b) \leq 2$ 的情况，否则显然c就是a去掉了开头的一个字符，设e=b+1（去头）$LCP(e,c)=LCP(a,b)-1$然后因为是字典序，e依然会在c前面，显然得证 按照这个做，时间复杂度就是2n的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const int MAX_N=310000;char str[MAX_N];int len;struct Sa&#123; int sa[MAX_N],tmp[MAX_N]; int rk[2*MAX_N],rk2[2*MAX_N];//两倍 int ct[MAX_N]; bool diff(int a,int b,int ln) &#123;return rk2[a]!=rk2[b] or rk2[a+ln]!=rk2[b+ln];&#125; void build() &#123; memset(ct,0,sizeof ct); for(int i=1;i&lt;=len;i++) ct[rk[i]=str[i]]++; for(int i=1;i&lt;=MAX_N;i++) ct[i]+=ct[i-1]; for(int i=len;i&gt;=1;i--) sa[ct[rk[i]]--]=i; int ln=1; while(ln&lt;len) &#123; int cnt=0;for(int i=len-ln+1;i&lt;=len;i++) tmp[++cnt]=i; for(int i=1;i&lt;=len;i++) if(sa[i]-ln&gt;=1) tmp[++cnt]=sa[i]-ln; memset(ct,0,sizeof ct); for(int i=1;i&lt;=len;i++) ct[rk[tmp[i]]]++; for(int i=1;i&lt;MAX_N;i++) ct[i]+=ct[i-1]; for(int i=len;i&gt;=1;i--) sa[ct[ rk[tmp[i]] ]--]=tmp[i]; cnt=0;memcpy(rk2,rk,sizeof rk); for(int i=1;i&lt;=len;i++) &#123; if(diff(sa[i-1],sa[i],ln)) cnt++; rk[sa[i]]=cnt; &#125; ln*=2; &#125; &#125; int hei[MAX_N]; void geth() &#123; int lst=0; for(int i=1;i&lt;=len;i++) &#123; if(rk[i]==1) &#123;hei[1]=0;continue;&#125; if(lst) lst--; while(max(i,sa[rk[i]-1])+lst&lt;=len and str[sa[rk[i]-1]+lst]==str[i+lst]) lst++; hei[rk[i]]=lst; &#125; &#125;&#125;sa;]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>sa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-5AC自动机]]></title>
    <url>%2Fposts%2Fab16.html</url>
    <content type="text"><![CDATA[AC自动机 一、定义 这东西就是KMP思想和字典树的结合。首先，对于多模问题，也就是对一个母串判断多个字符串是否是它的子串时，（对于判断多个字符串是否是它的母串，kmp灰常优秀）每个都做一次KMP显然是不合理的，同时为了减小空间，采用字典树 二、KMP思想我主要用fail“指针”实现在字典树中，假设现在有节点i，保证从【root到fail】路径上的字符串是从【root到i】的最长后缀这样，当我们失配时，退而求其次，尝试匹配它的后缀其实有种【树上kmp】的感觉 三、有关字典树在每个节点中有一个变量s，我们对于字典树模板的修改和利用主要体现在这上面，可能还有一个布尔保证不再来。 四、从例题开始Caioj1464注意solve中曾经有个BUG，就是应该每次都尝试引导k到fail那里，即使还没到字符串尾（这样才不会忽略掉包含的情况，例如abcd和bc，在abcd中计算），caioj的数据已经改进了~12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//*******************全局常量*******************const int MAXN=1100000;//*******************全局定义*******************char s[MAXN];//*******************实现*******************struct Trie&#123; int s; int ch[26]; int fail;&#125;a[510000];int cnt;void clear(int x)&#123; a[x].s=a[x].fail=0; memset(a[x].ch,0,sizeof(a[x].ch));&#125;void add()&#123; int ln=strlen(s+1); int now=0; for(int i=1;i&lt;=ln;i++) &#123; int t=s[i]-'a'; if(!a[now].ch[t]) &#123; clear(++cnt); a[now].ch[t]=cnt; &#125; now=a[now].ch[t]; &#125; a[now].s++;&#125;int lst[MAXN];void getfail()&#123; int tou=1,wei=2;lst[1]=0; while(tou!=wei) &#123; int x=lst[tou++];if(tou==MAXN) tou=1; for(int i=0;i&lt;26;i++) &#123; int son=a[x].ch[i]; if(!son) continue; if(x&gt;0)//debug &#123; int j=a[x].fail; while(j&gt;0 and !a[j].ch[i]) j=a[j].fail; a[son].fail=a[j].ch[i]; &#125; lst[wei++]=son;if(wei==MAXN) wei=1; &#125; &#125;&#125;int solve()&#123; int ln=strlen(s+1); int ans=0; int now=0; for(int i=1;i&lt;=ln;i++) &#123; int t=s[i]-'a'; while(now&gt;0 and !a[now].ch[t]) now=a[now].fail; now=a[now].ch[t]; if(now&gt;0) &#123; int tmp=now;//匹配了现在这个等同于匹配了其所有后缀 while(a[tmp].s&gt;=0) &#123; ans+=a[tmp].s; a[tmp].s=-1;//阻断 tmp=a[tmp].fail; &#125; &#125; &#125; return ans;&#125;//*******************主函数*******************int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; int n;scanf("%d",&amp;n); clear(0);cnt=0; while(n--) &#123; scanf("%s",s+1); add(); &#125; getfail(); scanf("%s",s+1); printf("%d\n",solve()); &#125;&#125; 五、练习地图匹配更全面的：Tag-AC自动机 upd时间复杂度的证明主要是构造fail方面 考虑链上，每个节点其fail的深度的关系$dep_{fail-i+1} \leq dep_{fail-i} - xx$$xx \leq dep_{fail-i} - dep_{fail-i+1}$显然xx的和，是和n同阶的]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-4字典树]]></title>
    <url>%2Fposts%2F7385.html</url>
    <content type="text"><![CDATA[这东西属于数据结构，还是很有趣的……这个的话我就不解释太多了，根据代码理解完全足够 简单的例题：统计前缀Caioj1463HDU1251 【题意】给出很多个字符串(只有小写字母组成)和很多个提问串，统计出以某个提问串为前缀的字符串数量(单词本身也是自己的前缀).【输入格式】输入n,表示有n个字符串(n&lt;=10000)接下来n行,每行一个字符串,字符串度不超过10输入m,表示有m个提问(m&lt;=100)第二部分是一连串的提问,每行一个提问,每个提问都是一个字符串.【输出格式】对于每个提问,给出以该提问为前缀的字符串的数量.【样例输入】5bananabandbeeabsoluteacm4babbandabc【样例输出】2310 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//*******************定义*******************struct Trie&#123; int s,c[27];&#125;a[500010];//*******************实现*******************void clean(int x)&#123; a[x].s=0; for(int i=1;i&lt;=26;i++) a[x].c[i]=-1;&#125;char s[20];int len,k;void add()&#123; len=strlen(s+1); int x=0; for(int i=1;i&lt;=len;i++) &#123; int t=s[i]-'a'+1; if(a[x].c[t]&lt;0) &#123; a[x].c[t]=++k; clean(k); &#125; x=a[x].c[t]; a[x].s++; &#125;&#125;int solve()&#123; len=strlen(s+1); int x=0; for(int i=1;i&lt;=len;i++) &#123; int t=s[i]-'a'+1; if(a[x].c[t]&lt;0) return 0; x=a[x].c[t]; &#125; return a[x].s;&#125;//*******************主函数*******************int main(int argc, char *argv[])&#123; clean(0);k=0; int n;scanf("%d",&amp;n); while(n--) &#123; scanf("%s",s+1); add(); &#125; int m;scanf("%d",&amp;m); while(m--) &#123; scanf("%s",s+1); printf("%d\n",solve()); &#125;&#125; 字典树练习：HDU1075HDU1800]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-3ExKMP]]></title>
    <url>%2Fposts%2F4360.html</url>
    <content type="text"><![CDATA[本文思路和图片大致来自于师兄cys大佬的论文本文会用相同颜色分别表示图片中某段的相等性 一、定义KMP：$str(1,nxt[i])=str(i-nxt[i]+1,i)$exKMP：$str(1,ext[i])=str(i,i+ext[i]-1)$然后接下来的过程中，思路和manacher是灰常类似的，各种分类讨论继承 二、求ext数组$ext[1]=lenb$（显而易见）因为ext[1]这个是具有一定性，所以我们基本把这东西废掉……那么我们就直接从ext[2]开始求。 A. k表示在当前搜索过的范围以内,rx=k+ext[k]-1最远（与manacher很像）故str(1,ext[k])=str(k,rx)因为$rx=k+ext[k]-1$，又得：$ext[k]=rx-k+1$代换变成：str(1,rx-k+1)=str(k,rx)因为现在要求ext[i]，截取str(i-k+1,rx-k+1)=str(i,rx) B. 设$L=ext[i-k+1]$，又得：str(1,L)=str(i-k+1,i-k+L)接下来尝试合并。因为L的不定性，需要考虑$i-k+L$和$rx-k+1$的大小 （1）i-k+L&lt;rx-k+1因为str(1,L)=str(i-k+1,i-k+L)，str(i-k+1,rx-k+1)=str(i,rx)所以在str(i,rx)中str(i,i+L-1)=str(1,L)因为str(i-k+1,rx-k+1)=str(i,rx)，得：str[i-k+L+1]=str[i+L]而因为ext[i-k+1]的定义，所以str[L+1]!=str[i-k+L+1]，得：str[i+L]!=str[L+1]，那么$ext[i]=L$小总结：主要利用【$i-k+L+1$已经扫描过】 （2）i-k+L&gt;=rx-k+1str(1,L)=str(i-k+1,i-k+L)所以str(1,rx-i+1)=str(i-k+1,rx-k+1)因为ext[k]的意义，所以str[rx+1]!=str[rx-k+2]又有可能str[rx-i+2]!=str[rx-k+2]（与rx-i+1与L的大小关系有关），那么就会得到：str[rx-i+2]!=str[rx+1]，所以$ext[i]\geq rx-i+1\geq ext[i-k+1]$ 总结：当$i-k+L&lt;rx-k+1$，$ext[i]=L$当$i-k+L\geq rx-k+1$，$ext[i]\geq ext[i-k+1]$ 三、用ext数组好啦我们要开始匹配A串（母串）和B串了定义ex数组，$B(1,ex[i])=A(i,i+ex[i]-1)$即A中每个后缀与B的最长公共前缀长度某种理解：将i-k+1看作i的对应点，将串B和串A放在同一条线上，前面用ext，后面用ex，则L为ext[i的对应点] 四、总结让我们再次对比一下kmp与exkmpKMP：$str(1,nxt[i])=str(i-nxt[i]+1,i)$exKMP：$str(1,ext[i])=str(i,i+ext[i]-1)$对于kmp，当i向后时，利用前面的信息是灰常简单的，一个比较即可；而对于exkmp，前后的i之间并没有较紧密的联系，需要较复杂地分情况讨论 那么这个“牺牲”为我们带来了什么呢？如ex一样的字符串局部信息，并且能够有从i开始的信息。 五、例题最长共同前缀长度回文串字符串的相似度 六、练习题Tag-exkmp 七、一张图快速复习exkmp]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>ExKMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-2Manacher]]></title>
    <url>%2Fposts%2F1c35.html</url>
    <content type="text"><![CDATA[Manacher 一、定义应用：求最长回文子串。暴力复杂度：O(n^3)Manacher复杂度：O(n)是不是特别优越？ 二、过渡算法考虑枚举每一个中间点，向两边拓展，此时即O(n^2)这种做法已经比暴力好很多了，但是让我们思考一些缺陷来提升效率。 1. 中间点的多样性目前的做法，中间点有可能是字符（回文串长度为奇数）也可能是字符间的空隙（回文串长度为偶数），比较麻烦。考虑将空隙变成‘#’等绝对不出现字符，复杂度不变，但便于我们处理。此时空隙数为字符数+1 2. 求解过程没有利用残留信息（这从来都是算法设计的关键） 通常我们要求的或者做题需要的辅助只是长度，与具体字符串无关，或许可以从这里入手。 所谓长度，而且还是回文的，我们可以定义【回文半径】，即回文串长度的一半，此后只需要考虑半径就等同于考虑长度。而且因为之前我们把空隙变成了字符，现在算出来的最大【回文半径-1】就是原来的回文串长度（因为空隙数必然是字符数+1）举例：123char: # a # b # b # a # RL : 1 2 1 2 5 2 1 2 1RL-1: 0 1 0 1 4 1 0 1 0 然后定义：rx：当前所有回文子串最右触及位置ma：回文半径数组 二、具体操作接下来就是分类讨论i与rx的位置关系啦，因为这关系到状态的继承 （pos是rx的对应中介点，lx是对于左端点） 1. i&lt;=rx那么找到i关于pos对称的j①ma[i]=ma[j]②ma[i]=rx-i+1 2. i&gt;rxma[i]=1 当然，这些继承只是基础，接下来还是要暴力拓展这些主要是缩短了前面无意义的继承。 三、例题代码2009 Multi-University Training Contest 16 - Host by NITHdu3068Caioj1179123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=110000;const char SPC='#';//*******************全局定义*******************char s2[MAXN*2];//*******************实现*******************char s[MAXN*2];int ma[MAXN*2];int manacher()&#123; int ln=strlen(s2+1); for(int i=1;i&lt;=ln;i++) s[2*i-1]=SPC,s[2*i]=s2[i]; ln=ln*2+1;s[ln]=SPC; int md,rx=0,ans=0; for(int i=1;i&lt;=ln;i++) &#123; if(i&lt;=rx) &#123; int j=2*md-i; if(i+ma[j]-1&lt;=rx) ma[i]=ma[j]; else ma[i]=rx-i+1; &#125; else ma[i]=1; while(i-ma[i]&gt;=1 and i+ma[i]&lt;=ln and s[i-ma[i]]==s[i+ma[i]]) ma[i]++; if(rx&lt;i+ma[i]-1) rx=i+ma[i]-1,md=i; chmax(ans,ma[i]-1); &#125; return ans;&#125;//*******************主函数*******************int main()&#123; //freopen("tmp.in","r",stdin); while(scanf("%s",s2+1)!=EOF) printf("%d\n",manacher());&#125; 参考文献：segmentfault-曾会玩刘毅]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-1KMP]]></title>
    <url>%2Fposts%2Fc111.html</url>
    <content type="text"><![CDATA[本质上是尽量地利用子信息、残留信息 一、说在正文前的小声明网络上有关KMP的文章灰常多，本文旨在给初学者一个大致理解，尽量以最简单最直观的方式实现kmp，而不考虑太多有关性能的问题。 参考文献（或者说建议你看看的东西）：1(并不是他原创，但原文找不到了。。)，用了个图片和栗子2 栗子比较完整，大家有兴趣可以看看，对本文无用3 阮一峰，挺好的，用了图片和前后缀角度的看法4 v_july_v，太强了，堪称完美，建议理解本文后去这里提高，目前我持膜拜状态5 matrix67，绝对经典 二、定义Knuth-Morris-Pratt字符串查找算法，简称为”KMP算法”，常用于在一个文本串S(母串)内查找一个模式串P(子串)的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H.Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。KMP算法的主要作用在于，计算出字符串B是否为字符串A的子串及其系列问题。它比简单的暴力算法更优秀的地方在于，当部分匹配失败时，暴力算法一个个字符向前回溯，KMP则通过预先根据字符串B所计算出的”假如我的下一个字符失配，我的新对应位置”（通常用Next数组表示）。由于此预处理过程只是与字符串B有关，所以很适合处理”某个字符串B验证多个字符串A是否是其母串”一类问题。 三、利用Next数组求解KMPNext的性质（你要是想成定义也行）（在实现中，通常把Next用其他更简短的单词表示，本文用p）B[1..p[i]]=B[i-p[i]+1..i]并且要求p[i]最大，从而让移动距离最小，成功可能性更大并且没有漏网之鱼，类似贪心思想 假设现在字符串A[i-1]匹配成功，字符串B[j]匹配成功伪代码：1234567891011j=0;for i=1 to lenA&#123; while(j&gt;0 and a[i]!=b[j+1]) j=p[j]; //将匹配成功的j的p[j]重新尝试对齐i-1 //此举意味着失配时，字符串B相对于字符串A向右移动了j-Next[j]位 if(a[i]==b[j+1]) j++; //此时j成功匹配 如果(j==lenb) ans++; //这句话看情况，目前表示统计的答案数+1（如果想搜出来的不重叠就加上j=0）&#125; 三、Next数组 对称不是中心对称，而是中心字符块对称，比如不是abba，而是abab这种对称 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合 “后缀”指除了最前一个字符以外，一个字符串的全部尾部组合 那么Next数组究竟怎么求？这也是网络上有关KMP最大的争议。首先，Next数组有几种定义（这也是为何初学者很容易混淆）。不过殊途同归，next本质上是相同的~ 四、Next的角度1“最大长度值”是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例。 (个人认为这个也适合作为性质去记忆而非求法，虽然听老师讲了一遍后开始折服于此) 序号 1 2 3 4 5 6 7 字符 A B C D A B D 最大长度 0 0 0 0 1 2 0 “A”的前缀和后缀都为空集，共有元素的长度为0；“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；“ABC”的前缀为[A,AB]，后缀为[BC,C]，共有元素的长度0；“ABCD”的前缀为[A,AB,ABC]，后缀为[BCD,CD,D]，共有元素的长度为0；“ABCDA”的前缀为[A,AB,ABC,ABCD]，后缀为[BCDA,CDA,DA,A]，共有元素为”A”，长度为1；“ABCDAB”的前缀为[A,AB,ABC,ABCD,ABCDA]，后缀为[BCDAB,CDAB,DAB,AB,B]，共有元素为”AB”，长度为2；“ABCDABD”的前缀为[A,AB,ABC,ABCD,ABCDA,ABCDAB]，后缀为[BCDABD,CDABD,DABD,ABD,BD,D]，共有元素的长度为0。 所以，p[i]可以说是从1到i形成的字符串中的最大长度值。其实与前面说的“s(1,p[i])=s(i-p[i]+1,i)”是一样的 1234567for(int i=2;i&lt;=lenb;i++)//X2，后缀头不变尾延长&#123; while(j&gt;0 and b[j+1]!=b[i]) j=p[j];//让前缀和后缀同时增长 //j是前缀的尾同时也是最大长度值，必然比i小所以其p已经计算出了 //失败的时候找更小一点的对称，也就从蓝色转变为红色来延长 if(b[i]==b[j+1]) p[i]=++j; else p[i]=0;&#125; 同样的代码，不同的理解方式。 另一个更贴合本理解的代码123456for(int i=2;i&lt;=lenb;i++)//图片中的X2，后缀头不变尾延长&#123; int j=p[i-1];//图片中的x1-1，因此蓝色相等 while(j&gt;0 and sb[i]!=sb[j+1]) j=p[j]; if(sb[i]==sb[j+1]) p[i]=j+1; else p[i]=0;&#125; 这两份代码可以结合图片理解，i就是x2，j是x1-1 五、Next的角度2Next数组相当于“最大长度值”整体向右移动一位，然后初始值赋为-1 序号 1 2 3 4 5 6 7 字符 A B C D A B D 最大长度 0 0 0 0 1 2 0 Next -1 0 0 0 0 1 2 其实这个角度本质上和上一个一样，只不过这样就能”在j失配时直接对j跳转“而不是”在j+1失配时对j跳转“《最大长度值》字符串B向右移动的位数[已匹配字符位置-失配字符的上一位字符的最大长度值]《Next数组》字符串B向右移动的位数[失配字符的位置-失配字符对应的Next值]上述两个值相等 六、Next的角度3用一个长长的字符串来解释 序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 符 A G C T A G C A G C T A G C T G Ne 0 0 0 0 1 2 3 1 2 3 4 5 6 7 4 0 假设当前字符位置i，子串位置j(1)递推比较把i与j+1进行比较，如果相等，直接继承为上个Next再+1，因为对称程度增加了。如果不相等，跳到(2)，很好理解 (2)回头来找对称性 t如果要存在对称性，那么对称程度肯定比前面这个c的对称程度小。要找更小的对称，必然在对称内部还存在子对称，而且这个t必须紧接着在子对称之后。 可以通过循环j=Next[j]不断找更小对称性个人感觉类似自己匹配自己 七、代码123456789101112131415161718192021222324252627282930313233343536373839//*******************定义*******************int p[11100],lenb;char b[11000];//*******************实现*******************void calcb(void)&#123; lenb=strlen(b+1); int j=0;p[1]=0; for(int i=2;i&lt;=lenb;i++) &#123; while(j&gt;0 and b[j+1!=b[i]]) j=p[j]; if(b[i]==b[j+1]) p[i]=++j; else p[i]=0; &#125;&#125;int KMP(char a[])&#123; int lena=strlen(a+1); int j=0;int ans=0; for(int i=1;i&lt;=lena;i++) &#123; while(j&gt;0 and a[i]!=b[j+1]) j=p[j]; if(a[i]==b[j+1]) j++; if(j==lenb) ans++,j=0; &#125; return ans;&#125;//*******************主函数*******************char a[11000];int main(int argc, char *argv[])&#123; int n;scanf("%d",&amp;n); while(n--) &#123; scanf("%s",b+1); calcb(); scanf("%s",a+1); printf("%d\n",KMP(a)); &#125;&#125; 检验数据：Inputalkdfjhaljhdgelqigljafiehiqhrougsgssgsgijosgsjeswsgjjiigj Output02 八、练习陶陶的名字（可以重叠的最小覆盖） 九、kmp与最小覆盖参考文献：FarmerJohn 定义：对于一个字符串，一个长度最小的满足【复制自己多次（不重叠，与陶陶的名字不同）后可以覆盖原串】的子串 结论：长度=n-next[n] 证明：先证明它是覆盖子串①next[n]&lt;=n-next[n]显而易见覆盖 ②next[n]&gt;n-next[n] 然后它也是最小的这里用反证法，假设存在一个比n-next[n]更小的C（所以蓝色&gt;0），然后截取掉强行定义一个黄色段，是C的补集，然后因为C会最小覆盖，所以是C的前缀这样的话，黄色部分比next[n]更长，不满足next[n]是最长这个定义 Q.E.D.]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>原创精品</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】05动态规划-4数位dp]]></title>
    <url>%2Fposts%2F8ba0.html</url>
    <content type="text"><![CDATA[数位dp 很好资料zbtrs 感觉这东西也没什么好说的了等碰到什么不套路，有特色的题目再加上来吧 练习题Tag-数位dp]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】05动态规划-5概率与期望]]></title>
    <url>%2Fposts%2F7366.html</url>
    <content type="text"><![CDATA[概率与期望 概率应该不难？ 期望通俗地讲，就是【所有结果状态的权值乘以概率】的和相当于，尝试无限次后，得到的平均数通常是倒推的，因为这样，当前状态的概率总是1，灰常方便 例题：3801 Rainbow的信号 然后讲讲期望的线性性结合例题：3802 绿豆蛙的归宿对于一个状态x，如果按照定义来计算期望枚举它的所有能产生的结果状态，然后累计权值乘以概率 然鹅事实上可以直接枚举k个后继状态y$f[x]=\sum_{i=1}^k (f[y_i]+c)\times \frac{1}{k}$这是为什么？其实就是把c按照后面发生的概率，等比例划分后更新到权值里面（因为权值也就是距离在变大） 有空再慢慢研究的资料练习题Tag-概率与期望]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】05动态规划-2-1d1d动态规划]]></title>
    <url>%2Fposts%2F4bab.html</url>
    <content type="text"><![CDATA[1D/1D动态规划状态为n，转移为n的dp方程动态规划的优化-周尚彦.pdf 单调队列主要步骤： 移除无效元素 计算队首的最优g，得到f(i)的最优结果 计算新的g，放入队列中，并维护单调性 有一道比较变态的变形题：Cut the Sequence 斜率优化这个东西学了n次，前面n-1次都没学扎实（教练水平有限）随着实力的提升，这次细细研究周尚彦的论文，终于彻底搞明白了所以我也尽力讲清楚，但开始研究之前请确保有扎实的基础（如提高一等水平） 斜率优化主要可以从数学和图形的角度去理解，数学方面的话可以看我玩具装箱的题解，本文以图形为主（更有助于后期的提升） dp方程的基本形式(不能有二维数组)：$f(i)=f(j)+w(j,i),w(j,i)=a_i+b_j+c_i \times d_j$如果j在i之前已经计算出来了，显然可以化一下柿子$f(i)=(d_j) \cdot (c_i) +a_i+b_j+f(j)$不难看出这是一个一次函数，i是带入的未知元，这个可以用李超树轻松解决看到别人说要化成一次函数的形式，这是我最先想到的做法，然而这样的复杂度下限是nlogn的然而有些题，使用斜率优化可以线性解决 换一种思路，考虑将j本身的东西所谓x和y，也就是变成点那么对于i，它的决策也可以是这种形式：$f(j)+b_j=(-c_i) \cdot (d_j) +f(i)-a_i$截距：直线与y轴的交点的纵坐标那么我们的目的就是最小化截距 据说这是一个线性规划问题，但我不清楚这是什么……但这和我们要讲的无关总之就是一个直线，其斜率和i有关，从下往上移直到碰到第一个点，就是最优决策点显然只有某个凸壳上的点是有用的（min则下凸壳） 然后下面的内容就要结合题目的具体性质了A. 点的x坐标是单调的 提供的直线的斜率是单调递增的这种情况的话，显然这个凸壳内部相邻点的斜率是单调递增的，否则不会有贡献而且决策点具有单调性，左边的部分无需保留，通常用单调队列实现 提供的直线的斜率是不单调的此时决策点不单调，不过因为维护好了凸壳，可以在上面二分（某个左右都更差的位置） B. 点的x坐标是不单调的平衡树动态插入来维护或者用cdq分治处理 练习详细地讲讲这个入门好题(仅从数学的角度)：玩具装箱好文章推荐：MashiroSky 四边形不等式如果转移满足该不等式，则称满足决策单调性形式1：对于 $a \leq b \leq c \leq d,w(a,d)+w(b,c) \geq w(a,c)+w(b,d)$（简单记为：交叉小于包含）形式2： $w(a,b+1)+w(a+1,b) \geq w(a,b)+w(a+1,b+1)$考场上可以考虑暴力打出决策点的表，验证单调性 一维：$f(i)=min f(j)+w(j,i)$一维状态例题：诗人小G这个套路还是很好用的 然后还有一种写法，某些情况下可能更好写就是分治，每次暴力处理mid的决策点 二维（虽然这个不属于1d1d，但是也顺便讲讲）：$f(l,r)=min f(l,k)+f(k+1,r)+w(l,r)$如果w满足四边形不等式，则f也满足四边形不等式如果f满足四边形不等式，则 $fm(l,r-1) \leq fm(l,r) \leq fm(l+1,r)$即f的决策，在同一行、同一列上单调递增 例题：合并石子显然其w满足四边形不等式（取等），则f也满足，那么决策的区间是确定了的然后你考虑每种ln$l=1，fm(1,ln-1) -&gt; fm(2,ln)$$l=2，fm(2,ln) -&gt; fm(3,ln+1)$……也就是枚举范围连起来只有一个n（感觉这种东西谁会想到啊……）l推荐文章：https://www.cnblogs.com/mlystdcall/p/6525962.htmlhttps://blog.csdn.net/noiau/article/details/72514812]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】05动态规划-1入门]]></title>
    <url>%2Fposts%2Fb119.html</url>
    <content type="text"><![CDATA[动态规划dp基础 7.1 采药的升级版终极装备 7.2 中链式（二维）乘积最大 7.3 最长升降序子序列合唱队形 7.4 最长公共子序列最长公共子序列 7.5 练习动态规划思想+二分优化：进攻策略难度较大 思维风暴~：乘电梯 7.6 多重背包二进制拆分法：每个物品有ci次使用机会可以把每个物品拆成log个主要是利用二进制的表示法记得把余数加上就好了还是很好理解的 7.7 环形dp对于没有产生环形依赖的情况，可以把自身复制一遍到后面但如果有环形依赖，但转移简单的时候，可以用高斯消元否则有一种精妙的办法，适用于那种收尾相接情况简单的时候，就是通过多次dp，第一次不相连，第二次强行相连（通过赋初始值）]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-11第k优解相关]]></title>
    <url>%2Fposts%2Fc623.html</url>
    <content type="text"><![CDATA[第k优解相关主要是【寻找第k优解的几种方法——俞鼎力】的学习笔记 区间k大的众多拓展暂未研究 k短路无负权边下对反图上终点建最短路径树然后每个点，存储一个非树边序列因为树上父亲是当前的序列的子集，继承过来，然后加入新的非树边（单个）那么为了减少状态的出度，从最基础的【在后面直接加边】改为【排序后，有序替换】，这个感觉论文的图不错那么每个点，开一个堆去维护，因为有继承的环节，用可持久化左偏树会非常方便，复杂度为严格logn（深度限制）$O(nlogn+mlogm+klogk)$似乎实现有很多边界和细节？ 暂未达成： $O(nlogn+m+klogk)$ （不过反正连supergaymj都不会……）以后补代码…… k小生成树暂未研究 k短简单路径暂未研究]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-10其他]]></title>
    <url>%2Fposts%2Fd107.html</url>
    <content type="text"><![CDATA[杂七杂八：Dilworth定理…… Dilworth定理严格偏序集的图像是dag传递闭包结果为其本身链即任意两个元素都能比较的集合反链即任意两个元素无法比较的集合 极小元：没有能和他比较得更小的元素的集合 【最大反链大小=最少链覆盖数】证明：显然每条链上只能选择最多一个，加入反链则 最大反链大小&lt;=最少链覆盖数那么如果我们能构造一种方案，使得其取到【最少链覆盖数】，即完成了证明 拆点二分图，左出右入因为路径覆盖时，每个点只有一条出边，二分图匹配，然后左边没有出度的节点就是链的终点其个数即链的数量 方法一：直接跑二分图的最大独立集A，取满足入度和出度都在A中的点S可行性：如果不是反链，那么会存在一条边，与最大独立集矛盾 最小性：设m为匹配数根据定理，知 $|A|=2n-m$$|A|=|S|+t（只有其中一个在A中）$然后 $t \leq n$所以 $|S| \geq n-m$现在 $|S|=n-m$ ，所以是最小方案 那么这个东东，可以构造 最小点覆盖，然后取补集具体方法在二分图一章 方法二（不会证明）：先取出每个路径的终点，作为集合A，将A走一步能到达的节点作为next(A)按照题意，$A \cap next(A)=\varnothing$ ，所以我们要有所调整取出这种元素，然后在其所属的【最小可重复点覆盖路径】上，往起点方向跳，一定能找到一个元素不属于next(A)，否则意味着整条路径都是可以被别人覆盖掉的，违反了我们先前最小的定义找到后，取代原先的元素，如此重复下去，最后总是能满足条件的综上所述，存在一种方案，满足条件 【最少反链覆盖数=最长链长度】证明：最长链上每个元素不能在同一条反链中构造法，每次选择极小元集合，选择【最长链长度】次就完全选完了]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-9二分图]]></title>
    <url>%2Fposts%2F250b.html</url>
    <content type="text"><![CDATA[博大精深的二分图 二分图顶点可以分类两个集合X和Y，所有的边关联的两个顶点，恰好一个属于集合X，另一个属于集合Y 二分图增广路的另一种理解：建立一个有向图，非匹配边看做从左向右，匹配边看做从右向左那么左边的x到右边的y存在增广路，相当于存在一条路径，非常方便 杂七杂八在平面二分图上，如果存在使边不会重叠的方案，那么其中一定有一种是边长和最小的方案也就是把合法性、可行性问题转化为求边长和最小的问题证明的话，显然如果我能够选择不跨越，边长和会变小 König定理最大 匹配数:顶点两两配对的对数最大 独立集:顶点两两不到达的点数最小 点覆盖:选一个点就能覆盖所有与它连接的边，求点覆盖所有边的点数最小 边覆盖:选一条边就能覆盖所有与它连接的点，求边覆盖所有点的边数 最小点覆盖（有时称为最小覆盖）=最大匹配数 最小边覆盖=最大独立集 最大独立集=去掉最少的点，剩下点之间没有边=n-最小点覆盖=n-匹配数 举例：经典模型 Muddy Fields 最小点覆盖自信地说，截至2018.11，没有看到更完善的证明感觉近几年没人研究这东西了……都是远古资料 对二分图先进行最大匹配，建议画图理解设匹配数为m，点覆盖集合为S 构造方法：每次从右边的非匹配点出发，找出所有【未匹配边-&gt;匹配边-&gt;…未匹配边-&gt;匹配边】的路径，经过的点打上标记则最小点覆盖方案为【A左边有标记】+【B右边没标记】 证明：一、合法性①标记-&gt;标记，可以用A覆盖②标记-&gt;无标记，可以用A覆盖③无标记-&gt;无标记，可以用B覆盖④无标记-&gt;标记，不存在对于④，如果边是匹配边，则右边的标记来自左边，变成①；如果是非匹配边，标记来自其他匹配点，将继续打标记，变成①二、最小性首先显然 $|S| \geq m$起点贡献为 $right-m$然后每次打标记，显然左标记一定会贡献一个且仅一个右标记所以 $右标记=左标记+right-m$$右非标记=m-左标记$$|S|=m$ 实现：网络流是最容易实现的匹配边总是向左，非匹配边总是向右，只走【流量=0】的边即可可以直接在上面搜索如何保证总是以匹配边结束?问出这个问题证明你对二分图匹配不熟练，请自行学习答：如果以非匹配边结束，意味着增广路！ 二分图最大匹配的必经边和可行边先从特殊的完备匹配开始考虑可以先任意找到一组匹配方案 必经边：【当前是匹配边】并且【删除后不存在从x到y的路径】因为匹配边意味着从y到x，现在又存在从x到y的路径那么就以为着 x和y属于同一个强连通分量所以必经边的判定条件可以改为：【当前是匹配边】并且【不同强连通分量中】 可行边：【当前是匹配边】或者【把x到y看做可行边后，存在连接原本另外两个匹配点的路径】因为我们刚才的建边方式，也就是另外两个原本的点之间有路径，同时原本就有匹配边把他们和x、y连接所以说条件可以改成：【当前是匹配边】或者【同一个强连通分量中】 不过，如果没有完备匹配呢？对于两种边的第二个条件，不一定非要增广x到y，而可以是到z所以就会出问题（还傻傻地以为没有问题） 怎么解决呢？接下来的内容很好懂但是我认为是神仙想出来的东西……太nb了，我也只有帮忙吹水的份 分情况去解决问题对于必经边的判定，不能只是x到y了，而是不能有任何新增广路所以我们要判断，删除之后是否存在其他增广路不过，这个增广路一定是连接x和y中某一个的，否则与此次操作无关，影响了最大匹配的“最大” 如果我们考虑用网络流解决二分图最大匹配问题，剩下的残余网络能够很清晰地得出具体的有向图方案因为对于匹配边，流量过去了，那么有效边是其反向弧，非匹配边则不变，恰好与我们提出的有向图表示法相一致 加入源点和汇点，那么匹配点也能很清晰地表示出来了然后我们可以用这个图去考虑完善判断条件 图示：a和b是非匹配点，u和v是匹配边蓝色是匹配边，红色是非匹配边然后绿色是在强连通分量中的部分 先解决必经边的判定，也就是断开原本的边，分为x和y去找两种情况 对于可行边的判定，原本是非匹配边可能x和y中只有一个匹配点，分为x和y去找两种情况也可能两个都是匹配点 综上所述，可以把原本的方案，判断强连通部分不变，对象从简单有向图变为网络流的残余网络（忽略流量为0的边） 例题：舞动的夜晚 最大二分图匹配（下文为早期所写，不保证正确性） 1234567891011121314151617181920212223242526272829303132333435363738394041424344例题[Caioj1122](http://caioj.cn/problem.php?id=1122)## 匈牙利算法：ask[i]==true，表示这一轮中母牛i有匹配成功的可能性（每到一只新公牛t就要重置）我们每次尽量让公牛x（不一定是t）配对，那么当询问到母牛i时### ask[i]==true情况一、match[i]==0，直接成功情况二、match[i]&gt;0，之前有一只公牛y=match[i]， 尝试让y找其他母牛去匹配，从而调整搭配 在这过程中，这个公牛y以及之后为了搞定公牛y所需要调整的其他公牛y2、y3 都不能占用母牛i（先宣告主权，ask[i]=false），从而避免死循环，这是一个潜在的贪心， 递归回来之后假如一切顺利，则x也成功假如情况任意一个成功，匹配match[i]=x但无论如何，ask[i]=false（别急着问为什么，看下去先）### ask[i]==false（看文字前再明确一遍，配对公牛t时曾经询问过i）情况一、之前匹配成功了，然鹅，仔细想想，我们的递归结构中，只要有一次成功， 就全部成功了，那么x的配对就不会找到母牛i了，所里本情况不存在。情况二、之前匹配也就是调整失败，那么在同样情况下（ask没变也就是公牛t没变） 这一次必然也会失败，所以这时应当退出，达到剪枝省时的目的总而言之，当ask[i]==false时，退出即可## 决策单调性（好像语言组织得不是特别好）：为什么当情况二调整公牛y后成功则母牛i属于x，而不是x自己去再往后尝试？好吧严格而言这并不是一个证明：目前先凑合着，假如以后发生状况需要调整x时再调整疑点：“现在调整”和“满足现状”面对的状况可能不一样？解答：这应该是可行最大二分图匹配方案不唯一的一种体现吧，反正目前而言我们的目的是求出最大匹配数，所以具体方案没有关系## 加速：可以考虑运用邻接表（这条边通往的地方）和时间戳（这样就不用每次初始化ask数组）邻接表：话说这可是我们学最短路后立刻就学了的东西，适用于稀疏图时间戳：ask用int存储，如果比“当前匹配公牛编号t”小就是过时的，相当于false## 改造：解决多重二分图匹配问题[Optimal Milking](41bc.html)感觉意义不大……## 练习：[【Poj1325】Machine Schedule](7392.html)]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>原创精品</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-8-2-SAT]]></title>
    <url>%2Fposts%2Fef65.html</url>
    <content type="text"><![CDATA[差分约束题目直观版：Tag-2-SAT经典论文：由对称性解2-SAT问题 不错的入门教程：csdn-jarjingx（不得不说，超级良心！） 话说2-sat问题好像是有很多种解法的，但我比较喜欢tarjan 正经说细节 如果要固定，某一个变量必须取某个值可以用一条单向边连接，表示如果选择了非法值，会导致矛盾 如果题目要求输出方案在scc缩点以后，不难发现，因为是个dag任意时刻一定会有出度为0的点 明确：缩点以后，边的关系就是，如果选择则必须传递选择如果我每次选择一个之前没选择而且出度为0的节点，那么一定是无害的（不选择它就不一定了）此时把对立的节点（由原本的逻辑关系产生，一定只有唯一一个，否则应合并，因为只有二元）定为不选择那么因为搞的是出度=0，可以在反图上跑拓扑 不过还有一个性质，能省去代码复杂度，不需要建立反图因为tarjan求scc的时候，编号是自下而上的（不了解的请博客中搜索“简单连通性问题”）不难发现，对于两个上下的scc之间，下面那个编号小，恰好拓扑序也是在上面之前所以可以根据两个对立scc的编号，直接确定选择与否（编号小，就选择）相当优美简洁 练习Caioj1405聚会Poj3207Panda’s TrickBzoj1997PlanarPoj3683Priest John’s Busiest Day]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-7生成树]]></title>
    <url>%2Fposts%2Fb399.html</url>
    <content type="text"><![CDATA[生成树（MST）相关 最小生成树性质1：对于点集中的一个真子集a，其补集b连接a和b的边中，最小的为t，则必定在最小生成树中出现证明：设有某种最小生成树并不包含t，因为联通，总有一条边连接a和b替换为t后显然会更优，与【最小】相矛盾 性质2：设f(生成树)=最大边权则最小生成树一定有最小的f证明：设某个非最小生成树有更小的f，则总有一条边，和最小生成树的f的连通性贡献相同（连接a和b点集） 性质3：相同权值的边，对mst的贡献总是相同的也就是mst的边权序列总是相同的证明：设两个mst，边权序列（升序）最前的不同位置，设a中的e更小将e插入到b，形成了一个环，其中一定存在一条边 【权值&gt;e】（否则，因为e是第一个不同，更小意味着两棵树都有，则在a中形成环）显然是可以替换掉的，违背【都是mst】推论：【没有相同边权】的无向图，最小生成树唯一 性质4：连通图上，a到b【最长边最小】的路径，总是在kruskal生成的mst上证明：感受一下，显然很对首先，每个mst的贡献一定是一样的，这个很好推然后这个知道以后，反正一个非mst，会使当前mst变小，用类似前面的方法即可 kruskal并查集维护连通性，每次取最小的，连接两个森林的一条边时间复杂度$O(m log_2 m)$ prim维护一个树，开始只有一个节点1加入n-1次，每次选择【加入这棵树的代价】最小的那个点时间复杂度如果直接暴力是 $O(n^2)$ 的，如果加入二叉堆可以变成 $O(m log_2 n)$如果logm和logn相差不大的话，写kruskal，否则显得更傻所以说prim只适用于稠密图 练习自行搜索tag 有意思的变形CH6201 走廊泼水节]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>原创精品</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-6差分约束]]></title>
    <url>%2Fposts%2F62.html</url>
    <content type="text"><![CDATA[差分约束，就是要满足一定条件(形如ax-ay&lt;=c)求最值的问题。可以应用于求解不等式。 其实就是把数形结合起来入门教程自行搜索差分约束题目直观版：Tag-差分约束 入门练习Caioj1400差分约束1区间Caioj1401差分约束2国王Caioj1402差分约束3消息可靠吗Caioj1403差分约束4整数区间Vijos1094关系运算图Bzoj2330糖果]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-5网络流]]></title>
    <url>%2Fposts%2F5c7c.html</url>
    <content type="text"><![CDATA[难点就是构图也有各种变例决策类问题的法宝之一（还有贪心等） 有个不错的入门教程网络流-纳米黑客PDF 最大流解决方案Edmond-Karp 理论上界是 $nm^2$ ，但通常可以解决$10^3$ ~ $10^4$ 的规模 EK的缺点主要是，每次只找出一条增广路Dinic算法试图改进这一点 通过bfs得出残余网络中的分层图（显然是一个dag） 通过dfs得出增广路，回溯时更新流量3.理论上界是 $n^2m$ ，但通常可以解决$10^4$ ~ $10^5$ 的规模 特别地，对于二分图匹配，时间复杂度可以达到$O(m \sqrt n)$ 当前弧优化：当层次确定的时候，反向弧是否使用也是确定的那么如果一条边流完了，可以在边链表中去除（有点类似欧拉路径的优化）因为是层次图，不用担心 dfs 对第一个有效边数组的影响例题：order 最大流练习题目直观版：Tag-网络流 最大流：Caioj1115 Poj1273Drainage DitchesCaioj1116 Poj3281DiningCaioj1117 Poj2455 Bzoj1733Secret Milking MachineCaioj1118 Poj2112Optimal MilkingCaioj1119 Poj2391Ombrophobic BovinesCaioj1120 Poj3189Steady Cow Assignment 最小（割的容量）=最大流很规范的PPT最小割：Bzoj1934 Bzoj2768善意的投票&amp;冠军调查Bzoj1001狼抓兔子 51nod-1299师兄刚好给我看这题，但这道题我就不做了，好像正解不是最小割，会超时一半，我就说说最小割部分分的思路：原图中每个点拆为左点和右点，原图的边边权为无限，左点和右点之间的边边权为1从源点到犯人的左点连条边，从出口点的右点到汇点连条边，跑一遍最大流就是答案 非常好的题目：【TJOI2015】线性代数，写了题解 费用流 最小费用最大流是指满足源点流出的流量最大时，总费用最小的一个网络，模板都是基于此。最大费用最大流则是将所有的费用取负，然后再跑一遍最小费用最大流，将最终的最小费用取负就是最大流量下的最大费用了。最大费用可行流关注的是费用而非流量是否最大，暂时不会最小费用可行流没有意义 资料：窝嘞割草本质上其实就是把EK中bfs换成能处理边权的spfa（因为dinic无法处理，所以只有EK的衍生版） 题目：Tag-费用流 至于zkw费用流……jzq233jzqzkw 最大权闭合子图闭合子图：只进不出的子图，可用于处理依赖关系很容易贪心地想到，最优情况是所有正权点，但为了闭合要有所割舍 考虑有网络流决策，将点分成选和不选两种，用割的模型，以是否和S联通来标识则S向所有正权点连边，边权为点权，所有负权点向T连边，边权为点权的绝对值割后，设选的点集为A，不选为B，根据点权正负细分，如图所示：如果x依赖y，则选x就要选y，此时从x到y连接一条INF的边，标识不可【选x不选y】注意一个细节（因为我这菜逼一开始忽略了）：这条边是允许选y不选x的，因为那种情况没有造成联通 此时只要是个合法的割，A一定是一个闭合子图，现在要最大化它显然割=B1-A0，而A=A1+A0故A+割=A1+A2=正权和，让割最小化即可]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-4简单连通性问题]]></title>
    <url>%2Fposts%2F293.html</url>
    <content type="text"><![CDATA[简单连通性问题，应该算比较全面了tarjan算法无向图与有向图致敬：维基百科Robert_Tarjan 无向图连通图割点：删去该点和相关的边后，分裂为两个或以上子图桥或割边：删去该边后，分裂为两个或以上子图 tarjan算法dfn表示时间戳low表示所有【子树内节点，能通过一条非搜索树边到达子树内的节点】的最小dfn 割点和割边的判定无向边x-&gt;y是割边，当且仅当搜索树上存在x和y，满足 $dfn_x &lt; low_y$含义就是，y无法通过其他方式到达比x更早的点显然割边一定是搜索树上面的为了也能兼容有重边的情况，可以考虑通过记录来到这里那条边的编号来判断是否是搜索树边 对于割点，当x不是根节点时，仅当搜索树上存在x的子节点y，满足 $dfn_x \leq low_y$但当x是根节点的时候，则更简单，即x要有至少两个儿子节点 双联通分量点双联通分量（v-DDC，又有一个经常被误用的名字：块）：无向图中，极大无割点联通子图显然任意两个点，都同时在至少一个简单环中求法和缩点：并不是去掉所有割点！割点可能同时存在多个v-DCC中维护一个栈（仅第一次访问才放入），当x和y满足割点判定条件（不管x是不是根节点），将顶部到y间的元素弹出，再强行加入一个x，作为v-DDC（不难发现x还在里面，以后可能会被取出）另外，孤立点也是v-DDC缩点的时候，要新建割点个数（分配新编号，指向所有包含自己的v-DDC）的点，是一棵树（或森林）原理：因为满足条件，去掉x无法导致y内分裂，而一定不存在内部有割点的情况，否则在前面就弹出了 边双联通分量（e-DDC）：无向图中，极大无割边联通子图显然任意一条边，都同时在至少一个简单环中求法和缩点：去掉所有割边，剩下的就是边双联通图把每个边双联通图缩成一个点，用割边连起来，就形成一棵树（或森林） 欧拉通路从s到t，经过每条边恰好一次判定：联通图无向图：【度数=奇】=0时，其实是欧拉回路；【度数=奇】=2时，一个起点一个终点有向图：【入度!=出度】=0时，其实是欧拉回路；【入度!=出度】=2时，【入度=出度-1】是起点，【入度=出度+1】是终点 欧拉回路欧拉回路：从s出发，回到s的欧拉通路 性质：如果原本是欧拉回路，拿走一个小欧拉回路（包括一个点），依然是欧拉回路 判定：联通图无向图：每个点度数=偶有向图：每个点入度=出度 无向图输出方案：从任意点出发，前往没有去过的边最后停止的时候一定会回到原本的点但可能漏了一些环，所以要在回溯的时候向其他分支走，然后作为一个插入但是直接插入会非常不方便，所以回溯的时候才把x（或者边）入栈，得出倒过来的路径 这样的时间复杂度较高，因为会多次尝试询问每一条边一种优化是，每次邻接表把用过的剔除掉，因为不可逆，时间降到n+m但此时空间搜索深度复杂度为m，即使linux也会爆（详见理论知识-概要），建议手写栈 模板题：uoj117 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=110000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int op; int hou[MAX_N],dg1[MAX_N],dg2[MAX_N]; struct Edge &#123; int y,g; &#125;e[MAX_N*4]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; bool v[MAX_N*2]; vector&lt;int&gt; ans; void euler(int x)//n+m &#123; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int tmp=(op==1?(k+1)/2:k); if(v[tmp]) hou[x]=e[k].g; else &#123; v[tmp]=1;euler(e[k].y); if(op==1) ans.push_back(k&amp;1?(k+1)/2:-k/2); else ans.push_back(k); k=hou[x];//被极限自环卡…… &#125; &#125; &#125; int sz; void col(int x)//n+m &#123; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int tmp=(op==1?(k+1)/2:k); if(!v[tmp]) &#123; v[tmp]=1,sz++; col(e[k].y);k=hou[x]; &#125; else hou[x]=e[k].g; &#125; &#125; int xx[MAX_N*2],yy[MAX_N*2]; void main() &#123; scanf("%d",&amp;op); int n,m;scanf("%d%d",&amp;n,&amp;m); if(m==0) &#123;puts("YES");return;&#125; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;xx[i],&amp;yy[i]); ins(yy[i],xx[i]); if(op==1) ins(xx[i],yy[i]); dg1[xx[i]]++;dg2[yy[i]]++; &#125; int cc=0,st=1; for(int i=1;i&lt;=n;i++) &#123; sz=0;col(i); if(sz&gt;0) cc++,st=i; &#125; if(cc&gt;1) &#123;puts("NO");return;&#125; for(int i=1;i&lt;=n;i++) &#123; if(op==1 and (dg1[i]+dg2[i])%2==1) &#123;puts("NO");return;&#125; if(op==2 and dg1[i]!=dg2[i]) &#123;puts("NO");return;&#125; &#125; memset(v,0,sizeof v); ln=0;memset(hou,0,sizeof hou); for(int i=1;i&lt;=m;i++) &#123;ins(yy[i],xx[i]);if(op==1) ins(xx[i],yy[i]);&#125; euler(st); puts("YES");for(int i=0;i&lt;=(int)ans.size()-1;i++) printf("%d ",ans[i]); &#125;&#125;;int main()&#123; mine::main();&#125; 混合图欧拉路判定：【Poi2010】Bridges 无向图的独立集和团独立集：任意两点间没有边相连团：任意两点都有一条边相连 定理1：最大团大小=补图（对于边集的补集）的最大独立集大小定理2：见套路集锦中二分图项目 有向图流图只要有任意起点满足能到达每个节点该点被称为源点 有四种类型的边： 搜索树边 前向边，搜索树中x是y的祖先 后向边，搜索树中y是x的祖先 横向边，搜索树中，谁也不是谁的祖先，因为不是树边，一定满足$dfn_y &lt; dfn_x$ 强连通强连通图：其中任意两点都能互相到达的图强连通分量(SCC)：有向图极大强连通子图 tarjan算法找scc：首先，前向边没有贡献，后向边有贡献，而横向边看其能否贡献出一条路径，从y能回到x的祖先为了利用后向边和横向边，需要维护一个栈，保存【x的祖先】和【子树内能前往x的祖先的的点】追溯值low：【在栈中，而且能够从x的子树内出发被到达的节点】的最小dfn 那么具体实现的时候 加入栈中 遍历所有边，如果没访问过就是子树内节点，递归；否则判断是不是栈中的节点，有两种可能【祖先】或者【在子树内并且能前往祖先的】这两个的dfn恰好是我们想要的（为什么这么恰好待会解释） 判断是否 $low_x = dfn_x$ ，若是，意味着没有节点能访问祖先，则弹出栈中节点直到x被弹出 之所以在栈中没有【在子树内而不能前往祖先的】，是因为这些节点已经出栈，作为其他scc的一部分了 对于能到祖先的点，显然不会满足等于自己这个条件，应该交给那个祖先去处理，所以在栈中保留 那么，对所有scc缩点后，就会得到一个dag（有向无环图） 必经点、必经边从s到t，所有路径上都存在的点必经边也类似 在普通有向图上求据说要使用支配树不过在一个有向无环图上，可以用拓扑统计到这里的路径数量，再跑一次反图那么枚举每个点，或者边，根据乘法原理检验即可但是数字可能太大，可以考虑搞点模数来校验 至于无向图就比较简单了，可以用相应的dcc去缩点 有向无环图的最小路径点覆盖简称最小路径覆盖，就是用最少数量的简单路径，覆盖每个点恰好一次解决方法：分析题意，因为点只能覆盖一次，对于路径上面的点，入度和出度不能超过1，而且至少一个是1把每个点，拆分成入度点和出度点，那么就形成了一个二分图，按照原图的边来构图即可 【最少路径数量】=【最少的终点】=【最少的出度=0】=【最少的出度点失配】所以数量就是n-最大匹配当然，用起点也可以，入度为0也就是右边的无匹配，不影响柿子 那么如果允许多次覆盖相同的点呢？这就是最小路径可重复点覆盖问题整个问题可以说变复杂了，也变简单了对于联通的两个点x和y，其实是可以直接添加一条边的，对答案没有影响这个可以用传递闭包实现 竞赛图每个点对之间，都有一条有向边相连，只是方向任意 定理：一定存在哈密顿路径证明与构造：考虑原本存在的一条路径，然后外面存在一个点P最优情况（直接放到头或者尾）下显然，而如果是这种比较坏的情况： 定理：如果图强连通，则存在哈密顿回路证明与构造：先将哈密顿路径拉出来同样，设此时1-&gt;x已经形成回路，考虑x+1e 如果 $x+1-&gt;1$ ，直接加入 如果 x+1能到环内部，则也可以加入 否则暂时跳过 练习自行搜索tag]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-3最近公共祖先]]></title>
    <url>%2Fposts%2Fdc4.html</url>
    <content type="text"><![CDATA[最近公共祖先的四种求法 倍增lca时间复杂度 预处理nlogn+询问logn其实也没什么好说的，结合代码注释吧1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//Zory-2017//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=100000,MAXM=200000;//*******************全局定义*******************struct pt&#123; int dep,hou;&#125;p[MAXN+10];struct rod&#123; int y,g;&#125;e[MAXM+10];int bin[31];//*******************实现*******************int ln=0;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;int f[MAXN+10][31];void dfs(int x,int fa)&#123; f[x][0]=fa;p[x].dep=p[fa].dep+1;//dep=bin[i]时只有f[x][i] for(int i=1;bin[i]&lt;=p[x].dep;i++) f[x][i]=f[f[x][i-1]][i-1]; for(int k=p[x].hou;k&gt;0;k=e[k].g) if(e[k].y!=fa) dfs(e[k].y,x);&#125;int LCA(int x,int y)&#123; if(p[x].dep&lt;p[y].dep) swap(x,y); for(int i=30;i&gt;=0;i--) if(p[x].dep-p[y].dep&gt;=bin[i]) x=f[x][i];//从高向低消除差距 if(x==y) return x;//y是x祖先 for(int i=30;i&gt;=0;i--) if(p[x].dep&gt;=bin[i] and f[x][i]!=f[y][i])//防止跳过头 x=f[x][i],y=f[y][i];//一起向上跳 return f[x][0];&#125;//*******************主函数*******************int main()&#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; int n,m;scanf("%d%d",&amp;n,&amp;m);ln=0; for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; dfs(1,0); while(m--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); printf("%d\n",LCA(x,y)); &#125;&#125; 树剖lca时间复杂度 预处理n+询问logn就是树剖跳tp的fa实现不太常用，适用于已经打了树剖的情况 ps：其实树剖是在线算法中最快的因为log是最坏情况下的复杂度 tarjan+并查集 lca时间复杂度 预处理n+询问1这属于离线算法 对于每个点，三种标记，0表示没访问过，1表示访问过但没有回溯（x和x的祖先）2表示访问且回溯过那么对于x的每个询问（可以建立链表去枚举），如果y是1，则lca=y如果y是2，则y向上的第一个【标记1】的节点就是lca 然后每次回溯的时候，把自己的块合并到父亲的块中这就相当于把第一个【标记1】的节点指向父亲那么每个询问的答案即findfa(y) st表lca用st表存储编号，预处理后即可O(1) 练习Caioj1236模版Caioj1237树上任意两点的距离]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-2并查集]]></title>
    <url>%2Fposts%2Fa89d.html</url>
    <content type="text"><![CDATA[3.3.1定义并查集，顾名思义就是有“合并集合”和“查找集合”两种操作的关于数据结构的一种算法。 用途1、维护无向图的连通性。支持判断两个点是否在同一连通块内，和判断增加一条边是否会产生环。2、用在求解最小生成树的Kruskal算法里。 初始化自己是自己的老大 3.3.2 代码1234567891011121314151617181920找老大：int findfa(int x)0&#123; if(fa[x]==x) return x; return fa[x]=findfa(fa[x]);&#125;合并：void join(int x,int y)&#123; int fx=findfa(x),fy=findfa(y); if(fx!=fy) fa[fx]=fy;&#125;检测环：for(int i=1;i&lt;=边数;i++)&#123; int q=findfa(b[i].x); int w=findfa(b[i].y); if(q==w) return 1;//如果在一个集合，就找到了环 join(q,w);&#125; 3.3.3 进阶练习魏总数星星星球大战 3.3.4 所有题目Tag-并查集 拓展进阶上文用到的合并方法叫做路径压缩，均摊log另外有种优化方法叫“按秩合并”，也是启发式合并的一种应用就是每次把小的合并到大的里面，在这里可以用大小来表示那么均摊也是log 然后如果两者合并，根据tarjan的论文证明，总是小于5的]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-1最短路]]></title>
    <url>%2Fposts%2F8720.html</url>
    <content type="text"><![CDATA[最短路 SPFA以下内容更新于2018.8.29spfa的时间复杂度为 $O(km)$在稀疏图上，k很小，但在稠密图上，有可能被卡成 $O(nm)$ 介绍两个优化策略，通常来说能稍微提高效率（似乎来自JBY09年集训队论文）SLF（Small Label First）优化（本机房俗称酸辣粉优化）：基于双端队列（deque）的思想，更新完disy后，如果它比队头小，就放在前面，否则放在后面然后如果没有负权边，可以用个堆取最小值，即堆优化spfa，但这个是没有任何意义的，spfa的唯一一点点优势就是负权边，现在这样搞，那不如写dijkstra堆优化（其实单纯写法上只是标记是否清空而已）LLL（Large Label Last）优化（本机房俗称啦啦啦优化）：维护队列的平均值，如果队首比平均值小，就丢到后面去总的来说，这两个优化策略的基本思路就是不用堆，保持能处理负权边的特性，但是又能尽量取出小的节点去拓展 最后，对于判断负权回路：bfs，一个点进入队列n次，或者记录每个节点当前最短路径的边数，超过n则跳出，通常会更快一些dfs，进入一个已经在栈中的节点，但听说可以被卡到 $2^n$ Dijkstra在无负权的图中，找最短路可防止被卡边（spfa容易被卡）时间复杂度相对没那么玄学，比较稳定（如果慢，那就真的慢） dijkstra算法基于贪心思想，每次找最小的dist来更新这是因为，当边长都是非负数的时候，全局最小的那个dist显然不会再被更新，所以已经是最短路径堆优化就是在找最小的dist的时候，用堆维护，时间复杂度从 $O(n^2)$ 变成 $O(mlogn)$ floyd这个算法用于求所有点对的最短距离，时间复杂度为O(n^3)。【无法判断、计算含有负环的图】依次扫描每一点(k)，并以该点作为中介点，计算出通过k点的其他任意两点(i,j)的最短距离，这就是floyd算法的精髓！同时也解释了为什么k点这个中介点要放在最外层循环。其实就是运用动态规划的思想。 代码12345678910void floyd()&#123; memset(dis,127,sizeof(dis)); for(int i=1;i&lt;=n;i++) dis[i][i]=0; for(int k=1;k&lt;=n;k++)//中介点 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);&#125; up 2018.8.29floyd的正确性证明：设$dis[k][i][j]$表示只经过编号小于k的点，从i到j的最小距离那么对于任意一条最短路径，可以想象为分割的，然后以k为阶段，长度递增，逐渐合并具体实现的时候，只要把k放在外面，就可以通过滚动数组，省去第一维 找无向图最小环：加入一句1ans=min(len[i][j]+dis[i][k]+dis[k][j]); 即可韵味自行理解其实就是假设这个环，编号最大那个为k不过要注意一点，就是要针对实际需求，看要不要打上i!=j等三个条件例题：poj1734 Sightseeing trip 然后无向图的话，因为两个点也能组成（甚至一个点）所以不需要对环的大小作限制，可以直接扫一次dis[i][i]例题：vijos1423123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=210; const int INF=0x3f3f3f3f; int w[MAX_N]; int dis[MAX_N][MAX_N]; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]); memset(dis,63,sizeof dis); while(m--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c);c+=w[x]; if(c&lt;dis[x][y]) dis[x][y]=c; &#125; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(dis[i][j]&gt;dis[i][k]+dis[k][j]) dis[i][j]=dis[i][k]+dis[k][j]; printf("%d ",dis[1][1]==INF?-1:dis[1][1]); &#125;&#125;;int main()&#123; mine::main();&#125; 当然如果跑dijkstra+heap把起点更新后，d[st]=正无穷，下一次取出也是最小环长度 Johnson全源最短路感觉挺偏的，拓展一下视野吧应用于有负权边的情况，且点相对稀疏（相比floyd）思路是把图转化为等效的图，那么我们希望最短路集不变从超级源点向各点连0边，先跑一次spfa，得到f表示最短路（显然为非正数）然后转化图，对于边x-&gt;y=z，显然： $z-(f[y]-f[x]) \leq 0$在新的图上跑n次dij每条路径长度为 $dis(st,ed)+f(st)-f(ed)$]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-21其他]]></title>
    <url>%2Fposts%2F774f.html</url>
    <content type="text"><![CDATA[瞎jb汇总 二项式反演$$f_n = \sum_{i=0}^n {n \choose i} g_i \Leftrightarrow g_n = \sum_{i=0}^n (-1)^{n-i} {n \choose i} f_i$$证明 min-max 容斥这东西好像不是出现在国家集训队论文里面的，可能嫌简单？也不知道是谁想到的，挺妙的 若用值大小定义元素大小$max(S)=\sum_{T\subseteq S}(-1)^{|T|-1}min(T)$证明：考虑存在容斥系数（这步操作是最骚的）$max(S)=\sum_{T \subseteq S} g(|T|) min(T)$考虑第x+1大的元素被统计的次数$f(n)=[n==0]=\sum_{i=0}^n C_n^i g(i)$二项式反演一下$g(n)=\sum_{i=0}^n (-1)^{n-i} C_n^i f(i)=(-1)^n$ 然后这种东西乍一看没什么用，但注意到推广性很强，而且有些东西的max很难求，min却很容易例如用出现的先后定义元素大小，那么max期望，感觉都不知道怎么算……套这个就很爽了推荐：按位或，写了题解 因为其十分良好的拓展性，这东西还可以求第k大自己推推柿子，得到 $g(n)=(-1)^{n-k+1} C_n^{k-1}$推荐：重返现世，写了题解]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-20多项式其他操作]]></title>
    <url>%2Fposts%2Ff502.html</url>
    <content type="text"><![CDATA[多项式其他操作 求逆元这里的逆元不是系数在模意义下（ntt），而是限制次幂： $\mod x^n$然后系数在实数下或者模意义下都行还有感觉这东西的思路清奇，难以直接思考得到，但容易证明正确性 根据逆元的定义$A(x)B(x)=1 (\mod x^n)$然后现在已知A求B，假设存在B2$A(x)B_2(x)=1 (\mod x^{\lceil \frac{n}{2} \rceil})$显然有$A(x)B(x)=1 (\mod x^{\lceil \frac{n}{2} \rceil})$两个式子相减$B_2(x)-B(x)=0 (\mod x^{\lceil \frac{n}{2} \rceil})$通过平方来得到当前的模数（长度限制），并同时乘以A，整理可得$B(x)=2B_2(x)-A(x)B_2^2(x) (\mod x^n)$ 感觉这东西的思路有一点像第一类斯特林数的单log求法， $T(n)=T(n/2)+nlogn=nlogn$然后如果在数论意义下，不难看出一个多项式存在逆元当且仅当其常数项存在逆元例题：bzoj3456 （带余）除法、取模定义： $\begin{equation} \label{div0} A(x) = D(x)B(x) + R(x) \end{equation}$设A的度为n，B为m，则D为n-m，R为m-1 然后我们定义一个骚操作，考虑对于一个度为k的多项式T， $x^k T(\frac{1}{x})$ 等价于系数反转$A^r(x)=D^r(x)B^r(x)+x^{n-m+1} R^r(x)$强行模意义，而且不会影响到D$D^r(x)=A^r(x) \times inv( B^r(x) ) (\mod x^n-m+1)$然后用定义求R即可 泰勒展开、麦克劳林级数泰勒展开（f上面的数字指第几阶导数）： $f(x)=\sum_{i=0}^n \frac{f^i(a)}{i!}(x-a)^i+\xi$不错的教程然后麦克劳林级数是泰勒展开在a=0时的特殊情况应用例子： $众所周知e^x的导数为其本身，则e^x=\sum_{i=0}^{\infty} \frac{x^i}{i!}$]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-19集合幂级数]]></title>
    <url>%2Fposts%2F8434.html</url>
    <content type="text"><![CDATA[集合幂级数学习笔记（vfk在15年的论文） 集合幂级数 $f=\sum_{S \subseteq 2^U} f_S x^S$然后对于乘法，不同的运算符有具体的不同操作集合并卷积：FMT，基本上就是对子集求和，便于或和与运算集合对称差卷积：注意到 $\frac{1}{2^n} \sum_{T \subseteq 2^U} (-1)^{|T|}=[T=\emptyset]$定义FWT，$f_2s=\sum_{T \subseteq 2^U} (-1)^{|T|} f_T$然后你化一波柿子，发现就是就是两边FWT，相乘后UFWT（可以只写一个函数），最后除以 $2^n$ （中间除也行，这个除以二意味着不能在2没有逆元的域下使用） 上面这两个东西，做除法的前提都是系数不能为0写的话，一般非递归，考虑首位是0还是1即可推导出来 子集卷积：或为S并为空，相当于两个不重叠集合的拼接，感觉不少状压都是这种形式将条件转化为 $a|b=S,|a|+|b|=|S|$可以看作是一个集合幂级数的或运算套一个形式幂级数的乘法，暴力枚举做即可，但要去除没有意义的地方当然转化为集合对称差也没有问题 下文是在看论文之前瞎学的东西 FWT定义A和B都是长度为2的整数次幂长度的【多项式】，按下标分A0和A1，表示二进制最高位定义 $+、-、\times$ 运算，表示按下标定义运算A@B表示以@为运算符，卷积起来$(A@B)[k]=\sum_{i@j=k} A[i] \times B[j]$然后用 $\bigstar$ 表示拼接 或运算@=or好像也叫FMT？$A’i=\sum{j \subseteq i} A_j$考虑分治显然FWT为 $A’=(A_0’) \bigstar (A_0’+A_1’)$然后乘法分配律 $C’=A’ \times B’$然后可以根据容斥（直接利用FWT的式子倒过来也行）推导IFW$C=(C_0) \bigstar (C_1-C_0)$时间为 $O(nlogn)$ 与运算@=and好像也叫FMT？和上面的推导类似，但FWT构造出超集$A’=(A_0’+A_1’) \bigstar (A_1’)$$A=(A_0-A_1) \bigstar (A_1)$时间为 $O(nlogn)$ 异或运算@=xor这个我还不会推导但同样是考虑分治$A’=(A_0+A_1) \bigstar (A_0-A_1)$逆运算都是倒过来即可 $A=(\frac{A_0+A_1}{2}) \bigstar (\frac{A_0-A_1}{2})$时间为 $O(nlogn)$ 异或的证明 子集卷积$C_k=\sum_{i|j=k,i \&amp; j=\varnothing} A_i \times B_j$巧妙地加多一维表示二进制下1的数量，然后数量对不上的就是0$C_{popcount(k),k}=\sum_{i|j=k} A_{popcount(i),i} \times B_{popcount(k)-popcount(i),j}$我们额外花费 $log^2 n$ 的时间枚举两个popcount，然后做完后可能k和popcount对不上，删除为0即可 总结子集卷积中用到的思想还是非常不错的，应该具有一定的推广意义所以即使是完全不同的运算符，可以尝试用上述基本运算符组合起来，并考虑套上去 FWT和FFT在处理问题的方式上都非常相似，通过构造一个更便于计算的表达，再通过分治解决问题]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-18群论]]></title>
    <url>%2Fposts%2F73b8.html</url>
    <content type="text"><![CDATA[群论入门（不知道算不算数论） 推荐不错的教程：annoyraindebug18 纯定理Burnside引理设置换f下，有C(f)个在f下保持不变的方案则总的本质不同的等价类数量有 $\frac{\sum_{f \in G} C(f)}{|G|}$ 个 然后，对了更快地解决问题，再找找C(f)的性质为了保证怎么置换都不变，对于每个循环，内部元素都应该一样，故当颜色为k时，得到Pόlya定理：$\frac{\sum_{f \in G} k^{循环数量} }{|G|}$ 例题luogu模板循环节的长度= $lcm(n,a)/a$循环的数量= $n \times a/lcm(n,a)=gcd(n,a)$$ans=\frac{1}{n} \sum_{a=1}^{n-1} n^{gcd(n,a)}$那么枚举gcd，dfs顺便求个phi即可（用vector求好根号内次幂即可），因为约数量在2000内，时间为 $O(1000^2 log n)$]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-17生成函数]]></title>
    <url>%2Fposts%2F7abd.html</url>
    <content type="text"><![CDATA[生成函数，又称母函数 不错的教程：SamjiaPoPoQQQ x的值没有意义，所以如果能我们总是假设其收敛 一般生成函数OGF然后这东西的变换 $f’(x)=\frac{1}{(1-x)^k}$ 很像是k维前缀和？然后其具体数列为 $\sum C_{i+k-1}^{k-1} x^i$证明： 考虑其组合意义，相当于将i分为k个非负数 求导的直观改变：左移一位，然后每个位置乘以其下标例子： $g1,2g2,3g3….$ 一般利用收敛简化组合意义 指数生成函数EGF即对象是带编号的$$\begin{aligned}F(x) \centerdot G(x) &amp;= (\sum\limits_{i = 0}^{\infty} a_i \frac{x^i}{i!})(\sum\limits_{i = 0}^{\infty} b_i \frac{x^i}{i!}) \\&amp;= \sum\limits_{n = 0}^{\infty} (\sum\limits_{i = 0}^{\infty} \frac{a_ix^i}{i!} \centerdot \frac{b_{n - i}x^{n - i}}{(n - i)!})x^n \\&amp;= \sum\limits_{n = 0}^{\infty} (\sum\limits_{i = 0}^{\infty} {n \choose i} a_i b_{n - i}) \frac{x^n}{n!}\end{aligned}$$然后一般存储的是 $\frac{A_n}{n!}$ ，直接乘法]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-16博弈]]></title>
    <url>%2Fposts%2Fc7bb.html</url>
    <content type="text"><![CDATA[博弈（勉强放在数论里面吧） 有向图游戏在一个DAG中，只由一个起点，上面有一个棋子，两个玩家轮流沿着有向边推动棋子，不能走的玩家判负P为必败点，N为必胜点 公平组合游戏ICG 两个玩家交替行动 能执行的操作与具体玩家无关 不能行动的玩家判负 mex运算与SG函数进定义mex为，非负整数集合S中，最小的不属于集合S的非负整数 对于状态x，有k个后继状态y$SG(x)=mex( { SG(y_1),SG(y_2)…SG(y_k) } )$ 而对于多个有向图游戏，定义有向图游戏的和为，它们sg(起点)的异或和定理：有向图游戏的某个局面必胜，当且仅当其对应节点，sg函数值大于0（能到达必败终点）例题：数学 斐波那契博弈有一堆石子共有N个A B两个人轮流拿，A先拿。每次拿的数量最少1个，最多不超过对手上一次拿的数量的2倍（A第1次拿时要求不能全拿走）。拿到最后1颗石子的人获胜结论：先手必胜，当且仅当 原本的石子数量为斐波那契数 巴什博弈 Bash Game直接套sg，不难发现sg=tot%(m+1) NIM博弈n堆物品，每堆有ai个，两个玩家轮流任选一堆来取物品，但不能不取，取走最后一个物品者获胜（不能取的玩家判负）不难发现NIM博弈是由n个有向图游戏组成的 定理：先手必胜，当且仅当sg异或和 $\neq 0$证明可用数学归纳法，从游戏结束开始分析，每次给对面一个平衡状态（异或和=0） 拓展 Nimk，即同时取k堆（可以不同）这个挺神奇的，就是每一位sum%(m+1)=0 阶梯博弈，每次把某个阶梯上若干个石头往下一个阶梯移动首先，不要考虑石子，而是考虑隔板的前移，那么石头相当于相对距离把两个隔板两两捆绑（奇数个的时候，把第 1 个和边界 0 捆绑）所以如果不考虑奇数的移动情况，就是一个 nim 游戏所以对于先手，如果他是赢家，一定按照 nim 来这个时候如果后手突然移动奇数，那么先手把偶数等距离向前移动，就能还原出相同局面，而且一定能实现而如果先手是输家，那么和上面同理无法改变结局 最后bibi几句其实研究这几个博弈有点伤感如果你感性理解而非利用sg，你会发现，这些游戏还没开始就被注定了结局……]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-15-Lucas及其拓展]]></title>
    <url>%2Fposts%2Fbb31.html</url>
    <content type="text"><![CDATA[Lucas及其拓展 Lucas条件：Mod是素数公式：$C_n^m=C_{n/Mod}^{m/Mod} \times C_{n \mod Mod}^{m \mod Mod} (\mod Mod)$证明 拓展Lucas 一阶条件：Mod是素数的次幂，即$Mod=p^k$ 做法： 根据组合数公式，如果能求出$n! \mod p^k$，那么就能计算出其值 因为是阶乘，把它表示出来$1 \times 2 … Mod … 2Mod … 3Mod … tMod … n$然后，因为我们要求逆元，必须保证与Mod互质，所以要先把p的倍数全部提出 $$(1=&gt;Mod-1) \\(Mod+1=&gt;2 \times Mod-1) \\… \\((t-1) \times Mod+1 =&gt;t \times Mod-1) \\t \times Mod+1 =&gt; n【上述都要跳过p的倍数】$$$p^t \times (1=&gt;t)=0$然后p的倍数，除了这个t次方的部分，其他除以p后是一个阶乘，可以递归处理 那么每个括号在模意义下，值是一样的，所以递归下去就好了，后面那个括号也是递归下去就好了唯一要在里面处理的就是暴力枚举从$t \times Mod+1到n$，看做是Mod的复杂度总之，这个复杂度是$O(Mod)$ 等阶乘和逆元处理完后，处理p的倍数那么因为一定能整除，可以用logn分别求出上和下次数，然后相减得出次数，最后带模快速幂一下就好了求次数的做法在阶乘分解中提到过 拓展Lucas 二阶条件：无对于一个更为一般的Mod，将其分解因式$Mod=p_1^{k_1} \times p_2^{k_2} … \times p_t^{k_t}$ 然后我们要用到中国剩余定理CRT你可能会问，这东西不是能被exgcd完美替代吗？我们其实是要用一下它的形式，而不是仅仅是解方程 把其答案和方程组对调，发现变成了【左边都一样，右边从一个大模数A拆分成多个小模数A’】我们现在想要求出组合数x在大模数下的值，把大模数拆分为多个互质的小模数这样子就得到了多个线性同余方程组，而在小的方程中，因为模数小，许多操作（如预处理逆元等）都便利许多 回归正题，对于每个小的同余方程，调用【拓展Lucas 一阶】即可 例题：礼物]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>Lucas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-14多项式乘法]]></title>
    <url>%2Fposts%2F4db.html</url>
    <content type="text"><![CDATA[快速傅里叶变换(Fast Fourier Transform),简称FFT快速数论变换(Fast Number-Theoretic Transform),简称NTT或者FNT以前的文章太sb了，已删除 fft前置知识： 复数，由实数和虚数（单位为i）组成 欧拉公式 $e^t=cos(t)+sin(t) i$ 单位复数根 $\omega_n^k = e^{ 2 \pi \frac{k}{n} }$可见， $(\omega_n^k)^2=(\omega_n^{k+n/2})^2$ 解决的主要问题：多项式乘法设最高次项为n，则暴力为 $O(n^2)$在系数为实数域下，借助单位复数根的性质优化复杂度为nlogn 思路：将多项式看作函数从函数的系数表达法 求值 为点值表达法，最高次为n的函数，至少需要n+1个点确定（倍数点的存在）点值表达法的两个函数相乘，时间为n（相同x，x不变，y相乘）从点值表达法 插值 为系数表达法（降低为nlogn） 分治：对于 $T(x)=\sum a_i x^i$将其奇偶分离，$T(x)=A(x^2)+x \times B(x^2)$其中A为偶数，多项式长度减半，但变成两个然后因为平方相同，联想到单位根的性质，不妨将其作为x来代入所以对于当前需要带入的n个，只要带入前面n/2个即可那么根据主定理可知其复杂度为 $nlogn$ ，如果不太懂可结合code因为需要完整地分治，所以要补0直到长度为2的次幂 然后插值的话，结论是将单位 $\omega_n^1变为 \omega_n^{-1}$ ，然后退出时将结果除以n证明见毛啸在2016发表的集训队论文，非常简洁 实现：递归版因其空间开销即常数巨大，很少使用如果每次都是将奇数位（次幂为偶数）放在前面，则最后奇偶分离的结果下, $num[i]=a[二进制翻转(i)]$1234567891011121314151617181920212223242526272829303132333435363738394041424344const double PI=acos(-1);const int MAX_N=4*110000;struct Cp&#123; double a,b; Cp(double c=0,double d=0) &#123;a=c,b=d;&#125; Cp operator + (Cp t) &#123;return Cp(a+t.a,b+t.b);&#125; Cp operator - (Cp t) &#123;return Cp(a-t.a,b-t.b);&#125; Cp operator * (Cp t) &#123;return Cp(a*t.a-b*t.b,a*t.b+b*t.a);&#125;&#125;;struct Fft&#123; Cp w[MAX_N]; void getw(int n,int f) &#123; for(int i=0;i&lt;n;i++) w[i]=Cp(cos(PI*2*f*i/n),sin(PI*2*f*i/n)); &#125; int R[MAX_N]; void pre(int n) &#123; int lg=log2(n); R[0]=0;for(int i=1;i&lt;n;i++) R[i]=(R[i&gt;&gt;1]&gt;&gt;1)+((i&amp;1)&lt;&lt;(lg-1)); &#125; void solve(Cp *a,int n,int f) &#123; for(int i=0;i&lt;n;i++) if(i&lt;R[i]) swap(a[i],a[R[i]]); for(int ln=1;ln&lt;=n/2;ln&lt;&lt;=1)//合并前 &#123; getw(ln*2,f); for(int st=0;st&lt;n;st+=2*ln) for(int k=0;k&lt;ln;k++) &#123; Cp x=a[st+k],y=w[k]*a[st+ln+k]; a[st+k]=x+y;a[st+ln+k]=x-y; &#125; &#125; &#125;&#125;fft;void FFT(Cp *a,Cp *b,Cp *c,int ln)&#123; fft.solve(a,ln,1);fft.solve(b,ln,1); for(int i=0;i&lt;ln;i++) c[i]=a[i]*b[i]; fft.solve(c,ln,-1);for(int i=0;i&lt;ln;i++) c[i].a/=ln;&#125; 拆系数fft暂时只会7次的，就是设 $m0=\sqrt M$ ，然后带余除法一下，展开成4个多项式DFT后，合并起来，然后外面系数相同的有3种，IDFT共3次，然后再把系数还原samjia的例子：【CF553E】Kyoya and Train，写了题解 ntt超赞的教程笔记：当p为素数，存在其原根g，使得 $g^0,g^1,… g^{p-2}$ 互不相同然后因为我们需要分治，同样希望能按2分解，所以p的形式必须为 $t \times 2^k+1$ ，然后能处理 $n \leq 2^k$ 的数据设 $g_n=g^{(p-1)/n}$然后通过各种方式可证明其满足我们用到的单位复数根的各种性质原根表最常见：998244353、1004535809是3的原根 常数优化还是推荐看毛啸的论文，非常多卡常技巧 DFT补充一下这个，因为有些时候是不能分治的，因为需要求自动的循环卷积（之所以这么说，是因为通常可以手动循环卷积，不过例如在快速幂里面就会多个log和大常数）首先DFT是个循环卷积，只不过因为通常情况下，我们的n都是到2的次幂，是个线性卷积有个性质(应用于复数根和原根)： $\frac{1}{k} \sum_{i=0}^{k-1} g_k^{ni}=[n\%k=0]$ 把柿子的简化版放在这里，完整版还是看mx的吧$$\begin{aligned}C_r=&amp; \sum [(p+q) \% n=r] a_pb_q\\=&amp; \frac{1}{n} \sum_{k=0}^{n-1} (w^{-r})^k \times (\sum (w^k)^p a_p ) \times (\sum (w^k)^p b_q )\\&amp;所以我们就能得到DFT和IDFT的柿子\\a_m&amp;=\sum_{k=0}^{n-1} (w^m)^k b_k\\c_m&amp;=\frac{1}{n} \sum_{k=0}^{n-1} (w^{-m})^k d_k\\\end{aligned}$$于是就可以全自动了，虽然是n方的]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>fft</tag>
        <tag>ntt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-13莫比乌斯]]></title>
    <url>%2Fposts%2Fd81d.html</url>
    <content type="text"><![CDATA[莫比乌斯反演其实还有其他的有趣的反演miskcook-xzy 以前自己写的文章已删除，太sb了优质教程：oi-wiki 证明：当 $\sum_{d|n} \mu(d)=[n=1]$k为奇数显然，k为偶数用逆的二项式定理，k-i的奇偶性和i的奇偶性相同这个可以用来证明莫比乌斯，这类东西感觉用卷积证明都非常妙 证明： $\sum_{d|n} \frac{\mu(d)}{d}=\frac{phi(n)}{n}$$\sum_{d|n} (\mu(d) \prod p_{oth_i}) =\prod (p_i -1)$观察法可知，两边项数相同，而且对于一个含有t个p的项，其系数由其他括号的-1贡献，次幂和左边相同还有一种证明方法是将【 $F(n)=n,f(n)=phi(n)$ 】带入到莫比乌斯中 还有倍数版的公式，是可以证明的，但目前还没用过，具体在这里 目前碰到最难的题目：【WC2014】时空穿梭，我写了题解]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>莫比乌斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-12组合数学与计数]]></title>
    <url>%2Fposts%2Fb51f.html</url>
    <content type="text"><![CDATA[组合数学入门 组合数$$P(n,m)=n\times (n-1)\times (n-2)……(n-m+1)=\frac{n!}{(n-m)!}$$ $$C(n,m)=\frac{P(n,m)}{P(m,m)}=\frac{n!}{m!(n-m)!}$$ 组合数的性质详见这里再补充：$\sum_{k=0}^p {n \choose k} = {n + 1 \choose p}$$\sum_{i=1}^n C_i^j=C_{n+1}^{j+1}$ 多重集也就是允许元素重复的广义集合表示为$S={n_1 \cdot a_1,n_2 \cdot a_2,…n_k \cdot a_k}$ 全排列$\frac{n!}{n_1! \times n_2! … \times n_k!}$ 组合设选r个先考虑较为特殊的$r \leq n_i (\forall i \in [1,k])$然后我们就能直接把问题转化为求 $S={r \cdot 0,k-1 \cdot 1}$ 的全排列所以得到 $\frac{ (r+k-1)! }{r! \times (k-1)!}=C_{r+k-1}^{r}$ 例题：Counting Swaps 那如果不是这样特殊的r个呢？对问题取补，$ans=C_{r-k+1}^{r}-非法数量$而非法数量，就是说存在一个i，取的数量达到了$n_i+1$ 那么我们枚举出每个数的非法情况，然后每个非法的数字，都先定向删除$n_i+1$个，然后照常取【$r-已经删除的数量$】个 因为状态的重复，联想一下小学的时候学的简单容斥，不难算出如果非法数量num是奇数，就减去，偶数就补回去具体实现可以枚举二进制数来搞 例题：CF451E Devu and Flowers Catalan数问题有多少个01序列满足【任意前缀中，0的个数不少于1的个数】 通项公式$Cat_n=\frac{C_{2n}^n}{n+1}$ 性质 $Cat_n=C_{2n}^n-C_{2n}^{n-1}$，可以由定义得出 $Cat_n=\sum Cat_a \times Cat_{n-a-1}$ 应用 简单应用，例如【合法括号序列】、【出栈序列】 由性质2这个递推式可知，能够解决【不同形态二叉树】 错排问题求有多少个1~n的排列，满足每个$a_i \neq i$ 递推式考虑元素1，找到2~n中的k，使$a_k=1$，k有n-1种取值① $a_1=k$，此时相当于剩下n-2个元素，进行错排② otherwise，此时相当于剩下n-1个元素，进行错排所以$D_n=(n-1)(D_{n-1}+D_{n-2})$ 通项公式考虑容斥原理首先，总排列数=$n!$枚举i表示至少i个在正确位置$D_n=\sum (-1)^i C_n^i (n-i)!=\sum (-1)^i \frac{n!}{i!}$ 差分序列与Stirling数教程差分序列结论：1.如果 $\Delta f(n)$ 的第0条对角线为 $c_0, c_1, c_2, c_3, \dots, c_p, 0, 0, \dots$那么： $f(n) = \sum_{k=0}^p c_k{n \choose k}$ $\sum_{k = 0}^n f(k) = \sum_{k = 0}^p c_k {n + 1 \choose k}$ （用组合数的性质） 题目：cf407c Stirling数各种性质（不知道有没有用） 第一类Stirling数（斯特林轮换数）：带标号 $S_s(n,m)$ ，n次上升幂的 $x^m$ 的系数不带标号 $S_u(n,m)$ ，n次下降幂的 $x^m$ 的系数显然能相互转化， $S_s(n,m)=(-1)^{n+m}\cdot S_u(n,m)$然后一般不说明指的是不带标号 组合意义：n个不同的人，放入m个圆排列（内部顺序不同为不同方案），不能有空的方案数递推式可考虑n放入新的排列，或者放在前面n-1个人中某个的右边 $S(n,m)=S(n-1,m-1)+(n-1)S(n-1,m)$边界： $S(0,0)=1,S(n,0)=0 (n \geq 1)$]求法（一行）：用上升幂的定义，暴力从前往后求多项式乘积，是n方log的但如果分治求，发现复杂度与当前长度线性相关， $T(n)=2T(n/2)+nlogn=nlog^2n$然后存在一个log的做法，主要思路是 $T(n)=T(n/2)+nlogn=nlog^2n$ ，也就是通过倍增，只分治一边那么我们的目标就是求出 $f_{2n}(n)=f_n(n)f_n(n+x)$ 中的后者，考虑用前者来求$$\begin{aligned}F_n(x+n)&amp;=\sum_{i=0}^{n-1}a_i (x+n)^i\\&amp;=\sum_{i=0}^{n-1}a_i\sum_{j=0}^i{i\choose j}n^{i-j}x^j\\&amp;=\sum_{j=0}^{n-1} ( b_j=\sum_{i=j}^{n-1} n^{i-j} {i \choose j} a_i ) x^j\\b_j \cdot j!&amp;=\sum_{i=j}^{n-1} \frac{n^{i-j}}{(i-j)!} i! a_i \\&amp;=\sum_{t=0}^{n-1-j} \frac{n^t}{t!} (j+t)! a_{j+t} \\A_i=\frac{n^i}{i!}，B_i&amp;=a_{n-1-i} \cdot (n-1-i)!，C_i=b_i (n-1-i)! \\C_{n-j-1}&amp;=\sum_{t=0}^{n-1-j} A_t B_{n-1-j-t}\\\end{aligned}$$第二类Stirling数（斯特林子集数）：n个不同的人，进入m个相同的房子中，不可有空房子的方案数递推式可考虑n放入新排列，或者放在已有的房子中$S2(n,m)=m S2(n-1,m)+S2(n-1,m-1)$非递推式的话，考虑容斥即可，为了方便处理先假设m个房子互不相同$S2(n,m)=\frac{1}{m!} \sum (-1)^k {m \choose k} (m-k)^n$ min-max容斥给定一些元素每次出现的概率，每轮随机一个放入集合中，然后求出现全集所需轮数的期望定义min为最早出现，max为最晚出现比较显然： $P_{min(S)}=\sum_{i \in S} Pi,E_{min(S)}=\frac{1}{\sum_{i \in S} Pi}$然后有个结论： $E_{max(S)}=\sum_{s \subseteq S} E_{min(s)} \times (-1)^{|s|+1}$然后min和max换一下也是成立的，不是期望而是值本身也是成立的证明例题：【HAOI2015】按位或]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>二项式定理</tag>
        <tag>杨辉三角</tag>
        <tag>错排</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-11-BSGS]]></title>
    <url>%2Fposts%2Fc508.html</url>
    <content type="text"><![CDATA[BSGS，用于解决高次同余问题 问题$a^x=b (\mod p)$求最小正整数x BSGS算法条件：$gcd(a,p)=1$然后这样就能用欧拉定理了当然等会在柿子的移项中，也会暗中用到逆元。 我们只需要验证在$x=0~ \varphi(x)-1$中是否有解就行了如果这中间都不行，那么后面都是循环，也就没可能了然后如果对复杂度没有什么要求的话，就没必要算phi了，现在确保是在p以内就好了 如果直接枚举x，显然过慢我们引入分块思想中的根号，换一种方式枚举x 设$x=i \times m-j,m=\lceil \sqrt p \rceil$，其中$1 \leq i \leq m , 0 \leq j \leq m$那么原方程就能变形为$(a^m)^i=b \times a^j (\mod p)$那么只要把$b \times a^j (\mod p)$全部塞到一个hash表或者map里面，再枚举$(a^m)^i (\mod p)$来查找即可 有个小细节：预处理时可能得到相同的结果，为了保证得到最小的答案，需要把后面的j覆盖前面的j exBSGS算法条件：无观察柿子，a和p的公约数，b中也一定会有（除非b是0），否则无解。设d=gcd(a,p)，那么把一个a拉出来，同时把a、b、p除以d如果操作的次数为num，直到$d=gcd(a,\frac{p}{d^{num}})=1$，柿子变成：$(\frac{a}{d})^{num} \times a^{x-num}=\frac{b}{d^{num}} (\mod \frac{p}{d^{num}})$然后此时$gcd(\frac{a^{num}}{d^{num}}),\frac{p}{d^{num}})=1$所以可以把它逆元一下，放到右边去最后$x=BSGS(a,\frac{b}{d^{num}} \times inv(\frac{a}{d})^{num}),\frac{p}{d^{num}})+num$不过这样以后，我们强行使$x \geq num$，这样就漏了（例如a=4,x=0,b=1,c=4）不过我们观察一下，发现$num&lt;=log_2 c$，所以直接枚举出前面的$0到num-1$就好了，复杂度不变 总结核心思想就是【分块+预处理】相辅相成，复杂度下降到根号然后为了能满足条件，强行对柿子进行修改 练习Tag-BSGS 指数循环节的性质顺便转载一下riteme]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-10自然数幂和]]></title>
    <url>%2Fposts%2Fce21.html</url>
    <content type="text"><![CDATA[自然数幂和 例题注意到n大k小，所以主要是希望复杂度和k有关 第二类斯特林数$a^b=\sum_{i=1}^a S(b,i) \cdot i! \cdot C_a^i$$\sum_{i=0}^n i^k=\sum( \sum_{j=1^k} S(k,j) \cdot j! \cdot C_i^j )$这里的组合数是广义的（其实在这里主要是想忽略大小关系，后面都是0）因为希望和k有关，把j提出来$\sum_{j=1}^k S(k,j) \cdot j! \times ( \sum_{i=0}^n C_i^j )$然后根据组合数的性质$\sum_{j=1}^k S(k,j) \cdot j! \times C_{n+1}^{k+1}$那么预处理一下下降幂即可 类似思想：bzoj5093]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>自然数幂和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-9线性基]]></title>
    <url>%2Fposts%2F6cd.html</url>
    <content type="text"><![CDATA[线性基的通俗解释 思想在普通线性基中用加、乘法，能表示出其对应线性空间中的所有数。在异或线性基中用异或操作，能表示出其对应线性空间中的所有数。然后一般第二种比较常用 主要的解法都是利用高斯消元（当然用插入版本的也行，比较动态，但本质上还是高斯消元），因为其【初等行列式变换】和加、乘法对应，行列间异或，其实也相当于是二进制，所以和异或对应。 性质：1.对于用高斯消元求出的异或线性基（还有用插入法的，不介绍了，因为复杂度一样）该列上唯一的1在这上面 2.异或线性基组合出来的数（即span张成）互不相同，而且不存在0可以用反证法证明：假设有一个柿子，左右两边都是异或出来的数字，把左边留下某一个，其他移项到右边，那么出现，那个数字能被其他数字表示出，则违反线性基定义不存在0也是相同的证明方法 这就是我目前理解的，灰常浅显的线性基应用。 简易代码1234567891011121314151617181920int n;bool zero;ll a[11000];int tot;//线性基长度void gauss()&#123; zero=0;tot=0; for(int i=60;i&gt;=0;i--) &#123; int nx=tot+1; while( !(a[nx]&amp;bin[i]) and nx&lt;=n ) nx++; if(nx&gt;n) continue; tot++;swap(a[tot],a[nx]); for(int k=1;k&lt;=n;k++) if(k!=tot and a[k]&amp;bin[i]) a[k]^=a[tot]; &#125; if(tot&lt;n) zero=1;&#125; 动态插入版12345678910111213141516ll bs[61]; void insert(ll now) &#123; for(int i=60;i&gt;=0;i--) if(now&amp;bin[i]) &#123; if(bs[i]&lt;0) &#123; bs[i]=now; //回代，这个看需求，例如第k大要用 for(int j=60;j&gt;i;j--) if(bs[j]&amp;bin[i]) bs[j]^=now; break; &#125; else now^=bs[i]; &#125; &#125; 练习Tag-线性基 By the way 通常看到异或和可以想想线性基，因为异或表达的时候，最多用一次 面对插入时有附加决策条件的题目，通常可以贪心，因为相互位之间不影响]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-8高斯消元]]></title>
    <url>%2Fposts%2Fe8f0.html</url>
    <content type="text"><![CDATA[用于求解线性方程组 思想模拟简单的解多元一次方程做法逐步改系数，通过柿子相减，消去公共元 流程 首先，用行列式表示左边各个$x_i$的系数，最后一列表示其右边的常量然后每行都代表一个方程，每一列都代表一个未知数 设当前要消除的是$x_i$，找到一行，对应的系数不为0，如果找不到，则不用消，直接跳过 把这一行移动到第i行，那么我们要做的就是消除下面的方程中的$x_i$上述步骤称为消元把每个$x_i$都解决后，就得到一个上三角行列式，下面开始返代从下往上枚举，用那个柿子给上面的柿子消元，最后得到一个对角矩阵，解方程完毕。 其实消元和返代是可以同时进行的……这里分开是为了好理解 然后可能出现的特殊情况： 如果出现某一行，系数都是0，但常量不是0，则无解 设不全为0的行，数量为k，则表示有n-k个自由元，其值可为任意实数 简易代码1234567891011121314151617181920212223double myabs(double x) &#123;return x&gt;0?x:-x;&#125;const double eps=1e-8;const int MAXN=20;double p[MAXN][MAXN];double a[MAXN][MAXN],b[MAXN];//系数、常数void gauss(int n)&#123; for(int i=1;i&lt;=n;i++)//目标为xi &#123; int nx=-1; for(int j=i;j&lt;=n;j++) if(myabs(a[j][i])&gt;eps) &#123;nx=j;break;&#125; if(nx&lt;0) continue; swap(b[i],b[nx]);for(int k=1;k&lt;=n;k++) swap(a[i][k],a[nx][k]); for(int j=1;j&lt;=n;j++) &#123; if(i==j) continue; double t=a[j][i]/a[i][i];//确保分母不为0 b[j]-=b[i]*t;for(int k=i;k&lt;=n;k++) a[j][k]-=a[i][k]*t; &#125; &#125;&#125; 练习Tag-高斯消元]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-7概率与期望]]></title>
    <url>%2Fposts%2F9163.html</url>
    <content type="text"><![CDATA[感觉我这方面特别烂 定义连续型随机变量为在实数域或区间上取连续值的随机变量，若不连续则为离散型概率函数（又叫分布律），为随机变量取某个元素的概率的函数 概率分布函数是概率函数的前缀和在连续型中，不存在概率函数，定义概率密度函数f满足 $概率分布函数F(x)=\int_{-\infty}^x f(t) dt$推广到高维就叫做联合概率密度函数 连续型随机变量的数学期望，要求概率密度函数的积分收敛]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>概率</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-6 原根]]></title>
    <url>%2Fposts%2F6189.html</url>
    <content type="text"><![CDATA[一个汇总只有结论 求原根的结论： m存在原根，当且仅当 $m=1,2,4,p^a,2p^a$ ，数量为 $\varphi( \varphi(m) )$ 求原根的结论：暴力枚举原根g，尝试验证；对 $\varphi(m)$ 质因数分解，对每个验证 $g^{\frac{\varphi(m)}{p_i}} \neq 1 (\% m)$速度的话1e9基本没问题 应用：$O(\sqrt n)$ 解决高次剩余问题，例题对模数的原根求离散对数，化乘法为加法，例题 更详细的资料：zhang20072844hdxrieriteme]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-5文化课知识]]></title>
    <url>%2Fposts%2F3afc.html</url>
    <content type="text"><![CDATA[文化课知识 $e=lim_{n-&gt;\infty} (1+\frac{1}{n})^n$ 对于某个函数，如果能求出其导函数，那么可以通过 $f’(x)=0$ 找到极值点 如果一个函数的积分存在，并且有限，则称为【可积】若定积分存在，则它是一个具体的数值，而不定积分是一个函数表达式定积分： $\int_{l}^{r}f(x)dx$ 牛顿-莱布尼茨公式： $\int_a^b f’(t)=f(b)-f(a)$只要不特别纠结一些区间的开闭这种东西，还是比较好理解的 $1^2+2^2+3^2+……+n^2=\frac{n(n+1)(2n+1)}{6}$ 证明]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-4矩阵乘法]]></title>
    <url>%2Fposts%2Fc6a2.html</url>
    <content type="text"><![CDATA[2.4.1定义矩阵乘法：用来求某种递推关系。矩阵相乘只有在第一个矩阵的列数和第二个矩阵的行数相同时才有意义。设A为A*M的矩阵，B为M*B的矩阵，那么矩阵C为矩阵A与B的乘积，其中矩阵C中的第i行第j列元素可以表示为：如下所示： 2.4.2例题【题目描述】a[1]=a[2]=a[3]=1a[x]=a[x-3]+a[x-1] (x&gt;3)求a数列的第n项对1000000007（10^9+7）取余的值。【输入格式】第一行一个整数T，表示询问个数。以下T行，每行一个正整数n。【输出格式】每行输出一个非负整数表示答案。【样例输入】36 8 10【样例输出】4 9 19【数据范围】T&lt;=100,n&lt;=2*10^9 开一个2*2的矩阵：主要是为了快速幂的方便，一个可以和自己乘上许多次（&gt;=2）的矩阵只有可能是正方形的，所以要开这样一个矩阵。然后就是使用矩阵乘法来递推。如果想要预处理，也是可以的，只不过T&lt;=100，所以偷懒省空间。 2.4.3代码12345678910111213141516171819202122232425262728293031323334353637383940struct mod&#123; long long a[4][4]; mod() &#123; memset(a,0,sizeof(a)); &#125;&#125;;mod mul(mod a,mod b)//矩阵乘法&#123; mod c; for(int i=1;i&lt;=3;i++) for(int j=1;j&lt;=3;j++) for(int k=1;k&lt;=3;k++) c.a[i][j]=(c.a[i][j]+a.a[i][k]*b.a[k][j])%1000000007; return c;&#125;void make(int n)&#123; mod a,c; c.a[1][1]=1;c.a[2][1]=1;c.a[3][1]=1; a.a[1][1]=0;a.a[1][2]=1;a.a[1][3]=0; a.a[2][1]=0;a.a[2][2]=0;a.a[2][3]=1; a.a[3][1]=1;a.a[3][2]=0;a.a[3][3]=1; n++; while(n&gt;0)//快速幂 &#123; if(n&amp;1) c=mul(c,a);//不能是mul(a,c) a=mul(a,a);//(A^n)*B n&gt;&gt;=1; &#125; printf("%d\n",c.a[3][3]%1000000007);&#125;int main(int argc,char *argv[])&#123; int t;scanf("%d",&amp;t); while(t--) &#123; int n; scanf("%d",&amp;n); make(n); &#125;&#125; 2.4.4正文开始！咳咳，上面的部分是我以前对于所谓矩阵乘法的浅显认知。首先，矩阵乘法经典中的经典：Matrix67矩阵乘法的精髓在于：能通过快速幂将操作简化 顺便介绍几个特殊01矩阵：单位矩阵，m[i][i]=1，其他是0，所有矩阵和它乘都是自己，相当于1邻接矩阵，m[i][j]=1表示从i能到j 再顺便说一下，通常而言，表示一个状态应该使用列向量，也就是一个a行1列的矩阵 2.4.5 众多练习题我写的时候是按照我的思路来写的所以如果有空的话，顺着做当然最好啦~题目好像真的蛮多的Tag-矩阵乘法]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-3逆元]]></title>
    <url>%2Fposts%2F71d2.html</url>
    <content type="text"><![CDATA[逆元(严格来说叫乘法逆元) 除法与模这个东西我们之前稍微讲了一下哈：【OI之路】02数论算法-1公约数公倍数与欧几里得 补充一些内容： $ (a+b)\mod p=(a\mod p)+(b\mod p)\mod p （对） $$ (a-b)\mod p=(a\mod p)-(b\mod p)\mod p （对） $$ (a\times b)\mod p=(a\mod p)\times (b\mod p) \mod p （对） $$ \frac{a}{b}\mod p=\frac{a\mod p}{b\mod p}\mod p （错） $$ a^b\mod p=(a^{b-k}\mod p)\times (a^{k}\mod p)\mod p （对） $没错，除法中是错误的【随便举个反例即可，毕竟“证明对的难，证明错的容易”】那容易爆的可以搞快速幂，但碰到有模数的时候，难道就不用除法了？当然不是，所以，有请逆元隆重登场！ 啥玩意？$a\times x=1 (\mod p)$是不是有点像数学里面的倒数？只不过这里因为是数论，所有是整数现在x就叫做mod p下a的逆元可见p不同，a的逆元也不同。 用法？可以把除以a变成乘以a的逆元（始终强调模意义下） 求法1欧拉-费马定理条件：gcd(a,p)=1 【原本就是定理的条件】因为费马小定理还额外要求 p是素数 【已亲自实验验证】所以不定模数或者已知是合数的时候线性筛好欧拉函数$a^{\varphi(p)}=1 (\mod p)$$inv(a)=a^{-1}=a^{\varphi(p)-1} (\mod p)$ 求法2扩展欧几里德算法条件：gcd(a,p)=1 【扩展欧几里德要求K（这里的1）是gcd(A,B)的倍数】$a\times x+p\times y=1$$a\times x\%p+p\times y\%p=1\%p$$a\times x\%p=1\%p$$x=inv(a) (\mod p)$复杂度O(loga)记得取最小正整数解 求法3当p是个质数的时候有$inv(a)=(p-\lfloor p/a \rfloor)\times inv(p\%a)\%p$ 证明：设$x=p\%a,y=\lfloor p/a \rfloor 【a&lt;p】$于是有$y\times a+x=p$ 【就是整数除法定义嘛】$y\times a+x=0 (\mod p)$$x=(-y)\times a (\mod p)$$inv(a)=(p-y)\times inv(x) (\mod p)$$inv(a)=(p-\lfloor p/a \rfloor)\times inv(p\%a) (\mod p)$ 边界：$inv(1)=1$时间复杂度：单个O(loga)，但加上记忆化可以线性 总结条件：gcd(a,p)=1这个条件不是由求法而得来的（例如第三种就不需要），而是由其定义$a \times inv(a)=1 (\mod p)$那么exBSGS算法中说过对于一个同余方程组，左边、右边和模数会有相同的质因子（除非是0）而现在右边是1，则$gcd(a \times inv(a),p)=1$则$gcd(a,p)=1$ 单个复杂度：O(loga)预处理：线性 练习Tag-逆元]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-2定理杂烩]]></title>
    <url>%2Fposts%2Fa06a.html</url>
    <content type="text"><![CDATA[数论定理杂烩 费马小定理条件：质数p，gcd(a,p)=1结果：$a^{p-1}=1 (\mod p)$顺便提一下，如果使用$a^p=a (\mod p)$的形式，不需要满足gcd(a,p)=1证明：不会应用：1.求逆元：【OI之路】11更高级数论-2逆元2.某些数据范围巨大的题目如Gauss Fibonacci矩阵游戏 欧拉函数与欧拉定理欧拉函数：对于正整数n，代表小于等于n的与n互质的数的个数，记作 $\phi(n)$设 $n=p1^{a1}\times p2^{a2} ……\times pk^{ak}$，那么 $\varphi(n)=n\times \frac{p1-1}{p1}\times \frac{p2-1}{p2}……\times \frac{pk-1}{pk}$ 性质： 积性函数 phi树的深度为log 对于n&gt;1，1~n中与n互质的数的和为$n \times \varphi(n)/2$ $\sum_{d|n} \varphi(d) = n$ 当 $gcd(a,p)=1$ 时，满足 $a^x=1 (mod p)$ 的最小正整数x一定是 $\varphi(p)$ 的约数 证明： 显而易见 不会 因为$gcd(n,x)=gcd(n,n-x)$，可以看作是一对，则每一对的和都是n 考虑gcd=x，把n个数按照这分类， $n=\sum \varphi(\frac{n}{x})=\sum \varphi(x)$ 运用反证法假设存在最小的x0，不是其约数，则$\varphi(p)=t \times x0 + r (0&lt;r&lt;x0)$那么因为$a^{x0}=1 (\mod m)$，$a^{t \times x0}=1 (\mod m)$又因为$a^{\varphi(m)}=1 (\mod m)$，所以$a^r=1 (\mod m)$这与x0的最小相矛盾。 欧拉定理： 当gcd(a,m)=1，$a^{\varphi(m)}=1 (\mod m)$ 拓展欧拉定理：ywwsam张maijing例题：BZOJ3884 bzoj4869 威尔逊定理万一派得上用场？当p是质数$(p-2)! = 1 (\mod p)$ 二项式定理$$(a+b)^k=\sum_{i=0}^kC_n^i \timesa^i \timesb^{n-i}$$深入运用 牛顿广义二项式定理，将k拓展到实数域条件： $0 \leq |a| \le |b|$$(a+b)^k=\sum_{i=0}^\infty {k \choose i} a^i b^{k-i}$其中组合数定义的柿子是不变的，但不能用阶乘这个符号了显然这个广义是兼容狭义的 差比数列每一项，可以拆分为等差数列（算数数列）和等比数列（几何数列）据说是高中常用知识…… 形如$S_n=a+A(a+d)+A^2(a+2d)…+A^n(a+nd)$参考等比数列中乘以A-1$$(A-1)S_n=-a+Aa-A(a+d)+A^2(a+d)-A^2(a+2d)…A^n(a+(n-1)d)-A^n(a+nd)+A^{n+1}(a+nd)$$ $$(A-1)S_n=-a-nAd+A^{n+1}(a+nd)$$ $$S_n=\frac{A^{n+1}(a+nd)-a-nAd}{A-1}$$ 神仙欧拉的另一个公式本公式属于拓扑学的研究范围不过之前做一道叫planar的题目用到过对于一个平面图，一定满足$m \leq 3n-6$ 原公式：点数n+面数r-边数m=联通块数量cnt（当做无向图）+1对于当前的平面图判定，每条边最多给两个面使用，每个面至少有3条边也就是说，$r \leq \frac{2m}{3}$原式化为 $m=n+r-cnt-1$ 后带入，得到 $m \leq n+\frac{2}{3} m -cnt-1$$3m \leq 3n+2m-3cnt-3$显然cnt最小为1，则 $m \leq 3n-6$ 特征方程应用不是太广rxzdh gcd的奇妙定理只放定理，证明在这里和这里$gcd(x^a-1,x^b-1)=x^{gcd(x,y)}-1$$gcd(fib(a),fib(b))=fib(gcd(a,b))$ 斐波那契数列$f(0)=0,f(1)=1,f(n)=f(n-1)+f(n-2)$$S(n)=f(n+2)-1$ ，可用归纳法证明]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-1约数与欧几里得]]></title>
    <url>%2Fposts%2F7748.html</url>
    <content type="text"><![CDATA[2.1.0 前言：%和mod都表示C++中的取余运算$\lfloor x \rfloor$就是向下取整数论这一章，建议大家用C++实现的时候以long long为主长文预警！ 2.1.1 取余和取模顺便讲讲~首先声明C++中的%运算符是取余运算基本思路：①$c=a/b$ ②$r=a-c\times b$取余：在①中，向0方向取整取模：在①中，向负无穷方向取整举个栗子：(4)/(-3)≈-1.3$4 rem (-3)=4-(-1)\times (-3)=1$$4 mod (-3)=4-(-2)\times (-3)=-2$C++中的%运算符其实是rem，但为了方便我比较习惯用mod表示，小心混淆划重点：数论中为了化公式，经常要变成$r=a-\lfloor a/b \rfloor \times b$的形式 2.1.2 最大公约数Greatest Common Divisorgcd(x,y)=x和y的最大公约数公共约数中最大的定义：gcd(x,0)=x划重点：约数的定义域是自然数，所以不能是负数！ 2.1.3 最小公倍数Least Common Multiplelcm(x,y)=x和y的最小公倍数公共倍数中最小的 2.1.4 补充知识 x*y=最小公倍数*最大公倍数最小公倍数=x/最大公倍数*y （这样不容易爆） 证明：设两个数为x和y,其最大公约数为a,则最小公倍数为$(x/a)\times (y/a)\times a=x\times y/a$最大公约数和最小公倍数的乘积为$(a)\times (x\times y/a)=x\times y$ 2.1.5 欧几里得算法Euclid又名辗转相除法，对于大小关系没有要求内容： $gcd(a,b)=gcd(b,a\%b)$证明： 设d是a,b的一个约数，所以a/d,b/d为整数 $r=a-k\times b 【0\leq r&lt;b，k为整】$同时除以d，$r/d=a/d-kb/d$因为$a/d-k\times (b/d)$为整数所以r/d也是整数，所以r是d的倍数 d本身就是a,b的约数,又d是r的约数，所以是a,b,a%b的公约数既然公约数是一样的（因为d并非定值，可以应用于所有公约数）最大公约数也必然相等，得证1234int Euclid(int a,int b)&#123; return (b==0)?a:Euclid(b,a%b);&#125; 时间复杂度：$O(log2b)$，证明 2.1.6 扩展欧几里德算法ExEuclid内容： 利用 $gcd(a,b)=gcd(b,a\%b)$ 递归求解 $ax+by=gcd(a,b)$ 【属于丢番图方程】证明： Ⅰ.该方程必定是多解的，但我们只需要知道一个解，就能得出其他解，下文为简洁设$GCD=gcd(a,b)=gcd(b,a\%b)$$x=x0-b/GCD\times t$$y=y0-a/GCD\times t$注意上面两个通解公式只能选择其中一个，然后获得另一个，其存在意义在于保证都是整数解举个栗子：2x+3y=7，就是解2x+3y=1$x_0=-1，y_0=1$$x=(1-3y)/2，y=(1-2x)/3$$x=x_0-b/GCD\times t=-1-3\times t$$y=y_0-a/GCD\times t=1-2\times t$t=1 x=-4则y=3t=2 x=-7则y=5原理（这东西网上根本没人说啊啊啊啊，只有乱引经据典自我搪塞的）：首先，这个t可以看作一个系数，那么对于同一个方程显然x的t增大(t)则y的t变小(-t)带入：$a(x_0+b/GCD\times t)+b(y_0-a/GCD\times t)=GCD$化简：$ax_0+by_0=GCD$感觉很神hh Ⅱ.假设当前要求gcd(a,b)，并求出了一组x和y使得$ax+by=GCD$已经求出gcd(b,a%b)并求出了一组tx和ty使得$b\times tx+(a\%b)\times ty=GCD$那么这两个相邻的状态之间是否存在某种关系呢？$ax+by=GCD=b\times tx+(a\%b)\times ty$$ax+by=b\times tx+(a-\lfloor{a/b}\rfloor \times b)\times ty$$ax+by=b\times tx-\lfloor{a/b}\rfloor \times b\times ty+a\times ty$$ax+by=b\times (tx-\lfloor{a/b}\rfloor \times ty)+a\times ty$所以$x=ty,y=tx-\lfloor{a/b}\rfloor\times ty$这个其实挺好推的，不推荐死记硬背记住普通欧几里得后要用时再推一遍就好了 Ⅲ.x转最小非负整数解：$t=B/GCD$$x=(x\%t+t)\%t$举例：初始：x=-1 y=12x+7y=5t=B/GCD=7/1=7最后：x=6 y=-1 Code递归求解，用指针传递x,y123456789101112ll ExEuclid(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(b==0) &#123; x=1;y=0; return a; &#125; ll tx,ty; ll d=ExEuclid(b,a%b,tx,ty); x=ty;y=tx-(a/b)*ty; return d;&#125; 2.1.7 扩展欧几里德算法的运用1解不定方程Ax+By=K（得到的x和y只是其中一组解）给出A、B、K，求出x和y，满足Ax+By=K。123456789101112int main()&#123; ll A,B,K;scanf("%lld%lld%lld",&amp;A,&amp;B,&amp;K); ll x,y; ll d=ExEuclid(A,B,x,y); if(K%d!=0) printf("no solution!"); else &#123; x=x*K/d;y=(K-A*x)/B;//保险~ printf("%lld %lld",x,y); &#125;&#125; 测试点：Caioj1153 2.1.8 扩展欧几里德算法的运用2求解同余方程已知a,b,m,求x的最小非负整数解，使得ax=b(mod m)通俗讲就是ax mod m=b mod m那么b是个常数，所以直接b=b%m，不影响结果 $ax\%m=b\%m$$ax-\lfloor{ax/m}\rfloor \times m=b$$ax+m\times (-\lfloor{ax/m}\rfloor )=b$然后两边都有x怎么办？直接当作x和y的某种关系即可，因为我们只要求x。 Ax+By=KA=a,B=m,K=b123456789101112131415int main()&#123; ll a,b,m;scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;m); ll A=a,B=m,K=b; ll x,y; ll d=ExEuclid(A,B,x,y); if(K%d!=0) printf("no solution!"); else &#123; x=x*K/d; ll t=B/d; ll XX=(x%t+t)%t; printf("%lld",XX); &#125;&#125; 测试点：Caioj1154 2.1.9 扩展欧几里德算法的运用3同余方程是这样的：已知a,b,n,求x的最小非负整数解，使得ax=b(mod m)同余方程组是这样：也是求x的最小非负整数解，但已知a=1，b数组和m数组x=b[1](mod m[1])x=b[2](mod m[2])x=b[3](mod m[3])……………………x=b[n](mod m[n]) 在x=b(mod m)中，与上一个同理，由于b和m都是常数，可以令b=b%m即x%m=b将x当作P以防混淆，并新设x为商(即倍数)$m\times x+b=P$ 我们先选取前面两个柿子来寻找公共解：$m1\times x+b1=P……①$$m2\times y+b2=P……②$①-② $m1\times x+(-m2)\times y=b2-b1$A=m1,B=-m2,K=b2-b1调用ExEuclid得到x 等等，不对！B居然是负数！根据前面公约数的描述，不能求负数！网上无数人忽略了这个问题，反正我是没看到有人说这一句的那怎么办？实现的时候，我们并不需要y（因为可以由x得出），那么就把B换做正数，求出一个-y虽然这道题不用，但万一以后碰到这种情况而且还有求y，记得取相反数还原 $t=B/d$$x=x\times K/d$最小非负整数解$XX=(x\%t+t)\%t$ $P=m1\times XX+b1+若干倍的LCM(m1,m2)$若干倍的LCM(m1,m2)是因为XX只是其中一个最小非负整数解，仔细思考一下就会发现加上最后这个部分对于①和②都没有影响，x依然是整数我们要求 同余方程组 的解，就要考虑周全 回归到 $x=m1\times XX+b1(\mod LCM(m1,m2))$【提醒一下：因为是模，其实里面已经暗含“若干”了】最早的格式 $x=b(\mod m)$ 综上所述：$b=m1\times XX+b1$$m=LCM(m1,m2)$ 如此合并，最后一个b就是答案等到最后一次的时候，因为我们不再需要考虑后面了将“若干”取0就是最小非负整数解了 1234567891011121314151617181920212223242526int main()&#123; int n;scanf("%d",&amp;n);n--; ll b1,m1;scanf("%lld%lld",&amp;b1,&amp;m1);b1=b1%m1; ll XX; while(n--) &#123; ll b2,m2;scanf("%lld%lld",&amp;b2,&amp;m2);b2=b2%m2; ll A=m1,B=m2,K=b2-b1; ll x,y; ll d=ExEuclid(A,B,x,y); if(K%d!=0) &#123; printf("no solution!"); return 0; &#125; else &#123; x=x*K/d; ll t=B/d;XX=(x%t+t)%t; b1=m1*XX+b1; m1=A*B/d;//LCM(m1,m2)=LCM(A,B) &#125; &#125; printf("%lld",b1);&#125; 测试点：Caioj1155Poj2891（poj要调换输入、把无解换-1、多组数据） 2.1.10 总结一下exgcd其实和gcd很像啦把这些认认真真消化后，以后复习很快滴 顺带一提，目前网上介绍OI方面的扩展欧几里得的文章很少所以到处综合网上文章加上个人思考写下本文，希望能对大家有所帮助! 2018.01.24 UP:写这篇文章的时候我的博客还不支持公式，大家将就着看吧，懒得改了，影响不是太大。 2018.03.28 UP:咳咳，忍不住还是改好了…… 2.2.1 线性筛选素数线性筛选素数，也就是O(n)条件：积性函数，常见如素数函数、莫比乌斯函数、欧拉函数精髓：每个合数都只被它的最小质因子筛出注意，作为素数的循环j是在内部的那么当i%prime[j]==0，意味着i中已经包含了prime[j]那后面的数中，prime[j]一定会比prime[t]小那么 至少 最小质因数不会是prime[t]12345678910111213141516const int MAXN=21000000;int prime[1100000],pr;bool v[MAXN];void calcprime()&#123; for(int i=2;i&lt;=MAXN;i++) &#123; if(v[i]==0) prime[++pr]=i; if(pr==1000000) return;//满意而归 for(int j=1;j&lt;=pr and i*prime[j]&lt;=MAXN;j++) &#123; if(i%prime[j]==0) break; v[ i*prime[j] ]=1; &#125; &#125;&#125; 2.2.2 约数个数与和对于数字G$$G=p1^{a1}\times p2^{a2}\times p3^{a3}\times …\times pk^{ak}$$ $$约数个数=(a₁+1)(a₂+1)(a₃+1)…(ak+1)$$$$和=(p1^0+p1^1+…p1^{a1})(p2^0+p2^1+…p2^{a2})…(pk^0+pk^1+…pk^{ak})$$ 其实就是傻傻的乘法原理啦 2.2.4 其他知识附赠几个有用的东西： 1.通过$O(\sqrt n)$枚举出n的所有约数推论: n的约数总数，上限$2 \sqrt n$ 2.通过$O(n log_2 n)$枚举d，更新其倍数得到1~n的所有约数复杂度证明：调和级数推论：1~n的所有约数个数，上限$n log_2 n$ 3.对于int范围内的x，其质因子数量&lt;10证明就是把最小那几个乘起来然后指数总和&lt;31 4.素数分布数量1~n大致上看作n/log n 5.$\sigma(a \cdot b)=\sum_{x|a} \sum_{y|b} [gcd(x,y)=1]$这个东西没接触过的话应该挺难想的吧证明的话我不会推广，所以就不给出来了所谓推广即，多个数乘积，要求各个约数两两互质]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>欧几里得</tag>
        <tag>原创精品</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-13左偏树]]></title>
    <url>%2Fposts%2F1197.html</url>
    <content type="text"><![CDATA[左偏树，可并堆的一种便利实现hyh论文的学习笔记 话说hyh原来是我校的……外节点：不是两个孩子距离：到子树内最近的外节点距离考虑固定一个距离，那么那么节点数最少的形态一定是二叉树根据左偏性质，根节点的距离为log级别 删除某个已知节点的操作，我yy了一下，不保证正确性……可能是直接向上跳，但发现距离不变时退出因为距离的变化是单向的，而且只有log次变化，所以复杂度为log级别]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-12虚树]]></title>
    <url>%2Fposts%2F3915.html</url>
    <content type="text"><![CDATA[虚树 主要应用于①树不大，多组询问，询问设计一些点，点总数和n同阶②树很大，但有用节点的不多 构造方式给有用的节点打上标记，点和点的lca也需要在虚树内听起来点数会很多，但我们可以通过构造的方法，证明点数和n同阶 然后我自己yy了一种方法（欢迎hack）：按照dfs序从小到大处理用一个栈维护当前虚树，最后一个节点向上的虚树上的点（即向上的链） 设当前加入的点为now，栈顶为top，最后一个被pop掉的元素是lst（用数组即可便利记录）因为有可能中间存在必要的lca，没有被pop的点以及最后一个被pop的点，不向上连边①如果now在top子树内，加入栈中 ②否则，循环执行【lst连向top，pop掉top】直到栈空或者now在top子树内，如果lca(now,lst)=top，则lst连向top；否则lst连向lca，将lca和now插入栈中；最后清空lst 每个now加入完成后，将栈清空，并连边即可 显然总点数不超过2n 模板：【HNOI2014】世界树]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-11点分治]]></title>
    <url>%2Fposts%2Fb350.html</url>
    <content type="text"><![CDATA[点分治 教程并不提供 提醒本算法仅使用于枚举类型的题目任何与原本结构有关的信息，必须在原树上查询 若在点分树上两点有lca，则原树上两点路径一定会经过lca]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-10整体二分]]></title>
    <url>%2Fposts%2F55c7.html</url>
    <content type="text"><![CDATA[基于值域的整体分治 推荐资料2013许昊然论文-《浅谈数据结构题的几个非经典解法》 复杂度保证的关键通常而言，我们能通过一个log来把问题转化为局部子问题但这要求我们在判定二分的时候，所需要的时间不能和n有关，而只能和当前的局部区间长度有关 例题Dynamic Rankings123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int INF=0x3f3f3f3f; typedef long long ll; const int MAX_N=110000*3; int n; int bit[MAX_N]; int lowbit(int x) &#123;return x&amp;-x;&#125; void change(int x,int c) &#123; while(x&lt;=n) &#123; bit[x]+=c; x+=lowbit(x); &#125; &#125; int sum(int x) &#123; int ans=0; while(x&gt;=1) &#123; ans+=bit[x]; x-=lowbit(x); &#125; return ans; &#125; struct Qes &#123; int op; int l,r,k;//0询问 int pos,d,num;//1修改 int id; &#125;q[MAX_N],q1[MAX_N],q2[MAX_N]; int ans[MAX_N]; void solve(int l,int r,int fl,int fr) &#123; if(l&gt;r or fl&gt;fr) return; if(l==r) &#123; for(int i=fl;i&lt;=fr;i++) if(q[i].op==0) ans[q[i].id]=l; return; &#125; //printf("(%d,%d,%d,%d)\n",l,r,fl,fr); int mid=(l+r)/2,tot1=0,tot2=0; for(int i=fl;i&lt;=fr;i++) &#123; if(q[i].op==0) &#123; int left=sum(q[i].r)-sum(q[i].l-1); if(q[i].k&lt;=left) q1[++tot1]=q[i]; else q2[++tot2]=q[i],q2[tot2].k-=left; &#125; else &#123; if(q[i].d&lt;=mid) change(q[i].pos,q[i].num),q1[++tot1]=q[i]; else q2[++tot2]=q[i]; &#125; &#125; for(int i=1;i&lt;=tot1;i++) if(q1[i].op==1) change(q1[i].pos,-q1[i].num); for(int i=1;i&lt;=tot1;i++) q[fl+i-1]=q1[i]; for(int i=1;i&lt;=tot2;i++) q[fl+tot1+i-1]=q2[i]; solve(l,mid,fl,fl+tot1-1); solve(mid+1,r,fl+tot1,fr); &#125; int a[MAX_N]; void main() &#123; int m;scanf("%d%d",&amp;n,&amp;m); int tot=0; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); q[++tot]=(Qes)&#123;1,0,0,0,i,a[i],1,0&#125;; &#125; for(int now=1;now&lt;=m;now++) &#123; char str[5];scanf("%s",str); if(str[0]=='Q') &#123; int l,r,k;scanf("%d%d%d",&amp;l,&amp;r,&amp;k); q[++tot]=(Qes)&#123;0,l,r,k,0,0,0,now&#125;; &#125; else &#123; int pos,t;scanf("%d%d",&amp;pos,&amp;t); q[++tot]=(Qes)&#123;1,0,0,0,pos,a[pos],-1,0&#125;; q[++tot]=(Qes)&#123;1,0,0,0,pos,a[pos]=t,1,0&#125;; &#125; &#125; memset(ans,-1,sizeof ans);//debug solve(0,INF,1,tot); for(int i=1;i&lt;=m;i++) if(ans[i]&gt;-1) printf("%d\n",ans[i]); &#125;&#125;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-9-cdq分治]]></title>
    <url>%2Fposts%2Fd12f.html</url>
    <content type="text"><![CDATA[又称为基于时间的分治算法 要求 修改操作之间相互独立 允许离线 推荐资料2013许昊然论文-《浅谈数据结构题的几个非经典解法》 大致基本思想以时间轴排序每次分成两段，将左边的修改处理到右边后，就能分成两个子问题那么每一段的复杂度是与当前长度相关的，而不是总长度 题目自行搜索tag]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>cdq分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-8线段树]]></title>
    <url>%2Fposts%2Fb1b7.html</url>
    <content type="text"><![CDATA[博大精深的线段树 区间查询，复杂度log的证明假设某一次要同时访问左右两边，后面一定是刚进入就退出的（区间的连续性）所以说其实只有一次需要同时访问两边，复杂度为深度即log区间修改同样如此 线段树合并的证明见典型例题 zkw线段树还没有去学统计的力量-线段树全接触-张昆玮BeiYuwyfcyx]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-7动态树]]></title>
    <url>%2Fposts%2Fe23c.html</url>
    <content type="text"><![CDATA[6.7.1 文章师兄写的浅谈LCT实现及应用.pdf 标准模板：Luogu动态树 6.7.2 练习弹飞绵羊Caioj1437Caioj1438Caioj1439Caioj1440 6.7.3 所有题目Tag-LCT 6.7.4 有兴趣刷题的可以看看这个http://www.cnblogs.com/flashhu/p/8324551.html]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-6主席树]]></title>
    <url>%2Fposts%2Fd299.html</url>
    <content type="text"><![CDATA[6.6.0 背景对于两颗上下界相同的线段树，其结构唯一，节点一一对应。至于主席树来历之类的八卦，请自行上网搜索。某大佬：http://blog.csdn.net/xgc_woker/article/details/78018297 6.6.1 性质主席树，主要用于解决区间大小关系询问类问题，当然也用到了身为区间问题始祖的前缀和。其实它本质上是一颗权值线段树，所以比较大小就比较方便啦。 由于它存储的值是，对应某段区间，在他管辖范围内的这些数字总共出现了多少次。也正是由于出现次数满足可加性，前缀和可以很好的解决。 对于长度为1的一个区间，如果只看有用的信息，它的形状大致是一根链（空间logn），所以应该看成残缺的线段树（否则就会需要大量空间导致MLE）利用前缀和思想，用n颗主席树分别维护1~i区间内的信息，合并重复信息即可。 哦对了因为是权值线段树，所以要离散化，既减少空间，也避免下标出现负数。 目前上面我只会上述这些解释，其实它还能应用于可持久化操作…… 6.6.2 例题应用Caioj1441Poj2104Hud2665 区间第k小（大）询问先利用前缀和获得对应区间信息，然后根据左右儿子的信息值，找到k在哪里，不断缩小范围，最后找到他的值。 caioj和hdu都AC然鹅，poj却RE，至今迷离，放弃治疗…… 6.6.3 例题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=100000;const int NUL=0;//*******************全局定义*******************struct nod&#123; int x,p,z;&#125;d[MAXN+10];//*******************离散化*******************bool cmp(nod a,nod b)&#123; return a.x&lt;=b.x;&#125;void lsh(int n)&#123; sort(d+1,d+1+n,cmp); for(int i=1;i&lt;=n;i++) d[d[i].p].z=i;&#125;//*******************主席树*******************struct mg&#123; int lc,rc; int c;&#125;s[20*MAXN];int ln;//因为动态建树，l、r要放这里void add(int &amp;x,int l,int r,int c)&#123; if(x==NUL) &#123; x=++ln; s[x].c=0; s[x].lc=s[x].rc=NUL; &#125; s[x].c++; if(l==r) return; int mid=(l+r)/2; if(c&lt;=mid) add(s[x].lc,l,mid,c); else add(s[x].rc,mid+1,r,c);&#125;void merg(int x,int &amp;y)&#123; if(x==NUL) return; if(y==NUL) &#123;y=x;return;&#125; s[y].c+=s[x].c; merg(s[x].lc,s[y].lc); merg(s[x].rc,s[y].rc);&#125;//x、y是节点编号，l、r是离散化值即排名int ask(int x,int y,int l,int r,int rk)&#123; if(l==r) return d[l].x;//排名为l的原值 int xlc=s[x].lc,ylc=s[y].lc; int ls=s[ylc].c-s[xlc].c; int mid=(l+r)/2; if(rk&lt;=ls) return ask(xlc,ylc,l,mid,rk); return ask(s[x].rc,s[y].rc,mid+1,r,rk-ls);&#125;//*******************主函数*******************int ys[MAXN+10];int main()&#123; //int t;scanf("%d",&amp;t); //while(t--) //&#123; ln=0;memset(ys,NUL,sizeof(ys)); int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;d[i].x),d[i].p=i; lsh(n); for(int i=1;i&lt;=n;i++) &#123; add(ys[i],1,n,d[i].z);//插入一条链 merg(ys[i-1],ys[i]);//合并从而形成前缀和 &#125; while(m--) &#123; int l,r,k;scanf("%d%d%d",&amp;l,&amp;r,&amp;k); printf("%d\n",ask(ys[l-1],ys[r],1,n,k)); //注意前缀和的-1 &#125; //&#125;&#125; 6.6.4 练习Bzoj1901 Zju2112Dynamic RankingsSpoj3267 D-query 6.4.7 所有题目Tag-主席树]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-5-kdtree]]></title>
    <url>%2Fposts%2F23c.html</url>
    <content type="text"><![CDATA[kdtree：同样是融合了贪心的某种暴力upd：很久没用了，感觉复杂度不靠谱，当然也是梦想暴力拿高分的好帮手 好文章K-DTree-n+e.pdf 练习SJY摆棋子最近点对Hide and Seek 练习题Tag-kdtree]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>kdtree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-4树上启发式合并]]></title>
    <url>%2Fposts%2Fb144.html</url>
    <content type="text"><![CDATA[dsu on tree 基本思路维护子树信息的时候，dfs处理每个节点，信息全局维护然后重儿子的信息保留给父亲，轻儿子重新遍历，逐个加入 （所以能遍历地维护一些平时很麻烦的东西）复杂度的话考虑每个节点被访问的次数，比较显然 入门题bzoj5040]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>树上启发式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-3伸展树]]></title>
    <url>%2Fposts%2F506a.html</url>
    <content type="text"><![CDATA[6.4.1 定义伸展树是一种相当灵活的平衡树结构（灵活：便于添加和删除）比较少直接使用，能应用于LCT 6.4.2 模版题我把最重要的讲解放在这里面了【Caioj1130】【Codevs4543】【Bzoj3224】普通平衡树 6.4.5 练习Codevs3303文艺平衡树Bzoj3196二逼平衡树Bzoj1500维修数列 6.4.5 其他题目Caioj1131 Bzoj1588 Codevs1296 HNOI2002 HNOI2014 营业额统计Caioj1132 Bzoj1503 Codevs1286 NOI2004 郁闷的出纳员Caioj1133 Bzoj1208 CCodevs1285 HNOI2004 宠物收养所Caioj1137 Bzoj1058 Codevs1429 ZJOI2007 报表统计 6.4.6 总结重点是利用伸展树的灵活性另外，每次Splay既是加速也是重要的更新（pushdown/pushup） 如果还看不懂，阔以看看介个文章：FlashHu 6.4.7 所有题目Tag-伸展树 update说说我对前驱后继操作的理解我的写法是兼容【参数不存在】的情况的findip会找到一个存在元素，可能不满足条件，但一定是在那个方向最接近的（如果比d小，那么一定是其中最大的，反之亦然）那么为了确保找到正确答案，不能直接找父亲什么的，要旋转到根，然后往那个方向按具体需求去找 目前已知的只有平衡树能实现，而set不能的功能： 找第k大等，与具体值没有关系，而且k不是首尾的操作（这里没必要用主席树） 目前已知的只有主席树能实现的东西：区间第k大（如果像二逼平衡树那样树套树也行，但显然的比赛找死行为）]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-2树状数组]]></title>
    <url>%2Fposts%2F1650.html</url>
    <content type="text"><![CDATA[6.2.0 前言本文同样不是教程，提供一些思路罢了 6.2.1 定义树状数组是一种利用正整数二进制的某种特殊性质，从而比线段树更精简但没这么强大的，并且借助了前缀和思路的特殊数组 6.2.2 有关二进制基础知识可以参考这篇文章主要就是这个函数，原理可以看网上的教程，主要就是O(1)找到自己的父亲（加上结果）和兄弟（减去结果）1234int lowbit(int x)&#123; return x&amp;-x;&#125; 6.2.2 单点更新, 区间询问前缀和:i到j就是ask(j)-ask(i-1) 12345678910111213141516171819void change(int x,int c)&#123; while(x&lt;=n) &#123; p[x]=c; x+=lowbit(x); //更新管理着x的所有父亲 &#125;&#125;int ask(int x)&#123; int s=0; while(x&gt;=1) &#123; s+=p[x]; x-=lowbit(x); //加上自己所管理不到的，在我前面的兄弟 &#125;&#125; 6.2.3 区间更新, 单点询问运用差分就是说原本的a[i]=p[1]+p[2]…+p[i]从而把数值变得依赖于前面的数值 若要将a数组区间[l,r]的元素都加上key，显然只需令p[l]+=key,p[r+1]-=key即可。 差分思想的运用灰常广泛，这只是其中一种简单的体现详见Tag-差分 6.2.4 区间更新, 区间询问假设现在求sum[s]，d[]是差分数组a[1]+a[2]+a[3]+…..+a[s-1]+a[s]=(d[1])+(d[1]+d[2])+…..+(d[1]+d[2]+…..+d[s])=(s)d[1]+(s-1)d[2]+…..+(1)d[s]=s(d[1]+d[2]+….+d[s])-((1-1)d[1]+(2-1)d[2]…+(s-1)d[s])为了简化，故定义另一个数组cc[i]=(i-1)d[i]从而把原式化简为=s*(d[1]+d[2]+….+d[s])-(c[1]+c[2]…+c[s]) 这样，只需要两个树状数组即可，一个维护d，一个维护c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;//*******************定义*******************typedef long long ld;ld n;ld c[2][210000];//*******************实现*******************ld lowbit(ld x)&#123; return x&amp;-x;&#125;void ch(ld f,ld x,ld s)&#123; while(x&lt;=n) &#123; c[f][x]+=s; x+=lowbit(x); &#125;&#125;ld sum(ld f,ld x)&#123; ld s=0; while(x&gt;0) &#123; s+=c[f][x]; x-=lowbit(x); &#125; return s;&#125;//*******************接口*******************ld ask(ld x)&#123; return x*sum(0,x)-sum(1,x);&#125;//*******************主函数*******************ld a[210000];int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;a[i]); ld d=a[i]-a[i-1]; ch(0,i,d); ch(1,i,(i-1)*d); &#125; int q;scanf("%d",&amp;q); while(q--) &#123; int o,a,b;scanf("%d%d%d",&amp;o,&amp;a,&amp;b); ld c; if(o==1) &#123; scanf("%lld",&amp;c); //d[i]+=c ch(0,a,c);ch(0,b+1,-c); //c[i]+=(i-1)*c ch(1,a,(a-1)*c);ch(1,b+1,-b*c); &#125; else printf("%lld\n",ask(b)-ask(a-1)); &#125;&#125; 可以去Codevs1082评测如果用线段树就灰常简单了：这篇文章 6.2.4 练习题Tag-树状数组 6.2.5 总结树状数组的核心竞争力在于比线段树容易实现（因为利用前缀和思想），但也正是因为用了前缀和，操作必须满足区间可加性，例如无法求最值]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-1分块]]></title>
    <url>%2Fposts%2F2aa7.html</url>
    <content type="text"><![CDATA[文章参考网页版：http://hzwer.com/8053.html 好吧，实话说已经灰常详细了，暂时不知道说些什么好…… 学习指导：Hzwer题表 所有题目Tag-分块]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】01语法与STL-5二叉树]]></title>
    <url>%2Fposts%2F212a.html</url>
    <content type="text"><![CDATA[初赛常考内容随便说点性质 树上的度指子节点数量，和通常说的不同！设ni为二叉树上，度为i的节点数量则n0=n2+1证明： n=n0+n1+n2 孩子节点总数=n1+2n2 显然n=n1+2n2+1 所以得证 树的层次，从第0层开始一棵树的高度，为其层数-1，所以和深度最大的节点，数值相同（根深度为0） 完美二叉树 Perfect Binary Tree: 没有度为0的节点完全二叉树 Complete Binary Tree：最后一层不满完满二叉树 Full Binary Tree：即国内通常指的满二叉树]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】01语法与STL-4原码反码补码]]></title>
    <url>%2Fposts%2Fa619.html</url>
    <content type="text"><![CDATA[初赛常考内容 5.1.1 基本概念字节：8各位。字长：若干个字节。到底是几个字节？具体看是哪种CPU。 比如2010普及组第11题就假设一个字长只有一个字节8个位。接下来原码、反码，补码都是建立在机器数在一个字长上的表示。为了方便理解，我们假设字长为一个字节。读者要注意事实上为32位CPU字长为4个字节，64位CPU字长为8个字节。 5.1.2 原码首位为符号位，其余为真值。比如：原码总结：范围：比如字长为8位，则范围为 11111111（－255） 至 01111111（＋255）。缺点：0有两个表示，分别为正零（00000000）和负零（10000000），给计算机计算带来不便。 5.1.3 反码首位为符号位，其它位分正数和负数两种情况。反码正数：所有位和原码一样；反码负数：除了符号位和原码一样，其他位相反。比如：77的反码表示为01001101 -77的反码表示为10110010补码总结：同样0有两个表示，也没有原码简单，反码存在的意义就是为了连接原码和补码。 5.1.4 补码分正数和负数两种情况。补码正数：所有位和反码一样，当然也和原码一样。补码负数：等于反码加1。简单的一句话，其实很麻烦。比如：77的补码表示为01001101（和原码、反码一致） -77的补码表示为10110011 加1之后会有进位，因为补码没有符号位，所以负零的补码表示也是00000000。补码总结：特点：表示比反码更麻烦。但是解决了一个问题：0只有一种表示。 原码 反码 补码 正零 00000000 00000000 00000000 负零 10000000 11111111 00000000 5.1.5 位运算不错的参考~和!都是取反，但~对符号位取反，!则不会]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】01语法与STL-3操作符和优先级]]></title>
    <url>%2Fposts%2Fd010.html</url>
    <content type="text"><![CDATA[表格 记忆方法：–摘自《C语言程序设计实用问答》 问题：如何记住运算符的15种优先级和结合性？解答：C语言中运算符种类比较繁多，优先级有15种，结合性有两种。如何记忆两种结合性和15种优先级？下面讲述一种记忆方法。结合性有两种，一种是自左至右，另一种是自右至左，大部分运算符的结合性是自左至右，只有单目运算符、三目运算符的赋值运算符的结合性自右至左。 优先级有15种。记忆方法如下：记住一个最高的：构造类型的元素或成员以及小括号。记住一个最低的：逗号运算符。剩余的是一、二、三、赋值。意思是单目、双目、三目和赋值运算符。在诸多运算符中，又分为：算术、关系、逻辑。两种位操作运算符中，移位运算符在算术运算符后边，逻辑位运算符在逻辑运算符的前面。再细分如下：1234算术运算符分 * / %高于+ -关系运算符中 &gt; &gt;= &lt; &lt;=高于== !=逻辑运算符中，除了逻辑求反(!)是单目外，逻辑与(&amp;&amp;)高于逻辑或(||)逻辑位运算符中，除了逻辑按位求反(~）外，按位与(&amp;)高于按位半加(^)高于按位或(|) 这样就将15种优先级都记住了，再将记忆方法总结如下：去掉一个最高的，去掉一个最低的，剩下的是一、二、三、赋值。双目运算符中，顺序为算术、关系和逻辑，移位和逻辑位插入其中。]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】01语法与STL-2STL]]></title>
    <url>%2Fposts%2Fa012.html</url>
    <content type="text"><![CDATA[壮哉我stl！ 字符串读取整行，getline(cin,s);123456789101112#include&lt;string&gt;string s1; //定义一个字符串s1，并初始化为空string s2(s1); //用s1初始化s2string s3("value"); //将s3初始化为"value"string s4(n,'c'); //将s4初始化为字符'c'的n个副本，简单来说就是n个'c'字符s.empty() //若s为空串，则返回true，否则为falses.size() //返回s中字符的个数，s.length()与其相同s.insert(pos,s2) //在s下标为pos的元素前插入字符串s2s.substr(pos,len) //返回s中下标为pos起的长度为len的子串s.replace(pos,l,s2) //替换s中下标为pos起的长度l个字符为字符串s2s.find(s2,pos) //在s中查找s2第一次出现的位置s.c_str() //返回一个C风格的字符串临时指针 关联式容器map &lt;类型1,类型2&gt; 变量名;在一些应用中，使用map容器来作为一个有序的映射表对map单次操作的时间复杂度为log(n)12345678910#include&lt;map&gt;ma["abc"]=2; //将字符串"abc"映射到整数2cout&lt;&lt;ma["abc"]; //输出为2ma.begin() //返回map中第一个元素的迭代器（指针）ma.end() //返回最后一个元素后一个的迭代器（指针）ma.size() //返回map中元素的个数ma.count(element) //判断元素element是否存在map中ma.clear() //初始化mapma.lower_bound() //返回键值大于等于给定元素的第一个位置,一旦map中的一个元素被访问，不论它之前是否已经被赋值，它都被视为存在operator[] //访问map中的元素，若该元素不存在,则创建一个新元素，并返回类型2初始值 set返回迭代器（直接减去begin()得到下标即排名，加上*得到值）begin()–返回指向第一个元素的迭代器end()–返回指向最后一个元素的迭代器find()–返回一个指向被查找到元素的迭代器，不存在则返回end()lower_bound()–返回指向大于（或等于）某值的第一个元素的迭代器，可外面，不存在则返回end()upper_bound()–返回大于某个值元素的迭代器，可外面，不存在则返回end() 用multiset可以完全代替优先队列，还可以同时小根、大根支持删除（s.erase(s.find())即可，只会删一个，如果传入值删除所有）、搜索元素 12得到最小值*(s.begin())最大值*(--s.end()) Zebras 1.2.9 迭代器123456map&lt;string,int&gt; m;for(map&lt;string,int&gt;::iterator i=m.begin();i!=m.end();i++)&#123; //或 cout&lt;&lt;i-&gt;first&lt;&lt;" "&lt;&lt;i-&gt;second&lt;&lt;endl; cout&lt;&lt;(*i).first&lt;&lt;" "&lt;&lt;(*i).second&lt;&lt;endl;&#125; 如果要反向枚举，可以从rbegin的结尾，到rend，注意遍历的时候要用++这样会方便很多，不用预处理st和edsort的时候（主要是vector）也会很方便：sort( a.rbegin(),a.rend() )这可以从大到小 bitset定义、初始化与赋值bitset 表示二进制长度为8默认初始值为0bs[0]=1 表示将最后一位设为1，而不是首位（bin[0]） 函数返回boolbs.any() 是否存在值为1的二进制位bs.none() 是否不存在值为1的二进制位，也就是0bs.count() 值为1的个数 返回bitsetbs.flip() 全部位逐位取反，等效于 ~bs 返回下标找1_Find_first()_Find_next(pos)Zebras 其他所有位运算，除了“!”，不知道原因赋值：set()全部1，reset()全部0 转化bs.to_string()bs.to_ulong() 变成 unsigned longbs.to_ullong() 变成 unsigned long longbs=”0001010”bs=31 优秀的空间复杂度 长度 bitset字节 bool[]字节 16 4 16 32 4 32 64 8 64 简而言之，每8位1个字节其实和用int存储是一样的，例如32位是4字节 时间复杂度每次操作，位数/32 其他nth_element(start, start+n, end)使第n大元素处于第n位置（从0开始,其位置是下标为 n的元素）常用于KD-Tree原理其实就是手写二分排序一样，然后只搞某一侧 deque与queue不同在于能任意访问其中的元素（因为是连续的空间），并且能在前面插入元素（与vector不同）（这是手写队列也无法做到的，虽然不常用，因为oi不考stl，只是作为工具） equal_range参数和lower_bound等类似能够返回容器内，等值区间，而且同样是左闭右开区间]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】01语法与STL-1概要与常识]]></title>
    <url>%2Fposts%2F5fe4.html</url>
    <content type="text"><![CDATA[这些可能在NOIP初赛、日常做题比较有用当然也是计算机领域的一些常识 系统dfs栈windows默认60000左右，linux默认250000左右解决方法：手写栈 主定理用来分析复杂度的东东$T(n)=aT(\frac{n}{b})+f(n)$如果 $f(n)&lt;n^{log_b a},T(n)=O(n^{log_b a})$如果 $f(n)=n^{log_b a},T(n)=O(n^{log_b a} log n)$否则， $T(n)=O(f(n))$很多分治算法不太好计算，就可以用这个 初赛易错 主频1 GHZ=1000 MHz 区位码转国际码，分别加上32；国际码转机内码，分别加128 LAN 局域网，MAN 城域网， WAN 广域网 网络协议应用层：telnet（远程登陆），ftp，e-mail传输层：TCP（传输控制协议）， Udp（用户数据报协议）网络层：IP 网际协议，ICMP（网际控制报文协议），IGMP（组管理协议）网络结构层：设备驱动程序 DNS域名系统，将域名转化为地址 电子邮件：简单邮件传输协议SMTP，电子邮件拓展协议MIME，POP协议 不稳定排序：选择排序，希尔排序，快排，堆排， 只有堆排和归并最坏nlogn 16位色指有 $2^{16}$ 种颜色，即每个像素2字节 面向对象的语言：C#，c++，java，smalltalk，eiffel 第一种高级语言：Fortran 浮点数分阶码和尾数两部分,阶码位数越多，可表示的数的范围越大；尾数越多，所表示的数的精度越高 复杂度包括时间和空间P问题：存在多项式解法的问题；NP问题：多项式时间内验证答案的问题；NP-hard问题：所有NP问题可以在多项式复杂度内归约到它NPC问题：所有NP问题可以在多项式复杂度内归约到它，而且是NP问题 IP0.0.0.0 对应于当前主机255.255.255.255当前子网的广播地址127.0.0.1 代表本机IP地址 oth我的：原码、补码、反码操作符和优先级可变参数数据类型的对照 别人的：数制转换逻辑运算栈与卡特兰数二叉树的遍历和性质哈夫曼树和哈夫曼编码模拟与高精度算法排序与算法复杂度数据结构基础数论算法基础图论算法基础组合数学基础计算几何基础基本算法思想计算机文化基础计算机系统原理计算机网络基础计算机病毒防治计算机信息处理信息学奥林匹克]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
</search>
