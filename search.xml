<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【置顶】目录]]></title>
    <url>%2Fposts%2F4c9e.html</url>
    <content type="text"><![CDATA[本站目录OI之路完整目录：Here 感觉不错的题目Tag-精品题 其他 1. 贪心 题目 2. 二分 题目 3. 哈希 题目 OI之路 4. 高精度 题目 OI之路 5. 启发式搜索 题目 OI之路 图论 1. dfs序 题目 2. 并查集 题目 OI之路 3. 最短路 题目 1. SPFA 题目 OI之路 2. Floyd 题目 OI之路 3. Dijkstra 题目 OI之路 4. 差分约束 题目 OI之路 5. 二分图 题目 1. 二分图染色 题目 2. 二分图匹配 题目 OI之路 7. 2-SAT 题目 OI之路 8. 网络流 题目 OI之路 1. 最大流 题目 2. 最小割 题目 3. 费用流 题目 有上下界网络流 9. 树（其实偏向数据结构） 1. 生成树 题目 矩阵树定理 2. 树链剖分 题目 3. 最近公共祖先 题目 OI之路 4. LCT动态树 题目 OI之路 5. 哈夫曼树 题目 OI之路 虚树 prufer编码 10. 拓扑 题目 11. 强连通 题目 OI之路 欧拉图 仙人掌 数学 1. 矩阵乘法 题目 OI之路 2. 概率与期望 题目 OI之路 3. 莫比乌斯反演 题目 OI之路 4. 快速傅里叶变换 题目 OI之路 5. 欧几里得 OI之路 6. 组合数学 题目 OI之路 7. 乘法逆元 题目 OI之路 8. 筛法 OI之路 9. 欧拉函数 题目 OI之路 博弈 BSGS 置换 卡特兰数 高斯消元 调和级数 模线性方程组 几何 1. 凸包 2. 半平面交 旋转卡壳 字符串 1. KMP 题目 OI之路 2. Manacher 题目 OI之路 3. exKMP 题目 OI之路 4. 字典树 题目 OI之路 5. AC自动机 题目 OI之路 6. 后缀数组 题目 OI之路 7. 后缀自动机 题目 OI之路 动态规划 动规 题目 1. 状压DP 题目 2. 数位DP 题目 3. 单调队列 题目 4. 斜率优化 题目 数据结构 2. 基础数据结构 1. 分块 题目 OI之路 2. 莫队 题目 OI之路 3. 中级数据结构 1. ST表 题目 2. 线段树 题目 3. 平衡树 1. splay 题目 4. 树状数组 题目 替罪羊树 可并堆 4. 高级数据结构 1. 可持久化数据结构 1. 可持久化线段树 题目 可持久化字典树 2. 树套树 题目 3. K-Dtree 题目 本文日期————希望我在这一天前不要AFO啦]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【Nwerc2015】赌骆驼]]></title>
    <url>%2Fposts%2F5fb6.html</url>
    <content type="text"><![CDATA[Source and JudgeNwerc2015 Guessing Camelsbzoj4430 Record1h Analysis请先思考后再展开 显然是个三维偏序，可以直接cdq，是log方的然而又一种巧妙的log的做法非法情况存在一种性质：每次取出两个排列的话，三种情况两种相同一种不同不妨设 $PA_i &gt; PA_j,PB_i &lt; PB_j$两两取出来，统计这个二维偏序，那么每队算重复一次，除以2，就是非法情况1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=210000; int n; int p[5][MAX_N]; int bit[MAX_N]; int lowbit(int x) &#123;return x&amp;-x;&#125; void change(int x,int c) &#123;while(x&lt;=n) bit[x]+=c,x+=lowbit(x);&#125; int ask(int x) &#123;int ans=0;while(x&gt;=1) ans+=bit[x],x-=lowbit(x);return ans;&#125; struct Nod&#123;int x,y;&#125;s[MAX_N]; bool cmp(Nod a,Nod b) &#123;return a.x&gt;b.x;&#125; ll ans=0; void solve(int k1,int k2) &#123; for(int i=1;i&lt;=n;i++) s[i]=(Nod)&#123;p[k1][i],p[k2][i]&#125;; sort(s+1,s+n+1,cmp); memset(bit,0,sizeof bit); for(int i=1;i&lt;=n;i++) ans+=ask(s[i].y-1),change(s[i].y,1); &#125; void main() &#123; scanf("%d",&amp;n); for(int t=1;t&lt;=3;t++) for(int i=1;i&lt;=n;i++) &#123;int x;scanf("%d",&amp;x);p[t][x]=i;&#125; solve(1,2);solve(1,3);solve(2,3); printf("%lld",(ll)n*(n-1)/2-ans/2); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>cdq分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【雅礼day4】t2]]></title>
    <url>%2Fposts%2F7387.html</url>
    <content type="text"><![CDATA[Source and Judge雅礼noip模拟题 题意给定一个无向图，n 个点（从1 开始编号）、m 条边（长度为1），每条边有一个权值c(0或1)。一条路径，可以表示为一个长度为经过边数的01 串，串的第i 位为经过的第i 条边的权值。两条路径相同，当且仅当表示其的01 串相同。求从1 号点出发、长度为d 的路径种数。n小于90，可能是完全图d小于20 Record1h Analysis请先思考后再展开 因为前导0的存在，给每种状态加上其长度的二次幂相当于强行插入一个1在最前面，使得所有状态不重不漏，共计 2^{n+1}这样状压好以后，很容易想出 $O(2^n n^2 / 32)$ 的做法，利用bitset可以卡时间过通过折半搜索可以把复杂度除以10，即 $O(2^{n/2} n^3 /32)$先枚举一个起点，然后枚举当前位置，转移即可最后把起点1的部分和其他起点合并起来，dp的时候顺便处理好就能快速实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=100; int bin[40]; typedef bitset&lt;MAX_N&gt; bs; bs e[2][MAX_N];//邻接矩阵 bs f[(1&lt;&lt;12)+10];//当前st下，能实现该状态的点 bs g[(1&lt;&lt;12)+10];//能实现该状态的st void main() &#123; if(!LOCAL) freopen("y.in","r",stdin); if(!LOCAL) freopen("y.out","w",stdout); bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; int n,m,D;scanf("%d%d%d",&amp;n,&amp;m,&amp;D); int D2=D/2,D1=D-D2;//D1&gt;=D2 for(int i=1;i&lt;=m;i++) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); e[c][x][y]=e[c][y][x]=1; &#125; for(int st=n;st&gt;=1;st--) &#123; for(int S=1;S&lt;=bin[D1+1]-1;S++) f[S].reset(); f[1][st]=1; for(int S=1;S&lt;=bin[D1+1]-1;S++) for(int x=1;x&lt;=n;x++) if(f[S][x]) f[S&lt;&lt;1]|=e[0][x],f[S&lt;&lt;1|1]|=e[1][x]; for(int S=bin[D2];S&lt;=bin[D2+1]-1;S++) g[S][st]=g[S][st] or f[S].any(); &#125; int ans=0; for(int left=0;left&lt;=bin[D1]-1;left++) for(int right=0;right&lt;=bin[D2]-1;right++) if( ( f[bin[D1]|left]&amp;g[bin[D2]|right] ).any() ) ans++;//存在交集 printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SDOI2013】保护出题人]]></title>
    <url>%2Fposts%2F44ef.html</url>
    <content type="text"><![CDATA[Source and JudgeSDOI2013luogu3299 Record1h Analysis请先思考后再展开 很容易划出柿子：$y_i=max \frac{sum_i-sum_{j-1}}{x_i-(i-j) \cdot d}$看到分数，考虑一下斜率、直线等东西所有以前的点为 $A(j \cdot d,sum_{j-1})$当前的点为 $B(x_i+i \cdot d,sum_i)$那么相当于求与B斜率中最大的那个，显然在凸壳上，三分找到极值横坐标单调很好维护凸壳]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【IOI2000】Post Office]]></title>
    <url>%2Fposts%2F5867.html</url>
    <content type="text"><![CDATA[Source and JudgeIOI2000poj1160 Record1h Analysis请先思考后再展开 放一个就是中位数，用这个来dp打决策表，验证决策单调性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=310; ll f[MAX_N][40],fm[MAX_N][40]; ll a[MAX_N],w[MAX_N][MAX_N]; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); for(int l=1;l&lt;=n;l++) for(int r=l;r&lt;=n;r++) w[l][r]=w[l][r-1]+a[r]-a[(l+r)/2]; //只会从偶数变奇数的时候移动，那么是满足柿子的 memset(f,63,sizeof f);f[0][0]=0; for(int k=1;k&lt;=m;k++) &#123; for(int i=n;i&gt;=k;i--) &#123; int fl=fm[i][k-1],fr=(i==n)?n:fm[i+1][k]; for(int j=fl;j&lt;=fr and j&lt;i;j++) &#123; ll now=f[j][k-1]+w[j+1][i]; if(now&lt;f[i][k]) f[i][k]=now,fm[i][k]=j; &#125; &#125; &#125; printf("%lld",f[n][m]); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>dp</tag>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poi2011】Lightning Conductor]]></title>
    <url>%2Fposts%2Fce55.html</url>
    <content type="text"><![CDATA[Source and JudgePoi2011bzoj2216 Record1h Analysis请先思考后再展开 突破口在根号，显然有决策单调性和诗人小G差不过，所以那个做法就不讲了看题解的时候意外地发现了分治做法，也是利用单调性，挺好的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=510000; double a[MAX_N],f1[MAX_N],f2[MAX_N]; void solve1(int l,int r,int fl,int fr)//l~r=更新的区域，fl~fr=选择的区域 &#123; if(l&gt;r) return; int mid=(l+r)/2,pos=mid; for(int j=fl;j&lt;=fr and j&lt;=mid;j++) &#123; double t=a[j]+sqrt((double)mid-j); if(t&gt;f1[mid]) f1[mid]=t,pos=j; &#125; solve1(l,mid-1,fl,pos); solve1(mid+1,r,pos,fr); &#125; void solve2(int l,int r,int fl,int fr) &#123; if(l&gt;r) return; int mid=(l+r)/2,pos=mid; for(int j=fr;j&gt;=fl and j&gt;=mid;j--) &#123; double t=a[j]+sqrt((double)j-mid); if(t&gt;f2[mid]) f2[mid]=t,pos=j; &#125; solve2(l,mid-1,fl,pos); solve2(mid+1,r,pos,fr); &#125; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lf",&amp;a[i]); solve1(1,n,1,n); solve2(1,n,1,n); for(int i=1;i&lt;=n;i++) printf("%d\n",(int)ceil(max(f1[i],f2[i])-a[i])); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOI2009】诗人小G]]></title>
    <url>%2Fposts%2Ffb5d.html</url>
    <content type="text"><![CDATA[Source and JudgeNOI2009bzoj1563 Record2h Analysis请先思考后再展开 题意：多组数据n个句子，分行，每行的代价为【总长度+中间的分割空格数量】与L的差的p次方最小化该代价并输出方案如果超过1e18，输出Too hard to arrange每组数据后输出20个“-” 发现了bzoj的目前唯一优点：将繁琐而sb的输出方案省略 本题通过暴力打表验证，发现决策满足单调性（从证明上说就是满足四边形不等式，虽然我并没有去证明hh）然后我一开始就想了一个很sb的问题：既然决策点单调，每次从那里开始往后移动指针不就好了？但对于每个i，其j的验证并不是单调的，虽然确实可以从那里开始，但不得不全部扫一遍如果每次的下一个就是最优解，那么依然是平方级别的 但反过来考虑，考虑i能够给多少个后面的k作贡献，就好维护多了维护一个数组q，表示最优决策点的位置，此时如果设计一个函数，表示和原本相比是否更优，那么一定是单调的，二分查找即可我在具体实现的时候，分了一下段，稍微加速下~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; bool error; ll cheng(ll x,ll y) &#123; if((double)x*y&gt;1e18) error=1; return x*y; &#125; ll qpower(ll x,int e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=cheng(ans,x); e&gt;&gt;=1;if(e&gt;0) x=cheng(x,x); &#125; return ans; &#125; const int MAX_N=110000; int n,L,p; char str[MAX_N][40]; int sum[MAX_N],s[MAX_N]; ll f[MAX_N]; bool big[MAX_N]; struct Nod&#123;int j,l,r;&#125;q[MAX_N]; ll w(int j,int i) &#123;return qpower(abs(s[i]-s[j]-L),p);&#125; bool better(int i,int j,int k) &#123; if(big[j]) return 1; if(big[i]) return 0; return f[i]+pow(abs(s[k]-s[i]-L),p)&lt;=f[j]+pow(abs(s[k]-s[j]-L),p); &#125; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d%d",&amp;n,&amp;L,&amp;p);L++; for(int i=1;i&lt;=n;i++) &#123; scanf("%s",str[i]+1); sum[i]=sum[i-1]+strlen(str[i]+1); s[i]=sum[i]+i; &#125; memset(big,1,sizeof big);big[0]=0; memset(f,63,sizeof f);f[0]=0; int tou=1,wei=1;q[1]=(Nod)&#123;0,1,n&#125;; for(int i=1;i&lt;=n;i++) &#123; while(q[tou].r&lt;i) tou++; error=0; if(!big[q[tou].j] and (double)f[q[tou].j]+w(q[tou].j,i)&lt;=1e18 and !error) &#123; big[i]=0; f[i]=f[q[tou].j]+w(q[tou].j,i); &#125; //if(LOCAL) printf("i=%d fm=%d\n",i,q[tou].j); int pos=n+1;//pos~n 修改为i while(tou&lt;=wei) &#123; if(better(i,q[wei].j,q[wei].l)) pos=q[wei].l,wei--; else if(better(q[wei].j,i,q[wei].r)) break; else &#123; int l=q[wei].l,r=q[wei].r; while(l&lt;=r) &#123; int mid=(l+r)/2; if(better(i,q[wei].j,mid)) pos=mid,r=mid-1; else l=mid+1; &#125; q[wei].r=pos-1; break; &#125; &#125; //if(LOCAL) printf("i=%d pos=%d\n",i,pos); if(pos&lt;=n) q[++wei]=(Nod)&#123;i,pos,n&#125;; &#125; if(big[n]) puts("Too hard to arrange"); else printf("%lld\n",f[n]); puts("--------------------"); &#125; &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>dp</tag>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CEOI2008】order]]></title>
    <url>%2Fposts%2F956c.html</url>
    <content type="text"><![CDATA[Source and JudgeCEOI2008bzoj3709luogu4177 Record2h Analysis请先思考后再展开 决策问题考虑网络流依赖关系再深入考虑到闭合子图如果没用租用机器这个选项，这就是个裸题租用机器和其他任务无关，考虑这个特征如果x依赖y，将原本的INF改成租金，表示破除依赖关系 当前弧优化：当层次确定的时候，反向弧是否使用也是确定的那么如果一条边流完了，可以在边链表中去除（有点类似欧拉路径的优化）因为是层次图，不用担心dfs对第一个有效边数组的影响 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=2100; int hou[MAX_N*2],cur[MAX_N*2]; struct Edge&#123;int y,g,c;&#125;e[MAX_N*MAX_N+2*MAX_N]; int ln;int oth(int x) &#123;return x&amp;1?x+1:x-1;&#125; void ins(int x,int y,int c) &#123; e[++ln]=(Edge)&#123;y,hou[x],c&#125;;hou[x]=ln; e[++ln]=(Edge)&#123;x,hou[y],0&#125;;hou[y]=ln; &#125; int st,ed; int h[MAX_N*2]; queue&lt;int&gt; q; bool bfs() &#123; memcpy(cur,hou,sizeof hou); memset(h,0,sizeof h); q.push(st);h[st]=1; while(!q.empty()) &#123; int x=q.front();q.pop(); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(h[y]==0 and e[k].c&gt;0) &#123; h[y]=h[x]+1; q.push(y); &#125; &#125; &#125; return h[ed]&gt;0; &#125; int dfs(int x,int now) &#123; if(x==ed) return now; int all=0; for(int k=cur[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(h[y]==h[x]+1 and e[k].c&gt;0 and all&lt;now) &#123; int t=dfs(y,min(now-all,e[k].c)); all+=t;e[k].c-=t;e[oth(k)].c+=t; &#125; if(e[k].c==0) cur[x]=e[k].g; if(all==now) break;//剪枝1 &#125; if(all==0) h[x]=0;//剪枝2 return all; &#125; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); st=0;ed=n+m+1; int ans=0; for(int i=1;i&lt;=n;i++) &#123; int get;scanf("%d",&amp;get); ans+=get,ins(st,i,get); int k;scanf("%d",&amp;k); while(k--) &#123; int id,t;scanf("%d%d",&amp;id,&amp;t); ins(i,n+id,t); &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; int t;scanf("%d",&amp;t); ins(n+i,ed,t); &#125; while(bfs()) ans-=dfs(st,INF); printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>难度2</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bridges]]></title>
    <url>%2Fposts%2F85f0.html</url>
    <content type="text"><![CDATA[Source and JudgePoi2010bzoj3709 Record2h Analysis请先思考后再展开 这题有点东西（ozy语气） 显然先二分，终点是check其实就是验证一个混合图的欧拉回路考虑无向边，先钦定一个方向，到时候再考虑转向 条件：最后每个点的入度=出度而且是连通图（并查集一下即可） 考虑每次换向，相关的点，度的差会+2或者-2，所以说肯定不会差为奇数，要判一下然后这种决策性的问题，可以考虑网络流，假如钦定了x到y，则从y到x连一条边，表示转向，流量为1然后我们要平衡每个点的入度和出度，如果入度多出来，连向起点，流量为需要转向相关的次数即 $(in-out)/2$否则连向终点，表示一种需要平衡的状态最后如果能跑满流，意味着流量的平衡 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=1100; int hou[MAX_N]; struct Edge&#123;int y,g,c;&#125;e[MAX_N*10]; int ln;int oth(int x) &#123;return x&amp;1?x+1:x-1;&#125; void ins(int x,int y,int c) &#123; e[++ln]=(Edge)&#123;y,hou[x],c&#125;;hou[x]=ln; e[++ln]=(Edge)&#123;x,hou[y],0&#125;;hou[y]=ln; &#125; int st,ed; int h[MAX_N*2]; queue&lt;int&gt; q; bool bfs() &#123; memset(h,0,sizeof h); q.push(st);h[st]=1; while(!q.empty()) &#123; int x=q.front();q.pop(); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(h[y]==0 and e[k].c&gt;0) &#123; h[y]=h[x]+1; q.push(y); &#125; &#125; &#125; return h[ed]&gt;0; &#125; int dfs(int x,int now) &#123; if(x==ed) return now; int all=0; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(h[y]==h[x]+1 and e[k].c&gt;0 and all&lt;now) &#123; int t=dfs(y,min(now-all,e[k].c)); all+=t;e[k].c-=t;e[oth(k)].c+=t; &#125; &#125; if(all==0) h[x]=0; return all; &#125; int n,m; int a[MAX_N*2],b[MAX_N*2],c[MAX_N*2],d[MAX_N*2]; int in[MAX_N],out[MAX_N]; int fa[MAX_N]; int findfa(int x) &#123;return x==fa[x]?x:(fa[x]=findfa(fa[x]));&#125; void join(int x,int y) &#123;x=findfa(x);y=findfa(y);if(x!=y) fa[x]=y;&#125; bool check(int mid) &#123; memset(in,0,sizeof in); memset(out,0,sizeof out); for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=m;i++) &#123; if(c[i]&lt;=mid) out[a[i]]++,in[b[i]]++,join(a[i],b[i]); else if(d[i]&lt;=mid) out[b[i]]++,in[a[i]]++,join(a[i],b[i]); else return 0; //注意双向边要钦定 &#125; for(int i=2;i&lt;=n;i++) if(findfa(i)!=findfa(i-1)) return 0; ln=0;memset(hou,0,sizeof hou); int tot=0; st=0,ed=n+1; for(int i=1;i&lt;=n;i++) &#123; if((in[i]-out[i])%2) return 0; if(in[i]&gt;out[i]) ins(st,i,(in[i]-out[i])/2),tot+=(in[i]-out[i])/2; if(in[i]&lt;out[i]) ins(i,ed,(out[i]-in[i])/2); &#125; for(int i=1;i&lt;=m;i++) if(c[i]&lt;=mid and d[i]&lt;=mid) ins(b[i],a[i],1);//钦定a-&gt;b while(bfs()) dfs(st,INF); for(int k=hou[st];k&gt;0;k=e[k].g) if(e[k].c!=0) return 0;//满流 return 1; &#125; void main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf("%d%d%d%d",&amp;a[i],&amp;b[i],&amp;c[i],&amp;d[i]); int l=0,r=1000,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; if(ans&lt;0) puts("NIE"); else printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>难度2</tag>
        <tag>欧拉路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[联盟]]></title>
    <url>%2Fposts%2F699c.html</url>
    <content type="text"><![CDATA[Source and Judge雅礼noip模拟题 问题给出一棵树，可以断开再连接一条边，求最小直径，n小于300000要求输出最小直径，和最优方案中所有可能断开的边，然后输出一组断开和连接的具体方案 Record7h Analysis请先思考后再展开 真tm佩服我的耐心都快忘记最初的思路了……太可怕了做法繁琐，细节无数，码量巨大，不愧是雅礼的防ak题 果然直径有很多性质，特别好用，虽然不会证明 就是两棵树合并起来，新的直径端点一定是在原本两边直径端点中产生 然后最优的连接方案一定是将两边直径的中点连接起来，这个倒好证明一点，连接其他地方一定不会更优$L=max(L1,L2,\lceil \frac{L1}{2} \rceil+\lceil \frac{L2}{2} \rceil+1)$ 考虑枚举每条边，断开他，然后问题变成求两边的直径，这个在处理了dfs序以后是可以用线段树维护的（注意，为了确保任何区间都能形成联通块，要回溯，这个在st表用深度求lca时也要用到）相当于，只用这段区间内的点，形成的树的直径，利用上面说的那个性质1合并（记录具体端点） 理论复杂度nlogn，但实际上因为结构体的维护，常数巨大，需要卡常本题有线性做法，感觉很繁琐，就没去搞 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;namespace mine&#123; const int MAX_N=310000; const int INF=0x3f3f3f3f; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; int hou[MAX_N],dep[MAX_N],faid[MAX_N],ff[MAX_N];//连向父亲的边的编号 struct Edge&#123;int y,g;&#125;e[MAX_N*2]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; int d1[MAX_N],d2[MAX_N],id=0; int h[MAX_N*2][25]; void dfs(int x,int fa) &#123; dep[x]=dep[fa]+1;ff[x]=fa; d1[x]=d2[x]=++id;h[id][0]=x; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; faid[y]=(k+1)/2;dfs(y,x); d2[x]=++id;h[id][0]=x;//确保连续的dfs序能联通 &#125; &#125; int getmin(int x,int y) &#123;return dep[x]&lt;dep[y]?x:y;&#125; int bin[40],log[MAX_N*2]; int getlca(int x,int y) &#123; x=d1[x];y=d2[y]; if(x&gt;y) swap(x,y);//debug int lg=log[y-x+1]; return getmin(h[x][lg],h[y-bin[lg]+1][lg]); &#125; int dis(int x,int y) &#123;return (x==0 or y==0)?INF:dep[x]+dep[y]-2*dep[getlca(x,y)];&#125; void preST() &#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; log[1]=0;for(int i=2;i&lt;MAX_N*2;i++) log[i]=log[i&gt;&gt;1]+1; dfs(1,0); for(int i=1;bin[i]&lt;=id;i++) for(int x=1;x&lt;=id-bin[i]+1;x++) h[x][i]=getmin(h[x][i-1],h[x+bin[i-1]][i-1]); &#125; struct Data&#123;int x,y;&#125;; Data getmax(Data a,Data b) &#123;return dis(a.x,a.y)&gt;dis(b.x,b.y)?a:b;&#125; Data merg(Data x,Data y) &#123; int a=x.x,b=x.y,c=y.x,d=y.y; if(a==0 and b==0) return y; if(c==0 and d==0) return x; Data now=getmax((Data)&#123;a,b&#125;,(Data)&#123;a,c&#125;); now=getmax(now,(Data)&#123;a,d&#125;); now=getmax(now,(Data)&#123;b,c&#125;); now=getmax(now,(Data)&#123;b,d&#125;); return getmax(now,(Data)&#123;c,d&#125;); &#125; Data zj[MAX_N*2*4]; struct SegmentTree &#123; #define lc 2*x #define rc 2*x+1 void build(int x,int l,int r) &#123; if(l==r) &#123;zj[x]=(Data)&#123;h[l][0],h[l][0]&#125;;return;&#125; int mid=(l+r)&gt;&gt;1; build(lc,l,mid);build(rc,mid+1,r); zj[x]=merg(zj[lc],zj[rc]); &#125; Data ask(int x,int l,int r,int fl,int fr) &#123; if(l==fl and r==fr) return zj[x]; int mid=(l+r)&gt;&gt;1; if(fr&lt;=mid) return ask(lc,l,mid,fl,fr); if(fl&gt;mid) return ask(rc,mid+1,r,fl,fr); return merg(ask(lc,l,mid,fl,mid),ask(rc,mid+1,r,mid+1,fr)); &#125; &#125;sgt; vector&lt;int&gt; output; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; preST(); sgt.build(1,1,id); //for(int i=1;i&lt;=n;i++) printf("%d:%d %d fm=%d\n",i,d1[i],d2[i],fm[i]); //printf("id=%d\n",id); int some;//one of result int ans=INF; for(int x=2;x&lt;=n;x++)//x-&gt;fa &#123; Data in=sgt.ask(1,1,id,d1[x],d2[x]); Data out=sgt.ask(1,1,id,1,d1[x]-1); if(d2[x]+1&lt;=id) out=merg(out,sgt.ask(1,1,id,d2[x]+1,id)); int ln1=dis(in.x,in.y),ln2=dis(out.x,out.y); int now=max( int(ceil((double)ln1/2)+ceil((double)ln2/2))+1,max(ln1,ln2) ); //printf("x=%d in=%d-&gt;%d=%d out=%d-&gt;%d=%d now=%d\n",x,in.x,in.y,ln1,out.x,out.y,ln2,now); if(now&lt;ans) &#123; ans=now;output.clear(); output.push_back(faid[x]);some=x; &#125; else if(now==ans) output.push_back(faid[x]); &#125; sort(output.begin(),output.end()); printf("%d\n%d ",ans,output.size()); for(int i=0;i&lt;(int)output.size();i++) printf("%d ",output[i]); int x=some; Data in=sgt.ask(1,1,id,d1[x],d2[x]); Data out=sgt.ask(1,1,id,1,d1[x]-1); if(d2[x]+1&lt;=id) out=merg(out,sgt.ask(1,1,id,d2[x]+1,id)); int a,b,ln1=dis(in.x,in.y),ln2=dis(out.x,out.y); for(int i=d1[x];i&lt;=d2[x];i++) if(myabs(dis(h[i][0],in.x)-dis(h[i][0],in.y))==(ln1&amp;1) and dis(h[i][0],in.x)+dis(h[i][0],in.y)==ln1) a=h[i][0]; for(int i=1;i&lt;=d1[x]-1;i++) if(myabs(dis(h[i][0],out.x)-dis(h[i][0],out.y))==(ln2&amp;1) and dis(h[i][0],out.x)+dis(h[i][0],out.y)==ln2) b=h[i][0]; for(int i=d2[x]+1;i&lt;=id;i++) if(myabs(dis(h[i][0],out.x)-dis(h[i][0],out.y))==(ln2&amp;1) and dis(h[i][0],out.x)+dis(h[i][0],out.y)==ln2) b=h[i][0]; printf("\n%d %d %d %d",x,ff[x],a,b); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蔬菜]]></title>
    <url>%2Fposts%2Fc8e3.html</url>
    <content type="text"><![CDATA[Source and Judge雅礼noip模拟题 问题给出一个矩阵，q次询问，求一个子矩阵中，每种颜色出现次数的平方和n和m在200以内，询问在100000以内 Record1h Analysis请先思考后再展开 这道题同时用到了多个思想显然先离散化一下 有一个子任务，可以给我们启示：颜色种类数比较少那我们可以给每种颜色处理一个二维前缀和 但如果比较多呢？有一个不好想的做法：对每种颜色的出现次数（总矩阵而言），分类讨论处理办法如果某种颜色数量多，意味着在总矩阵中份额大对于数量级达到T的颜色，只有 $\frac{n^2}{T}$ 种，这些是可以预处理前缀和的但对于零散的颜色，就要用另外一种思想了：平方和转点对数量也就是说，如果这些颜色的所有点内部形成点对那么每个询问就转化为一个四维偏序问题（询问为abcd）：$a \leq x1,x2 \leq b;c \leq y1,y2 \leq d$对于这种类型的颜色，处理所有点对，离线后将点对和询问混合再排序，那么就变成一个三位偏序问题，可以用三维树状数组搞这里有个细节，因为第一维我们用的是排序，但同时有可以去等，所以一定将具体类型作为第二关键字 接下来考虑复杂度零散的颜色即使有n方种，每次往前扫k个形成点对总时间为 $O(\frac{n^2}{T}(n^2+q)+(q+n^2T) log^3 n)$考虑均值不等式 $a+b \geq 2 \sqrt{ab}$ ，取等号当且仅当a=b，列等式计算得 $T=\sqrt{ \frac{n^2+q}{log^3 n} }$时间复杂度自行验证，通过计算知其也可以通过本题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; ll mysqr(ll x) &#123;return x*x;&#125; const int MAX_N=210; struct Nod&#123;int d,x,y;&#125;s[MAX_N*MAX_N]; bool cmp(Nod a,Nod b) &#123;return a.d&lt;b.d;&#125; int yz[MAX_N][MAX_N]; #define PR pair&lt;int,int&gt; #define FR first #define SE second vector&lt;PR&gt; old[MAX_N*MAX_N]; int bit[MAX_N][MAX_N][MAX_N]; int lowbit(int x) &#123;return x&amp;-x;&#125; void change(int x,int y,int z,int d) &#123; for(int a=x;a&lt;MAX_N;a+=lowbit(a)) for(int b=y;b&lt;MAX_N;b+=lowbit(b)) for(int c=z;c&lt;MAX_N;c+=lowbit(c)) bit[a][b][c]+=d; &#125; int ask(int x,int y,int z) &#123; int ans=0; for(int a=x;a&gt;=1;a-=lowbit(a)) for(int b=y;b&gt;=1;b-=lowbit(b)) for(int c=z;c&gt;=1;c-=lowbit(c)) ans+=bit[a][b][c]; return ans; &#125; int tot=0;ll ans[110000]; struct Node&#123;int x1,x2,y1,y2,id;&#125;p[MAX_N*MAX_N*20+100000];//id=询问编号 bool cmp2(Node a,Node b) &#123;return a.x1&gt;b.x1 or (a.x1==b.x1 and a.id&lt;b.id);&#125; void solve() &#123; sort(p+1,p+tot+1,cmp2); for(int u=1;u&lt;=tot;u++) &#123; if(p[u].id==0) change(p[u].x2,p[u].y1,p[u].y2,1); else ans[p[u].id]+=(ask(p[u].x2,200,p[u].y2)-ask(p[u].x2,p[u].y1-1,p[u].y2)); &#125; &#125; int rx; int num[MAX_N*MAX_N];//count times int sum[MAX_N][MAX_N];//二维前缀和 void main() &#123; int n,m,q;scanf("%d%d%d",&amp;n,&amp;m,&amp;q); double lg=log2(n); int k=sqrt( (double)(n*n+q)/lg/lg/lg );//mx=20 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; int t;scanf("%d",&amp;t); s[(i-1)*m+j]=(Nod)&#123;t,i,j&#125;; &#125; sort(s+1,s+n*m+1,cmp);rx=0; for(int i=1;i&lt;=n*m;i++) &#123; if(i==1 or s[i-1].d!=s[i].d) rx++; yz[s[i].x][s[i].y]=rx;num[rx]++; &#125; for(int i=1;i&lt;=q;i++) &#123; int a,b,c,d;scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d); p[++tot]=(Node)&#123;a,c,b,d,i&#125;; &#125; //大量部分 for(int u=1;u&lt;=rx;u++) &#123; if(num[u]&gt;=k) &#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+(yz[i][j]==u); for(int i=1;i&lt;=q;i++) &#123; int a=p[i].x1,b=p[i].y1,c=p[i].x2,d=p[i].y2; ans[i]+=mysqr(sum[c][d]-sum[a-1][d]-sum[c][b-1]+sum[a-1][b-1]); &#125; &#125; &#125; //零散部分 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; int now=yz[i][j]; if(num[now]&lt;k) &#123; old[now].push_back( make_pair(i,j) ); for(int u=0;u&lt;(int)old[now].size();u++) &#123; Node tmp=(Node)&#123; min(old[now][u].FR,i),max(old[now][u].FR,i), min(old[now][u].SE,j),max(old[now][u].SE,j),0&#125;; p[++tot]=tmp; if(u!=(int)old[now].size()-1) p[++tot]=tmp;//debug 自己算一次 &#125; &#125; &#125; solve(); for(int i=1;i&lt;=q;i++) printf("%lld\n",ans[i]); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>四维偏序</tag>
        <tag>分类处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【poj2057】The Lost House]]></title>
    <url>%2Fposts%2F4075.html</url>
    <content type="text"><![CDATA[Source and Judgepoj2057 Record2h Analysis请先思考后再展开 感觉这个期望的柿子很不好推啊，我也是看了提示才想到的提示：将以x为根节点的子树代价，分答案是否在其中考虑，其期望分别为f和g “贪婪的动态规划”论文上没有利用期望的线性性，而我感觉用的话容易理解一点……我的方程：$g(x)=\sum 2+有虫子则g(y)$假如我们已经知道某个遍历顺序（尝试顺序，可能走到一半出来）然后考虑枚举某个孩子，答案就在这里的贡献$f(x)=\sum 该后继状态发生的可能 \times 该状态的期望$$f(x)=\sum \frac{叶子数量}{总叶子数量} ( \sum( g(s_1 \to s_{i-1})+2 ) + f(y)+1 )$注意这里g的计算规则和上面g那个一样，根据虫子跳出，具体实现可以前缀和 然后因为题目保证孩子数量最大为8，可以预处理所有排列，可通过本题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=1100; int son[MAX_N][10]; struct Nod&#123;int s[10];&#125;now; vector&lt;Nod&gt; pl[10]; bool use[10]; void dfs(int n,int k) &#123; if(k==n+1) &#123;pl[n].push_back(now);return;&#125; for(int i=1;i&lt;=n;i++) if(!use[i]) use[i]=1,now.s[k]=i,dfs(n,k+1),use[i]=0; &#125; double f[MAX_N],g[MAX_N]; bool cz[MAX_N]; int leave[MAX_N]; void solve(int x) &#123; int snum=son[x][0]; if(snum==0) leave[x]=1; else &#123; for(int i=1;i&lt;=son[x][0];i++) &#123; int y=son[x][i]; solve(y); g[x]+=(cz[y]?0:g[y])+2; leave[x]+=leave[y]; &#125; for(int t=0;t&lt;(int)pl[snum].size();t++) &#123; double tmp=0,nowg=0; for(int i=1;i&lt;=snum;i++) &#123; int y=son[x][ pl[snum][t].s[i] ]; tmp+=(nowg+f[y]+1)*leave[y]; nowg+=(cz[y]?0:g[y])+2; &#125; f[x]=min(f[x],tmp/leave[x]); &#125; //printf("f[%d]=%lf g[x]=%lf\n",x,f[x],g[x]); &#125; &#125; void main() &#123; for(int i=1;i&lt;=8;i++) dfs(i,1); while(1) &#123; int n,rt;scanf("%d",&amp;n); if(n==0) break; memset(son,0,sizeof son); memset(leave,0,sizeof leave); for(int i=1;i&lt;=n;i++) &#123; int fa;char str[4];scanf("%d%s",&amp;fa,str); cz[i]=(str[0]=='Y'); if(fa&lt;0) rt=i; else son[fa][++son[fa][0]]=i; &#125; for(int i=1;i&lt;=n;i++) g[i]=0,f[i]=(son[i][0]==0)?0:INF; solve(rt); printf("%.4lf\n",f[rt]); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 其实还有更快的做法考虑相邻的两个，他们产生的贡献，=推推柿子，再交换一下，就会变成：g的贡献（g(x)+2，同样考虑虫子来计算），除以其叶子数量那么这个比较只和自己有关，可以直接排序 这样1000个孩子我都不怕了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=1100; int son[MAX_N][10]; double f[MAX_N]; int g[MAX_N]; bool cz[MAX_N]; int leave[MAX_N]; bool cmp(int a,int b) &#123;return double(g[a]+2)*leave[b]&lt;double(g[b]+2)*leave[a];&#125; void solve(int x) &#123; int snum=son[x][0]; if(snum==0) leave[x]=1; else &#123; for(int i=1;i&lt;=snum;i++) &#123; int y=son[x][i]; solve(y); leave[x]+=leave[y]; g[x]+=g[y]+2; &#125; sort(son[x]+1,son[x]+snum+1,cmp); double nowg=0; for(int i=1;i&lt;=snum;i++) &#123; int y=son[x][i]; f[x]+=(nowg+f[y]+1)*leave[y]; nowg+=g[y]+2; &#125; f[x]/=leave[x]; if(cz[x]) g[x]=0; &#125; &#125; void main() &#123; while(1) &#123; int n,rt;scanf("%d",&amp;n); if(n==0) break; memset(son,0,sizeof son); memset(leave,0,sizeof leave); memset(f,0,sizeof f); memset(g,0,sizeof g); for(int i=1;i&lt;=n;i++) &#123; int fa;char str[4];scanf("%d%s",&amp;fa,str); cz[i]=(str[0]=='Y'); if(fa&lt;0) rt=i; else son[fa][++son[fa][0]]=i; &#125; solve(rt); printf("%.4lf\n",f[rt]); &#125; &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>贪心</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折射]]></title>
    <url>%2Fposts%2Fedc4.html</url>
    <content type="text"><![CDATA[Source and Judge雅礼noip模拟题 问题给出n个点，计数有多少种方案满足：yj &lt; yj−1xj−2 &lt; xj &lt; xj−1 或 xj−1 &lt; xj &lt; xj−2空间128，时间1sn小于6000 Record1h Analysis请先思考后再展开 以我自然的思维，直接把y排序了，然后空间就被卡128MB了正解是把x从小到大排序，那么问题会转化为区间dp，只不过方向稍微有点不同本代码保留了逐步优化的痕迹，应该非常好懂12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=6100; struct Pt&#123;int x,y;&#125;p[MAX_N]; bool cmp(Pt a,Pt b) &#123;return a.x&lt;b.x;&#125; const int MOD=1e9+7; int get[2][MAX_N];//0左1右 //int f[MAX_N][MAX_N],get[2][MAX_N]; void mod(int &amp;a) &#123;if(a&gt;=MOD) a-=MOD;&#125; void main() &#123; freopen("refract.in","r",stdin); freopen("refract.out","w",stdout); int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].x,&amp;p[i].y); sort(p+1,p+n+1,cmp); int ans=n; for(int ln=2;ln&lt;=n;ln++) &#123; for(int i=1;i&lt;=n-ln+1;i++) &#123; int j=i+ln-1; if(p[i].y&lt;p[j].y) &#123; //for(int t=i+1;t&lt;=j-1;t++) if(p[t].y&lt;p[i].y) mod(f[i][j]+=f[t][i]); //mod(f[i][j]+=get[0][i]);mod(get[1][j]+=f[i][j]); int now=1;//f[1][j] mod(now+=get[0][i]);mod(get[1][j]+=now); mod(ans+=now); &#125; else &#123; //for(int t=i+1;t&lt;=j-1;t++) if(p[t].y&lt;p[j].y) mod(f[j][i]+=f[t][j]); //mod(f[j][i]+=get[1][j]);mod(get[0][i]+=f[j][i]); int now=1;//f[0][i] mod(now+=get[1][j]);mod(get[0][i]+=now); mod(ans+=now); &#125; &#125; &#125; printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2015 接水果]]></title>
    <url>%2Fposts%2F4478.html</url>
    <content type="text"><![CDATA[Source and JudgeHNOI2015 接水果 Record1h Analysis请先思考后再展开 目前见过最难的整体二分了，但也不是很难，可能是我刷题太少 包含这东西，很显然可以化化柿子，然后就是dfs序的一个矩形 问题转化为，求每个点，覆盖它的矩形中，第k大的整体第k大的查询，就是很套路二分以后，重点就是check，用小于mid的部分，询问被多少个覆盖掉那这个暴力搞得话例如cdq、树套树什么的……但都太复杂了没细想其实，终点在于它是一个矩形，可以扫描线搞 例如说拆成左线段和右线段，然后就变成修改和查询，然后就树状数组询问次数就好了]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>难度2</tag>
        <tag>整体二分</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适者]]></title>
    <url>%2Fposts%2F81f.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj4700 Record1h Analysis请先思考后再展开 神仙栋老师的比赛题 毫无疑问，应该先把血量转化为需要攻击的次数 先考虑一开始不杀人的情况设有相邻的两个，编号1号和2号，1号在2号前的必要条件是 $t[1] \cdot a[2]&lt;t[2] \cdot a[1]$其实这就是个性价比，比赛的时候顺利猜到结论……那么顺序就确定了 T表示时间的前缀和，A表示攻击力的后缀和然后时间总和就是 $\sum (t[i]-1) \times a[i] + t[i] \times A[i+1]$ 考虑杀死一个的情况，将每个人被秒杀的价值表示出来$c[i]=(T[i]-1) \times a[i] + t[i] \times A[i+1]$但两个（设为 x &lt; y ）怎么处理呢？$c[x]+c[y]-t[x] \cdot a[y]$前一个的决策影响后一个，如果直接枚举，好像也没有什么好办法 做法一把y固定，x的贡献就是一个关于ay的一次函数（直线）然后询问相当于找到与直线交点中y最大的那个有一种名为李超线段树的数据结构能很方便地维护其主要思路就是，记录当前区间内，完全覆盖的线段（本题是直线，不用考虑）中交mid最高的那个然后因为只能和当前层有关，只能标记永久化当一个线段被淘汰的时候，就往某个方向下传更新（自行推导具体方向）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=310000; struct Nod&#123;int a,t;ll c;&#125;s[MAX_N]; bool cmp(Nod a,Nod b) &#123;return a.a*b.t&gt;b.a*a.t;&#125; ll dairu(int id,int x) &#123;return s[id].c-(ll)x*s[id].t;&#125; struct SegmentTree &#123; int mx[MAX_N*4]; #define lc (2*x) #define rc (2*x+1) void change(int x,int l,int r,int id) &#123; ll l1=dairu(id,l),l2=dairu(mx[x],l); ll r1=dairu(id,r),r2=dairu(mx[x],r); if(l==r) &#123; if(l1&gt;l2) mx[x]=id; return; &#125; if(l1&gt;=l2 and r1&gt;=r2) &#123;mx[x]=id;return;&#125; else if(l2&gt;=l1 and r2&gt;=r1) return; else &#123; int mid=(l+r)/2; int mid1=dairu(id,mid),mid2=dairu(mx[x],mid); if(mid1&gt;=mid2) swap(id,mx[x]),swap(l1,l2);//向下传可能有用的sid if(l1&lt;=l2) change(rc,mid+1,r,id); else change(lc,l,mid,id); &#125; &#125; ll ask(int x,int l,int r,int pos) &#123; ll ans=dairu(mx[x],pos); if(l&lt;r) &#123; int mid=(l+r)/2; if(pos&lt;=mid) ans=max(ans,ask(lc,l,mid,pos)); else ans=max(ans,ask(rc,mid+1,r,pos)); &#125; return ans; &#125; &#125;sgt; ll T[MAX_N],A[MAX_N];//前缀时间，后缀攻击 void main() &#123; int n,atk;scanf("%d%d",&amp;n,&amp;atk); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;s[i].a,&amp;s[i].t),s[i].t=ceil((double)s[i].t/atk); sort(s+1,s+n+1,cmp); ll ans=0; for(int i=n;i&gt;=1;i--) A[i]=A[i+1]+s[i].a; for(int i=1;i&lt;=n;i++) &#123; T[i]=T[i-1]+s[i].t,s[i].c=(T[i]-1)*s[i].a+A[i+1]*s[i].t; ans+=ll(s[i].t-1)*s[i].a+A[i+1]*s[i].t; &#125; ll tmp=0; for(int y=1;y&lt;=n;y++) &#123; tmp=max(tmp,s[y].c+sgt.ask(1,1,10000,s[y].a)); sgt.change(1,1,10000,y); &#125; printf("%lld",ans-tmp); &#125;&#125;;int main()&#123; mine::main();&#125; 做法二其实看起来会联想到斜率优化的方程形式…… 同样是固定y，设有 a &lt; b则a更优秀的条件： $c[a]-t[a] \cdot a[y] &gt; c[b]-t[b] \cdot a[y]$如果 $t[a]-t[b]&gt;0,\frac{c[a]-c[b]}{t[a]-t[b]} &gt; a[y]$这个斜率是单调递增的，也就是一个下凸壳，具体证明可以随便画一个经典的凸三角 因为在原本的顺序上，t和a都不是单调的，所以相当于维护一个动态凸壳可以用平衡树搞，也可以用cdq 这里讲cdq的做法，因为比较短只考虑左边对右边的影响左边按照t降序，强行满足上面的条件右边按照a升序，那么单调队列的头是只会往后的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int MAX_N=310000;struct Nod&#123;int a,t;ll c;&#125;s[MAX_N];bool cmp(Nod a,Nod b) &#123;return a.a*b.t&gt;b.a*a.t;&#125;bool cmp2(Nod a,Nod b) &#123;return a.t&gt;b.t;&#125;bool cmp3(Nod a,Nod b) &#123;return a.a&lt;b.a;&#125;ll X(int a,int b) &#123;return (ll)s[a].t-s[b].t;&#125;ll Y(int a,int b) &#123;return s[a].c-s[b].c;&#125;ll mx=0;int que[MAX_N];void solve(int l,int r)&#123; if(l&gt;=r) return; int mid=(l+r)/2; solve(l,mid);solve(mid+1,r); sort(s+l,s+mid+1,cmp2);sort(s+mid+1,s+r+1,cmp3); int tou=1,wei=1;que[tou]=l; for(int now=l+1;now&lt;=mid;now++) &#123; while(tou&lt;wei and Y(que[wei-1],que[wei])*X(que[wei],now) &gt; Y(que[wei],now)*X(que[wei-1],que[wei]) ) wei--; //while(tou&lt;wei and slope(que[wei-1],que[wei])&gt;slope(que[wei],now)) wei--; que[++wei]=now; &#125; for(int y=mid+1;y&lt;=r;y++) &#123; while(tou&lt;wei and Y(que[tou],que[tou+1])&lt;X(que[tou],que[tou+1])*s[y].a) tou++; int x=que[tou];mx=max(mx,s[x].c+s[y].c-(ll)s[x].t*s[y].a); &#125;&#125;ll T[MAX_N],A[MAX_N];//前缀t，后缀aint main()&#123; int n,atk;scanf("%d%d",&amp;n,&amp;atk); for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;s[i].a,&amp;s[i].t); s[i].t=ceil((double)s[i].t/atk); &#125; sort(s+1,s+n+1,cmp); for(int i=n;i&gt;=1;i--) A[i]=A[i+1]+s[i].a; ll ans=0; for(int i=1;i&lt;=n;i++) &#123; T[i]=T[i-1]+s[i].t; s[i].c=(T[i]-1)*s[i].a+A[i+1]*s[i].t; ans+=ll(s[i].t-1)*s[i].a+A[i+1]*s[i].t; &#125; solve(1,n); printf("%lld",ans-mx);&#125; 左右两边关键字不同，怎么把log省掉呢？其实维护两个数组，要用哪个用哪个就好了……123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int MAX_N=310000;struct Nod&#123;int a,t;ll c;&#125;s[MAX_N],s2[MAX_N],tmp[MAX_N];bool cmp(Nod a,Nod b) &#123;return a.a*b.t&gt;b.a*a.t;&#125;ll X(int a,int b) &#123;return (ll)s[a].t-s[b].t;&#125;ll Y(int a,int b) &#123;return s[a].c-s[b].c;&#125;ll mx=0;int que[MAX_N];void cdq(int l,int r)&#123; if(l&gt;=r) return; int mid=(l+r)/2; cdq(l,mid);cdq(mid+1,r); int tou=1,wei=1;que[tou]=l; for(int now=l+1;now&lt;=mid;now++) &#123; while(tou&lt;wei and Y(que[wei-1],que[wei])*X(que[wei],now) &gt; Y(que[wei],now)*X(que[wei-1],que[wei]) ) wei--; //while(tou&lt;wei and slope(que[wei-1],que[wei])&gt;slope(que[wei],now)) wei--; que[++wei]=now; &#125; for(int y=mid+1;y&lt;=r;y++) &#123; while(tou&lt;wei and Y(que[tou],que[tou+1]) &lt; X(que[tou],que[tou+1])*s2[y].a) tou++; int x=que[tou];mx=max(mx,s[x].c+s2[y].c-(ll)s[x].t*s2[y].a); &#125; //t递减 &#123; for(int i=l;i&lt;=r;i++) tmp[i]=s[i]; int now=l,now1=l,now2=mid+1; while(now1&lt;=mid and now2&lt;=r) &#123; if(tmp[now1].t&gt;=tmp[now2].t) s[now++]=tmp[now1++]; else s[now++]=tmp[now2++]; &#125; for(int i=now1;i&lt;=mid;i++) s[now++]=tmp[i]; for(int i=now2;i&lt;=r;i++) s[now++]=tmp[i]; &#125; //a递增 &#123; for(int i=l;i&lt;=r;i++) tmp[i]=s2[i]; int now=l,now1=l,now2=mid+1; while(now1&lt;=mid and now2&lt;=r) &#123; if(tmp[now1].a&lt;=tmp[now2].a) s2[now++]=tmp[now1++]; else s2[now++]=tmp[now2++]; &#125; for(int i=now1;i&lt;=mid;i++) s2[now++]=tmp[i]; for(int i=now2;i&lt;=r;i++) s2[now++]=tmp[i]; &#125;&#125;ll T[MAX_N],A[MAX_N];//前缀t，后缀aint main()&#123; int n,atk;scanf("%d%d",&amp;n,&amp;atk); for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;s[i].a,&amp;s[i].t); s[i].t=ceil((double)s[i].t/atk); &#125; sort(s+1,s+n+1,cmp); for(int i=n;i&gt;=1;i--) A[i]=A[i+1]+s[i].a; ll ans=0; for(int i=1;i&lt;=n;i++) &#123; T[i]=T[i-1]+s[i].t; s[i].c=(T[i]-1)*s[i].a+A[i+1]*s[i].t; ans+=ll(s[i].t-1)*s[i].a+A[i+1]*s[i].t; &#125; memcpy(s2,s,sizeof s); cdq(1,n); printf("%lld",ans-mx);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>贪心</tag>
        <tag>动态凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Wf2016】Swap Space【PA2014】Bohater]]></title>
    <url>%2Fposts%2F2c33.html</url>
    <content type="text"><![CDATA[Source and JudgeWf2016 Swap SpacePA2014 Bohaterbzoj3709bzoj1495 Record30min Analysis请先思考后再展开 神仙栋老师的比赛题然后发现对于下降的类型，按b降序能过样例和随便手出的数据写一发，和其他策略对拍也没错，然后就顺利瞎jb过了…… 赛后补一发证明（忽略相等情况等细节）：设有1号和2号，满足 $a1&gt;b1,a2&gt;b2,b1&gt;b2$$A=max(a1,a1-b1+a2)$$B=max(a2,a2-b2+a1)$仅当 $A&lt;B$ 时，1号放在2号前面 情况1$a1&lt;a2$ 此时1号优 情况2$a1&gt;a2$① $b1&lt;a2$$a1&gt;a2&gt;b2$$A=a1-b1+a2$$B=a2-b2+a1$则1号优 ② $b1&gt;a2$$a1&gt;b1&gt;a2&gt;b2$$A=a1$$B=a2-b2+a1$则1号优 综上所述，b越大越应该放在前面]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC41】最短路]]></title>
    <url>%2Fposts%2Fabe2.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC41 Record1h Analysis请先思考后再展开 暴力分是个经典套路，居然忘记了……参见 WC2011 最大XOR和路径，之前写过题解的就是把每条环的异或和放到线性基里面 正解感觉不太好想，不过被xgc大爷秒了就是给r排序，然后不同的线性基只有30个用链表动态维护好左边的每一个位置（记录left表示最后一个有贡献的位置）询问的时候30+30找到包含的第一个查询的时候，因为左边的线性基会包含右边的，从右往左扫，现在插入的num不断少个1，具有单调性这样乍一看是log方的，但如果预处理出每个数的最高位的位置，insert的时候从那里开始，就log的复杂度了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=310000; struct Nod &#123; int hou; int dis;//xor Nod() &#123;hou=dis=0;&#125; &#125;p[MAX_N]; struct Edge&#123;int y,g,c;&#125;e[MAX_N*2]; int ln=0;void ins(int x,int y,int c) &#123;e[++ln]=(Edge)&#123;y,p[x].hou,c&#125;;p[x].hou=ln;&#125; void dfs(int x,int fa) &#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; p[y].dis=p[x].dis^e[k].c;dfs(y,x); &#125; &#125; int bin[40],Log[70000]; int hbit(int num) &#123;return (num&gt;bin[16])?(16+Log[num/bin[16]]):Log[num];&#125; struct Lin &#123; int nxt,left;//链表 int lin[40]; void init(int ll,int num)//num&gt;0 &#123; memset(lin,0,sizeof lin);left=ll; lin[hbit(num)]=num; &#125; int insert(int num)//return 剩下 &#123; while(num&gt;0) &#123; int t=hbit(num); if(lin[t]==0) &#123;lin[t]=num;return num;&#125; num^=lin[t]; &#125; return 0;//fail &#125; int quary(int num)//min xor &#123; for(int i=30;i&gt;=0;i--) if(num&amp;bin[i]) num^=lin[i]; return num; &#125; &#125;lb[40]; int id=0,rt=0; void insert(int pos,int num)//log &#123; if(num==0) return; int now=rt,lst=-1,backup=num; while(now&gt;0) &#123; num=lb[now].insert(num); if(num==0) break; lst=now;now=lb[now].nxt; &#125; if(lst&lt;0 and rt&gt;0) return;//空是允许的 if(num==0) &#123; lb[lst].nxt=lb[now].nxt; lb[lst].left=lb[now].left;//debug 延长 lb[now].nxt=rt;rt=now; &#125; else//线性无关，新的贡献 &#123; lb[++id].nxt=rt;rt=id; &#125; lb[rt].init(pos,backup);//backup&gt;0 &#125; int quary(int left,int num)//log &#123; int now=rt;while(left&lt;lb[now].left) now=lb[now].nxt;//包含 //这里其实很奇怪，在我理解中应该是now的后一个才对 return lb[now].quary(num); &#125; int get[MAX_N];//环的贡献 struct Qes&#123;int id,left,now;&#125;; vector&lt;Qes&gt; qq[MAX_N];//according to right point int ans[MAX_N]; void main() &#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; Log[1]=0;for(int i=2;i&lt;70000;i++) Log[i]=Log[i&gt;&gt;1]+1; int n,m,q;scanf("%d%d%d",&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=n-1;i++) &#123;int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c);ins(x,y,c);ins(y,x,c);&#125; dfs(1,0); for(int i=1;i&lt;=m;i++) &#123;int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c);get[i]=p[x].dis^p[y].dis^c;&#125; for(int i=1;i&lt;=q;i++) &#123; int st,ed,l,r;scanf("%d%d%d%d",&amp;st,&amp;ed,&amp;l,&amp;r); qq[r].push_back( (Qes)&#123;i,l,p[st].dis^p[ed].dis&#125; ); &#125; for(int r=1;r&lt;=m;r++) &#123; insert(r,get[r]); for(int t=0;t&lt;(int)qq[r].size();t++) ans[qq[r][t].id]=quary(qq[r][t].left,qq[r][t].now); &#125; for(int i=1;i&lt;=q;i++) printf("%d\n",ans[i]); &#125;&#125;;int main()&#123; mine::main();&#125;其实还有更简单的写法……根本不需要30个线性基，也不需要预处理什么的只维护一个线性基，每个数位存储值和能产生贡献的最后那个位置然后回答询问的时候判断其位置能否消除我的1即可]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线性基</tag>
        <tag>难度2</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC40】Erlang]]></title>
    <url>%2Fposts%2Fcc15.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC40 Record1h Analysis请先思考后再展开 一开始看错题意了，决策可以是动态的，根据取出来的数再决定下一步 如果是静态的话，显然最多搞两个集合考虑枚举每一种颜色一、如果某个集合有多个，贡献为 len-其他种类+2（取光其他所有才出来）二、分开来， len-其他种类+1 最少的两个之和（最后才出来）时间复杂度n 其实改成动态并不难，最多搞两个集合这个性质依然是对的，但不能再枚举具体颜色了一、如果某个集合有多个，贡献为 颜色种类+1二、分开来这里是难点自己曾想到一种情况，但不知道怎么解决：可能我后面取出来的答案即使加上取出来的消耗依然比早出来的小然后看到动态决策就很蒙蔽，不知道怎么处理…… 其实很容易证明，最坏情况一定是按贡献从大到小出来的用微扰可以证明，其他的情况都会比这个更优所以排序后每个的贡献就很明确了，即【存在此颜色的所有集合中，除了这个之外，最小的 其他颜色个数+1】（这里我们不再考虑，因为取到别的相同颜色而停止的情况，因为在前面已经计算过了） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=510000; int cc[MAX_N];bool cmp(int a,int b) &#123;return a&gt;b;&#125; int mi[MAX_N],mi2[MAX_N]; void insert(int num,int c) &#123; //printf("num=%d c=%d\n",num,c); if(c&lt;mi[num]) mi2[num]=mi[num],mi[num]=c; else if(c&lt;mi2[num]) mi2[num]=c; &#125; vector&lt;int&gt; a[MAX_N]; int n,ans=INF; int ct[MAX_N];//值的出现情况 void solve() &#123; for(int i=1;i&lt;=n;i++) &#123; int tmp=0,m=(int)a[i].size(); for(int j=0;j&lt;m;j++) ct[a[i][j]]++; for(int j=0;j&lt;m;j++) &#123; int get=mi[a[i][j]]; if(get==m-ct[a[i][j]]+1) get=mi2[a[i][j]]; cc[++tmp]=get; &#125; for(int j=0;j&lt;m;j++) ct[a[i][j]]--; sort(cc+1,cc+tmp+1,cmp); for(int j=1;j&lt;=tmp;j++) ans=min(ans,cc[j]+j); &#125; if(ans==INF) puts("-1"); else printf("%d",ans); &#125; int ed[MAX_N]; int b[MAX_N];//集合的种类数 void main() &#123; memset(mi,63,sizeof mi); memset(mi2,63,sizeof mi2); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int m;scanf("%d",&amp;m); bool bk=0; for(int j=0;j&lt;m;j++) &#123; int t;scanf("%d",&amp;t); a[i].push_back(t);ed[t]=j; if(ct[t]==0) b[i]++; else bk=1; ct[t]++; &#125; if(bk) ans=min(ans,b[i]+1);//只选一个的情况 for(int j=0;j&lt;(int)a[i].size();j++) &#123; if(ed[a[i][j]]==j) insert(a[i][j],(int)a[i].size()-ct[a[i][j]]+1);//只插入一次 ct[a[i][j]]--; &#125; &#125; solve(); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOI2006】网络收费]]></title>
    <url>%2Fposts%2F51ff.html</url>
    <content type="text"><![CDATA[Source and JudgeNOI2006Luogu4297bzoj1495 Record1h Analysis请先思考后再展开 一开始没看懂题意……这里费用的计算，是对于所有的点对，而不是自己配对…… 因为是所有点对，观察系数，发现可以拆分到点权上预处理cost[x][j]表示x这个叶子节点，【与其lca在第j层】的节点的f之和那么如果知道了这个祖先管辖区域内哪种多，就能知道具体费用了 接下来基本上就等价于 JLOI2015 战争调度 了就是管理节点有两种类型，暴力枚举，背包时去除非法状态然后叶子节点也是两种，暴力向上统计 时间复杂度的话，$T(m)=4T(\frac{m}{2})+2m$设 $T(m)=1$ ，则根据主定理得 $T(m)=m^2$然后 $m=2^n,T(2^n)=2^{2n}$考虑到 $T(1)=n$ ，时间复杂度为 $O(n \times 2^{2n})$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC31】MST]]></title>
    <url>%2Fposts%2F381c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC31 Record3h Analysis请先思考后再展开 神仙题，%出题人这道题我能非常认同其做法，但我深知不是我能自己想出来的范围内 如果我按顺序枚举每一条边，那么非树边一定连接同一个块，而树边连接不同两个块因为每个节点都是一样的，用【每个大小的联通块数量】表示，这个状态总数是37338用这个状态的出现编号作为hash，那么就可以用这个来线性dp把状态按照【越大联通块是越前的关键字】排序，这样就能保证线性性然后顺序枚举每个状态，往后继状态转移为了方便找到对应的hash，建议用一个trie，因为map是其15倍（如果hash不稳……） 现在是 $O(n^4 \times 状态)$ 的，分情况加速考虑树边，枚举两个联通块然后合并起来，在这个过程中显然和具体边无关所以可以对于每个状态预处理，记录能否转移以及转移系数（这个自行推算）考虑非树边，因为是一个完全图，我们需要知道有哪些地方还能加入边注意到加入之后状态的表示没有变化，所以其实跟具体在哪个加入是没有关系的所以说，可以动态维护一个全局num数组，表示每个状态在当前可以加入的空位数量这个东西的维护可以自行推导 注意到一个重要的细节，也是我之前的疑惑之处就是我原本认为这个num应当是状态的一部分，但显然这样会炸其实你会发现，在外层枚举了边数之后，某个状态的num其实是确定的（从num的维护可以看出） 然后这道题就做了两天…… 计数dp中，滚动数组用完要清零 注意各种边界 其实这个num是可以不用dp的，不过我不想再花n的时间去计算num，好像ozy会很快的方法，不管了…… 时间复杂度的话，感觉是n三方的，而且个人感觉会跑满……然而最后还是O(能过)，可能会有更优秀的做法? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int n; //*******************State******************* struct Nod&#123;int num[41],pos;&#125;p[40000];//pos用于还原 bool cmp(Nod a,Nod b) &#123; for(int i=n;i&gt;=1;i--) if(a.num[i]!=b.num[i]) return a.num[i]&gt;b.num[i]; return 0; &#125; void output(Nod a) &#123; for(int j=1;j&lt;=n;j++) printf("%d ",a.num[j]); puts(""); &#125; //*******************Trie******************* struct Trie &#123; int hash; int son[41]; void clear() &#123;memset(son,0,sizeof son);&#125; &#125;tr[1500000]; int id=0; int findhash(Nod to) &#123; int now=0; for(int i=1;i&lt;=n;i++) &#123; int wt=tr[now].son[ to.num[i] ]; if(wt==0) return -1; now=wt; &#125; return tr[now].hash; &#125; int cnt=0,a[50]; void addhash() &#123; int now=0; for(int i=1;i&lt;=n;i++) &#123; if(tr[now].son[a[i]]==0) tr[now].son[a[i]]=++id,tr[id].clear(); now=tr[now].son[a[i]]; &#125; p[++cnt].pos=now; for(int i=1;i&lt;=n;i++) p[cnt].num[i]=a[i]; &#125; void dfs(int num,int now) &#123; if(now==0) &#123; if(num==0) addhash(); return; &#125; for(int i=0;i&lt;=num/now;i++) a[now]=i,dfs(num-now*i,now-1); &#125; //*******************prework******************* const ll MOD=1e9+7; int hou[40000]; struct Edge&#123;int y,g;int xs,adnum;&#125;;//系数、可用边数量的增加 vector&lt;Edge&gt; e;//O(开的下)…… void prework() &#123; e.push_back((Edge)&#123;0,0,0&#125;);//规避 编号0 for(int s=1;s&lt;=cnt;s++) &#123; Nod now=p[s]; for(int a=1;a&lt;=n-1;a++) if(now.num[a]&gt;0) for(int b=a;a+b&lt;=n;b++) if(now.num[b]&gt;(a==b)) &#123; int xs=(ll)a*b%MOD; if(a==b) xs=(ll)xs*(now.num[a]*(now.num[a]-1)/2)%MOD; else xs=(ll)xs*now.num[a]*now.num[b]%MOD;//有序数对 Nod tmp=now;tmp.num[a]--;tmp.num[b]--;tmp.num[a+b]++; int s2=findhash(tmp);if(s2&lt;0) continue; e.push_back( (Edge)&#123;s2,hou[s],xs,a*b-1&#125; );hou[s]=e.size()-1; &#125; &#125; &#125; //*******************DP******************* bool istree[50*50]; int f[2][40000],num[2][40000];//num用来简便计算 void solve() &#123; for(int i=1;i&lt;=n-1;i++) &#123;int t;scanf("%d",&amp;t);istree[t]=1;&#125; f[0][cnt]=1; for(int ln=1;ln&lt;=n*(n-1)/2;ln++) for(int s=1;s&lt;=cnt;s++) if(f[(ln-1)&amp;1][s])//01背包，自带滚动 &#123; if(istree[ln]) &#123; for(int k=hou[s];k&gt;0;k=e[k].g) &#123; int s2=e[k].y; f[ln&amp;1][s2]=(f[ln&amp;1][s2]+(ll)e[k].xs*f[(ln-1)&amp;1][s]%MOD)%MOD; num[ln&amp;1][s2]=num[(ln-1)&amp;1][s]+e[k].adnum;//覆盖无影响 &#125; &#125; else &#123; if(num[(ln-1)&amp;1][s]&gt;0) &#123; f[ln&amp;1][s]=(f[ln&amp;1][s]+(ll)f[(ln-1)&amp;1][s]*num[(ln-1)&amp;1][s]%MOD)%MOD; num[ln&amp;1][s]=num[(ln-1)&amp;1][s]-1; &#125; else f[ln&amp;1][s]=num[ln&amp;1][s]=0; &#125; f[(ln-1)&amp;1][s]=num[(ln-1)&amp;1][s]=0; &#125; &#125; void main() &#123; scanf("%d",&amp;n); tr[0].clear();dfs(n,n);sort(p+1,p+cnt+1,cmp); for(int i=1;i&lt;=cnt;i++) tr[p[i].pos].hash=i; prework();solve(); printf("%d",f[(n*(n-1)/2)&amp;1][1]); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC32】Sort]]></title>
    <url>%2Fposts%2Fbfa5.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC32 Record1h Analysis请先思考后再展开 思考排序本质的好题 先考虑只有0和1的做法考虑归并排序，那么一定是000000111110000001111这样的那么只要把中间的部分翻转就好了 回到原问题，回忆朴素的快排，找到一个基准点后，小的放左边，大的放右边，再搞一下去那这个过程可以转化为01序列然后套归并上去 不过这里会出现很多细节，比如132，就不能保证小的到左边如果变成0、1、2或许可以解决问题，但这样再归并会很麻烦一种巧妙的做法是基于值域分治（离散化后） 时间显然是log方的，现在让我们证明代价的复杂度（忽略常数） 归并：$T(n)=2T(\frac{n}{2})+n$根据主定理，$T(n)=nlogn$ 快排：$T_2(n)=2T_2(\frac{n}{2})+T(n)=2T_2(\frac{n}{2})+nlogn$那么每层是nlogn，然后有log层$T_2(n)=nlog^2n$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=51000; int n; int a[MAX_N]; void mergsort(int l,int r,int pt) &#123; if(l&gt;=r) return; int mid=(l+r)/2; mergsort(l,mid,pt);mergsort(mid+1,r,pt); int fl=l;while(a[fl]&lt;=pt and fl&lt;=mid) fl++; int fr=r;while(a[fr]&gt;pt and fr&gt;mid) fr--; if(fl&lt;fr) &#123; printf("%d %d\n",fl,fr); for(int i=fl;i&lt;=(fl+fr)/2;i++) swap(a[i],a[fl+fr-i]); &#125; &#125; void solve(int l,int r,int numl,int numr)//基于值域的快排 &#123; if(l&gt;=r or numl&gt;=numr) return; int pt=(numl+numr)/2; mergsort(l,r,pt); for(int t=l;t&lt;=r;t++)//divide point if(a[t]&lt;=pt and a[t+1]&gt;pt) &#123; solve(l,t,numl,pt);solve(t+1,r,pt+1,numr); break; &#125; &#125; struct Nod&#123;int d,p;&#125;p[MAX_N]; bool cmp(Nod a,Nod b) &#123;return a.d&lt;b.d;&#125; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]),p[i]=(Nod)&#123;a[i],i&#125;; sort(p+1,p+n+1,cmp); int rx=1;a[p[1].p]=rx; for(int i=2;i&lt;=n;i++) &#123; if(p[i-1].d!=p[i].d) rx++; a[p[i].p]=rx; &#125; solve(1,n,1,rx); puts("-1 -1"); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod刷题计划]]></title>
    <url>%2Fposts%2F8a7d.html</url>
    <content type="text"><![CDATA[刷atcoder的题解好像有点少……去刷51nod吧，好像很多是翻译成中文的原题 1 1051 最大子矩阵和9.25 难度1请先思考后再展开 二维版，套个一维的+前缀和就好了12345678910111213141516171819202122232425int a[MAX_N][MAX_N];ll sum[MAX_N][MAX_N];//向上前缀和void main()&#123; int m,n;scanf("%d%d",&amp;m,&amp;n); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;a[i][j]); for(int j=1;j&lt;=m;j++) for(int i=1;i&lt;=n;i++) sum[j][i]=sum[j][i-1]+a[i][j]; ll ans=0; for(int l=1;l&lt;=n;l++) for(int r=l;r&lt;=n;r++) &#123; ll now=0; for(int t=1;t&lt;=m;t++) &#123; if(now&lt;0) now=0; now+=sum[t][r]-sum[t][l-1]; ans=max(ans,now); &#125; &#125; printf("%lld",ans);&#125; 2 1020 逆序排列 HAOI2009 逆序对数列9.25 难度1请先思考后再展开 $f(n,k)=\sum_{i=0}^{n-1} f(n-1,k-i)$不能开ll，会被卡空间然后为了方便可以相邻做差，具体看代码12345678910111213141516171819202122const int MOD=1e9+7;int f[1001][20001];void main()&#123; f[1][0]=1; for(int n=2;n&lt;=1000;n++) &#123; f[n][0]=1; for(int k=1;k&lt;=20000 and k&lt;=n*(n-1)/2;k++) &#123; f[n][k]=(f[n][k-1]+f[n-1][k])%MOD; if(k-n&gt;=0) (f[n][k]-=f[n-1][k-n])%=MOD; &#125; &#125; int T;scanf("%d",&amp;T); while(T--) &#123; int n,k;scanf("%d%d",&amp;n,&amp;k); printf("%d\n",(f[n][k]+MOD)%MOD); &#125;&#125; 3 1674 区间的价值 V29.25 难度1请先思考后再展开 枚举每个l，然后向右看，计算贡献分开来考虑每个位，对于and只关心第一个1，or只关心or那么可以统计每个位的贡献，分成两部分的权值，最多共有60个不同的断点那么排序一下就好了，差分统计贡献 我真的好菜啊上一道题的maxn忘记改了……12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=110000; const int INF=0x3f3f3f3f; typedef long long ll; struct LJB &#123; int hou[MAX_N]; int to[MAX_N*2],g[MAX_N*2]; int ln;void ins(int x,int y) &#123;to[++ln]=y;g[ln]=hou[x];hou[x]=ln;&#125; LJB() &#123;ln=0;memset(hou,0,sizeof hou);&#125; &#125;E; const ll MOD=1000000007; struct Pos &#123; int p,op; ll c; &#125;p[200];//0-and 1-or bool cmp(Pos a,Pos b) &#123;return a.p&lt;b.p;&#125; int a[MAX_N]; int nx[40][MAX_N],lst[40][2]; int f[40][2];//指针 int bin[40]; void main() &#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); for(int j=0;j&lt;=30;j++) &#123; int t=(a[i]&amp;bin[j])&gt;0; if(f[j][t]==0) f[j][t]=i; nx[j][lst[j][t]]=i;lst[j][t]=i; &#125; &#125; for(int j=0;j&lt;=30;j++) &#123; nx[j][lst[j][0]]=n+1; nx[j][lst[j][1]]=n+1; if(f[j][0]==0) f[j][0]=n+1; if(f[j][1]==0) f[j][1]=n+1; &#125; ll ans=0; for(int l=1;l&lt;=n;l++) &#123; int tot=0; int nowand=0,nowor=0; for(int j=0;j&lt;=30;j++) &#123; if(f[j][0]&gt;1) nowand+=bin[j],p[++tot]=(Pos)&#123;f[j][0],0,-bin[j]&#125;;//and p[++tot]=(Pos)&#123;f[j][1],1,bin[j]&#125;;//or f[j][(a[l]&amp;bin[j])&gt;0]=nx[j][l];//update &#125; sort(p+1,p+tot+1,cmp);p[tot+1].p=n; for(int i=1;i&lt;=tot;i++) &#123; if(p[i].p&gt;n) break;//debug if(p[i].op==0) nowand+=p[i].c; else nowor+=p[i].c; if(p[i].p==p[i+1].p) continue; ans=(ans+(ll)nowor*nowand%MOD*(p[i+1].p-p[i].p)%MOD)%MOD; &#125; &#125; printf("%lld",(ans+MOD)%MOD); &#125;&#125;int main()&#123; mine::main();&#125; 4 1675 序列变换9.26 难度2请先思考后再展开 莫反显然，但我发现我不会计算条件2……看题解，原来用个桶就好了，根据调和级数是log的12345678910111213141516171819202122int basket[MAX_N];ll F[MAX_N];int a[MAX_N],b[MAX_N];void main()&#123; pre(); int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;b[i]); for(int d=1;d&lt;=n;d++) &#123; for(int y=d;y&lt;=n;y+=d) basket[ b[a[y]] ]++; for(int x=d;x&lt;=n;x+=d) F[d]+=basket[ a[b[x]] ]; for(int y=d;y&lt;=n;y+=d) basket[ b[a[y]] ]=0;//保证复杂度 &#125; ll ans=0; for(int d=1;d&lt;=n;d++) ans+=(ll)mu[d]*F[d]; printf("%lld",ans);&#125; 5 1682 中位数计数9.26 难度2请先思考后再展开 又是巧妙地用桶，套路地转化为-1和1，然后找和为0123456789101112131415int a[MAX_N];int basket[MAX_N+MAX_N];void main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++) &#123; int ans=0;memset(basket,0,sizeof basket); for(int sum=0,j=i;j&gt;=1;j--) sum+=(a[j]&lt;a[i]?-1:(a[j]!=a[i])),basket[MAX_N+sum]++; for(int sum=0,j=i;j&lt;=n;j++) sum+=(a[j]&lt;a[i]?-1:(a[j]!=a[i])),ans+=basket[MAX_N-sum]; printf("%d ",ans); &#125;&#125; 6 1686 第K大区间9.26 难度2请先思考后再展开 我不会二分了怎么办……1234567891011121314151617181920212223242526272829303132333435363738394041424344int n;ll k;int a[MAX_N];int num[MAX_N];bool check(int mid)&#123; ll ans=0;memset(num,0,sizeof num); for(int l=1,r=0;l&lt;=n;num[a[l]]--,l++) &#123; if(l&gt;r) num[a[++r]]++; while(r+1&lt;=n) &#123; if(num[a[r+1]]+1&gt;mid) break; num[a[++r]]++; &#125; ans+=r-l+1; &#125; return ans&lt;=(ll)n*(n+1)/2-k;&#125;struct Nod&#123; int d,p;&#125;s[MAX_N];bool cmp(Nod a,Nod b) &#123;return a.d&lt;b.d;&#125;void main()&#123; scanf("%d%lld",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;s[i].d),s[i].p=i; sort(s+1,s+n+1,cmp); int rx=1;a[s[1].p]=rx; for(int i=2;i&lt;=n;i++) &#123; if(s[i-1].d!=s[i].d) rx++; a[s[i].p]=rx; &#125; int l=1,r=n,ans=0; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid-1)) ans=mid,l=mid+1; else r=mid-1; &#125; printf("%d",ans);&#125; 7 1052 最大M子段和9.26 难度1请先思考后再展开 显然的dp前缀和mx优化一下就好了123456789101112131415161718ll sum[MAX_N];ll f[MAX_N][2];ll mx[MAX_N][2];//前缀最大继承位置void main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;sum[i]),sum[i]+=sum[i-1]; for(int k=0;k&lt;=m;k++) &#123; for(int i=k;i&lt;=n;i++) &#123; if(k&gt;0) f[i][k&amp;1]=max(mx[i-1][(k-1)&amp;1]+sum[i],f[i-1][k&amp;1]); mx[i][k&amp;1]=max(mx[i-1][k&amp;1],f[i][k&amp;1]-sum[i]); &#125; &#125; printf("%lld",f[n][m&amp;1]);&#125; 8 1120 机器人走方格 V39.26 难度2请先思考后再展开 卡特兰数裸题1234567891011121314151617181920212223242526const int MOD=10007;int qpower(int x,int e)&#123; int ans=1;x%=MOD;//debug while(e&gt;0) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans;&#125;int inv(int x) &#123;return qpower(x,MOD-2);&#125;//is primeint fac[MOD+10];int C(int n,int m)&#123; if(n&lt;m) return 0; if(n&gt;=MOD or m&gt;=MOD) return C(n/MOD,m/MOD)*C(n%MOD,m%MOD)%MOD; return fac[n]*inv(fac[m])%MOD*inv(fac[n-m])%MOD;&#125;int Cat(int n) &#123;return C(2*n,n)*inv(n+1)%MOD;&#125;void main()&#123; fac[0]=1;for(int i=1;i&lt;=MOD;i++) fac[i]=fac[i-1]*i%MOD; int n;scanf("%d",&amp;n); printf("%d",Cat(n-1)*2%MOD);&#125; 9 1555 布丁怪9.29 难度2请先思考后再展开 本来以为这是一道找性质题，然后想了个错误的性质，就凉了…… 首先不难想到，问题会转化成，求一个序列的某一段，其中每个数都出现且仅出现一次，并且连续覆盖本来想着可能可以用什么巧妙的技巧去判断bitset中连续的1，但没什么想法…… 正解是转化为区间极值，让极值的差和长度差相同log方的话显然线段树但也可以分治，每一层，处理l和r不在相同区间的问题 这个极值挺麻烦的，用分情况讨论可以简化一、min和max都在左边，此时计算一下前缀后缀与mid的极值即可快速计算二、min在左边，max在右边，此时需要用两个尺取法，同时维护，并用桶维护公共区间 另外的两种情况是镜像问题，可以通过 【翻转序列+调整mid】 简化代码复杂度12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=310000; int a[MAX_N]; ll ans=0; int basket[MAX_N*2]; int mx[MAX_N],mi[MAX_N];//与mid的前后缀极值 void solve(int fl,int fr,int op) &#123; if(fl&gt;=fr) return; int mid=(fl+fr-op)/2;//处理l和r不同区间的情况 mx[mid]=mi[mid]=a[mid];for(int i=mid-1;i&gt;=fl;i--) mx[i]=max(mx[i+1],a[i]),mi[i]=min(mi[i+1],a[i]); mx[mid+1]=mi[mid+1]=a[mid+1];for(int i=mid+2;i&lt;=fr;i++) mx[i]=max(mx[i-1],a[i]),mi[i]=min(mi[i-1],a[i]); //1. 都在左边 for(int l=fl;l&lt;=mid;l++) &#123; int r=mx[l]-mi[l]+l; ans+=(mx[r]&lt;mx[l] and mi[r]&gt;mi[l] and mid+1&lt;=r and r&lt;=fr);//debug 没有判断越界！ &#125; //2. 左min右max for(int l=fl,mir=fr,mxr=fr+1;l&lt;=mid;l++) &#123; while(mir&gt;=mid+1 and mi[mir]&lt;mi[l]) basket[MAX_N+mir-mx[mir]]--,mir--; while(mxr-1&gt;=mid+1 and mx[mxr-1]&gt;mx[l]) mxr--,basket[MAX_N+mxr-mx[mxr]]++; ans+=(mxr&lt;=mir?basket[MAX_N+l-mi[l]]:0); &#125; for(int i=mid+1;i&lt;=fr;i++) basket[MAX_N+i-mx[i]]=0; solve(fl,mid,op);solve(mid+1,fr,op); &#125; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123;int x,y;scanf("%d%d",&amp;x,&amp;y);a[x]=y;&#125; solve(1,n,0); for(int i=1;i&lt;=n/2;i++) swap(a[i],a[n-i+1]); solve(1,n,1); printf("%lld",ans+n); &#125;&#125;int main()&#123; mine::main();&#125; 10 1125 交换机器的最小代价10.1 难度2请先思考后再展开 每个位置向它想去的点连边，那么因为每个点出度和入度都是1，一定是若干个环组成的对于每个环，有两种策略一、用内部最小的节点逛一圈二、用外部最小的节点逛一圈再回去 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=51000; struct Nod&#123;int d,p;&#125;p[MAX_N]; bool cmp(Nod a,Nod b) &#123;return a.d&lt;b.d;&#125; int to[MAX_N]; bool v[MAX_N]; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); p[i]=(Nod)&#123;t,i&#125;; &#125; sort(p+1,p+n+1,cmp); for(int i=1;i&lt;=n;i++) to[p[i].p]=i; ll ans=0; for(int st=1;st&lt;=n;st++) if(!v[st] and to[st]!=st) &#123; v[st]=1; int t=st,mi=p[to[t]].d,ln=1; while(to[t]!=st) t=to[t],v[t]=1,ans+=p[to[t]].d,mi=min(mi,p[to[t]].d),ln++; //ans+=p[to[st]].d+min((ll)mi*(ln-2),(ll)p[1].d*(ln+1)); debug ans+=p[to[st]].d+min((ll)mi*(ln-2),(ll)p[1].d*(ln+1)+mi); &#125; printf("%lld",ans); &#125;&#125;;int main()&#123; mine::main();&#125; 11 1131 覆盖数字的数量10.1 难度2请先思考后再展开 根据 $num\%a \leq b-a+1$ 可知能表示的区间一定是用 $ka \to kb$ 组成的然后当k达到一定大小后，后面都会重叠，所以二分k，前面等差数列，后面连续 打这个细节多到吃屎……1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const double eps=1e-3; ll solve(ll A,ll B) &#123; ll l=1,r=1ll&lt;&lt;60,ans=-1; while(l&lt;=r+eps) &#123; ll mid=(l+r)/2; if( (double)mid*B&gt;=double(mid+1)*A-1-eps ) ans=mid,r=mid-1; else l=mid+1; &#125; return ans; &#125; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; ll A,B,X,Y;scanf("%lld%lld%lld%lld",&amp;A,&amp;B,&amp;X,&amp;Y);//debug 爆ll if(A&lt;=X and Y&lt;=B) &#123;printf("%lld\n",Y-X+1);continue;&#125; ll k=solve(A,B);//k~INF ll ans=0; ll st=X/A,ed=min(Y/A,k-1); if(st&lt;=ed) &#123; if((double)st*B&gt;=X-eps) ans+=min(st*B,Y)-X+1; st+=1; if((double)ed*B&gt;Y+eps) ans+=Y-max(X,ed*A)+1,ed-=1; ans+=(double)(st+ed)*(ed-st+1)/2*(B-A)+(ed-st+1); &#125; k=max(k,st);k=min(k,ed+1); if((double)A*k&lt;=Y) ans+=Y-max(A*k,X)+1;//连续 printf("%lld\n",ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 12 1189 阶乘分数10.3 难度2请先思考后再展开 bzoj2721 感觉我不可能想到……$n!(x+y)=xy,x&gt;n!,y&gt;n!$$y=n!+z$$x=\frac{(n!)^2}{z} + n!$$ans=(n!)^2 的约数$那么筛一下最小质因子，套个公式就好了 13 1201 整数划分10.16 难度2请先思考后再展开 好像又被套路了感觉这种思路非常难想主要是因为互不相同，你可以维护一个相对大小关系，这个关系一定是从1开始的然后经过一系列的整体增加1得到当前的方案那么现在dp，要么群体加1，要么群体加1然后前面插入一个1，总是能保证互不相同的12345678910111213const int MOD=1e9+7;int f[330][51000];void main()&#123; int n;scanf("%d",&amp;n); f[0][0]=1; for(int ln=1;ln&lt;=320;ln++) for(int num=1;num&lt;=n;num++) if(num&gt;=ln) f[ln][num]=(f[ln-1][num-ln]+f[ln][num-ln])%MOD; int ans=0; for(int ln=1;ln&lt;=320;ln++) (ans+=f[ln][n])%=MOD; printf("%d",ans);&#125; 14 1215 数组的宽度10.16 难度2请先思考后再展开 被lxj锤爆了，只会分治的nlogn做法处理出min和max下，每个数能覆盖的范围然后柿子是可以拆开来的，min和max拆开统计就行了 15 1217 Minimum Modular CF303C10.16 难度2请先思考后再展开 感觉这题有点难度考虑相等的二元组， $a_i=a_j (\% m)$如果枚举每个m，那么他们的差一定是m的倍数（包括0）那么如果存储差，通过枚举m的倍数，就能得到所有的数对，而且是mlogm的注意到k很小，数对显然不会超过 $k(k+1)/2$ 对，是很强力的剪枝对于每一种实际的余数，第一个不需要删除，可以用链表拿出所有点对，进行计算该做法的复杂度是有保证的，但常数略大，很容易被暴力枚举n的做法吊锤，而且还被卡空间…… 故本代码暂时没ac，但一定是正确的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=5001; int n,k; #define pr pair&lt;short,short&gt;//卡空间 #define FR first #define SE second vector&lt;pr&gt; ct[1000010]; int a[MAX_N]; bool in[MAX_N];bool v[1100000];//实际余数的存在性 int all; int tmp[100];//撤回操作 void put(int x,int m) &#123; if(!in[x]) &#123; in[x]=1; tmp[++tmp[0]]=x; if(!v[a[x]%m]) v[a[x]%m]=1;else all++; &#125; &#125; void erase(int x,int m) &#123;v[a[x]%m]=0;in[x]=0;&#125; int solve() &#123; for(int m=1;m&lt;=1000001;m++) &#123; int tot=0; for(int now=0;now&lt;=1000001;now+=m) tot+=ct[now].size(); if(tot&gt;k*(k+1)/2) continue;//最坏情况 //利用k剪枝 all=0;tmp[0]=0; for(int now=0;now&lt;=1000001;now+=m) for(int t=0;t&lt;(int)ct[now].size();t++) put(ct[now][t].FR,m),put(ct[now][t].SE,m); for(int t=1;t&lt;=tmp[0];t++) erase(tmp[t],m); if(all&lt;=k) return m; &#125; return -1; &#125; void main() &#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) ct[abs(a[i]-a[j])].push_back( make_pair(i,j) ); printf("%d",solve()); &#125;&#125;;int main()&#123; mine::main();&#125; 16 1241 特殊的排序10.16 难度2请先思考后再展开 非常秒的思维题答案是，保留一段值连续数列，其他的一定存在一种方案，移动到左边或者右边所以线性dp一下就好了 17 1259 整数划分 V210.16 难度2请先思考后再展开 因为可以相同，数的数量会达到n可以巧妙地分块 只用1~T的数， $g(num)=\sum g(num-a)$ 用后面的数，那么这个部分，数的数量会在n/T以内，那么又可以用前面的做法了，不过不在需要保证互不相同了，在插入一个T+1的时候，其他不需要增加$f(i,num)=f(i-1,num-(T+1)),f(i,num-i)$答案就是其卷积12345678910111213141516171819const int MAX_N=51000;const ll MOD=1e9+7;ll g[MAX_N],f[320][MAX_N];void main()&#123; int n;scanf("%d",&amp;n);int T=sqrt(n); g[0]=1; for(int a=1;a&lt;=T;a++) for(int num=a;num&lt;=n;num++) g[num]=(g[num]+g[num-a])%MOD; f[0][0]=1; for(int i=1;i&lt;=n/T;i++) for(int num=i*(T+1);num&lt;=n;num++) f[i][num]=(f[i][num-i]+f[i-1][num-(T+1)])%MOD; int ans=0; for(int a=0;a&lt;=n;a++) for(int i=0;i&lt;=n/T;i++) (ans+=g[a]*f[i][n-a]%MOD)%=MOD; printf("%d",ans);&#125; 18 1262 扔球10.16 难度1请先思考后再展开 其实画这个图的途中，想了很多东西，最后的结论只和左下角那个反例有关那就是你必须经过这n+1个点！那画图的时候，我枚举了一个跨度，这也是灵感的来源这个跨度必须和n+1互质，用公式求一下欧拉函数即可ans=phi(n+1) 19 1273 旅行计划10.17 难度2请先思考后再展开 我的思路，下限nlogn：维护一个线段树表示，以dfs序为编号，每个点到根的距离然后动态选取最大的那个，把这条链并到根节点，合并的途中影响的总是子树整体，dfs序上是连续的然后每个节点只会被合并一次，所以是nlogn 正解，下限n：显然选择的点总是叶子节点，每个节点只会被一个叶子节点覆盖，父亲节点被覆盖的候选总是在儿子节点中产生，dfs回溯的时候处理即可最后再把叶子排序即可 20 1274 最长递增路径10.17 难度2请先思考后再展开 性质1： 一条边最多经过1次性质2：路径上边权严格递增将每条边排序，然后加入图中，此时一定是路径的最后一条（严格递增），没有后效性，可以直接转移（但为了保证严格单调，需要将同权值的边分组，滚动一下即可） 21 1277 字符串中的最大值10.17 难度2请先思考后再展开 kmp$f(nxt[i])+=f(i)$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=110000; int ln; char s[MAX_N]; int nxt[MAX_N]; void getnext() &#123; nxt[1]=0; for(int i=2;i&lt;=ln;i++) &#123; int j=nxt[i-1]; while(j!=0 and s[j+1]!=s[i]) j=nxt[j]; if(s[j+1]==s[i]) nxt[i]=j+1; else nxt[i]=j; &#125; &#125; int num[MAX_N]; void main() &#123; scanf("%s",s+1);ln=strlen(s+1); getnext(); ll ans=0; for(int i=ln;i&gt;=1;i--) &#123; num[i]+=1; num[nxt[i]]+=num[i]; ans=max(ans,(ll)num[i]*i); &#125; printf("%lld",ans); &#125;&#125;;int main()&#123; mine::main();&#125; 22 1293 球与切换器10.17 难度2请先思考后再展开 这是一道sb题，但我也是个sb……唯一提示：可以看作所有球同时放进去1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=1100; int mp[MAX_N][MAX_N]; ll f[MAX_N][MAX_N][2];//0上1左 void main() &#123; int m,n;scanf("%d%d%lld",&amp;m,&amp;n,&amp;f[1][1][0]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;mp[i][j]); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; if(mp[i][j]==0) &#123; f[i+1][j][0]+=f[i][j][0]; f[i][j+1][1]+=f[i][j][1]; &#125; else &#123; ll sum=f[i][j][0]+f[i][j][1]; f[i][j+1][1]+=sum/2+(sum&amp;1 and mp[i][j]&gt;0); f[i+1][j][0]+=sum/2+(sum&amp;1 and mp[i][j]&lt;0); &#125; &#125; &#125; printf("%lld",f[n+1][m][0]); &#125;&#125;;int main()&#123; mine::main();&#125; 23 1296 有限制的排列10.17 难度2请先思考后再展开 显然先拆开，变成每个位置，和前面的大小关系然后我就卡住了，不知道怎么解决，必须是排列这个条件然后好像这是一个套路？dp的时候保证f(i)是大小为i的排列，时刻保证合法性，然后插入一个数的话可以把前面&gt;=num的部分整体+1 24 1322 关于树的函数10.18 难度2请先思考后再展开 一道sb题，但我这sb又没想到唯一提示：||A1|B1||:-:|:-:|:-:||A2|a|b||B2|c|d| a+b=a+c=b+d=c+d=n 2510.18 难度2请先思考后再展开 12 2610.18 难度2请先思考后再展开 12 2710.18 难度2请先思考后再展开 12]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【Cqoi2011】动态逆序对]]></title>
    <url>%2Fposts%2Ffea4.html</url>
    <content type="text"><![CDATA[Source and JudgeCqoi2011bzoj4237luogu3157 Record1h Analysis请先思考后再展开 带修主席树：时间倒流，变成求在前面的比它大的数和后面小的数用前、后缀的带修主席树维护一下就好了 cdq分治：我似乎和网上所有人的都不一样……一开始还怀疑我的做法是错误的，后来发现是枚举顺序有一点问题，不单调了 就是给每个数打上时间戳，然后不删除的就是m+1、m+2……n俺么问题变成 $t_a&gt;t_b,p_a&lt;p_b,d_a&gt;d_b$ 和 $t_c&gt;t_b,p_c&gt;p_b,d_c&lt;d_b$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; #define int ll const int INF=0x3f3f3f3f; const int MAX_N=110000; struct Nod&#123;int t,d,p;Nod()&#123;t=0;&#125;&#125;p[MAX_N]; bool cmp1(Nod a,Nod b) &#123;return a.t&lt;b.t;&#125; bool cmp2(Nod a,Nod b) &#123;return a.p&lt;b.p;&#125; int n; int bit[MAX_N]; int lowbit(int x) &#123;return x&amp;-x;&#125; void change(int x,int c) &#123; while(x&lt;=n) bit[x]+=c,x+=lowbit(x); &#125; int sum(int x) &#123; int ans=0; while(x&gt;=1) ans+=bit[x],x-=lowbit(x); return ans; &#125; int ans[MAX_N]; void cdq(int fl,int fr) &#123; if(fl&gt;=fr) return; int mid=(fl+fr)&gt;&gt;1; cdq(fl,mid);cdq(mid+1,fr); sort(p+fl,p+mid+1,cmp2);sort(p+mid+1,p+fr+1,cmp2); int k1=fl-1; for(int k2=mid+1;k2&lt;=fr;k2++) &#123; while(k1+1&lt;=mid and p[k1+1].p&lt;p[k2].p) change(p[++k1].d,1); ans[p[k2].t]+=(k1-fl+1)-sum(p[k2].d); &#125; for(int t=fl;t&lt;=k1;t++) change(p[t].d,-1); int k3=mid+1; for(int k2=fr;k2&gt;=mid+1;k2--) &#123; while(k3-1&gt;=fl and p[k3-1].p&gt;p[k2].p) change(p[--k3].d,1); ans[p[k2].t]+=sum(p[k2].d-1); &#125; for(int t=k3;t&lt;=mid;t++) change(p[t].d,-1); &#125; int pos[MAX_N];//值的位置 void main() &#123; int m;scanf("%lld%lld",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;p[i].d),p[i].p=i,pos[p[i].d]=i; for(int i=1;i&lt;=m;i++) &#123; int t;scanf("%lld",&amp;t); p[pos[t]].t=i; &#125; for(int now=m,i=1;i&lt;=n;i++) if(p[i].t==0) p[i].t=++now; sort(p+1,p+n+1,cmp1);reverse(p+1,p+n+1); cdq(1,n); sort(p+1,p+n+1,cmp2); ll tot=0;for(int i=1;i&lt;=n;i++) tot+=(i-1)-sum(p[i].d),change(p[i].d,1); for(int i=1;i&lt;=m;i++) printf("%lld\n",tot),tot-=ans[i]; &#125;&#125;signed main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>树状数组</tag>
        <tag>难度2</tag>
        <tag>cdq分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POI2009】救火站]]></title>
    <url>%2Fposts%2F9d1.html</url>
    <content type="text"><![CDATA[Source and JudgePOI2009bzoj1117 Record1h Analysis请先思考后再展开 神仙题……而且我不知道怎么证明其正确性所以我权当记录我的做法的合理性和逻辑性，如果有帮助证明的好角度请评论 设 $ned(x,t)$ 表示当前节点x的子树中，有多少个节点是没有被覆盖而且与x距离为t的设 $remain(x,t)$ 表示x的子树中，某些点放置了消防站，而且其配额K即使到达x依然剩下t的距离，的节点数量 我们放置节点，当且仅当有距离为K的节点没有被覆盖（此策略不包括根节点）此时我们放置了足够的消防站，同时产生了许多配额把这些配额随着深度的减小统计起来后，使用当且仅当，我必须在此时去更新，否则到父亲那里我就需要用更大的花费了这里的必须，指对于我而言多出的配额与需要的距离相差在1以内（否则总是可以稍微延后一点的，不会亏，如果有更适合的还会赚） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=110000; int hou[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N*2]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; int ans=0; int mx,S; ll remain[MAX_N][30]; ll ned[MAX_N][30]; void dp(int x,int fa) &#123; ned[x][0]=1; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dp(y,x); for(int t=1;t&lt;=mx;t++) ned[x][t]+=ned[y][t-1]; for(int t=0;t&lt;=mx-1;t++) remain[x][t]+=remain[y][t+1]; &#125; if(ned[x][mx]&gt;0) &#123; int t=ceil((double)ned[x][mx]/S); ans+=t;remain[x][mx]+=(ll)t*S-ned[x][mx];ned[x][mx]=0; &#125; for(int t=0;t&lt;=mx;t++) &#123; if(ned[x][t]&lt;=remain[x][t]) remain[x][t]-=ned[x][t],ned[x][t]=0; else ned[x][t]-=remain[x][t],remain[x][t]=0; if(t==0) continue; if(ned[x][t-1]&lt;=remain[x][t]) remain[x][t]-=ned[x][t-1],ned[x][t-1]=0; else ned[x][t-1]-=remain[x][t],remain[x][t]=0; &#125; &#125; void main() &#123; int n;scanf("%d%d%d",&amp;n,&amp;S,&amp;mx); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; dp(1,0); for(int t=0;t&lt;=mx;t++) for(int t2=0;t2&lt;=t;t2++) &#123; if(ned[1][t2]&lt;=remain[1][t]) remain[1][t]-=ned[1][t2],ned[1][t2]=0; else ned[1][t2]-=remain[1][t],remain[1][t]=0; &#125; int sum=0;for(int t=0;t&lt;=mx;t++) sum+=ned[1][t]; printf("%d",ans+(int)ceil((double)sum/S)); &#125;&#125;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>精品题</tag>
        <tag>难度3</tag>
        <tag>贪心</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JOI】稻草人]]></title>
    <url>%2Fposts%2Fa999.html</url>
    <content type="text"><![CDATA[Source and JudgeJOIbzoj4237 Record1h Analysis请先思考后再展开 太巧妙了……分治真是世界上最美妙的思想…… 这道题的重点就是矩形中间不能有其他的稻草人任意一个矩形一定会经过一个横线，我们可以分治y，然后考虑两个端点一个在右上一个在左下的情况 不妨把上下分别按照x排序，然后枚举上面的一个点看做右上角，然后考虑下面的贡献首先，显然不能先覆盖到上面的节点，而此时x是单调的，所以维护y比当前小的最近位置这个可以非常轻松地用单调栈维护，因为如果下一个更高，则最近为当前，否则一定在前面而没有被删除从那个位置到当前之间的x都是可选的，接下来考虑下半部分的处理因为不能被前面的点的y覆盖到，可选的点，随着x的增加一定递减不妨用一个单调递减栈维护，内部x递增，可以用刚才得到的x区间来二分查找，统计答案 分治log层，每层nlogn，所以复杂度是 $O(nlog_2^2n)$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ZJOI2016】旅行者]]></title>
    <url>%2Fposts%2Faf7.html</url>
    <content type="text"><![CDATA[Source and JudgeZJOI2016bzoj3319Luogu3350完整题面uoj184 Record1h Analysis请先思考后再展开 神仙分治题（抱着整体二分的目的前来……然而并不太一样）考虑分割矩形，用类似整体二分的思想，把询问也分割但和常见的题型相比（我指我唯一做过的找k大模型……），我们并不能保证询问结果一定完全这么贡献但是，分割的时候，有一个特殊的性质，也是本算法最关键的地方：如果某问题应该在当前分治段解决（最优的路径被分割线划分），那么一定会经过分割线于是，跑最短路的时候就不需要枚举起点了，从s变成根号为了让复杂度尽量低，应该选择短的那条分割线，同时后面的分割区间可以不再管mid（大概是稍微优化点常数吧，跑到了bzojrk62）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=21000; int n,m; int to[MAX_N][4];//右、左、下、上 const int tx[4]=&#123;0,0,1,-1&#125;; const int ty[4]=&#123;1,-1,0,0&#125;; int calc(int x,int y) &#123;return (x-1)*m+y;&#125; int dis[MAX_N]; #define PR pair&lt;int,int&gt; #define MP make_pair #define FR first #define SE second priority_queue&lt; PR,vector&lt;PR&gt;,greater&lt;PR&gt; &gt; qq; void dijkstra(int x1,int y1,int x2,int y2,int st) &#123; dis[st]=0;qq.push(MP(dis[st],st)); while(1) &#123; while(qq.size() and qq.top().FR!=dis[qq.top().SE]) qq.pop(); if(qq.empty()) break; int x=qq.top().SE;qq.pop(); int fx=(x-1)/m+1,fy=(x-1)%m+1; for(int k=0;k&lt;4;k++) &#123; int fx2=fx+tx[k],fy2=fy+ty[k]; if(fx2&lt;x1 or fx2&gt;x2 or fy2&lt;y1 or fy2&gt;y2) continue; int y=calc(fx2,fy2); if(dis[y]&gt;dis[x]+to[x][k]) &#123; dis[y]=dis[x]+to[x][k]; qq.push(MP(dis[y],y)); &#125; &#125; &#125; &#125; struct Qes &#123; int x1,y1,x2,y2; int id; &#125;q[110000],q1[110000],q2[110000]; int ans[110000]; void solve(int x1,int x2,int y1,int y2,int fl,int fr) &#123; if(x1&gt;x2 or y1&gt;y2 or fl&gt;fr) return; for(int i=x1;i&lt;=x2;i++) for(int j=y1;j&lt;=y2;j++) dis[calc(i,j)]=INF; if(x2-x1&gt;y2-y1) &#123; int midx=(x1+x2)/2,tot1=0,tot2=0; for(int nowy=y1;nowy&lt;=y2;nowy++) &#123; for(int i=x1;i&lt;=x2;i++) for(int j=y1;j&lt;=y2;j++) dis[calc(i,j)]+=to[calc(midx,nowy)][1]; dijkstra(x1,y1,x2,y2,calc(midx,nowy)); for(int t=fl;t&lt;=fr;t++) ans[q[t].id]=min(ans[q[t].id],dis[calc(q[t].x1,q[t].y1)]+dis[calc(q[t].x2,q[t].y2)]); &#125; for(int t=fl;t&lt;=fr;t++) &#123; if(q[t].x1&lt;midx and q[t].x2&lt;midx) q1[++tot1]=q[t]; if(q[t].x1&gt;midx and q[t].x2&gt;midx) q2[++tot2]=q[t]; &#125; for(int i=1;i&lt;=tot1;i++) q[fl+i-1]=q1[i]; for(int i=1;i&lt;=tot2;i++) q[fl+tot1+i-1]=q2[i]; solve(x1,midx-1,y1,y2,fl,fl+tot1-1); solve(midx+1,x2,y1,y2,fl+tot1,fl+tot1+tot2-1); &#125; else &#123; int midy=(y1+y2)/2,tot1=0,tot2=0; for(int nowx=x1;nowx&lt;=x2;nowx++) &#123; for(int i=x1;i&lt;=x2;i++) for(int j=y1;j&lt;=y2;j++) dis[calc(i,j)]+=to[calc(nowx,midy)][3]; dijkstra(x1,y1,x2,y2,calc(nowx,midy)); for(int t=fl;t&lt;=fr;t++) ans[q[t].id]=min(ans[q[t].id],dis[calc(q[t].x1,q[t].y1)]+dis[calc(q[t].x2,q[t].y2)]); &#125; for(int t=fl;t&lt;=fr;t++) &#123; if(q[t].y1&lt;midy and q[t].y2&lt;midy) q1[++tot1]=q[t]; if(q[t].y1&gt;midy and q[t].y2&gt;midy) q2[++tot2]=q[t]; &#125; for(int i=1;i&lt;=tot1;i++) q[fl+i-1]=q1[i]; for(int i=1;i&lt;=tot2;i++) q[fl+tot1+i-1]=q2[i]; solve(x1,x2,y1,midy-1,fl,fl+tot1-1); solve(x1,x2,midy+1,y2,fl+tot1,fl+tot1+tot2-1); &#125; &#125; void main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m-1;j++) &#123; int t;scanf("%d",&amp;t); to[calc(i,j)][0]=to[calc(i,j+1)][1]=t; &#125; for(int i=1;i&lt;=n-1;i++) for(int j=1;j&lt;=m;j++) &#123; int t;scanf("%d",&amp;t); to[calc(i,j)][2]=to[calc(i+1,j)][3]=t; &#125; int t;scanf("%d",&amp;t); for(int i=1;i&lt;=t;i++) &#123; int x1,y1,x2,y2;scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); q[i]=(Qes)&#123;x1,y1,x2,y2,i&#125;; &#125; memset(ans,63,sizeof ans); solve(1,n,1,m,1,t); for(int i=1;i&lt;=t;i++) printf("%d\n",ans[i]); &#125;&#125;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj3261】最大异或和]]></title>
    <url>%2Fposts%2F10a2.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj3261 Record2h Analysis请先思考后再展开 类似之前做的最大xor路径等题（刷算法竞赛进阶指南的时候）维护区间的trie，在上面贪心即可写的过程非常不顺利，一大堆sb错误 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int INF=0x3f3f3f3f; typedef long long ll; const int MAX_N=310000*2;//n+q int bin[40]; struct Trie &#123; int c; int son[2]; void clear() &#123;c=son[0]=son[1]=0;&#125; &#125;p[MAX_N*30]; int id=0; int rt[MAX_N]; void add(int now,int num) &#123; for(int u=25;u&gt;=0;u--) &#123; int t=(num&amp;bin[u])&gt;0; if(p[now].son[t]==0) p[now].son[t]=++id,p[id].clear(); now=p[now].son[t];p[now].c++; &#125; &#125; void merg(int fl,int &amp;fr) &#123; if(fl==0) return; if(fr==0) &#123;fr=fl;return;&#125; p[fr].c+=p[fl].c; merg(p[fl].son[0],p[fr].son[0]); merg(p[fl].son[1],p[fr].son[1]); &#125; int solve(int l,int r,int now) &#123; int fl=rt[l-1],fr=rt[r]; for(int u=25;u&gt;=0;u--) &#123; int to=!( (now&amp;bin[u])&gt;0 ); if(p[p[fr].son[to]].c-p[p[fl].son[to]].c==0) to^=1; now^=(to*bin[u]);fl=p[fl].son[to];fr=p[fr].son[to]; &#125; return now; &#125; void main() &#123; bin[0]=1;for(int u=1;u&lt;=30;u++) bin[u]=bin[u-1]&lt;&lt;1; int n,m;scanf("%d%d",&amp;n,&amp;m); int sum=0;//前缀异或和 p[0].c=0; rt[1]=++id;p[id].clear();add(rt[1],0);//偏移，避免越界 for(int i=2;i&lt;=n+1;i++) &#123; int a;scanf("%d",&amp;a);sum^=a; rt[i]=++id;p[id].clear(); add(rt[i],sum); merg(rt[i-1],rt[i]); &#125; n=n+1; while(m--) &#123; char s[5];scanf("%s",s); if(s[0]=='A') &#123; int a;scanf("%d",&amp;a);sum^=a; rt[++n]=++id;p[id].clear(); add(rt[n],sum); merg(rt[n-1],rt[n]); &#125; else &#123; int l,r,x;scanf("%d%d%d",&amp;l,&amp;r,&amp;x);l++;r++; printf("%d\n",solve(l-1,r-1,x^sum));//后缀转化前缀问题 &#125; &#125; &#125;&#125;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>可持久化字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HAOI2012】外星人]]></title>
    <url>%2Fposts%2Ff69a.html</url>
    <content type="text"><![CDATA[Source and JudgeHAOI2012bzoj2749luogu2350 Record2h Analysis请先思考后再展开 题面上的x是指函数的阶，可以理解为嵌套数量 首先，phi有个奇妙的性质：只有phi(2)=1，其他的结果都是偶数这个不难证明，根据欧拉函数的公式，除2以外的素数都是技术，减一得到偶数 逆向考虑一下，那么为了得到1，迟早要变成2的形式对于a为偶数的情况，枚举拆phi会去除一个2，然后2-1在连乘中没有影响，所以等价于一个2去除了但此时其他的素数会变成p-1，一定会产生2（如果有） 因为这个性质中，2的去除每次拆开只会进行一次（整个a而言，而不是每个素数都这样）那么这个2的次数其实能推导出嵌套深度，所以问题转化为，求出N在不断拆开的过程中，产生的2的数量 而对于a是奇数的情况，这一次拆开不会消除2，所以应该在原本的基础上+1同时不需要考虑以后的情况，就像上文所说的，以后的phi的结果都是偶数 接下来就是推导了$f(p)=f(p-1)$$f(p^k)=f(p) \times k$$f(a为偶)=\sum f(p^{k-1})+f(p-1)=\sum f(p^{k-1})+f(p)$这个是可以线筛的时候顺便搞的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int INF=0x3f3f3f3f; typedef long long ll; const int MAX_NUM=100001; int pr=0,prime[MAX_NUM]; bool isp[MAX_NUM]; int f[MAX_NUM]; void pre() &#123; f[1]=1; memset(isp,1,sizeof isp); for(int i=2;i&lt;MAX_NUM;i++) &#123; if(isp[i]) prime[++pr]=i,f[i]=f[i-1]; for(int j=1;j&lt;=pr and (ll)i*prime[j]&lt;MAX_NUM;j++) &#123; isp[i*prime[j]]=0; f[i*prime[j]]=f[i]+f[prime[j]]; if(i%prime[j]==0) break; &#125; &#125; &#125; void main() &#123; pre(); int T;scanf("%d",&amp;T); while(T--) &#123; int n;scanf("%d",&amp;n); ll ans=0;bool two=0; for(int i=1;i&lt;=n;i++) &#123; int p,k;scanf("%d%d",&amp;p,&amp;k); ans+=(ll)f[p]*k;if(p==2) two=1; &#125; if(!two) ans++; printf("%lld\n",ans); &#125; &#125;&#125;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SDOI2012】Longge的问题]]></title>
    <url>%2Fposts%2Fafb7.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj270551nod1040 Record1h Analysis请先思考后再展开 约数个数表：num=256 sum=9699690num=512 sum=223092870num=768 sum=446185740num=864 sum=290990700num=1024 sum=892371480num=1152 sum=581981400num=1280 sum=698377680num=1296 sum=857656800num=1344 sum=931170240num=1152 sum=1338557220num=1296 sum=2036934900num=1536 sum=1745944200num=1600 sum=2095133040 $f(x)=\sum gcd(t,x)=\sum{t|x} phi(x/t) t$ 网上普遍的做法是暴力枚举约数，再暴力计算phi这个的复杂度很难计算，感觉非常不可靠 受cty博客的启示，继续深入考虑从公式后者的形式来看，据说叫做狄利克雷卷积（普通卷积是通过和卷起来，这个是通过乘积卷起来）就是因为phi和1函数都是积性函数，所以这个整体也是个积性函数 那么现在我们需要求 $f(p^k)$ ，我们希望规避【暴力计算phi】，所以考虑利用刚才想到的性质，去递推$f(p^{k+1})=\sum f(p^k) \times p + phi(p^{k+1})$ 那么这个东西的计算是可以忽略的所以总时间主要是 根号n来分解质因数，找到p计算f的时间复杂度的外部系数只有30即最大不同质数数量]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>欧拉函数</tag>
        <tag>积性函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj3319】黑白树]]></title>
    <url>%2Fposts%2Faba8.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj3319 Record30min Analysis请先思考后再展开 log方显然不能过考虑特性，黑边只会增加不会减少找向上第一个黑边等价于把所有黑边断开后向上最高的点这个可以离线一下，并查集维护一下就好了]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu4891】序列]]></title>
    <url>%2Fposts%2F6301.html</url>
    <content type="text"><![CDATA[Source and JudgeLuogu4891 Record2h Analysis请先思考后再展开 感谢myh大爷的解释……当时比赛完发现官方不发题解，抱着试一试的想法去找myh，没想到他真的回复了 我们需要维护操作对于操作1，分三种情况 原本小于，后来小于：拿出来再放回去 原本小于，后来大于等于：拿出来不放回去 原本大于等于，此时不用理会 用一个set维护一个不同C的区间，以位置排序每次询问，先二分找到具体位置，然后枚举每个块，直到不能贡献那么因为操作后这些块相当于消失（向前合并），所以枚举的复杂度从从势能上看只有n+q同时这个块一定原本和最后都是相同的值 那么，为了能够维护有多少个 $C&lt;B$ ，如果暴力去维护，势能是值域级别的，没有意义但如果每次log地找到，最小那个B，知道大于等于新的值，那么这个的势能会明确地减少1这个新产生的部分和原本的加起来，会远比每一次重新统计好得多此处的时间同样是n次 具体而言，维护二元组mi和贡献数量sum 对于 $C&lt;B$ 的部分，mi=(B,pos)，sum=1 否则，mi=(INF,0)，sum=0 操作1找mi去更新操作2暴力处理 综上说述，时间复杂度为 $O((n+q) log n)$感觉这道题比较考验思路的清晰和明确]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC43】ladder]]></title>
    <url>%2Fposts%2F67b3.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC43 Record1h Analysis请先思考后再展开 又是计数题，显然不能直接计算，考虑dp然后比赛我的时候我就一直努力计算非法状态数量，发现超级复杂，不知道如何巧妙地设计状态吃完饭回来，什么鬼？？直接计算就好了，合法状态好表示多了，非要脑残搞非法…… 设 $f(i,dis1,dis2,dis3,dis4)$ 表示现在在位置i，每个梯子与当前的距离如果dis=h，表示已经断开了，此时具体dis没有意义，用非法制h表示此时我们说h是非法值，是指它作为【被继承状态】而言所以答案即 $f(n,0 \leq dis1&lt;h,0 \leq dis2&lt;h,0 \leq dis3&lt;h,0 \leq dis4&lt;h)$显然有一维一定是0，所以可以省略，用0和1表示最后滚动一下即可]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC44】color]]></title>
    <url>%2Fposts%2Fd64f.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC44 Record1h Analysis请先思考后再展开 对于T=1的情况，对于一个l，考虑其贡献那么从l开始的第一个颜色，权值为1，下一个为-1，仅当只包含1的，那么就能产生贡献对询问排序后，l单调递增，r的变化只需要树状数组询问前缀和那么每次l的移动，把该颜色对应的贡献更新一下即可 而对于T更普通的情况，维护好每个位置向后T次同颜色的位置，那么用类似的方法，向后T+1次的位置为-1即可 还有一种变形：HEOI2012 采花SDOI2009 HH的项链也是类似的方法，只不过不要添加-1，而是用0即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=510000; const int INF=0x3f3f3f3f; typedef long long ll; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int qread() &#123; int ans=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans; &#125; struct Qes &#123; int l,r; int ans; int pos; &#125;q[MAX_N]; bool cmp(Qes a,Qes b) &#123;return a.l&lt;b.l or (a.l==b.l and a.r&lt;b.r);&#125; bool cmp2(Qes a,Qes b) &#123;return a.pos&lt;b.pos;&#125; int n; int bit[MAX_N]; int lowbit(int x) &#123;return x&amp;-x;&#125; void change(int x,int c) &#123; if(x==0) return; while(x&lt;=n) &#123; bit[x]+=c; x+=lowbit(x); &#125; &#125; int ask(int x) &#123; int ans=0; while(x&gt;=1) &#123; ans+=bit[x]; x-=lowbit(x); &#125; return ans; &#125; int pos[MAX_N],fir[MAX_N]; int nx[MAX_N],nxT[MAX_N]; int ans[MAX_N]; void main() &#123; int m,k,T;scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;T); for(int i=1;i&lt;=n;i++) &#123; int t=qread(); if(pos[t]&gt;0) nx[pos[t]]=i; else fir[t]=i; pos[t]=i; &#125; for(int i=1;i&lt;=k;i++) &#123; int l=fir[i],r=fir[i]; for(int t=2;t&lt;=T;t++) r=nx[r]; while(r&gt;0) &#123; nxT[l]=r; l=nx[l];r=nx[r]; &#125; change(nxT[fir[i]],1); change(nx[nxT[fir[i]]],-1); &#125; for(int i=1;i&lt;=m;i++) q[i].l=qread(),q[i].r=qread(),q[i].pos=i; sort(q+1,q+m+1,cmp); for(int i=1;i&lt;=m;i++) &#123; if(q[i-1].l!=q[i].l) &#123; int t=q[i-1].l; for(int j=t;j&lt;=q[i].l-1;j++) &#123; change(nxT[j],-1); change(nx[nxT[j]],2); change(nx[nx[nxT[j]]],-1); &#125; &#125; q[i].ans=ask(q[i].r); &#125; sort(q+1,q+m+1,cmp2); for(int i=1;i&lt;=m;i++) ans[q[i].pos]=q[i].ans; for(int i=1;i&lt;=m;i++) printf("%d\n",ans[i]); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC46】【POI2007】堆积木兼删数游戏]]></title>
    <url>%2Fposts%2Fd023.html</url>
    <content type="text"><![CDATA[Source and JudgePOI2007NOIAC46bzoj1109 Record1h Analysis请先思考后再展开 先从简单一点的堆积木开始 考虑dp，设 $f(i)$ 表示考虑了前面i个数，此时 $a[i]=i$$f(i)=f(j)+1，当j&lt;i，a_j&lt;a_i，j-a_j \leq i-a_i$不过，我们可以把其中一个消除 当 $a_j&lt;a_i，j-a_j \leq i-a_i$不难得出 $j-a_j&lt;i-a_i+1$相减得出 $j \leq i$因为 $a_j&lt;a_i$ ，显然不可能相等，由此可知最前面那个可以去除（注意，此时第一个是第三个的子集，由一和二不能得出三） 观察一下那两个条件，可以发现形式是相同的，是一个二维偏序问题因为有递推性，可以按照第三个排序（否则不能在相同的第一关键字继承），然后把第二个最长不严格上升子序列一下即可 细节1：对于 $a[i]&gt;i$ 的位置，不能参与dp，这个不方便判断，可以直接剔除（但不能影响编号） 细节2：因为要最大化答案，而我们的三是可以相同的所以对于相同的第一关键字，我们也应该把二排序 细节还是有点多的，还不是很好发现可能只能对拍了……12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=1100000; const int INF=0x3f3f3f3f; typedef long long ll; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int n,k; int tot=0; int bit[MAX_N]; int lowbit(int x) &#123;return x&amp;-x;&#125; void update(int x,int c) &#123; while(x&lt;=n)//debug 很小的细节，bzoj帮忙发现了x&lt;=tot &#123; bit[x]=mymax(bit[x],c); x+=lowbit(x); &#125; &#125; int findmx(int x) &#123; int ans=0; while(x&gt;=1) &#123; ans=mymax(ans,bit[x]); x-=lowbit(x); &#125; return ans; &#125; struct Nod &#123; int a,b; int pos; &#125;s[MAX_N]; bool cmp(Nod a,Nod b) &#123;return a.a&lt;b.a or (a.a==b.a and a.b&lt;b.b);&#125; int f[MAX_N]; int solve() &#123; int ans=0; for(int i=1;i&lt;=tot;i++) &#123; f[i]=findmx(s[i].b-1)+1; update(s[i].b,f[i]); if(s[i].a&lt;=k and n-s[i].pos+s[i].a&gt;=k) ans=mymax(ans,f[i]); //debug if(s[i].a==k and n-s[i].pos+s[i].a&gt;=k) ans=mymax(ans,f[i]); //可能导致 a&gt;k，其实现在想想很明显…… //bzoj ans=mymax(ans,f[i]); &#125; return ans; &#125; void main() &#123; //scanf("%d",&amp;n); scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) &#123; int ai;scanf("%d",&amp;ai); if(i-ai&gt;=0) s[++tot]=(Nod)&#123;i-ai,ai,i&#125;; &#125; sort(s+1,s+tot+1,cmp); printf("%d",solve()); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>dp</tag>
        <tag>偏序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF511A】Enlarge GCD]]></title>
    <url>%2Fposts%2F4ed.html</url>
    <content type="text"><![CDATA[Source and JudgeCF511A Record2h Analysis请先思考后再展开 本文用GCD表示原本的最大公约数，gcd表示最大公约数 第一次尝试开场做c，杠半天，想到一个aloga的做法：要增大gcd，那么统计f[t]表示t的倍数的数量，答案即合法范围内的 $min{ n-f[t] }$注意此时我要求 $t&gt;原GCD$ ，相当于我知道最后的GCD一定是t的倍数，那么把所有不存在t这个因子的数删除即可为什么我不能直接取质数呢？主要是担心，为了增大GCD，可能选择了2GCD，例如2 4 8这组数据 那么这个f怎么求呢？我想了差不多半个小时，只能想到用莫比乌斯函数，再枚举倍数，时间根据调和级数是log的 当时机房大佬们个个都切四道题了，心里慌的一匹然后我觉得可能做法上是理论极限了，是思路的问题，可能需要省去一些状态，但依然毫无思路 正解：显然最后得到的gcd一定是GCD的倍数可以把每个数除以GCD，那么现在总gcd为1，只要变成任何大于1的数，都意味着成功现在我们成功地不用再考虑GCD的影响了，只要考虑t是素数的情况就好了 只关心素数那么就容易多了，可以对每个数分解质因数而不用把它们组合不过暴力去找质数分解需要根号的时间，主要是寻找素数的时间太长了到这里的话，不难想到可以在线性筛的时候记录一下最小素因子，时间复杂度降低成素因子次幂和，最大30 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=310000; const int INF=0x3f3f3f3f; typedef long long ll; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; const int MAX_NUM=15000001; int pr=0,prime[MAX_NUM]; bool isp[MAX_NUM]; int mip[MAX_NUM]; void pre() &#123; memset(isp,1,sizeof isp); for(int i=2;i&lt;MAX_NUM;i++) &#123; if(isp[i]) prime[++pr]=mip[i]=i; for(int j=1;j&lt;=pr and (ll)i*prime[j]&lt;MAX_NUM;j++) &#123; isp[i*prime[j]]=0; mip[i*prime[j]]=prime[j]; if(i%prime[j]==0) break; &#125; &#125; &#125; int gcd(int x,int y) &#123;return y==0?x:gcd(y,x%y);&#125; int a[MAX_N]; int f[MAX_NUM]; void main() &#123; pre(); int n;scanf("%d%d",&amp;n,&amp;a[1]); int GCD=a[1];for(int i=2;i&lt;=n;i++) scanf("%d",&amp;a[i]),GCD=gcd(GCD,a[i]); for(int i=1;i&lt;=n;i++) &#123; a[i]/=GCD; while(mip[a[i]]&gt;1) &#123; int t=mip[a[i]];while(a[i]%t==0) a[i]/=t; f[t]++; &#125; if(a[i]&gt;1) f[a[i]]++; &#125; int ans=INF; for(int i=2;i&lt;MAX_NUM;i++) if(f[i]&gt;0 and f[i]&lt;n) ans=mymin(ans,n-f[i]); if(ans==INF) puts("-1"); else printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC47】power]]></title>
    <url>%2Fposts%2F42a8.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC47 Record2h Analysis请先思考后再展开 这道题如果从联通块的角度来思考，情况太多，dfs序也不连续经p老大提醒，如果从那段连续编号着手，然后像异象石那道题一样（自行搜索），找出需要的联通块大小就好了那么因为要求块大小小于等于k，可以用尺取法维护一个set，显然单调（xgc居然不while右指针都过了……） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=110000; const int INF=0x3f3f3f3f; typedef long long ll; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; struct Nod &#123; int hou; int dfn; int dep; Nod() &#123;hou=dep=dfn=0;&#125; &#125;p[MAX_N]; struct Edge &#123; int y,g; &#125;e[MAX_N*2]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,p[x].hou&#125;;p[x].hou=ln;&#125; int id=0,yz[MAX_N]; int f[MAX_N][20],bin[20]; void dfs(int x,int fa) &#123; p[x].dfn=++id;yz[id]=x; f[x][0]=fa;p[x].dep=p[fa].dep+1; for(int i=1;i&lt;20;i++) f[x][i]=f[f[x][i-1]][i-1]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dfs(y,x); &#125; &#125; int LCA(int x,int y) &#123; if(p[x].dep&lt;p[y].dep) swap(x,y); for(int i=19;i&gt;=0;i--) if(p[x].dep-p[y].dep&gt;=bin[i]) x=f[x][i]; if(x==y) return x; for(int i=19;i&gt;=0;i--) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0]; &#125; int dis(int x,int y) &#123;return p[x].dep+p[y].dep-2*p[LCA(x,y)].dep;&#125; set&lt;int&gt; s; typedef set&lt;int&gt;::iterator It; int calc(int x) &#123; It rr=s.upper_bound(p[x].dfn);if(rr==s.end()) rr=s.begin(); It ll=rr;if(ll==s.begin()) ll=s.end(); --ll; int fl=yz[*ll],fr=yz[*rr]; return dis(fl,x)+dis(x,fr)-dis(fl,fr);//恰好完美处理单个的情况 &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;20;i++) bin[i]=bin[i-1]&lt;&lt;1; int n,k;scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; dfs(1,0); int ans=1,sum=0; for(int l=1,r=2;l&lt;=n;l++) &#123; if(!s.count(p[l].dfn)) s.clear(),s.insert(p[l].dfn),sum=0,r=l+1; while(r&lt;=n) &#123; int t=calc(r); if((sum+t)/2+1&gt;k) break; sum+=t;s.insert(p[r].dfn);r++; &#125; ans=mymax(ans,(r-1)-l+1); s.erase(s.find(p[l].dfn)); if(s.size()&gt;1) sum-=calc(l); &#125; printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC37】染色]]></title>
    <url>%2Fposts%2F7761.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC37 Record30min Analysis请先思考后再展开 好奇妙的dp呀本来一直在想组合数学，然后想着用容斥因为如果互相不重叠，那么是非常好计算的然后我想着应该不需要重叠，因为按照容斥原理，不会互相重复计算后来打了半天，才发现形式上会重复 正解是dp，f(i,j)表示处理到第i个，然后前面j个互不相同，【但是再往前一个就出现相同】的方案数，确保 $j \leq m-1$如果第i+1个是和前面这j个中某个相同，则j减小，否则可以在这j个之外任选一个 如果能成功列出这个dp方程，转移后缀和优化一下，就能达到n方 123456789101112131415161718192021222324252627282930313233343536373839//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=5100; typedef long long ll; ll MOD,f[MAX_N][MAX_N]; void main() &#123; int n,m;scanf("%d%d%lld",&amp;n,&amp;m,&amp;MOD); f[0][0]=1; for(int i=1;i&lt;=n;i++) &#123; for(int k=1;k&lt;=i and k&lt;=m-1;k++) f[i][k]=f[i-1][k]+(f[i-1][k-1]-f[i-1][k])*(m-(k-1))%MOD; for(int j=m-1;j&gt;=0;j--) f[i][j]=(f[i][j]+f[i][j+1])%MOD;//后缀和优化dp &#125; printf("%lld",(f[n][0]+MOD)%MOD); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>计数dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[atcoder套刷计划]]></title>
    <url>%2Fposts%2F84cd.html</url>
    <content type="text"><![CDATA[发现自己经常打比赛挂机……正好在noip前练习一下思维题 arc102之前做了c、d、e题 1 F - Revenge of BBuBBBlesort!9.20 难度2题意：给你一个长度为n的排列A，可以交换(ai,ai+1,ai+2)当且仅当ai&gt;ai−1&gt;ai−2,问A是否能经过一系列交换最后有序 请先思考后再展开 感觉这种性质题对我来说难度很大如果一次操作以i为轴心，则称对i进行操作 找找性质： 从操作位置来看：因为操作的条件限制，对i操作后，无论i-2和i+2是什么，都不可能再次对i-1和i+1操作既然如此，i上面的数字就动不了了，所以不可能对于一个 $i \neq a_i$ 的位置操作因此，如果连续三个位置， $i \neq a_i$ ，记中间的是i，那么可以直接判断无解因为此时i不能动，唯一希望就是i+1把值i送过来，但这要求 i+1=ai+1 ，但又只能从i+2送过来现在i+1自己都要送过来，那么i+2只能作为轴心，无法得到i 从值来看：如果我一开始向左走，那么我永远只能向左走证明：最初我跨越了位置x，那么我 &lt; x上的数字，而x作为转轴不可能再变化，对于值x而言，无法达成反方向操作的条件 综上所述，如果已经在位置上，就不能再动了，称为定点，其他的就是动点（不能存在连续三个）对于每个位置p，如果上面的值是x，那么x要变成p，而每次操作，上面的数字的奇偶性不会变化所以说x和p的奇偶性要相同 然后我们把原序列分段，每个段满足定点动点交错，那么内部的值可以跳来跳去，但不能跳出去（可能这个段只有单个元素） 然后我们取出每个段，在内部进行判断条件1，所有值的目标不能在该段之外条件2，两个目标方向相同的值，不能相互跨越否则意味着其中一个值没有按照规定方向跳跃，与前面的性质矛盾 总结：感觉这道题很奇怪就是你就算找到了一些性质，也不知道是否找全了典型的【不做完别的题目不会开】的题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=310000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; int a[MAX_N],b[MAX_N]; bool check(int l,int r) &#123; int left=0,right=0; for(int i=l;i&lt;=r;i++) &#123; if(a[i]&lt;l or a[i]&gt;r) return 0; if(a[i]&lt;i)//left &#123; if(left&gt;a[i]) return 0; left=a[i]; &#125; else if(a[i]&gt;i) &#123; if(right&gt;a[i]) return 0; right=a[i]; &#125; &#125; return 1; &#125; #define GG &#123;puts("No");return;&#125; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); if((a[i]-i)%2) GG//奇偶性 b[i]=(a[i]==i); if(i&gt;=3 and !b[i-2] and !b[i-1] and !b[i]) GG//连续三个动点 &#125; for(int l=1;l&lt;=n;l++) if(b[l]==0)//动点 &#123; int now=1;//交替 int r=l;while(r+1&lt;=n and b[r+1]==now) now^=1,r++; if(!check(l,r)) GG l=r; &#125; puts("Yes"); &#125;&#125;;int main()&#123; mine::main();&#125; arc1012 E - Ribbons on Tree9.20 难度2题意：给定一棵点数为偶数的树求有多少种将点两两配对的方案使得每一条边至少被一对匹配点之间的路径覆盖 请先思考后再展开 非常神仙的容斥：设边集T为必定不经过的边，则答案即 $\sum (-1)^{|T|} F(T)$显然大小为t的联通块，任意选择的方案数 $g(t)=(t-1)(t-3)(t-5)… \times 1$具体的奇偶性等细节自行处理如果T把树分成了多个联通块，则答案即每个块的g(t)的乘积 然而指数级枚举T显然是不现实的利用图是一棵树的特性，考虑树形dp设 $f(x,k)$ 表示在x的子树中，有k个是最顶上的联通块这个联通块是可拓展的，所以不统计内部的方案数，直到被其父亲统计 dp转移时，常规地枚举两次siz，然后复杂度也同样是套路：把siz看做子树的每个节点，则每个点对只会在lca处被遍历到，所以复杂度 $O(n^2)$ 转移方程的话，因为边集大小增加，如果不断开，相当于合并上面那个块， $f(x,sz1+sz2)+=f(x,sz1) \times f(y,sz2)$如果断开(x,y)， $f(x,sz1)+=(-1) \times f(x,sz1) \times f(y,sz2) \times g(sz2)$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=5100; typedef long long ll; int hou[MAX_N],siz[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N*2]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; const ll MOD=1e9+7; void addup(ll &amp;x,ll y) &#123;x=(x+y)%MOD;&#125; ll g[MAX_N],f[MAX_N][MAX_N],tmp[MAX_N]; void dfs(int x,int fa) &#123; siz[x]=1;f[x][1]=1; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dfs(y,x); for(int i=0;i&lt;=siz[x]+siz[y];i++) tmp[i]=0; for(int sz1=0;sz1&lt;=siz[x];sz1++) for(int sz2=0;sz2&lt;=siz[y];sz2++) &#123; addup(tmp[sz1+sz2],f[x][sz1]*f[y][sz2]%MOD); if(sz2%2==0) addup(tmp[sz1],-f[x][sz1]*f[y][sz2]%MOD*g[sz2]%MOD); &#125; siz[x]+=siz[y]; for(int i=0;i&lt;=siz[x];i++) f[x][i]=tmp[i]; &#125; &#125; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; g[0]=1;for(int i=2;i&lt;=n;i+=2) g[i]=g[i-2]*(i-1)%MOD; dfs(1,0); ll ans=0; for(int sz=2;sz&lt;=n;sz+=2) addup(ans,f[1][sz]*g[sz]%MOD); addup(ans,MOD); printf("%lld",ans); &#125;&#125;;int main()&#123; mine::main();&#125; arc1003 E Or Plus Max9.20 难度2题意：又看错题了……细思极恐给定一个正整数 n(n≤18)然后给定一行共 $2^n$ 个正整数 a0,a1,⋯,a2n−1对于每一个 k( $1≤k&lt;2^n$ )，输出满足 i OR j≤k 的最大 ai+aj 值。 请先思考后再展开 我能想到的最好的做法：如果能得出 $i|j=k$ 的情况，那么前缀max就是答案然而很难算出来但如果能得出 $i|j \in k$ 的答案，那么前缀max也是可以的而这个显然好算很多，i和j基本没关系了 枚举每个k，然后枚举其子集，维护最大和次大时间复杂度： $O(3^n)$1234567891011121314151617int a[MAX_N],mx[MAX_N];int ans[MAX_N];void main()&#123; int n;scanf("%d",&amp;n); int m=1&lt;&lt;n; for(int i=0;i&lt;m;i++) scanf("%d",&amp;a[i]); for(int k=1;k&lt;m;k++) &#123; ans[k]=mymax(a[0],ans[k-1]); mx[k]=a[0]; for(int u=k;u&gt;0;u=(u-1)&amp;k) ans[k]=mymax(ans[k],a[u]+mx[k]),mx[k]=mymax(mx[k],a[u]); printf("%d\n",ans[k]); &#125;&#125; 然而4亿在atcoder上面居然只需要760ms 正解：既然我们的答案和具体子集没有关系，只关心其最大值和次大值可以不用枚举子集，而是用子集来更新父亲对于一个集T，不一定所有的子集都直接更新到T，也可能先经过T的子集，但这样一定不会漏时间复杂度降低到了 $O(n2^n)$据说这个技巧有个更深入的应用：Fast Zeta Transform123456789101112131415161718192021222324252627282930int a[MAX_N];int f[MAX_N],g[MAX_N];//最大和次大值的位置void update(int x,int pos)&#123; if(pos&lt;0 or pos==f[x] or pos==g[x]) return; if(a[pos]&gt;=a[f[x]]) g[x]=f[x],f[x]=pos; else if(a[pos]&gt;=a[g[x]]) g[x]=pos;&#125;int bin[30];void main()&#123; bin[0]=1;for(int i=1;i&lt;30;i++) bin[i]=bin[i-1]&lt;&lt;1; int n;scanf("%d",&amp;n); for(int i=0;i&lt;bin[n];i++) scanf("%d",&amp;a[i]),f[i]=i,g[i]=-1; int ans=0; for(int k=0;k&lt;bin[n];k++) &#123; for(int i=0;i&lt;n;i++) &#123; if(k&amp;bin[i]) continue; update(k+bin[i],f[k]); update(k+bin[i],g[k]); &#125; ans=mymax(ans,a[f[k]]+a[g[k]]); if(k&gt;0) printf("%d\n",ans); &#125;&#125;&#125;; 4 F - Colorful Sequences9.26 难度3题意：定义一个长度为n，字符集大小为k的序列是好的，当且仅当其中存在一个长度为k的子串满足1到k每个数在这里面恰好出现一次。现在给一个长度为m的序列a，问在所有好的序列里面，a作为子串的出现次数的和。 请先思考后再展开 感觉这道题好神仙啊，还好有我p老大教我这个菜逼 先思考简化的问题一、问题一只考虑出现的次数，不考虑序列的好坏因为互相之间没有影响，直接搞枚举左边的数量，乱填， $(n-m+1) k^{n-m}$ 二、问题二考虑all-不好的那么问题转化为染色，最近在noiac做的一道比赛题（题解自行搜索）$f(n,ln)=f(n-1,ln-1) \times (k-(ln-1)) + \sum f(n-1,ln&lt;t \leq k)$此处复杂度为nk 三、问题一 + 问题二 A. 串a中包含k个不相同的直接按照问题一计算即可 B. 串a中包含最长不相同，长度小于k，前后延伸最长不重叠同样是计算不合法的数量，左右两边以刚才得到的延伸作为强制起点，按照问题二一样向左右分别dp然后和问题一一样，枚举左边，只不过此时左右两边填写的数量不是乱填，而是要保证非法性 C. 串a整体都是互不重复，但长度小于k我们既要求非法，有要统计贡献因为串a本身是互不相同的，不能像B那样左右搞，因为互相影响 这里用到一个非常巧妙的转化先忽略串a的具体字母，统计所有非法串中，长度为m的互不相同字符串的贡献这样以后我们就不再关心串a的具体值了，反正互不相同且唯一就是了最后把贡献还原回去，可以通过除以 排列数P(m,k) 实现 贡献的计算可以仿照前面的dp方式设f表示串总数，当后缀不可延伸长度满足长度条件的时候就统计进g，然后g自己也转移 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int INF=0x3f3f3f3f; typedef long long ll; const ll MOD=1e9+7; ll qpower(ll x,ll e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll x) &#123;return qpower(x,MOD-2);&#125; const int MAX_N=25100; ll fac[410];//&lt;=k ll P(int n,int m) &#123;return fac[n]*inv(fac[n-m])%MOD;&#125; int a[MAX_N]; bool b[410]; ll f[MAX_N][410],g[MAX_N][410]; void main() &#123; fac[0]=1;for(int i=1;i&lt;410;i++) fac[i]=fac[i-1]*i%MOD; int n,k,m;scanf("%d%d%d",&amp;n,&amp;k,&amp;m); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;a[i]); int mxlen=1; for(int l=1,r=0;l&lt;=m;b[a[l++]]=0) &#123; if(l&gt;r) b[a[++r]]=1; while(r+1&lt;=m and !b[a[r+1]]) b[a[++r]]=1; mxlen=max(mxlen,r-l+1); &#125; ll ans=ll(n-m+1)*qpower(k,n-m)%MOD; if(mxlen==k) ; else if(mxlen&lt;m) &#123; memset(b,0,sizeof b);int ls=0;while(ls+1&lt;=m and !b[a[ls+1]]) b[a[++ls]]=1; f[0][ls]=1; memset(b,0,sizeof b);int rs=m+1;while(rs-1&gt;=1 and !b[a[rs-1]]) b[a[--rs]]=1; g[0][m-rs+1]=1;//debug 要的是长度 for(int i=1;i&lt;=n-m;i++) &#123; ll fsum=0,gsum=0; for(int ln=k-1;ln&gt;=1;ln--) &#123; (fsum+=f[i-1][ln])%=MOD;(gsum+=g[i-1][ln])%=MOD; f[i][ln]=(f[i-1][ln-1]*(k-(ln-1))%MOD+fsum)%MOD; g[i][ln]=(g[i-1][ln-1]*(k-(ln-1))%MOD+gsum)%MOD; &#125; &#125; for(int left=0;left&lt;=n-m;left++) &#123; ll fsum=0,gsum=0; for(int ln=k-1;ln&gt;=1;ln--) (fsum+=f[left][ln])%=MOD,(gsum+=g[n-m-left][ln])%=MOD; (ans-=fsum*gsum%MOD)%=MOD; &#125; &#125; else &#123; f[0][0]=1; for(int i=1;i&lt;=n;i++) &#123; ll fsum=0,gsum=0; for(int ln=k-1;ln&gt;=1;ln--) &#123; (fsum+=f[i-1][ln])%=MOD;(gsum+=g[i-1][ln])%=MOD; f[i][ln]=(f[i-1][ln-1]*(k-(ln-1))%MOD+fsum)%MOD; g[i][ln]=(g[i-1][ln-1]*(k-(ln-1))%MOD+gsum)%MOD; if(ln&gt;=m) (g[i][ln]+=f[i][ln])%=MOD; &#125; &#125; ll tot=0; for(int i=1;i&lt;=k-1;i++) (tot+=g[n][i])%=MOD; (ans-=tot*inv(P(k,m))%MOD)%=MOD; &#125; printf("%lld",(ans+MOD)%MOD); &#125;&#125;int main()&#123; mine::main();&#125; arc0995 E - Independence9.21 难度1题意：给定一个有 n 个节点， m条边的无向图，保证没有自环和重边。请你把所有的 n 个节点分成两组，同组中的任意两个节点之间都有边直接连接。问连接同组节点的总边数最小为多少？如果不存在合法的划分方案，则输出 −1 请先思考后再展开 我能想到的最好做法：题目要求分成两个团，取补图后就是分成两个独立集那么这个可以二分图染色，因为边意味着排斥关系然后我们需要最小化 $min{ \frac{a(a-1)+b(b-1)}{2} }$因为染色的时候我们会先入为主，那其实是可以整体取反的，也就是交换a和b为了求最小值，我想到二维背包，但时间为 $O(n^3)$感觉3亿在atcoder上应该是能跑过去的……有了上一道题的经验 我tm在想些什么？？？a+b=n，做个屁的二维背包……气到不想打 arc0986 D - Xor Sum 29.21 难度2题意：给你一个长度为n的整数序列，让你求出满足以下条件的(l, r)的对数：其异或和=其和 请先思考后再展开 能想到的最好做法：维护一个前缀异或和a，前缀和b$a[r]^a[l-1]=b[r]-b[l-1]$然而异或没法和四则运算一起化柿子，复杂度只能是 $O(n^2)$ 正解：刚问出来就被秒掉了$0 xor 0=0,0+0=0$$0 xor 1=1,0+1=1$$1 xor 1=0,1+1=2$唯一的差异就是进位而这个差异是没有办法消除的，只能避免所以该区间一定不会在同一个位置上存在超过一个1所以具有单调性 7 E - Range Minimum Queries9.21 难度2题意：给定一个n个数的数列和两个整数数K,Q，执行Q次操作：选择一段长度为K的区间，删除其中的最小值。问：执行Q次操作后，被删除的数的最小值和最大值之差 的最小值是多少？ 请先思考后再展开 max-min的最小值显得很复杂但因为取得都是原本就有的数，所以可以枚举min，然后找最小的max因为min确定了，那么不能有任何区间包含小于min的数，这些数把整个区间分成很多段对于每个长度为len的段，只能取出前面len-k小的数把每个段能贡献的所有数排序，其中第q小的就是答案 arc0978 D - Equals9.21 难度2题意：给出可交换的两个位置，和一个排列，最大化pi=i的位置 请先思考后再展开 这都没想出来……对于能间接互相交换的位置，假设有a要和b交换，则总是能够a到b，此时b被挤开，跳到a，然后中间的部分不会发生改变 所以，可以用并查集维护间接到达关系，然后询问能够回到原本位置即可 9 E - Sorted and Sorted9.21 难度1题意：排成一列的2N个球，有黑球和白球，黑球和白球上面都写了1-N的数字，给定一个操作：swap相邻两个球。问最少操作次数使得白球和黑球上的序号都分别递增。 请先思考后再展开 从简单问题入手，如果给出一个n的排列，要让a[i]=i，只能相邻交换此时因为每次交换只能消除一个逆序对，所以答案是逆序对数此时所谓逆序对即原位置p1，终位置p2， $p1[i]&gt;p1[j]且p2[i]&lt;p2[j]$ 那么回到本题，求出一个最优秀的终止状态p2，就能得出答案了那么，白球和黑球内部要有序，但交错的顺序不确定即使暴力也不好枚举，但因为黑白内部的顺序已经确定，不难想到可以用类似字符串匹配的方式dp 设 $f(x \leq 2n,a,b)$ 表示填写到第x位，白色填了a个，黑色填了b个的逆序对最少个数显然i=a+b，实现的时候需要去除一维转移的话，关键就是要快速地计算新逆序对设白色的id为x，则对应黑色的id为n+x当放白色， $p1[t]&gt;p1[a]，t=1 \to a-1和n+1 \to n+b$当放黑色， $p1[t]&gt;p1[n+b]，t=1 \to a和n+1 \to n+b-1$这个东西可以预处理一下，然后就能达到 $O(n^2)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=2100; const int INF=0x3f3f3f3f; typedef long long ll; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int p1[MAX_N*2]; int f[MAX_N*2][MAX_N]; int nw[MAX_N*2][MAX_N*2]; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=2*n;i++) &#123; char s[5];int id;scanf("%s%d",s,&amp;id); p1[id+n*(s[0]=='B')]=i; &#125; for(int i=1;i&lt;=2*n;i++) for(int t=1;t&lt;=2*n;t++) nw[i][t]=nw[i][t-1]+(p1[t]&gt;p1[i]); memset(f,63,sizeof f);f[0][0]=0; for(int x=1;x&lt;=2*n;x++) &#123; for(int a=0;a&lt;=x and a&lt;=n;a++) &#123; int b=x-a; if(a&gt;0) f[x][a]=mymin(f[x][a], f[x-1][a-1]+nw[a][a-1]+nw[a][n+b]-nw[a][n] ); if(b&gt;0) f[x][a]=mymin(f[x][a], f[x-1][a]+nw[n+b][a]+nw[n+b][n+b-1]-nw[n+b][n] ); &#125; &#125; printf("%d",f[2*n][n]); &#125;&#125;;int main()&#123; mine::main();&#125; 10 F - Monochrome Cat9.24 难度2题意：给定一棵有n个节点的树，每个点有黑白两个颜色。现在有一只猫可以从任意节点开始，任意一个节点结束，要把所有节点染成黑色。可以执行如下两种操作之一： 移动到相邻节点，并改变其颜色 改变当前节点颜色求：把所有节点染成黑色所需的最少操作次数数据范围：N&lt;=2e5 请先思考后再展开 设白0黑1 不难想到：如果叶子节点是黑色，可以删除，如此重复直到所有叶子节点都是白色位置 如果起点和终点一样，显然遍历所有叶子节点需要遍历每个节点和边（基于上面的操作）如果对于一个点，其度是偶数，意味着会被抵消掉，如果此时是白色则要改变，同理如果是奇数而且是黑色，也要改变自己一次，所以答案为 $\sum 度数+【(度数+颜色)\%2=0】$ 但如果起点和终点不一样呢？和起点终点相同的情况相比，从路径的形式上 就是少了【起点到终点的一条链】，这个过程中，如果本来不需要操作就是黑色的节点，现在少经过一次，但需要操作，代价不变而本来需要操作的节点，现在不经过，也不需要操作，少了2的代价 现在问题转化成，需要找出一条链，经过最多【本来需要操作的节点】，不过每个节点最多经过一次，而且链的终点不能累加 这个终点有点烦人，但注意到终点总是能拓展的，即使是最极端的叶子节点，因为度数=1，颜色一定是白色，所以权值为0，不是必须终点，即使终点为其父亲，形式上也可延伸到叶子节点综上所述，只要在原答案的基础上，减去带权树的直径即可 arc09611 E - Everything on It9.21 难度2题意：拉面有 n 种配料 每种配料可以选择加入到拉面中，也可以不加入一共 $2^n$ 种组合 有人来订购一些拉面要求：每种拉面配料不能相同。每种配料在全部的面中至少出现过两次。 请先思考后再展开 这道题一眼容斥来搞【不能出现少于两次】的这个条件$ANS=\sum_{k=0}^n (-1)^k C(n,k) f(k)$其中f(k)表示有k个颜色只能不用或用一次，剩下n-k个颜色任意放，但不能出现两个完全相同的组合数然后到这里我就不知道怎么处理不能完全相同这个问题了 f(k)应该分两部分去思考① 不合法的k个颜色那么相当于这k个元素，要么不放，要么放进一个集合中假设有t个非空集合，那么这个是类似于第二类斯特林数的（刚学……）递推式： $g(k,t)=g(k-1,t-1)+g(k-1,t) \times (t+1)，0 \leq t \leq k$解释：在原本第二类斯特林数的基础上，加上【可以丢掉】这个选项可以是把第k个元素单独放进第t个位置，也可能第t个集合是混合的，再或者丢掉②其他的n-k个颜色这里非常巧妙，也是我一直不知道怎么解决的地方方案数量为 $2^{n-k}$那么对于那k个非法元素，本来觉得超级复杂，其实因为每个最多出现一次，不同的碗一定不会重复所以是 $2^{(n-k)t}$ 而合法元素的话，不应该和碗的数量扯上关系，而是考虑把每个方案看作一个碗，考虑这个碗是否出现所以是 $2^{2^{n-k}}$ 综上所述， $f(k)=\sum_{t=0}^k g(k,t) \times 2^{(n-k)t} \times 2^{2^{n-k}}$套一个小费马定理即可 12 F - Sweet Alchemy9.24 难度2题意：n≤50的树，每个点有权值，现要选点（可多次选一个点）使点数尽量多，如下限制：选的总权值不超过C≤1e9；ci表示i选的次数，pi表示i的父亲，那么cpi≤ci≤cpi+D，D≤1e9是给定常数。 请先思考后再展开 因为子节点选择的数量至少比父节点多可以把操作看做是选择一整棵子树，那么问题转化成： 有n个物品，有体积和价值，要求在体积小于X的条件下让价值最大化，每个物品也有选择次数的限制（根节点无限，其他节点为D）观察值域，物品的数量很小，体积很大，单个价值很小，次数很大直接用多重背包的模板，无法存下体积，用价值dp的话，总价值可能也会很大（因为次数大） 此时有一个很不好想到的姿势：用贪心代替大部分dp结论：每个物品，只用前面n个去dp，其他的贪心该贪心主要用微扰（应该是吧？）来证明：当物品数量足够大的时候，如果不考虑小的误差，是可以用贪心，选择性价比高的物品来得到大致结果的为什么只能是大致呢？主要可能是部分细小的体积有优化空间 思考什么情况下，选择性价比高的物品一定是正确的设有物品i和j， 并假设i的性价比更高即 $v_i / w_i &gt; v_j / w_j$选择vi个j物品，和选择vj个i物品，其价值都是 $v_i \times v_j$但体积 $w_j \times v_i &gt; w_i \times v_j$ 也就是说选择i的体积更小这就是说，当达到此数量级，一定是性价比高的更优秀 那么，在这个数量级之外的次数可以用贪心计算，内部的情况因为比较复杂，不能贪心，只能dp那么注意到w在单个的时候，和n是同阶的，也就是dp的权值是 $n^3$ 级别的，而体积依然非常大所以应该用权值来dp，即 $f[权值]=min 体积$考虑到用二进制拆分法处理多重dp，值域为 $n^3$ ，时间复杂度为 $O(n^4logn)$ dp完成后，剩余的空间就贪心地在剩余物品中选择即可 up：忘记了，用单调队列优化一下就到n四方了…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=60; const int INF=0x3f3f3f3f; typedef long long ll; struct LJB &#123; int hou[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N]; int ln;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; LJB() &#123;ln=0;memset(hou,0,sizeof hou);&#125; &#125;E; struct Nod &#123; ll w,v; ll num; &#125;p[MAX_N]; bool cmp(Nod a,Nod b) &#123;return a.w*b.v&gt;b.w*a.v;&#125; //规避除法，已知都是非负数 void dfs(int x,int fa) &#123; p[x].w=1; for(int k=E.hou[x];k&gt;0;k=E.e[k].g) &#123; int y=E.e[k].y;if(y==fa) continue; dfs(y,x); p[x].w+=p[y].w;p[x].v+=p[y].v; &#125; &#125; ll f[MAX_N*MAX_N*MAX_N]; void main() &#123; int n;ll mxV,D;scanf("%d%d%d",&amp;n,&amp;mxV,&amp;D); scanf("%lld",&amp;p[1].v); for(int i=2;i&lt;=n;i++) &#123; int fa;scanf("%lld%d",&amp;p[i].v,&amp;fa); E.ins(fa,i); &#125; dfs(1,0); memset(f,63,sizeof f);f[0]=0; for(int i=1;i&lt;=n;i++) &#123; ll num=mxV/p[i].v;//debug v可能退化成int再参与运算 if(i&gt;1) num=min(num,(ll)D); if(num&gt;n) p[i].num=num-n,num=n; else p[i].num=0; ll now=1; while(num&gt;0) &#123; ll w=now*p[i].w,v=now*p[i].v; for(int ww=n*n*n;(ll)ww&gt;=w;ww--) f[ww]=min(f[ww],f[ww-w]+v); num-=now; now=min(now&lt;&lt;1,num); &#125; &#125; sort(p+1,p+n+1,cmp); ll ans=0; for(int ww=0;ww&lt;=n*n*n;ww++) &#123; if(f[ww]&gt;mxV) continue; ll ret=ww,left=mxV-f[ww]; for(int i=1;i&lt;=n;i++)//debug 注意此时不是原编号 &#123; ll num=min(left/p[i].v,p[i].num); left-=num*p[i].v;ret+=num*p[i].w; &#125; ans=max(ans,ret); &#125; printf("%lld",ans); &#125;&#125;;int main()&#123; mine::main();&#125; arc10313 E - Tr/ee9.30 难度2题意：构造题给出一个01串，位置i表示能否通过去除某条边得到大小为i的联通块 请先思考后再展开 rose秒了……我的思路：显然位置1一定是1，位置n一定是0然后它还必须具有对称性 构造的话我想着可能应该从链开始考虑，然后像样例那样构造出一个大小合法的子树 但随后我就不知道如何保证一定不会出现某个大小了正解：从大到小枚举，如果不可行就作为单个节点挂在根节点那里（反正大小为1一定会产生）否则搞一个大小为i的子树，递归下去 12345678910111213141516171819202122char s[MAX_N];int id=0;void solve(int x,int siz)&#123; for(int i=siz-1;i&gt;=1;i--) &#123; printf("%d %d\n",x,++id); if(s[i]=='1') &#123; solve(id,i); break; &#125; &#125;&#125;void main()&#123; scanf("%s",s+1);int n=strlen(s+1); for(int i=1;i&lt;=n/2;i++) if(s[i]!=s[n-i]) &#123;puts("-1");return;&#125; if(s[1]=='0' or s[n]=='1') &#123;puts("-1");return;&#125; solve(++id,n);&#125; D - Robot Arms9.30 难度2题意：确定小于等于40个步长，长度自己定，但要应对所有询问满足n个询问（1000内），通过上下左右能到达不同的n个位置，并输出具体方案 请先思考后再展开 大致思路是二进制拆分，但本题的难点就在于只能上下左右，不能不走比赛的时候想过，如果放大限制行不行？例如把每个位置拆开成2个、3个乃至4个，但好像都不行比赛就只打了个暴力部分分 正解看起来很暴力，晚上对着yww大爷的代码看半天全机房都不会证明……就是从大到小，然后看x和y哪个绝对值大，然后就“gao”，最后再移动多几步第二天早上过来，忽然就大致理解了这道题的特殊性就在于1和-1的运用，也就是说虽然不能都不走，但是可以对二进制做差而二进制有这许多非常奇妙的性质，比如说后面的t个二进制之和+1是等于t+1个二进制所以如果我们直接把x搞定了，剩下的部分做和、差总是能得出y的（因为最大拼出int，而x+y小于int） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=1100; int n,x[MAX_N],y[MAX_N]; vector&lt;int&gt; d; vector&lt;char&gt; ans[MAX_N]; void gao(int k) &#123; d.push_back(k); for(int i=1;i&lt;=n;i++) if(abs(x[i])&gt;abs(y[i])) &#123; if(x[i]&lt;0) x[i]+=k,ans[i].push_back('L'); else x[i]-=k,ans[i].push_back('R');//debug 倒着走！ &#125; else &#123; if(y[i]&lt;0) y[i]+=k,ans[i].push_back('D'); else y[i]-=k,ans[i].push_back('U'); &#125; &#125; void main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;x[i],&amp;y[i]); for(int i=30;i&gt;=0;i--) gao(1&lt;&lt;i); for(int i=1;i&lt;=8;i++) gao(1); if(x[1]!=0 or y[1]!=0) gao(1);//曼哈顿距离为奇数 for(int i=1;i&lt;=n;i++) if(x[i]!=0 or y[i]!=0) &#123;puts("-1");return;&#125; printf("%d\n",d.size()); for(int i=0;i&lt;(int)d.size();i++) printf("%d ",d[i]); puts(""); for(int i=1;i&lt;=n;i++) &#123; for(int j=0;j&lt;(int)ans[i].size();j++) printf("%c",ans[i][j]); puts(""); &#125; &#125;&#125;int main()&#123; mine::main();&#125; F - Distance Sums9.30 难度2题意：构造一棵树给出对于每个节点，其他节点到它的距离之和 请先思考后再展开 按照d排序，d最小的一定是树的重心那么考虑d最大的节点，同理，它一定是叶子节点，否则存在比它更大的d那么每次取出最大的d，它的子树确定，同时它的父亲也是能够确定的（ $d[fa]=d[x]-n+2 \times siz[x]$ ）最后还必须要跑一次dfs验证，因为此时只能说相对大小是正确的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int n; const int MAX_N=110000; struct Nod &#123; ll d;int p,siz; friend bool operator &lt; (Nod a,Nod b) &#123;return a.d&lt;b.d;&#125; &#125;p[MAX_N]; #define PR pair&lt;int,int&gt; vector&lt;PR&gt; ans; int hou[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N*2]; int ln=0; void ins(int x,int y) &#123; e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln; &#125; ll f[MAX_N]; void dfs(int x,int fa,int dis) &#123; f[x]=dis; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dfs(y,x,dis+1); &#125; &#125; void main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;p[i].d),p[i].p=i,p[i].siz=1; sort(p+1,p+n+1); for(int i=n;i&gt;=2;i--) &#123; ll want=p[i].d-n+2*p[i].siz; int fa=lower_bound(p+1,p+n+1,(Nod)&#123;want,0,0&#125;)-p;//互不相同 if(p[fa].d!=want or fa==i) &#123;puts("-1");return;&#125; ins(p[i].p,p[fa].p);ins(p[fa].p,p[i].p); ans.push_back( make_pair(p[i].p,p[fa].p) ); p[fa].siz+=p[i].siz; &#125; dfs(1,0,0); ll rt=0,rt2=0;for(int i=1;i&lt;=n;i++) &#123;rt+=f[i];if(p[i].p==1) rt2=p[i].d;&#125; if(rt!=rt2) &#123;puts("-1");return;&#125; for(int i=0;i&lt;(int)ans.size();i++) printf("%d %d\n",ans[i].first,ans[i].second); &#125;&#125;int main()&#123; mine::main();&#125; arc096###9.21 难度2题意： 请先思考后再展开 12 ###9.21 难度2题意： 请先思考后再展开 12]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【训练】算法竞赛进阶指南-4数据结构 8题]]></title>
    <url>%2Fposts%2F59da.html</url>
    <content type="text"><![CDATA[本处难度分档以个人实力为参照系难度1：半小时内想出，半小时内ac难度2：半小时想不出，看题解，服气难度3：半小时想不出，看题解，ac后依然觉得难度很大 另外，由于追进度，对于coding部分比较有自信的题目，不再具体实现 0x40 数据结构部分题目 1 Noi2015 程序自动分析9.18 难度1请先思考后再展开 交上去50，真的难受码的时候还在想为什么po姐要拍……立刻就打脸了虽然说没细细检查主要是输入的时候，把x放进去了两次……超搞笑好吧对noip超虚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=1100000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int fa[MAX_N*2]; int findfa(int x) &#123;return fa[x]=(fa[x]==x?x:findfa(fa[x]));&#125; void join(int x,int y) &#123; int fx=findfa(x),fy=findfa(y); if(fx!=fy) fa[fx]=fy; &#125; struct Data &#123; int d,p; friend bool operator &lt; (Data a,Data b) &#123;return a.d&lt;b.d;&#125; &#125;a[MAX_N*2]; int yz[MAX_N*2]; int op[MAX_N]; int n; bool check() &#123; for(int i=1;i&lt;=n;i++) if(!op[i]) &#123; int fx=findfa(yz[2*i-1]),fy=findfa(yz[2*i]); if(fx==fy) return 0; &#125; return 1; &#125; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int x,y;scanf("%d%d%d",&amp;x,&amp;y,&amp;op[i]); a[2*i-1].d=x;a[2*i-1].p=2*i-1; a[2*i].d=y;a[2*i].p=2*i;//debug &#125; sort(a+1,a+2*n+1); int rx=1;yz[a[1].p]=rx; for(int i=2;i&lt;=2*n;i++) rx+=(a[i-1].d!=a[i].d),yz[a[i].p]=rx; for(int i=1;i&lt;=rx;i++) fa[i]=i; for(int i=1;i&lt;=n;i++) if(op[i]) join(yz[2*i-1],yz[2*i]); if(check()) puts("YES"); else puts("NO"); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 2 poj1456 Supermarket9.18 难度1请先思考后再展开 我的做法和网上的都不一样lyd1：在前i天，尽量卖出合法的前i个值lyd2：从大到小处理，然后找过期前面的空位，可以用并查集加速我的做法：从大到小枚举天数，每次把这一天的所有新商品放到堆里面，然后卖出其中最大的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=11000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int hou[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N]; int ln;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; struct Nod &#123; int a,b; friend bool operator &lt; (Nod x,Nod y) &#123;return x.a&lt;y.a;&#125; &#125;p[MAX_N]; priority_queue&lt;Nod&gt; q; void main() &#123; int n; while(scanf("%d",&amp;n)!=EOF) &#123; ln=0;memset(hou,0,sizeof hou); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].a,&amp;p[i].b),ins(p[i].b,i); int ans=0;while(!q.empty()) q.pop(); for(int now=MAX_N-1;now&gt;=1;now--) &#123; for(int k=hou[now];k&gt;0;k=e[k].g) q.push(p[e[k].y]); if(q.empty()) continue; Nod t=q.top();q.pop(); ans+=t.a; &#125; printf("%d\n",ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 3 poj1733 Parity game9.18 难度1请先思考后再展开 lyd边带权做法：奇1偶0，路径压缩时异或同集合判断合法性，不同集合就合并 lyd拓展域做法：拆成奇数域和偶数域，同集合表示一种能互相推导的关系判断非法的话，是根据此前是否有和当前操作相反的信息 我的做法是乱yy的，和拓展域做法类似区别： 在我的理解里面，拆点表示和我不一样（因为只有两个情况） 判断非法时，我是看是否会导致我和我的对立点相同12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=11000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int fa[MAX_N]; int findfa(int x) &#123;return fa[x]=(x==fa[x]?x:findfa(fa[x]));&#125; void merg(int x,int y) &#123; int fx=findfa(x),fy=findfa(y); if(fx!=fy) fa[fx]=fy; &#125; bool one(int x,int y) &#123;int fx=findfa(x),fy=findfa(y);return fx==fy;&#125; struct Nod &#123; int d,p; friend bool operator &lt; (Nod a,Nod b) &#123;return a.d&lt;b.d;&#125; &#125;a[MAX_N]; int yz[MAX_N]; bool v[MAX_N]; char s[10]; int solve() &#123; int n,q;scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=q;i++) &#123; int l,r;scanf("%d%d%s",&amp;l,&amp;r,s+1); if(l&gt;r or r&gt;n) return i-1; v[i]=(s[1]=='o'); a[2*i-1]=(Nod)&#123;l-1,2*i-1&#125;;//debug 不能离散化l a[2*i]=(Nod)&#123;r,2*i&#125;; &#125; sort(a+1,a+2*q+1); int rx=1;yz[a[1].p]=rx; for(int i=2;i&lt;=2*q;i++) rx+=(a[i-1].d!=a[i].d),yz[a[i].p]=rx; for(int i=1;i&lt;=2*rx;i++) fa[i]=i; for(int i=1;i&lt;=q;i++) &#123; int l1=yz[2*i-1],r=yz[2*i]; if(v[i]) merg(l1,rx+r),merg(rx+l1,r); else merg(l1,r),merg(rx+l1,rx+r); if(one(l1,rx+l1) or one(r,rx+r)) return i-1; &#125; return q; &#125; void main() &#123; printf("%d",solve()); &#125;&#125;;int main()&#123; mine::main();&#125; 4 poj2182 Lost Cows9.18 难度1请先思考后再展开 如果前面有k个比我大的，那么显然我就是当前可选里面第k+1名从后往前，那么我们需要一个数据结构维护当前第k大，支持删除splay和树状数组都可以，就看值域了，显然这道题选择树状数组适合 5 4302 Interval GCD9.18 难度2请先思考后再展开 太巧妙了原串的GCD和差分的GCD相同 6 Violet 蒲公英9.19 难度2请先思考后再展开 区间众数！而且因为强制在线，把莫队卡掉了 显然数字先离散化设每个块的长度为T设询问和N相同量级 方法一：暴力处理每次询问，时间复杂度$O(n^2)$ 方法二：以块编号为端点，得出 $(n/T)^2$ 个区间，每个区间存储当前众数具体计算可以确定左端点，然后向右暴力 再以块编号为端点，前缀和存储每个颜色出现个数（可以在刚才的步骤中顺便算好）对于每次询问，A为整区间[L,R]的众数，在前缀和数组的基础上，遍历两边的零散区域，B=A，动态更新维护B，得出答案后再还原时间复杂度$O(n^2/T+nT)$取$T=n……{1/2}$，得出最小值$O(n^{3/2})$，本题=11000000（可以强行把两边相等，一般都是最小……我也不知道为什么） 方法三：以块编号为端点，得出 $(n/T)^2$ 个区间，每个区间存储当前众数具体计算可以确定左端点，然后向右暴力 然后我们还需要维护一个vector，以数值为索引，保存该数字所有出现位置对于每次询问，A为整区间[L,R]的众数，再遍历两边的零散区域，B=A，对于每个数字，在vector中二分得出l到r出现次数，维护B时间复杂度$O((n/T)n+nTlogn)=O(n^2/T+Tnlogn)$（同样可以强行相等），取$T=\sqrt \frac{n}{logn}$时间复杂度$O(n \sqrt {nlogn})$，本题=45000000 7 CH#46 磁力块9.19 难度1请先思考后再展开 一开始没思路，看了看第一句话居然就有想法了因为有两个条件，不妨用其中一个排序，然后在当前的序列中分块，大小为T然后在每个块，相互之间完全独立，然后内部保持另一个条件的有序性 然后我们用类似bfs的思想去维护（这就是我看的那句话，好菜……）那么每次询问，可以二分一个k，保证k前面都是小于，k后面都是大于那么k前面的部分，枚举每个块，然后从左往右扫描，直到不满足条件，此时把满足的删除，放入队列中对于第k个块，暴力处理，维护好l到r的连续性，整体不连续没有关系，因为已经相对独立 分析一下复杂度，当时考虑的时候我是考虑尺取法的思想，就是指针的单调性（整体不单调，局部单调）对于这道题，出去了就不会进来，每个被指针扫描过的点，都不会再次经过所以复杂度是$O(nT+n^2/T)$，T取根号为最优12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=310000; typedef long long ll; ll mysqr(ll x) &#123;return x*x;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; struct Nod &#123; ll dis,bj; int m,cl; &#125;p[MAX_N],tmp[MAX_N]; //p以块的形式，相对独立在 int left[MAX_N],right[MAX_N]; bool cmp(Nod a,Nod b) &#123;return a.dis&lt;b.dis;&#125; ll ds[MAX_N];//仅用来找，哪些块一定满足 bool cmp2(Nod a,Nod b) &#123;return a.m&lt;b.m;&#125; int n; queue&lt;Nod&gt; q; int solve() &#123; int T=sqrt(n); sort(p+1,p+n+1,cmp); for(int i=1;i&lt;=n;i++) ds[i]=p[i].dis; for(int i=1;i&lt;=(n-1)/T+1;i++) &#123; left[i]=(i-1)*T+1;right[i]=mymin(n,i*T); int fl=left[i],fr=right[i]; sort(p+fl,p+fr+1,cmp2); &#125; q.push(p[0]);int tot=0; while(!q.empty()) &#123; Nod now=q.front();q.pop(); int rr=upper_bound(ds+1,ds+n+1,now.bj)-ds-1;//&lt;=半径 int ed=(rr-1)/T+1; for(int i=1;i&lt;=ed-1;i++)//完整块 &#123; int r=left[i]-1;while(p[r+1].m&lt;=now.cl and r+1&lt;=right[i]) r++,q.push(p[r]),tot++; left[i]=r+1; &#125; int tt=0; for(int i=left[ed];i&lt;=right[ed];i++) if(p[i].dis&lt;=now.bj and p[i].m&lt;=now.cl) q.push(p[i]),tot++; else tmp[++tt]=p[i]; right[ed]=left[ed]+tt-1; for(int i=left[ed];i&lt;=right[ed];i++) p[i]=tmp[i-left[ed]+1]; &#125; return tot; &#125; void main() &#123; int x0,y0;scanf("%d%d%d%lld%d",&amp;x0,&amp;y0,&amp;p[0].cl,&amp;p[0].bj,&amp;n); p[0].dis=0;p[0].bj=mysqr(p[0].bj); for(int i=1;i&lt;=n;i++) &#123; int x,y;scanf("%d%d%d%d%lld",&amp;x,&amp;y,&amp;p[i].m,&amp;p[i].cl,&amp;p[i].bj); p[i].bj=mysqr(p[i].bj);//规避double p[i].dis=mysqr(x-x0)+mysqr(y-y0); &#125; printf("%d",solve()); &#125;&#125;;int main()&#123; mine::main();&#125; 0x49 数据结构练习部分题目 8 IOI1998 Picture9.19 难度2请先思考后再展开 问题转化为，通过一个数据结构，只有区间+1和-1两种操作，然后保证运算过程中始终不是负数求整个区间的0的数量（通过变化量得出周长） 然后这东西昨天中午想过，想出来了，然后听说是练习的题目，所以就想着到时再说结果今天忘记昨天曾经想过了……而且还不会做其实只要维护区间最小值以及其次数即可，关键是【始终没有负数】的性质123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=5100; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; struct Seg &#123; int mi,num; int lz; &#125;p[21000*5]; #define lc (2*x) #define rc (2*x+1) void update(int x) &#123; p[lc].mi+=p[x].lz;p[lc].lz+=p[x].lz; p[rc].mi+=p[x].lz;p[rc].lz+=p[x].lz; p[x].lz=0; &#125; void pre(int x,int l,int r) &#123; p[x].mi=p[x].lz=0; if(l==r) p[x].num=1; else &#123; int mid=(l+r)&gt;&gt;1; pre(lc,l,mid);pre(rc,mid+1,r); p[x].num=p[lc].num+p[rc].num; &#125; &#125; void change(int x,int l,int r,int fl,int fr,int cc) &#123; if(l==fl and r==fr) &#123; p[x].mi+=cc; p[x].lz+=cc; return; &#125; update(x); int mid=(l+r)&gt;&gt;1; if(fr&lt;=mid) change(lc,l,mid,fl,fr,cc); else if(fl&gt;mid) change(rc,mid+1,r,fl,fr,cc); else change(lc,l,mid,fl,mid,cc),change(rc,mid+1,r,mid+1,fr,cc); p[x].mi=mymin(p[lc].mi,p[rc].mi); if(p[lc].mi==p[rc].mi) p[x].num=p[lc].num+p[rc].num; else if(p[lc].mi&lt;p[rc].mi) p[x].num=p[lc].num; else p[x].num=p[rc].num; &#125; int getid(int x) &#123;return 10000+x;&#125;//化点为区间后，最小为-9999 int getzero() &#123;return (p[1].mi==0)?p[1].num:0;&#125; struct Nod&#123;int x,y0,y1,cc;&#125;s[MAX_N*2]; bool cmp(Nod a,Nod b) &#123;return a.x&lt;b.x or (a.x==b.x and a.cc&gt;b.cc);&#125; //先增后减，防止不同矩形的重边 int n,pos[MAX_N][2][2]; int solve(int op) &#123; for(int i=1;i&lt;=n;i++) &#123; s[2*i-1]=(Nod)&#123;pos[i][op][0],pos[i][op^1][0],pos[i][op^1][1],1&#125;; s[2*i]=(Nod)&#123;pos[i][op][1],pos[i][op^1][0],pos[i][op^1][1],-1&#125;; &#125; sort(s+1,s+2*n+1,cmp); pre(1,getid(-9999),getid(10000)); int ans=0,lst=getzero(); for(int i=1;i&lt;=2*n;i++) &#123; //忘记化点为区间了 change(1,getid(-9999),getid(10000),getid(s[i].y0+1),getid(s[i].y1),s[i].cc); int t=getzero();ans+=myabs(lst-t);lst=t; &#125; return ans; &#125; void main() &#123; while(scanf("%d",&amp;n)!=EOF) &#123; for(int i=1;i&lt;=n;i++) scanf("%d%d%d%d",&amp;pos[i][0][0],&amp;pos[i][1][0],&amp;pos[i][0][1],&amp;pos[i][1][1]); printf("%d\n",solve(0)+solve(1)); &#125; &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF#509 比赛总结]]></title>
    <url>%2Fposts%2Fbeed.html</url>
    <content type="text"><![CDATA[CF#509 比赛总结题目即1041F，1041E，1041D，1041C，1041B，1041A 比赛经历t1原本超快做完，然后submit没按到+交错语言，ggt2一开始忘记gcd了，还好良心样例t3感觉可以贪心，对set不太熟悉，因为要找upper-1的位置，然后感觉写不了就感觉只能splay（虽然我知道一定不是正解，毕竟是cf）先去看t4，发现可以尺取法，写完发现tkj也是先t4，感觉可能t3码农，不过同学都切完是什么鬼耐下性子，老老实实写splay，感觉思路特清晰，写的很快（毕竟至少5个月没写过了……）过了以后只剩10min了，发现自己是最慢的（大众四题，毫无竞争力）……手速弱鸡表示怀念oi赛制然后就是真的要认真了解一下stl+结构题的各种语法了 T1_Analysis请先思考后再展开 没什么好说的mx-mi+1-n T1_Code_old请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=110000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; ll MOD; ll qpower(ll x,ll e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; void main() &#123; int n;scanf("%d",&amp;n); int mi=0x3f3f3f3f,mx=0; for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); if(t&lt;mi) mi=t; if(t&gt;mx) mx=t; &#125; printf("%d",mx-mi+1-n); &#125;&#125;;int main()&#123; mine::main();&#125; T2_Analysis请先思考后再展开 gcd+向下取整 T2_Code_old请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=110000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; ll MOD; ll qpower(ll x,ll e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll gcd(ll a,ll b) &#123;return b==0?a:gcd(b,a%b);&#125; void main() &#123; ll a,b,x,y;scanf("%I64d%I64d%I64d%I64d",&amp;a,&amp;b,&amp;x,&amp;y); ll d=gcd(x,y);x/=d;y/=d; ll t=floor((double)a/x); ll t2=floor((double)b/y); printf("%I64d",t&lt;t2?t:t2); &#125;&#125;;int main()&#123; mine::main();&#125; T3_Analysis请先思考后再展开 我的做法是贪心地去找 $a&lt;a2-d$ 中最大的，时间复杂度nlognset的新内容已经在oi之路的stl处更新然后看rk1发现可以 $O(n)$ 贪心得更加彻底：同样是排序后，维护k为“当天合法最远距离”，可以用尺取法实现，那么中间的一定是其他天数的然后就1 2 3 4 …… k 1 2 3 …… k 这样分配，不难发现这样一定是合法的，最小性同样可以证明，因为如果用更大的，例如r+1和l在同一天，那么答案不会变小 T3_Code_old请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=110000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; struct Nod &#123; int son[2],f; int d,pos; Nod() &#123;son[0]=son[1]=f=d=pos=0;&#125; &#125;p[MAX_N*2]; void rotate(int x,int w) &#123; int f=p[x].f,ff=p[f].f; if(p[ff].son[0]==f) p[ff].son[0]=x; else p[ff].son[1]=x; p[x].f=ff; int pson=p[x].son[w]; p[f].son[1-w]=pson; if(pson&gt;0) p[pson].f=f; p[x].son[w]=f; p[f].f=x; &#125; int root; void splay(int x,int rt) &#123; while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(ff==rt) &#123; if(p[f].son[0]==x) rotate(x,1); else rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==0) root=x; &#125; int findip(int d) &#123; int x=root; while(p[x].d!=d) &#123; int lc=p[x].son[0],rc=p[x].son[1]; //printf("x=%d lc=%d rc=%d\n",x,lc,rc); if(d&lt;p[x].d) &#123; if(!lc) break; x=lc; &#125; else &#123; if(!rc) break; x=rc; &#125; &#125; return x; &#125; int id=0; void insert(int d,int pos) &#123; //printf("d=%d\n",d); if(root==0) &#123; root=++id; p[id].d=d; p[id].pos=pos; return; &#125; int t=findip(d); //printf("d=%d t=%d\n",d,t); p[++id].f=t;if(d&lt;p[t].d) p[t].son[0]=id; else p[t].son[1]=id; p[id].d=d;p[id].pos=pos; splay(id,0); &#125; void del(int d) &#123; int x=findip(d); if(p[x].d!=d) return; splay(x,0); int lc=p[x].son[0],rc=p[x].son[1]; if(lc==0 and rc==0) &#123; root=0; &#125; else if(lc&gt;0 and rc==0) &#123; root=lc;p[lc].f=0; &#125; else if(lc==0) &#123; root=rc;p[rc].f=0; &#125; else &#123; int t=lc; while(p[t].son[1]&gt;0) t=p[t].son[1]; splay(t,x); root=t;p[t].f=0; p[t].son[1]=rc;p[rc].f=t; &#125; &#125; int findQ(int d) &#123; int x=findip(d);splay(x,0); if(p[x].d&gt;=d and p[x].son[0]&gt;0) &#123; x=p[x].son[0]; while(p[x].son[1]&gt;0) x=p[x].son[1]; &#125; if(p[x].d&lt;d) return x; return -1; &#125; struct dat &#123; int d,p; &#125;a[210000]; bool cmp(dat a,dat b) &#123;return a.d&lt;b.d;&#125; int ans[210000]; void main() &#123; root=0; int n,m,d;scanf("%d%d%d",&amp;n,&amp;m,&amp;d); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i].d),a[i].p=i; sort(a+1,a+n+1,cmp); ans[a[1].p]=1; insert(a[1].d,a[1].p); int id=1; for(int i=2;i&lt;=n;i++) &#123; int t2=findQ(a[i].d-d);//&lt;a[i].d-d if(t2&lt;0) &#123; ans[a[i].p]=++id; insert(a[i].d,a[i].p); &#125; else &#123; ans[a[i].p]=ans[p[t2].pos]; del(p[t2].d); insert(a[i].d,a[i].p); &#125; &#125; printf("%d\n",id); for(int i=1;i&lt;=n;i++) printf("%d ",ans[i]); &#125;&#125;;int main()&#123; mine::main();&#125; T3_Code_用set请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=110000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; struct Nod &#123; int d,p; friend bool operator &lt; (Nod a,Nod b) &#123;return a.d&lt;b.d;&#125; &#125;a[210000]; set&lt;Nod&gt; q; Nod findQ(int d)//&lt;d &#123; set&lt;Nod&gt;::iterator it=q.lower_bound( (Nod)&#123;d,0&#125; ); if(it==q.begin()) return (Nod)&#123;-1,0&#125;;//debug Nod t=*(--it); if(t.d&lt;d) return t; return (Nod)&#123;-1,0&#125;; &#125; int ans[210000]; void main() &#123; int n,m,d;scanf("%d%d%d",&amp;n,&amp;m,&amp;d); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i].d),a[i].p=i; sort(a+1,a+n+1); ans[a[1].p]=1; q.insert( (Nod)&#123;a[1].d,a[1].p&#125; ); int id=1; for(int i=2;i&lt;=n;i++) &#123; Nod t=findQ(a[i].d-d);//&lt;a[i].d-d if(t.d&lt;0) &#123; ans[a[i].p]=++id; &#125; else &#123; ans[a[i].p]=ans[t.p]; q.erase(t); &#125; q.insert( (Nod)&#123;a[i].d,a[i].p&#125; ); &#125; printf("%d\n",id); for(int i=1;i&lt;=n;i++) printf("%d ",ans[i]); &#125;&#125;;int main()&#123; mine::main();&#125; T3_Code_完美贪心请先思考后再展开 自行看众ak爷代码…… T4_Analysis请先思考后再展开 尺取法一下即可 T4_Code_old请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=510000; typedef long long ll; const int INF=0x3f3f3f3f; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int hei[MAX_N],dis[MAX_N]; void main() &#123; int n,h;scanf("%d%d",&amp;n,&amp;h); int lstr=-1e9; for(int i=1;i&lt;=n;i++) &#123; int l,r;scanf("%d%d",&amp;l,&amp;r); hei[2*i-1]=l-lstr;dis[2*i-1]=l-lstr; hei[2*i]=0;dis[2*i]=r-l; lstr=r; &#125; hei[2*n+1]=INF;dis[2*n+1]=INF; int r=0,sum=0,dd=0; int ans=0; for(int l=0;l&lt;=2*n;l++) &#123; while(sum&lt;h) &#123; sum+=hei[r+1]; dd+=dis[r+1]; if(sum&gt;h) &#123;sum-=hei[r+1],dd-=dis[r+1];break;&#125; r++; &#125; //printf("l=%d r=%d sum=%d dd=%d\n",l,r,sum,dd); ans=mymax(ans,dd+h-sum); dd-=dis[l+1]; sum-=hei[l+1]; &#125; printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷18年7月月赛比赛总结]]></title>
    <url>%2Fposts%2Fb37c.html</url>
    <content type="text"><![CDATA[洛谷18年9月月赛比赛总结题目 比赛经历哇这次是oi赛制耶感觉心理压力会小很多…… 第一题一开始很自信，觉得可以暴力，因为位数可能不会太大……当时电脑上没有g++，于是就应验了师兄们对在线ide的推测，没来得及装的时候比赛就开始了……主要是没检查到（原电脑在竞赛室不想拿回来）随便出组数据就tle了但仔细看看题目，就是没有说无解的情况，我也不会证明有解后来认真想想，推推柿子，发现原来是bsgs，时间复杂度nlogn然后如果无解，我会输出-1打了个对拍，暴力会出负数，也就是无解情况为了方便对拍，统一输出-1拍了30min的rand数据，范围不会太大（感觉rand的最大值是刚好的），避免暴力太慢，感觉应该没问题了……（30min伏笔） 然后是t2，感觉是约束一下，但没有太明确的思路，先跳t3是一棵树，除以2以后，化一下柿子，发现就是 $min \sum C-&gt;A_i$然后感觉可以参考一下“中位数的应用”，就是考虑移动的贡献那么不难发现，从根向下移动，相当于非该子树的A要多走w，子树内则少走w这样就是每条边走过去的贡献那么我们不妨先把初始的C设在根节点，然后往下重新计算dis，如果最小的dis小于0，那么移动到那里会更优仔细检查一下变量类型，感觉没问题，然后思考一下也应该是正解，时间复杂度n 此时只剩一个半小时，稍微有点慢了看看t4，标题写着分块是什么鬼感觉能拿30分后来忽然发现，统计1的数量需要乘以15，凉凉 看t2，发现只需要转移成第二行的情况，然后维护一下确定的区间具体而言，就是把每个约束条件转化为a~b的形式，而且满足 $2 \leq num \leq 2m$如果宽度小于m多解，大于m无解，否则定位一下就好了一直coding到最后3min，虚的一匹还好最后成功写完，交了上去到比赛首页，居然发现比赛延迟30min！赶快回去细细检查，发现细节稍微有点多，挖掘了一下样例后真发现几个bug，应该问题也不大了 检查一波，然后看t4，发现我制杖了，预处理一下1的数量就好了，值域很小那么又骗了30分目前最高分330时间刚好结束 好像比赛首页因为太多人刷新炸了？出去陪弟弟玩了波大富翁，好颓废啊回来发现145是什么鬼？怎么可能还有rk23，这么sb的分数……woc，80+60+0+5太困了先睡了…… T1_Analysis请先思考后再展开 因为 $n \leq MOD$所以答案是超过int的，没发现这点交上去还是80再仔细想想，因为刚刚发现的这一点，两个MOD相乘会爆ll，所以要快速乘tle!因为现在复杂度变成了log方，真是连锁反应……主要是因为我之前的写法一直都是 $A^b=ed \times inv(A^{at})$ ，n=at+b那么改改就好了，避免以后吃亏$A^b=A^{at} \times inv(ed)$ , n=at-b 所以说，还是考虑不够周全，造成连锁反应感觉这种事情很危险啊，特别是noip之前不久前还跟别人说自己很少fail题，因为大部分题都不会做……立刻就来教训了 T1_Code_std请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=110000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; ll MOD; ll qmul(ll x,ll e) &#123; ll ans=0; while(e&gt;0) &#123; if(e&amp;1) ans=(ans+x)%MOD; x=(x+x)%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll qpower(ll x,ll e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=qmul(ans,x); x=qmul(x,x);e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll x) &#123;return qpower(x,MOD-2);&#125;//MOD is prime ll ed; map&lt;ll,int&gt; mp; ll bsgs() &#123; int t=ceil(sqrt((double)MOD)); ll now=1; for(int i=0;i&lt;=t;i++) &#123; mp[now]=i; now=now*10%MOD; &#125; ed=inv(ed); ll dec=qpower(10,t); now=1; for(int a=1;a&lt;=t;a++) &#123; now=qmul(now,dec); ll wt=qmul(now,ed); if(mp.count(wt)) return (ll)a*t-mp[wt]; &#125; return -1; &#125; void main() &#123; scanf("%lld%lld",&amp;ed,&amp;MOD); if(ed==0) &#123;puts("0");return;&#125; ed=ed*9+1;ed%=MOD; printf("%lld",bsgs()); &#125;&#125;;int main()&#123; mine::main();&#125; T2_Analysis请先思考后再展开 发现这种做法是错误的因为我不能确定它实际在第二行还是第三行……所以换个思路，考虑直接约束1的位置然而我完全不会怎么解带模的不等式：$(A+k-2) \% m \leq m+A-B-1$总之，如果能解出来，可能是同时多个区间，需要找到被覆盖s次的区间这个的话，可以补集转化一下，维护其补集的交，这样无论解有多少个区间都能解决，非常巧妙 T3_Analysis请先思考后再展开 哇哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈……woc看错题了使得他送货所需的最长距离最小而不是使得他送货所需的距离总长最小我就说怎么会爆零大概是第一次彻头彻尾看错题？可能真的没细看那时候如果要找个理由的话，哪有人会关心最长那个啊还有就是样例恰好只有一个商品…… 不过然后就不会做了……好像二分也没有什么卵用 膜出题人嗯决策和刚才一样，都是具有单调性的，而且最优方向一定是由局部最优组成的然后我自己也能猜到一个性质：题目中的距离，一定是 $2 \times c到ab路径的距离+ab路径长度$那么关键是最小化左边的部分考虑从任意一个点开始，用刚才的思路，考虑跳过去的贡献每一次，暴力计算出所有总答案最大的点对考虑每条边，如果有任何点对跨越该边（可以用dfs序和siz判断），意味着当前是最优位置如果那边有点对，另一边也有点对，跳过去没有意义，当前也是最优位置否则，单纯地往那边跳即可 当前的时间复杂度是 $O(深度 \times n)$套一个点分治即可 T4_Analysis请先思考后再展开 原来是空间挂了……正解是神仙的莫队改版以后做……]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【Luogu4882】lty loves 96]]></title>
    <url>%2Fposts%2F9a30.html</url>
    <content type="text"><![CDATA[Source and JudgeLuogu4882 Record2h Analysis请先思考后再展开 非常有趣的一次经历（把本题当做是本比赛回忆吧……）如果能ac，就能和rose、xgc平分3块……当时的第一感觉是，从来没做过这么复杂的数位dp预处理非常麻烦，反正不会写然后这时候红太阳xgc出现了，他说不需要预处理，要相信记忆化的力量……其实也没错，数位dp的特性就在于，和具体数字的关系不会太大，一般都是部分 所以就听他的，瞎jb设了个状态开码中途到了5:40，必须要走了，当时xgc有50分在车上，仔细反思，觉得我的思路没有问题，可能超时或者爆long long但应该不会这么少分发现可能是转移的01写错了，匆忙回到家发现没写错……（学校的时候根本没细想） 补充说明一下，比赛7点结束 吃饭的时候一声不吭，觉得应该是边界的地方，忘记判断69数量了匆忙改，成功过了样例……交上去却只有20（他曾经也是，不知道怎么改的，好像思路不太一样） 测一测时间，恩很快但是极限数据出现负数！！（之前学校的错误代码，出来个4000以为没事）当时还剩30min，很赖皮地从以前的高精度模板那里copy下来恩样例还是能过的，但极限数据非常慢不管了交一发吧mle！没时间计算空间了优化一下发现还是不行，那应该意思就是写压位了ps 后来发现，原来是gb出题人把空间改到了64mb…… 当时还剩5min学校的时候和xgc就py过，他的50分代码已经发给了我，作为压箱手段（因为我乐多赛罚分最少）匆忙改了改格式，怕被识别作弊看rk，13是什么鬼？最后这么多人上去了（前10有3块，学校rk9） 当时真的好绝望，本来以为稳了，只是不太想用忽然想起来应该发邮箱给rose，发现有新邮件！标题为“kuai”，来自xgc！发现他打了压位高精度，然后才发现自己又傻了没有提醒他……交上去，ac看着那个rk8忽然觉得人生好神奇hh 方法一先给出一份long long的清纯版谁会想到现在还有这么毒瘤的出题人（所以说以后还是不想做洛谷的非月赛了）因为本来也以“条件很强，不会太多的”来安抚自己 好了说正事，数位dp现在觉得一点也不难大概也就是位数乘以10的复杂度1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long fuk; fuk zero,one; fuk jia(fuk a,fuk b) &#123; fuk c; c=a+b; return c; &#125; void output(fuk a) &#123; printf("%lld",a); &#125; fuk f[55][55][2][10][10]; bool v[55][55][2][10][10]; bool is(int x) &#123;return x==6 or x==9;&#125; fuk dp(int n,int ct,int ok,int b,int c) &#123; if(ct&lt;0) return zero; if(n==2 and ok) return zero; if(n==1) &#123; if(ct==is(c) and b==0 and ok==0 and c!=0) return one; else return zero; &#125; if(v[n][ct][ok][b][c]) return f[n][ct][ok][b][c]; v[n][ct][ok][b][c]=1; fuk ans=zero; for(int a=0;a&lt;=9;a++) &#123; if(ok) &#123; int fc=(a*a+b*b); if(c==0) fc=-1; else fc%=c; if(is(a+b+c) or is(fc)) ans=jia(ans,dp( n-1,ct-is(c),0,a,b )); else ans=jia(ans,dp( n-1,ct-is(c),1,a,b )); &#125; else ans=jia(ans,dp( n-1,ct-is(c),0,a,b )); &#125; return f[n][ct][ok][b][c]=ans; &#125; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); //n=50;m=1; zero=0; one=1; fuk ans=zero; for(int ct=m;ct&lt;=n;ct++) for(int b=0;b&lt;=9;b++) for(int c=0;c&lt;=9;c++) ans=jia(ans,dp(n,ct,1,b,c)); output(ans); &#125;&#125;;int main()&#123; mine::main();&#125; 方法二压位高精度，第一是能解决空间问题但还有个也非常重要的，就是速度快很多空间的计算：$\frac{64 \times 1024^2 /4}{50^2 \times 2 \times 10^2}=30$所以结构体最多30位考虑一下速度，决定压5位 其实压位也不难写，改动一点点而已，但当时时间真的太紧了，又有责任在身，再加上没写过，所以就放弃了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; struct fuk &#123; int num[15],ln; fuk() &#123;memset(num,0,sizeof num);&#125; &#125;; fuk zero,one; fuk jia(fuk a,fuk b) &#123; fuk c;c.ln=mymax(a.ln,b.ln); for(int i=1;i&lt;=c.ln;i++) &#123; c.num[i]+=a.num[i]+b.num[i]; if(c.num[i]&gt;99999) &#123; c.num[i+1]++; c.num[i]-=100000; if(i==c.ln) c.ln++; &#125; &#125; while(c.num[c.ln]==0 and c.ln&gt;1) c.ln--; return c; &#125; void output(fuk a) &#123; for(int i=a.ln;i&gt;=1;i--) &#123; if(i!=a.ln and a.num[i]&lt;10) printf("0000%d",a.num[i]); else if(i!=a.ln and a.num[i]&lt;100) printf("000%d",a.num[i]); else if(i!=a.ln and a.num[i]&lt;1000) printf("00%d",a.num[i]); else if(i!=a.ln and a.num[i]&lt;10000) printf("0%d",a.num[i]); else printf("%d",a.num[i]); &#125; &#125; fuk f[55][55][2][10][10]; bool v[55][55][2][10][10]; bool is(int x) &#123;return x==6 or x==9;&#125; fuk dp(int n,int ct,int ok,int b,int c) &#123; if(ct&lt;0) return zero; if(n==2 and ok) return zero; if(n==1) &#123; if(ct==is(c) and b==0 and ok==0 and c!=0) return one; else return zero; &#125; if(v[n][ct][ok][b][c]) return f[n][ct][ok][b][c]; v[n][ct][ok][b][c]=1; fuk ans=zero; for(int a=0;a&lt;=9;a++) &#123; if(ok) &#123; int fc=(a*a+b*b); if(c==0) fc=-1; else fc%=c; if(is(a+b+c) or is(fc)) ans=jia(ans,dp( n-1,ct-is(c),0,a,b )); else ans=jia(ans,dp( n-1,ct-is(c),1,a,b )); &#125; else ans=jia(ans,dp( n-1,ct-is(c),0,a,b )); &#125; return f[n][ct][ok][b][c]=ans; &#125; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); zero.ln=1;zero.num[1]=0; one.ln=1;one.num[1]=1; fuk ans=zero; for(int ct=m;ct&lt;=n;ct++) for(int b=0;b&lt;=9;b++) for(int c=0;c&lt;=9;c++) ans=jia(ans,dp(n,ct,1,b,c)); output(ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu4881】hby与tkw的基情]]></title>
    <url>%2Fposts%2F3729.html</url>
    <content type="text"><![CDATA[Source and JudgeLuogu4881 Record30min Analysis请先思考后再展开 非常好推柿子$\sum_{i=0}^{ \lfloor \frac{n-1}{2} \rfloor } (2i+1)26^{i+1}$ 方法一n非常大显然要用快速幂和矩阵乘法那么矩阵的设计可以参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const ll MOD=1e9+7; struct mm &#123; ll a[4][4]; mm() &#123;memset(a,0,sizeof a);&#125; &#125;; mm pre() &#123; mm t; for(int i=1;i&lt;=3;i++) t.a[i][i]=1; return t; &#125; mm cheng(mm a,mm b) &#123; mm c; for(int i=1;i&lt;=3;i++) for(int j=1;j&lt;=3;j++) for(int k=1;k&lt;=3;k++) c.a[i][j]+=a.a[i][k]*b.a[k][j]%MOD; return c; &#125; mm qpower(mm x,int e) &#123; mm c=pre(); while(e&gt;0) &#123; if(e&amp;1) c=cheng(c,x); x=cheng(x,x);e&gt;&gt;=1; &#125; return c; &#125; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; int n;scanf("%d",&amp;n); n=(n-1)/2; mm op;op.a[1][1]=op.a[2][1]=op.a[2][2]=26;op.a[3][1]=1;op.a[3][2]=2;op.a[3][3]=1; op=qpower(op,n+1); mm st;st.a[1][1]=26; st=cheng(op,st); printf("%lld\n",st.a[3][1]); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 方法二然鹅上面的方法很慢，因为矩阵乘法的常数达到了30其实有高中数学常识的很容易看出是一个差比数列（看题解后学的……）不了解的可以去定理杂烩一章]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度1</tag>
        <tag>差比数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【TJOI2013】循环格]]></title>
    <url>%2Fposts%2Fccfc.html</url>
    <content type="text"><![CDATA[Source and JudgeTJOI2013bzoj3171luogu3965 Record1h Analysis请先思考后再展开 首先，显然需要一些决策但好像不是很好贪心于是自然鹅言想到了网络流（或者费用流） 然后就不会了，主要是不太熟悉其实很容易发现题目要求的就是，每个点都要在至少一个环中 可以把题目再转化一下：给每个节点一滴水如果每个点都能有水过来，并且消耗掉，那么显然能满足题目的条件 按照这样建图以后，为了追求最小权值，跑费用流，把额外的边设费用1所谓费用流，前提是最大流，所以一定会把每个点都满足 不过有个小问题，就是可能自己立刻就出去了所以要拆一下点，分为入x和出y123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; const int MAX_N=50; struct Nod &#123; int hou; int fm; bool v; Nod() &#123;hou=0;v=0;&#125; &#125;p[MAX_N*MAX_N*2]; struct Edge &#123; int y,g; int c,w; &#125;e[MAX_N*MAX_N*2*10]; int oth(int x) &#123;return (x&amp;1)?(x+1):(x-1);&#125; int ln=0; void ins(int x,int y,int c,int w) &#123; e[++ln]=(Edge)&#123;y,p[x].hou,c,w&#125;;p[x].hou=ln; e[++ln]=(Edge)&#123;x,p[y].hou,0,-w&#125;;p[y].hou=ln; &#125; int ans=0; int st,ed; queue&lt;int&gt; q; int dis[MAX_N*MAX_N*2]; int flow[MAX_N*MAX_N*2];//最短路径到此流量 bool solve() &#123; memset(dis,63,sizeof dis); memset(flow,63,sizeof flow); dis[st]=0;p[st].v=1;q.push(st); while(!q.empty()) &#123; int x=q.front();q.pop(); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(dis[y]&gt;dis[x]+e[k].w and e[k].c&gt;0) &#123; dis[y]=dis[x]+e[k].w; p[y].fm=k; flow[y]=mymin(flow[x],e[k].c); //debug 不能用全局变量flow，因为路径的选择会改变 if(!p[y].v) p[y].v=1,q.push(y); &#125; &#125; p[x].v=0; &#125; if(dis[ed]==INF) return 0; ans+=flow[ed]*dis[ed]; for(int x=ed;x!=st;) &#123; int rd=p[x].fm; e[rd].c-=flow[ed];e[oth(rd)].c+=flow[ed]; x=e[oth(rd)].y; &#125; return 1; &#125; int r,c; int calc(int x,int y,int t) &#123; if(x==0) x=r; if(x==r+1) x=1; if(y==0) y=c; if(y==c+1) y=1; return (x-1)*c+y+(t?(r*c):0); &#125; //0右 1左 2上 3下 const int tx[4]=&#123;0,0,-1,1&#125;; const int ty[4]=&#123;1,-1,0,0&#125;; char mp[MAX_N][MAX_N]; void main() &#123; scanf("%d%d",&amp;r,&amp;c); for(int i=1;i&lt;=r;i++) scanf("%s",mp[i]+1); st=0;ed=2*r*c+1; for(int i=1;i&lt;=r;i++) for(int j=1;j&lt;=c;j++) &#123; ins(st,calc(i,j,1),1,0);//st=&gt;y ins(calc(i,j,0),ed,1,0);//x=&gt;ed int now; if(mp[i][j]=='R') now=0; if(mp[i][j]=='L') now=1; if(mp[i][j]=='U') now=2; if(mp[i][j]=='D') now=3; for(int t=0;t&lt;=3;t++) ins(calc(i,j,1),calc(i+tx[t],j+ty[t],0),1,now!=t); &#125; while(solve()) ; printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>lca</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【国家集训队】跳跳棋]]></title>
    <url>%2Fposts%2F4147.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj2144luogu1852 Record2h Analysis请先思考后再展开 很好的题目不妨设a&lt;b&lt;c 考虑我能怎么跳因为题目要求，每次只能跳过一个棋子发现在任意时刻，只有三种移动方法$dis1=b-a,dis2=c-b$ $a-dis1,a,c$ $a,c,c+dis2$ $b,b+dis1,c$ 或者 $a,b-dis2,b$ （如果都不行，则没有）度大部分都是3，你想到了什么？一棵二叉树！把第一种和第二种，看作是孩子，第三种看作是父亲不过，树的深度无限，因为你总是能不停向外跳的 那么我们来证明一下这为什么是一棵二叉树（网上的漏点） 对于没有父亲的节点，本身就是根节点，所以严格来说这是一个二叉树森林 我们必须要证明x的祖先不可能会出现在x的子树中如果我们定义一个值：最接近两点间的距离不难发现，向上时必定变小，向下时必定变大（不能够重叠棋子） 操作可逆，所以是无向图 那么，现在要求的就是两个节点间的lca此时已经有40分了，如何避免暴力存图呢？ 考虑每次向上跳（再也不用考虑向下了，我向下就是等它上来）如果方向是相同的（缩左边或者缩右边），那么间距不变，可以直接通过一个除法来计算出来，然后距离取模那么复杂度基本上就是log（参考gcd的复杂度）如果要限制长度，可以判断一下，确保不超过（当覆盖时） 那么找lca的时候，先到相同高度，然后二分向上距离即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; struct Nod &#123; int a,b,c; Nod(int x=0,int y=0,int z=0) &#123;a=x,b=y,c=z;&#125; &#125;; int dep; Nod jump(Nod now,int mx)//限制步数 &#123; int a=now.a,b=now.b,c=now.c; dep=0; while(1) &#123; int stp=0; int dis1=b-a,dis2=c-b; if(dis1&lt;dis2) &#123; stp=mymin(mx-dep,(dis2-1)/dis1); a+=stp*dis1,b+=stp*dis1; &#125; else if(dis2&lt;dis1) &#123; stp=mymin(mx-dep,(dis1-1)/dis2); b-=stp*dis2,c-=stp*dis2; &#125; dep+=stp; if(stp==0) return Nod(a,b,c); &#125; &#125; bool check(Nod x,Nod y,int mx) &#123; x=jump(x,mx);y=jump(y,mx); return x.a==y.a and x.b==y.b and x.c==y.c; &#125; Nod ss(Nod now) &#123; if(now.a&gt;now.b) swap(now.a,now.b); if(now.a&gt;now.c) swap(now.a,now.c); if(now.b&gt;now.c) swap(now.b,now.c); return now; &#125; void main() &#123; Nod x,y;scanf("%d%d%d%d%d%d",&amp;x.a,&amp;x.b,&amp;x.c,&amp;y.a,&amp;y.b,&amp;y.c); x=ss(x);y=ss(y);//debug 漏了 jump(x,2*INF);int xdep=dep; jump(y,2*INF);int ydep=dep; if(xdep&lt;ydep) swap(xdep,ydep),swap(x,y); x=jump(x,xdep-ydep); int l=0,r=ydep,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(x,y,mid)) ans=mid,r=mid-1; else l=mid+1; &#125; if(ans&lt;0) puts("NO"); else printf("YES\n%d",2*ans+xdep-ydep); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>lca</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Arc102c】Stop. Otherwise]]></title>
    <url>%2Fposts%2F7deb.html</url>
    <content type="text"><![CDATA[Source and JudgeArc102c Record2h Analysis请先思考后再展开 以下做法层层递进…… 方法一（WA）因为求的是组合数，肯定至少要先n能算出完整数量$T(n,k)={ 1:∞,2:∞ … k:∞ }中选n个$$T(n,k)={ 0:n,1:k-1 }的全排列数量$$T(n,k)=\frac{ (n+k-1)! }{ n! (k-1)! }$然后考虑每个i，能得到i的二元组数量当$i-1 \leq k$，数量为$\lceil \frac{i-1}{2} \rceil$$otherwise$，数量为$\lceil \frac{2k-i+1}{2} \rceil$然后我们固定前面的几个（依然是多重集），根据$(-1)^k$ 去贡献，后面乱搞 然后，手动模拟样例2发现，相同的用多次，后面去重复，会以为多次重叠，但其实反而不应该这样给出代码留作纪念……凉凉12345678910111213141516171819ll T(int n,int k) &#123;return C(n+k-1,n);&#125;void main()&#123; int K,n;scanf("%d%d",&amp;K,&amp;n); for(int i=2;i&lt;=2*K;i++) &#123; int all=(i-1&lt;=K)?(i-1):(2*K-i+1); all=ceil( (double)all/2 ); ll ans=T(n,K); for(int k=1;2*k&lt;=n;k++) &#123; ll now=C(k+all-1,k)*T(n-2*k,K)%MOD; if(k&amp;1) ans-=now; else ans+=now; ans%=MOD; &#125; printf("%lld\n",(ans+MOD)%MOD); &#125;&#125; 方法二（AC）既然一定要去重，但刚才的思路，会死在【同一种多次用】上面于是膜了发网上题解（官方看不懂……）然后就发现其实我们是可以直接搞出合法数量而不需要取补的（其实有可能，没办法直接求出非法数量……当初主要是觉得不好算，所以习惯性取了补以后，思维又先入为主了） 先把刚才的违法对数的种类称为tot那么为了避免刚才的尴尬，直接枚举k表示【在违法二元组中，只出现其中一个】（也就是其他tot-k种完全不出现）那么每个种，相当于有了一个代表元素，方案为$2^k$当然，这里面不一定都要真的出现那我可以选择的数字就是oth+k个（具体是什么不重要）这个依然可以$$ans=\sum_{k=0}^{tot} (-1)^k C_{tot}^k C2(oth+k,n) 2^{k}$$ 方法三（AC）其实上面那种方法，略微有一点玄学因为你不限制它是否出现，怎么知道在Venn图中被覆盖k次从而使用那个 $(-1)^k$ 呢？然后我就自己再yy了一种做法，稍微改进就连容斥都不需要了，因为按照前面的基础，其实我完全可以把k看作一定出现至少一次（否则你枚举来干嘛，像上面那样） $$ans=\sum_{k=0}^{tot} C_{tot}^k C2(oth+k,n-k) 2^{k}$$ 提醒以下一个细节，要特判$oth+k=0$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const ll MOD=998244353; ll bin[4100]; ll c[4100][4100]; ll C(int n,int m) &#123;return c[n][m];&#125; ll C2(int n,int m) &#123;return C(n-1+m,n-1);&#125; ll solve(int i,int K,int n) &#123; int tot=(i-1&lt;=K)?(i-1):(2*K-i+1); tot=floor( (double)tot/2 );//不再是ceil，单独考虑 i/2 int oth=K-tot*2-((i%2)==0); ll ans=0; for(int k=0;k&lt;=tot and k&lt;=n;k++) if(oth+k&gt;0)//debug ans+=C(tot,k)*C2(oth+k,n-k)%MOD*bin[k]%MOD,ans%=MOD; return (ans+MOD)%MOD; &#125; void main() &#123; bin[0]=1; c[0][0]=1; for(int i=1;i&lt;4100;i++) &#123; bin[i]=bin[i-1]*2%MOD; c[i][0]=1; for(int j=1;j&lt;=i;j++) c[i][j]=(c[i-1][j-1]+c[i-1][j])%MOD; &#125; int K,n;scanf("%d%d",&amp;K,&amp;n); for(int i=2;i&lt;=2*K;i++) if(i%2==0) printf("%lld\n",(solve(i,K,n)+solve(i,K,n-1))%MOD);//i/2的不选和选 else printf("%lld\n",solve(i,K,n)); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>难度2</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Arc102b】All Your Paths are Different Lengths]]></title>
    <url>%2Fposts%2F9f63.html</url>
    <content type="text"><![CDATA[Source and JudgeArc102b Record2h Analysis请先思考后再展开 原来这就是传说中的构造题首先明确，基本的结构一定是二进制拆分但不难发现，很难保证只有L条路径，得出来的长度还绝对不能重复 其实我有点思维僵化了如果把1和后面的东西拆开来，分开讨论，后面的全部都是完全的二进制（也就是2的次幂边，以及0）那么我们记录一个当前已经搞定的最大范围mx-1，从mx开始然后对L二进制拆分，然后假如加入之后，依然在合法范围内，那么就加上mx，并更新范围不难发现，现在得出来的路径长度，一定不会重复出现（通过简单地记录一个当前上界） Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=110000,MAX_M=410000; const int INF=0x3f3f3f3f; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int bin[20]; struct Edge &#123; int x,y,c; &#125;; vector&lt;Edge&gt; q; void main() &#123; bin[0]=1;for(int i=1;i&lt;20;i++) bin[i]=bin[i-1]&lt;&lt;1; int mx;scanf("%d",&amp;mx);//0~mx-1 int nowmx=0; for(int i=18;i&gt;=0;i--) while(nowmx+bin[i]-1&lt;=mx-1) &#123; q.push_back( (Edge)&#123;1,20-i,nowmx&#125; ); nowmx+=bin[i]; &#125; printf("20 %d\n",18*2+q.size()); for(int i=2;i&lt;=19;i++) printf("%d %d %d\n%d %d 0\n",i,i+1,bin[19-i],i,i+1); for(int i=0;i&lt;q.size();i++) printf("%d %d %d\n",q[i].x,q[i].y,q[i].c); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【训练】算法竞赛进阶指南-6图论 32题]]></title>
    <url>%2Fposts%2F6259.html</url>
    <content type="text"><![CDATA[本处难度分档以个人实力为参照系难度1：半小时内想出，半小时内ac难度2：半小时想不出，看题解，服气难度3：半小时想不出，看题解，ac后依然觉得难度很大 另外，由于追进度，对于coding部分比较有自信的题目，不再具体实现 0x60 图论部分题目 1 poj3662 Telephone Lines8.29 难度2请先思考后再展开 找出一条从1到n的路径，上面第k+1大的那条边，权值最小好弱啊第一题就不会做，天天看题解…… 最小化除了前面k个以外的最大值，二分答案把所有长度在mid以内的边看做0，否则1跑一次最短路，如果花费在k以内，意味着可行代码略 2 noip2009 最优贸易8.29 难度2请先思考后再展开 曾经做过 3 Usaco2011 Jan Gold 道路和航线8.29 难度2请先思考后再展开 这道题挺有意思的，本来以为是裸题想跳的，看到lyd说spfa会tle，就不想以身试法了（网上说加上slf就好了……不过本着锻炼思维的理念，学习一下正解）因为题目保证航线没有环，本来以为这仅仅是保证没有负环，没想到这还是一个突破口（还有就是道路都是双向的这个性质） 如果只加入双向边，那么就会形成多个联通块如果缩点后再加入单向航线，图会形成一个有向无环图，是可以通过拓扑得到最短路的不过具体而言，不能真的缩点，因为需要具体得出每个点的最短路大致上就是沿着负权边找到各个联通块，以拓扑为框架跳来跳去 具体的话有个细节：就是有可能st所在的联通块，入度不为0或者可能出了st联通块外，还有其他入度不为0的联通块所以还是要按照平常拓扑那样，把所有入度为0的加入栈不过为了防止，单源最短路被扰乱，应该先把st联通块的dis置0，这样无论如何也没法更新掉了然后其他联通块的inf也应该设置大一点，这样即使被更新，也是一个很大的值然后输出no path的时候，不能只是和inf比较，因为可能曾经被更新，要看它是否明显超过理论正常最大距离( $T \times 10000=250000000$ )，设为0x3f3f3f3f就够了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=31000,MAX_M=160000; const ll INF=(1ll&lt;&lt;60); int n; struct Nod &#123; int hou; ll dis; int uni; Nod() &#123; uni=hou=0; dis=INF; &#125; &#125;p[MAX_N]; struct Edge &#123; int y,c,g; &#125;e[MAX_M]; int ln=0; void ins(int x,int y,int c) &#123; e[++ln]=(Edge)&#123;y,c,p[x].hou&#125;; p[x].hou=ln; &#125; int deg[MAX_N]; vector&lt;int&gt; vt[MAX_N]; void dfs(int x,int now) &#123; p[x].uni=now;vt[now].push_back(x); for(int k=p[x].hou;k&gt;0;k=e[k].g) if(p[e[k].y].uni==0) dfs(e[k].y,now); &#125; struct Que &#123; ll d; int x; friend bool operator &lt; (Que a,Que b) &#123;return a.d&gt;b.d;&#125; &#125;; int sta[MAX_N],top=0; priority_queue&lt;Que&gt; q; void solve(int st) &#123; for(int i=0;i&lt;vt[p[st].uni].size();i++) p[vt[p[st].uni][i]].dis=0;//确保不会被，st无法到达的块更新 for(int i=1;i&lt;=n;i++) if(vt[i].size()&gt;0 and deg[i]==0) sta[++top]=i; while(top&gt;0)//topsort &#123; int t=sta[top--]; for(int i=0;i&lt;vt[t].size();i++) &#123; int x=vt[t][i]; if(t==p[st].uni and x!=st) p[x].dis=INF;//debug 漏了 q.push((Que)&#123;p[x].dis,x&#125;); &#125; while(!q.empty())//dijkstra &#123; Que now=q.top();q.pop(); int x=now.x;if(now.d!=p[x].dis) continue;//delete for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dis&gt;p[x].dis+e[k].c) &#123; p[y].dis=p[x].dis+e[k].c; if(p[y].uni==p[x].uni) q.push((Que)&#123;p[y].dis,y&#125;); &#125; if(p[y].uni!=p[x].uni) &#123; deg[p[y].uni]--; if(deg[p[y].uni]==0) sta[++top]=p[y].uni; &#125; &#125; &#125; &#125; &#125; void main() &#123; int ma,mb,st;scanf("%d%d%d%d",&amp;n,&amp;ma,&amp;mb,&amp;st); while(ma--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);ins(y,x,c); &#125; for(int i=1;i&lt;=n;i++) if(p[i].uni==0) dfs(i,i); while(mb--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);if(p[x].uni!=p[y].uni) deg[p[y].uni]++; &#125; solve(st); for(int i=1;i&lt;=n;i++) if(p[i].dis&gt;0x3f3f3f3f) puts("NO PATH"); else printf("%lld\n",p[i].dis); &#125;&#125;;int main()&#123; mine::main();&#125; 4 poj1734 Sightseeing trip8.29 难度2请先思考后再展开 floyd找最小环123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=110; const int INF=0x3f3f3f3f; int ans[MAX_N],ln; int fm[MAX_N][MAX_N]; int dis[MAX_N][MAX_N],a[MAX_N][MAX_N]; void getans(int x,int y) &#123; if(fm[x][y]&lt;0) &#123;ans[++ln]=x;return;&#125; int k=fm[x][y]; getans(x,k);getans(k,y); &#125; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); memset(a,63,sizeof a); memset(fm,0,sizeof fm); for(int i=1;i&lt;=n;i++) a[i][i]=0; while(m--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); if(c&lt;a[x][y]) a[x][y]=a[y][x]=c,fm[x][y]=fm[y][x]=-1; &#125; memcpy(dis,a,sizeof a); int mi=INF; for(int k=1;k&lt;=n;k++) &#123; for(int i=1;i&lt;k;i++) for(int j=i+1;j&lt;k;j++) &#123; ll tmp=(ll)dis[i][j]+a[j][k]+a[k][i];//debug 爆int if(mi&gt;tmp) &#123; mi=tmp; ln=0;getans(i,j);ans[++ln]=j;ans[++ln]=k; &#125; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(i!=j) if(dis[i][j]&gt;dis[i][k]+dis[k][j]) dis[i][j]=dis[i][k]+dis[k][j],fm[i][j]=k; &#125; if(mi==INF) puts("No solution.");//神tm漏了一个点…… else for(int i=1;i&lt;=ln;i++) printf("%d ",ans[i]); &#125;&#125;;int main()&#123; mine::main();&#125; 5 6201 走廊泼水节8.29 难度2请先思考后再展开 这道题设计得很好个人很喜欢这种，对看似简单、经典的算法，推陈出新地挖掘细节、原理的题目结果就不会做了…… 这道题从边的角度思考会简单一些想到边，以及最小生成树，会想到kruskal把所有边排序，然后关键就是“完全图中的边，是否跨树”对于这一点我只能出个数据把自己的乱搞做法卡掉，但不知道怎么去解决 其实这条边什么时候会跨树呢？盗lyd好图：是不是豁然开朗了？模拟kruskal的过程，连接两个树之间的边，只会在这一次跨树此时，他们的取值都应为z+1，个数则是 $Sx \times Sy-1$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=6100; const int INF=0x3f3f3f3f; struct Edge &#123; int x,y,c; &#125;e[MAX_N]; bool cmp(Edge a,Edge b) &#123;return a.c&lt;b.c;&#125; int fa[MAX_N],siz[MAX_N]; int findfa(int x) &#123;return fa[x]=(x==fa[x]?x:findfa(fa[x]));&#125; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) fa[i]=i,siz[i]=1; for(int i=1;i&lt;=n-1;i++) scanf("%d%d%d",&amp;e[i].x,&amp;e[i].y,&amp;e[i].c); sort(e+1,e+n-1+1,cmp); ll ans=0; for(int i=1;i&lt;=n-1;i++) &#123; int x=e[i].x,y=e[i].y; int fx=findfa(x),fy=findfa(y); ans+=ll(e[i].c+1)*( (ll)siz[fx]*siz[fy]-1 ); if(fx!=fy) fa[fx]=fy,siz[fy]+=siz[fx];//merg &#125; printf("%lld\n",ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 6 poj1639 Picnic Planning8.30 难度2请先思考后再展开 就是限制了根节点度数的最小生成树先去除1节点，跑出每个节点的最小生成树，然后找最小的一条边连接上去然后有可能可以对某个点x，去掉某条1到x的一条边，并连接x和1 7 poj2728 Desert King8.30 难度1请先思考后再展开 01分数规划+最小生成树不过不知道为什么跑得很慢log的大小，无论如何都是在100以内的，那么正常来说这道题就一亿，时限3s个人觉得它非要卡二分我也没办法，Dinkelbach大概只是恰好快而已（毕竟那东西的复杂度很玄学）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=1100; const int INF=0x3f3f3f3f; double myabs(double x) &#123;return x&gt;0?x:-x;&#125; const double eps=1e-8; struct Nod &#123; int x,y; int h; &#125;p[MAX_N]; double dis(double x1,double y1,double x2,double y2) &#123;return sqrt( (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2) );&#125; int n; double L; double d[MAX_N],a[MAX_N][MAX_N],cst[MAX_N][MAX_N],ln[MAX_N][MAX_N]; bool v[MAX_N]; bool check()//prim&lt;=0 &#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) a[i][j]=cst[i][j]-L*ln[i][j]; d[0]=INF;d[1]=0;for(int i=2;i&lt;=n;i++) d[i]=a[1][i]; memset(v,0,sizeof v);v[1]=1; double sum=0; for(int cnt=1;cnt&lt;=n-1;cnt++) &#123; int t=0;for(int i=1;i&lt;=n;i++) if(!v[i] and d[i]&lt;d[t]) t=i; sum+=d[t];v[t]=1; for(int i=1;i&lt;=n;i++) if(!v[i] and a[t][i]&lt;d[i]) d[i]=a[t][i]; &#125; return sum&lt;=eps; &#125; /* int m; struct Edge &#123; int x,y; double cst,ln; &#125;e[MAX_N*MAX_N]; bool cmp(Edge a,Edge b) &#123;return a.cst-L*a.ln&lt;b.cst-L*b.ln;&#125; int fa[MAX_N]; int findfa(int x) &#123;return fa[x]=(x==fa[x]?x:findfa(fa[x]));&#125; bool check()//kruskal&lt;=0 沙茶了，完全图用kruskal…… &#123; sort(e+1,e+m+1,cmp); for(int i=1;i&lt;=n;i++) fa[i]=i;//debug double sum=0; for(int i=1;i&lt;=m;i++) &#123; int x=e[i].x,y=e[i].y; int fx=findfa(x),fy=findfa(y); if(fx!=fy) &#123; sum+=e[i].cst-L*e[i].ln; fa[fx]=fy; &#125; &#125; return sum&lt;=0; &#125;*/ void main() &#123; while(1) &#123; scanf("%d",&amp;n); if(n==0) break; for(int i=1;i&lt;=n;i++) scanf("%d%d%d",&amp;p[i].x,&amp;p[i].y,&amp;p[i].h); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) cst[i][j]=myabs(p[i].h-p[j].h),ln[i][j]=dis(p[i].x,p[i].y,p[j].x,p[j].y); double l=0,r=INF,ans=-1; while(l&lt;=r+eps) &#123; L=(l+r)/2; if(check()) ans=L,r=L-eps; else l=L+eps; &#125; printf("%.3lf\n",ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 8 APIO2010 巡逻8.30 难度2请先思考后再展开 这道题的k=1、2，先从k=0入手不难发现，每条边一定要经过两次（因为是树，一定会递归一次回溯一次），所以就是$2(n-1)$对于k=1，加入一条新的边以后，一定出现了环，就不一定是两次了同时，在这个环上，其他边都从经过两次变成了经过一次（例如题目中的a）不难发现，此时答案为$2(n-1)-(直径长度-1)$ 对于k=2的情况，稍微复杂了一些如果产生的新的环，没有和原本的环重叠，那么同样是不用经过一次（例如题目中的b）但是，如果重叠了（例如题目中的c），那么由于“新的边必须经过一次”这个限制，公共部分又变成了要经过两次 总上所述，第一次找直径L1，把边权变为-1第二次找到直径L2，答案即$2(n-1)-(L1-1)-(L2-1)$ 有木有觉得apio的图片非常良心 9 CH#56C 异象石8.30 难度2请先思考后再展开 先从每个节点上都有石头的情况开始考虑如果从边的角度，那就是边总长但因为这道题，主要从点的情况考虑，所以转化为，按照dfs搜索顺序，经过的相邻两点间距离/2而对于不满的情况也是类似，把存在的所有点，按照dfs序收尾相接，相邻间距离和即为答案那么具体实现的时候，可以搞一个set，用upper_bound等找相邻并动态维护当前总和即可 10 BJWC2010 严格次小生成树8.30 难度2请先思考后再展开 按照惯例，对于这种在树上有非树边的问题，可以考虑一下，由非树边产生的环例如本题，对于这个环，我们断掉任何一个，整个图依然是树（本来就是挂起来的无向无环图）所以说，对于每条边，其贡献就是，把它替换掉原本树上路径中最大那一条产生的差然后因为求的是严格次小，所以有种特殊情况，就是最大那个和当前边相同长 引理：在最小生成树原本的路径中，一定不会有比当前非树边大的边 证明：否则应该被当前非树边替换掉（替换掉一定不会有其他副作用之类，还是那句话，树本来就是挂起来的无向无环图） 那么也就是我们还需要且只需要再考虑次大值具体实现的话，用一个倍增st表维护一下就好了（以倍增lca为框架） 11 IOI2008 Island8.30 难度1请先思考后再展开 题意为，给出一个基环树森林，每个节点只能去一次，起点任意跨基环树的时候，不能回到曾经去过的基环树求最大化的【经过的基环树边的总和】显然答案就是每个基环树内直径之和然后基环树直径这种东西，写个dfs找环，dfs向下找最大深度，然后套个单调队列就好了 12 6401 创世纪8.30 难度2请先思考后再展开 在lxj的提醒下才想到正解……其实一点都不难 图显然是一个内向树森林，要求选自己，则至少一个孩子不被选考虑dp，$f(x,0/1)$表示当前子树满足条件时，x选择0/1的最大选择节点数先搞定树上的部分，如果枚举固定一个孩子不选，然后其他乱搞，但给个菊花图就会炸不难想到取补，把任意情况减去所有孩子都选了的情况（套路之记录次小值） 对于环上的怎么搞呢？看一眼这里就知道了 13 POI2008 BLO-Blockade8.31 难度2请先思考后再展开 教程然后还是不会做…… 在搜索树上考虑对于每个节点，假如它不是割点，那么只有它和其他人是联通块，贡献为$2(n-1)$而如果是割点，我们需要知道产生了多少个联通块，以及他们的大小 但怎么找？$low_y \leq dfn_x$这等价于割点的判定条件主要考虑是可以相等，因为每次我们会断掉所有的边 联通块有三种： x自己，大小1 共有t个满足上面的条件，大小为在搜索树上的子树大小 剩下的所有点（假如大小不为0，则一定存在） 第三点非常容易想漏，所以说建议多构造几组数据，当然对拍也是可以如果求稳的话 时间复杂度$O(n+m)$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=110000,MAX_M=510000; const int INF=0x3f3f3f3f; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; struct Nod &#123; int hou; int siz; int dfn,low; ll ans; Nod() &#123;hou=dfn=siz=0;ans=0;&#125; &#125;p[MAX_N]; struct Edge &#123; int y,g; &#125;e[MAX_M*2]; int ln=0; void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,p[x].hou&#125;;p[x].hou=ln;&#125; int oth(int t) &#123;return (t&amp;1)?t+1:t-1;&#125; int id=0; int n; void tarjan(int x,int from) &#123; p[x].siz=1; p[x].dfn=p[x].low=++id; int sum=0,cnt=0;bool cut=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) &#123; tarjan(y,k); p[x].siz+=p[y].siz; p[x].low=mymin(p[x].low,p[y].low); if(p[y].low&gt;=p[x].dfn) &#123; cnt++; p[x].ans+=(ll)p[y].siz*(n-p[y].siz); sum+=p[y].siz; if(x!=1 or cnt&gt;1) cut=1; &#125; &#125; else if(k!=oth(from)) p[x].low=mymin(p[x].low,p[y].dfn); &#125; if(cut) p[x].ans+=ll(n-sum-1)*(sum+1)+(n-1); else p[x].ans=2*(n-1);//注意要直接赋值 &#125; void main() &#123; int m;scanf("%d%d",&amp;n,&amp;m); while(m--) &#123;int x,y;scanf("%d%d",&amp;x,&amp;y);ins(x,y);ins(y,x);&#125;//无重边 tarjan(1,-1); for(int i=1;i&lt;=n;i++) printf("%lld\n",p[i].ans); &#125;&#125;;int main()&#123; mine::main();&#125; 14 poj3694 Network8.31 难度1请先思考后再展开 教程考虑合并每个e-DCC，形成一棵树然后倍增预处理一下lca 然后对于操作，其实就是合并x到y树上路径上的所有点，这个可以考虑用并查集维护由于单个的小合并操作，只会发生n次，即使并查集log，也只有nlogn而这个复杂度是超脱于询问这个循环之外的总复杂度 其实细节挺多的，大致流程： tarjan找到e-DCC，确定代表元素，初始化其并查集（最后别漏了根节点） 建立新的边目录，预处理倍增lca 回答询问的时候，一个个向上跳，维护割边数量cnt123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=110000,MAX_M=410000; const int INF=0x3f3f3f3f; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; struct Nod &#123; int hou; int dfn,low; int fa;//块父亲 &#125;p[MAX_N]; struct Edge &#123; int x,y,g; &#125;e[MAX_M*2]; int ln; void ins(int x,int y) &#123; ln++; e[ln].x=x;e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln; &#125; int oth(int t) &#123;return (t&amp;1)?(t+1):(t-1);&#125; int id[MAX_N];//并查集维护，所在的块 int findfa(int x) &#123;return id[x]=(x==id[x]?x:findfa(id[x]));&#125; void dfs(int x,int fa,int now) &#123; id[x]=now; for(int k=p[x].hou;k&gt;0;k=e[k].g) if(e[k].y!=fa and id[e[k].y]==0) dfs(e[k].y,x,now); &#125; int ct,cnt; void tarjan(int x,int from) &#123; p[x].dfn=p[x].low=++ct; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) &#123; tarjan(y,k); p[x].low=mymin(p[x].low,p[y].low); if(p[y].low&gt;p[x].dfn)//割边 &#123; cnt++;//割边数 p[y].fa=x; dfs(y,x,y); &#125; &#125; else if(k!=oth(from)) p[x].low=mymin(p[x].low,p[y].dfn); &#125; &#125; int hou[MAX_N],dep[MAX_N]; Edge e2[MAX_M*2]; int ln2; void ins2(int x,int y) &#123; ln2++; e2[ln2].y=y;e2[ln2].g=hou[x]; hou[x]=ln2; &#125; int f[MAX_N][20]; void pre(int x,int fa) &#123; dep[x]=dep[fa]+1; f[x][0]=fa;for(int i=1;i&lt;20;i++) f[x][i]=f[f[x][i-1]][i-1]; for(int k=hou[x];k&gt;0;k=e2[k].g) &#123; int y=e2[k].y;if(y==fa) continue; pre(y,x); &#125; &#125; int n,m; void make_graph() &#123; ln=0;for(int i=1;i&lt;=n;i++) p[i].hou=p[i].dfn=0; for(int i=1;i&lt;=m;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x);//无自环 &#125; cnt=0;ct=0;memset(id,0,sizeof id); tarjan(1,-1);dfs(1,0,1); ln2=0;memset(hou,0,sizeof hou); for(int i=1;i&lt;=2*m;i+=2) &#123; int fx=findfa(e[i].x),fy=findfa(e[i].y); if(fx!=fy) ins2(fx,fy),ins2(fy,fx); &#125; pre(1,0); &#125; int bin[20]; int getlca(int x,int y) &#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=19;i&gt;=0;i--) if(dep[x]-dep[y]&gt;=bin[i]) x=f[x][i]; if(x==y) return x; for(int i=19;i&gt;=0;i--) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0]; &#125; int solve() &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); int fx=findfa(x),fy=findfa(y),lca=findfa(getlca(fx,fy));//debug getlca(x,y) while(fx!=lca) cnt--,id[fx]=lca,fx=findfa(p[fx].fa); while(fy!=lca) cnt--,id[fy]=lca,fy=findfa(p[fy].fa); //因为每次findfa找最上面的代表元素，所以p[fx].fa一定是另一个节点 return cnt; &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;20;i++) bin[i]=bin[i-1]&lt;&lt;1; int cas=0; while(1) &#123; scanf("%d%d",&amp;n,&amp;m); if(n==0) break; printf("Case %d:\n",++cas); make_graph(); int q;scanf("%d",&amp;q); while(q--) printf("%d\n",solve()); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 15 poj2942 Knights of the Round Table9.1 难度2请先思考后再展开 题意：找出有多少个骑士，无法出席任何会议会议的要求是有奇数个人，成环形后相邻的人没有憎恨关系 因为是环形，考虑连成一个环，不难想到建立一个补图，用【无憎恨关系】来建边那么就转化成，有多少个点，不在任何奇环（奇数个点的简单环）中 然后判断奇环可以染色，但怎么标记呢？暴力搞我自己都能出个数据卡成nm百思不得其姐，又去膜题解题解给出的又是两个结论……还好这一次，这两个结论的证明都很简单 结论1：奇环不会垮v-DCC存在证明：显然两个v-DCC能合并成一个v-DCC，与v-DCC的“极大”矛盾 结论2：如果某个v-DCC中有奇环，则整个v-DCC的每个节点，至少被一个奇环所包含假设有奇环外节点x，总是能和奇环上任意两个节点vi和vj形成奇环，因为无论【x到vi+x到vj】的奇偶性如何，奇环上两个点间距离总是能取奇数或者偶数……因为奇=奇+偶，亘古不变…… 怎么说呢？这两个结论都不是太好猜，但偏偏缺一不可 16 poj1236 Network of Schools9.1 难度2请先思考后再展开 开始想法：设强连通分量缩点后，a=【入度=0】，b=【出度=0】那么第一问求a，第二问求b 其实已经和正解接近了，但还是错误的第二问求的其实是max(a,b)重新思考，对于入度为0的scc，如果起点不在这里就凉了，要消除掉对于出度为0的scc，如果起点在这里就凉了，要消除掉因为一次可以同时消除两种各一个，得证 17 poj2226 Muddy Fields9.7 难度2请先思考后再展开 不会做的经典模型将连续的泥地分为行泥泞块和列泥泞块，形成了二分图那么，对于每个小泥地，至少要被其中一种覆盖那么把每个小泥地作为边，恰好连接两个元求最小覆盖即可 18 6902 Vani和Cl2捉迷藏9.9 难度2请先思考后再展开 神仙结论题，结论不好猜，证明不好想，但出得挺好因为不能有路径相连，可以联想到传递闭包（居然没有想到），转移为边的相连（构造新图，边就是用闭包得出来的结果）那么现在类似于要找最大独立集 结论：总能在【最小可重复点覆盖路径】的每条路径中，找出一个点证明：首先，【隐藏点】显然小于等于【路径数量】那么我们只要说我们能构造出一种方法来，就相当于证明了结论（这也是一种有趣的证明方法） 先取出每个路径的终点，作为集合A，将A走一步能到达的节点作为next(A)按照题意，$A \cap next(A)=\varnothing$ ，所以我们要有所调整取出这种元素，然后在其所属的【最小可重复点覆盖路径】上，往起点方向跳，一定能找到一个元素不属于next(A)，否则意味着整条路径都是可以被别人覆盖掉的，违反了我们先前最小的定义找到后，取代原先的元素，如此重复下去，最后总是能满足条件的综上所述，存在一种方案，满足条件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=210; int n,m; int match1[MAX_N],match2[MAX_N]; int ask[MAX_N],ti;//时间戳 bool mp[MAX_N][MAX_N]; bool fd(int x) &#123; for(int y=1;y&lt;=n;y++) &#123; if(!mp[x][y] or ask[y]==ti) continue; ask[y]=ti; if(match2[y]==0 or fd(match2[y])) &#123; match1[x]=y; match2[y]=x; return 1; &#125; &#125; return 0; &#125; bool A[MAX_N],Anx[MAX_N]; int up(int x) &#123;return match2[x];&#125; void main() &#123; scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); mp[x][y]=1; &#125; //传递闭包 for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) mp[i][j]|=mp[i][k]&amp;mp[k][j]; //二分图匹配 int ans=0;for(ti=1;ti&lt;=n;ti++) ans+=fd(ti); printf("%d\n",n-ans); for(int i=1;i&lt;=n;i++) if(match1[i]==0) A[i]=1; bool modif=1; while(modif) &#123; modif=0; memset(Anx,0,sizeof Anx); for(int i=1;i&lt;=n;i++) if(A[i]) for(int j=1;j&lt;=n;j++) if(mp[i][j]) Anx[j]=1; for(int i=1;i&lt;=n;i++) if(A[i] and Anx[i]) &#123; modif=1; int t=up(i);while(Anx[t]) t=up(t); A[i]=0;A[t]=1; break; &#125; &#125; for(int i=1;i&lt;=n;i++) if(A[i]) printf("%d ",i); &#125;&#125;;int main()&#123; mine::main();&#125; 19 CH#17 舞动的夜晚9.10 难度2请先思考后再展开 详见oi之路的二分图一章123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=11000,MAX_M=110000; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; struct Nod &#123; int hou; bool v; Nod() &#123;hou=0;v=0;&#125; &#125;p[MAX_N*2]; struct Edge &#123; int y,g,c; &#125;e[(MAX_N*2+MAX_M)*2]; int oth(int x) &#123;return x&amp;1?x+1:x-1;&#125; int ln=0; void ins(int x,int y,int c) &#123; e[++ln]=(Edge)&#123;y,p[x].hou,c&#125;;p[x].hou=ln; e[++ln]=(Edge)&#123;x,p[y].hou,0&#125;;p[y].hou=ln; &#125; int st,ed; int h[MAX_N*2]; queue&lt;int&gt; q; bool bfs() &#123; memset(h,0,sizeof h); q.push(st);h[st]=1; while(!q.empty()) &#123; int x=q.front();q.pop(); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(h[y]==0 and e[k].c&gt;0) &#123; h[y]=h[x]+1; q.push(y); &#125; &#125; &#125; return h[ed]&gt;0; &#125; int dfs(int x,int flow) &#123; if(x==ed) return flow; int out=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y,fine=mymin(flow-out,e[k].c); if(h[y]==h[x]+1 and fine&gt;0)//注意e[k].c，可能改变了 &#123; int t=dfs(y,fine); out+=t;e[k].c-=t;e[oth(k)].c+=t; &#125; &#125; if(out==0) h[x]=0;//剪枝 return out; &#125; int dfn[MAX_N*2],low[MAX_N*2],id=0; int sta[MAX_N*2],top=0; bool insta[MAX_N*2]; int belg[MAX_N*2],cnt=0; void tarjan(int x) &#123; dfn[x]=low[x]=++id; sta[++top]=x;insta[x]=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(e[k].c==0) continue; if(dfn[y]==0) tarjan(y),low[x]=mymin(low[x],low[y]); else if(insta[y]) low[x]=mymin(low[x],dfn[y]); &#125; if(dfn[x]==low[x]) &#123; ++cnt; int now; do &#123; now=sta[top--]; belg[now]=cnt; insta[now]=0; &#125;while(now!=x); &#125; &#125; int xx[MAX_M],yy[MAX_M]; void main() &#123; int n,m,ct;scanf("%d%d%d",&amp;n,&amp;m,&amp;ct); st=0,ed=n+m+1; for(int i=1;i&lt;=n;i++) ins(st,i,1); for(int i=1;i&lt;=m;i++) ins(n+i,ed,1); for(int i=1;i&lt;=ct;i++) &#123; scanf("%d%d",&amp;xx[i],&amp;yy[i]); ins(xx[i],n+yy[i],1); &#125; while(bfs()) dfs(st,0x3f3f3f3f); for(int i=st;i&lt;=ed;i++) if(dfn[i]==0) tarjan(i); int tot=0; for(int i=1;i&lt;=ct;i++) tot+=(e[2*(n+m+i-1)+1].c==0 or belg[xx[i]]==belg[n+yy[i]]); printf("%d\n",ct-tot); for(int i=1;i&lt;=ct;i++) if(e[2*(n+m+i-1)+1].c==0 or belg[xx[i]]==belg[n+yy[i]]) ; else printf("%d ",i); &#125;&#125;;int main()&#123; mine::main();&#125; 20 Poj3422 Kaka’s Matrix Travels9.10 难度1请先思考后再展开 考虑用流量表示路径的移动然后因为每个格子只能取一次，拆一下点$st=&gt;(1,1,0),flow=k,cost=0$$(i,j,0)=&gt;(i,j,1),flow=1,cost=num(i,j)$$(i,j,0)=&gt;(i,j,1),flow=\infty,cost=0$$(i,j,1)=&gt;(i+tx[t],j+ty[t],0),flow=\infty,cost=0$$(n,n,1)=&gt;ed,flow=\infty,cost=0$跑最大费用最大流即可 0x6B 图论练习部分题目 21 6B02 升降梯上9.11 难度1请先思考后再展开 把每个点拆成m个操作后的状态，最短路即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=21000; const int INF=0x3f3f3f3f; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; struct Nod &#123; int hou; int dis; Nod() &#123;hou=0;dis=INF;&#125; &#125;p[MAX_N]; struct Edge &#123; int y,c,g; &#125;e[MAX_N*30]; int ln=0;void ins(int x,int y,int c) &#123;e[++ln]=(Edge)&#123;y,c,p[x].hou&#125;;p[x].hou=ln;&#125; int st,ed; struct Data &#123; int dis,id; friend bool operator &gt; (Data a,Data b) &#123;return a.dis&gt;b.dis;&#125; &#125;; priority_queue&lt; Data,vector&lt;Data&gt;,greater&lt;Data&gt; &gt; q; void dijkstra() &#123; p[st].dis=0;q.push((Data)&#123;p[st].dis,st&#125;); while(!q.empty()) &#123; Data t=q.top();q.pop(); int x=t.id;if(p[x].dis&lt;t.dis) continue; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dis&gt;p[x].dis+e[k].c) &#123; p[y].dis=p[x].dis+e[k].c; q.push((Data)&#123;p[y].dis,y&#125;); &#125; &#125; &#125; &#125; int n,m; int c[30]; int calc(int x,int y) &#123;return (x-1)*m+y;&#125; void main() &#123; scanf("%d%d",&amp;n,&amp;m); st=0;ed=n*m+1; for(int j=1;j&lt;=m;j++) &#123; scanf("%d",&amp;c[j]); if(c[j]==0) ins(st,calc(1,j),0); &#125; for(int i=1;i&lt;n;i++) for(int j=1;j&lt;=m;j++) for(int k=1;k&lt;=m;k++) if(1&lt;=i+c[k] and i+c[k]&lt;=n) ins(calc(i,j),calc(i+c[k],k),myabs(j-k)+2*myabs(c[k])); for(int j=1;j&lt;=m;j++) ins(calc(n,j),ed,0); dijkstra(); printf("%d",p[ed].dis==INF?-1:p[ed].dis); &#125;&#125;;int main()&#123; mine::main();&#125; 22 NOI2007 社交网络9.11 难度2请先思考后再展开 原来最短路路径数是可以用floyd统计的然后记住一定要去除编号相同的情况（以前总是偷懒）还有就是，一开始总是想不通怎么处理一条链的情况，为什么不会重复统计呢？但其实，由于其dp性质，一条路径只会在k为最大编号时才被统计12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=110; typedef long long ll; int mp[MAX_N][MAX_N]; ll cnt[MAX_N][MAX_N]; void main() &#123; memset(mp,0x3f,sizeof mp); int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) mp[i][i]=0,cnt[i][i]=1; while(m--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); mp[x][y]=mp[y][x]=c; cnt[x][y]=cnt[y][x]=1; &#125; //因为floyd的dp性质，左右两边只经过小于当前编号的节点，所以不会计算重复 for(int k=1;k&lt;=n;k++) for(int x=1;x&lt;=n;x++) if(x!=k)//避免重复情况 for(int y=1;y&lt;=n;y++) if(y!=k and y!=x) &#123; if(mp[x][y]&gt;mp[x][k]+mp[k][y]) &#123; mp[x][y]=mp[x][k]+mp[k][y]; cnt[x][y]=cnt[x][k]*cnt[k][y]; &#125; else if(mp[x][y]==mp[x][k]+mp[k][y]) cnt[x][y]+=cnt[x][k]*cnt[k][y]; &#125; for(int x=1;x&lt;=n;x++) &#123; double ans=0; for(int st=1;st&lt;=n;st++) if(st!=x) for(int ed=1;ed&lt;=n;ed++) if(ed!=x) if(mp[st][x]+mp[x][ed]==mp[st][ed]) ans+=(double)cnt[st][x]*cnt[x][ed]/cnt[st][ed]; printf("%.3lf\n",ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 23 NOI2003 逃学的小孩9.12 难度2请先思考后再展开 算法一：最小化答案：min(c-&gt;a,c-&gt;b)+a-&gt;b结论：可以取直径作为a-&gt;b神仙证明 算法二：最小化答案：min(c-&gt;a,c-&gt;b)+a-&gt;b可能这个稍微常规一点?不妨设最小的是a，题目变成求出 a-&gt;c+a-&gt;b这是两条点不重复的路径，并且要求对于a而言c比b近如果枚举这两条路径的分叉点，巧妙地转化成求不同三个子树的最大深度这个可以用二次扫描+换根法实现还有个小细节，分岔点可能就是a 24 AHOI2008 紧急集合9.12 难度2请先思考后再展开 又感到很惭愧了……想了些数据，发现一定是跑到其中一个lca然后又yy几个情况，发现都是应该找深度最小那两个，然后到他们的lca，就不用枚举三次了然后就秒wa了然后就被rose秒出hack数据了，就是深度大那个点在它们到lca之间的路径上……所以最后还是枚举，发现有点慢，最大0.93s……所以正解应该是用离线lca算法，不过太复杂就不改了，大概yy了一下算法权当复习 下面就只给出朴素代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=510000; struct Nod &#123; int hou; int dep; Nod() &#123;hou=dep=0;&#125; &#125;p[MAX_N]; struct Edge &#123; int y,g; &#125;e[MAX_N*2]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,p[x].hou&#125;;p[x].hou=ln;&#125; int bin[21]; int f[MAX_N][21]; void pre(int x,int fa) &#123; p[x].dep=p[fa].dep+1; f[x][0]=fa;for(int i=1;i&lt;20;i++) f[x][i]=f[f[x][i-1]][i-1]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; pre(y,x); &#125; &#125; int LCA(int x,int y) &#123; if(p[x].dep&lt;p[y].dep) swap(x,y); for(int i=20;i&gt;=0;i--) if(p[x].dep-p[y].dep&gt;=bin[i]) x=f[x][i]; if(x==y) return x; for(int i=20;i&gt;=0;i--) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0]; &#125; int dis(int x,int y) &#123;return p[x].dep+p[y].dep-2*p[LCA(x,y)].dep;&#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; int n,q;scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=n-1;i++) &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); ins(a,b);ins(b,a); &#125; pre(1,0); while(q--) &#123; int a,b,c;scanf("%d%d%d",&amp;a,&amp;b,&amp;c); int lca1=LCA(a,b),lca2=LCA(b,c),lca3=LCA(a,c); int c1=(p[a].dep-p[lca1].dep)+(p[b].dep-p[lca1].dep)+dis(lca1,c); int c2=(p[b].dep-p[lca2].dep)+(p[c].dep-p[lca2].dep)+dis(lca2,a); int c3=(p[a].dep-p[lca3].dep)+(p[c].dep-p[lca3].dep)+dis(lca3,b); if(c1&lt;=c2 and c1&lt;=c3) printf("%d %d\n",lca1,c1); else if(c2&lt;=c1 and c2&lt;=c3) printf("%d %d\n",lca2,c2); else printf("%d %d\n",lca3,c3); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 25 poj1275 Cashier Employment9.13 难度2请先思考后再展开 本来想着如果在费用流统计答案的时候不把费用乘以流量，就能让边权只表示使用这条边的费用那么就可以构图，从st到每个人，流量8费用1，然后时间连向ed，流量就是需求量然后发现这样的修改没有用，因为我可能流量在下一条增广路采用，然后费用就被多次统计了……看了眼tag居然是差分约束…… 不难想到可以前缀和一下，构造不等式组不过不知道怎么处理环形的情况，好像涉及了三个元$s[i] \geq s[i-1]$$当i leq 7,s[i]+tot-s[i+15] \geq c[i]$$otherwise,s[i]-s[i-8] \geq c[i]$ 膜lxj后发现，显然的单调性，二分即可 26 6B12 最优高铁环9.13 难度2请先思考后再展开 连01规划的sb题都不会做了有点担忧……现在才相同专题都这样，感觉后面要更多地做综合题对于有思考环节深度的题目，经常比别人走得浅当别人在关心判正环太慢的时候，我还毫无思路甚至别人以为我没去做例题…… 总之这道题为了判断负环的速度，写的是栈spfa如果在初始值为0的情况下，只要存在最长路的松弛，就是产生了正环然后不知为何本机ac提交wa123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=1100; typedef long long ll; int hou[5*MAX_N]; struct Edge &#123; int y,g,c; &#125;e[51000]; int ln=0;void ins(int x,int y,int c) &#123;e[++ln]=(Edge)&#123;y,hou[x],c&#125;;hou[x]=ln;&#125; double dis[5*MAX_N]; bool v[5*MAX_N]; bool dfs(int x,double mid) &#123; v[x]=1; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(dis[y]&lt;dis[x]+e[k].c-mid) &#123; if(v[y]) return 1; dis[y]=dis[x]+e[k].c-mid; if(dfs(y,mid)) return 1; &#125; &#125; v[x]=0; return 0; &#125; bool check(double mid) &#123; memset(v,0,sizeof v); memset(dis,0,sizeof dis); for(int i=1;i&lt;=5000;i++) if(dfs(i,mid)) return 1; return 0; &#125; int sum;bool bk; int getid() &#123; char c=getchar(); char c2=getchar();int t=0; while('0'&lt;=c2 and c2&lt;='9') t=t*10+c2-'0',c2=getchar(); bk=(c2=='-'); if(c=='S') &#123;sum+=1000;return t;&#125; if(c=='G') &#123;sum+=500;return 1000+t;&#125; if(c=='D') &#123;sum+=300;return 2000+t;&#125; if(c=='T') &#123;sum+=200;return 3000+t;&#125; sum+=150;return 4000+t; &#125; void main() &#123; int m;scanf("%d",&amp;m);getchar(); for(int i=1;i&lt;=m;i++) &#123; sum=0; int st=getid(); int ed=getid(); while(bk) ed=getid(); ins(st,ed,sum); &#125; ll l=0,r=(ll)1000*20*50000*10,ans=-1; while(l&lt;=r) &#123; ll mid=(l+r)&gt;&gt;1; if(check((double)mid/10)) ans=mid,l=mid+1; else r=mid-1; &#125; if(ans&lt;0) puts("-1"); else printf("%d",(int)round( (double)ans/10 )); &#125;&#125;;int main()&#123; mine::main();&#125; 27 HNOI2012 矿场搭建9.14 难度2请先思考后再展开 显然先求一下割点，求出每个块的组成分析每个块，如果内部没有割点，那么需要两个出口，位置任意，但不重复如果只有一个割点，那么堵掉就凉了，所以要添加出口，而且不能在割点处如果有两个或以上，那么就无需担心，总能够出去综上说述，乘法原理统计一下即可 然后我以为根节点那个特判会影响vdcc的判断，其实只是影响割点……没有好好思考还有就是完全没考虑孤立点，还好这道题不需要123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=110000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int hou[MAX_N]; struct Edge &#123; int y,g; &#125;e[MAX_N]; int oth(int x) &#123;return x&amp;1?x+1:x-1;&#125; int ln;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; int cnt;vector&lt;int&gt; vdcc[MAX_N]; bool gd[MAX_N]; int id,dfn[MAX_N],low[MAX_N]; int sta[MAX_N],top;bool insta[MAX_N]; void tarjan(int x,int fm) &#123; sta[++top]=x;insta[x]=1; dfn[x]=low[x]=++id; int son=0;//debug 这个不能影响vdcc的判定条件，只是和是否割点有关 for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(k==oth(fm)) continue; if(dfn[y]==0) &#123; tarjan(y,k);low[x]=mymin(low[x],low[y]); if(low[y]&gt;=dfn[x] or (fm==0 and son&gt;=2))//块 &#123; son++;vdcc[++cnt].clear(); if(fm!=0 or son&gt;=2) gd[x]=1; while(1) &#123; int now=sta[top--]; vdcc[cnt].push_back(now); if(now==y) break; &#125; vdcc[cnt].push_back(x); &#125; &#125; else if(insta[y]) low[x]=mymin(low[x],dfn[y]); &#125; //debug 注意我忘记考虑孤立点的情况了 //但因为这道题没有自环，也确实不用考虑 &#125; void main() &#123; int ct=0; while(1) &#123; int n;scanf("%d",&amp;n); if(n==0) break; ln=0;memset(hou,0,sizeof hou); int mx=0; for(int i=1;i&lt;=n;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); mx=mymax(mx,mymax(x,y)); &#125; id=top=cnt=0; memset(insta,0,sizeof insta); memset(gd,0,sizeof gd); memset(dfn,0,sizeof dfn); for(int i=1;i&lt;=mx;i++) if(dfn[i]==0) tarjan(i,0); ll tot=0,ans=1; for(int i=1;i&lt;=cnt;i++) &#123; int siz=vdcc[i].size(); int dg=0;for(int j=0;j&lt;siz;j++) if(gd[vdcc[i][j]]) dg++; if(dg==0) tot+=2,ans*=(ll)siz*(siz-1)/2; if(dg==1) tot++,ans*=siz-1; &#125; printf("Case %d: %lld %lld\n",++ct,tot,ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 28 bzoj3033 太鼓达人9.15 难度2请先思考后再展开 非常好的一道题，如果lxj不说是欧拉图我肯定不会做……先考虑长度，显然不会超过 $2^k$ ，否则一定会出现重复那么如果我们能构造出一种方案，保证长度为 $2^k$ ，那么答案就是 $2^k$ 假设该结论成立，那么我们需要覆盖 0~ $2^k-1$ 的每个值有一个不那么好像的方法，但因为自己受到提示，不难想到把每个值作为边然后为了确保出现的独一无二，分割为前面k-1个和后面k-1个，转移的边为了字典序优先选最小的那么因为出度为2，入度为2，一定是一个欧拉图，那么一定能得出 $2^k$ 的长度0 如果讲得不清楚，这位女选手的图片不错 29 中山市选 杀人游戏9.15 难度1请先思考后再展开 这道题的题意不太清晰其实就是尽量少去交给命运决定……（少尝试）答案就是 $\frac{n-尝试数量}{n}$ ，也就是都不是杀手那么缩点后找入度为0即可不过如果本来是一个点，那么可以用排除法得出结果，稍微判断一下即可 30 poj3648 Wedding9.15 难度1请先思考后再展开 2-sat比较显然假设新娘在右边，然后左边不能有通奸，直接scc判断即可那么因为有可能新郎也通奸，导致新娘去左边了，为了防止这种情况，从新娘到新郎连一条边表示非法性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=110000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int hou[MAX_N]; struct Edge &#123; int y,g; &#125;e[MAX_N]; int ln;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; int id,dfn[MAX_N],low[MAX_N]; int cnt,belg[MAX_N]; int sta[MAX_N],top;bool insta[MAX_N]; void tarjan(int x) &#123; sta[++top]=x;insta[x]=1; dfn[x]=low[x]=++id; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(dfn[y]==0) tarjan(y),low[x]=mymin(low[x],low[y]); else if(insta[y]) low[x]=mymin(low[x],dfn[y]); &#125; if(dfn[x]==low[x]) &#123; cnt++; while(1) &#123; int now=sta[top--]; belg[now]=cnt; insta[now]=0; if(now==x) break; &#125; &#125; &#125; int getid() &#123; int t;char c;scanf("%d%c",&amp;t,&amp;c); return 2*t+(c=='h');//0~2n-1 &#125; void output(int x) &#123;printf("%d%c ",x/2,x&amp;1?'h':'w');&#125; bool v[MAX_N];//块的选择状态 void main() &#123; while(1) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); if(n==0 and m==0) break; ln=0;memset(hou,0,sizeof hou); ins(0,1);//确保选新郎，否则非法 for(int i=1;i&lt;=m;i++) &#123; int a=getid(),b=getid(); ins(a,b^1);ins(b,a^1); &#125; cnt=0;top=0;id=0; memset(dfn,0,sizeof dfn); for(int i=0;i&lt;=2*(n-1)+1;i++) if(dfn[i]==0) tarjan(i); memset(v,0,sizeof v); //反图拓扑序小=&gt;正图拓扑序大=&gt;正图scc编号小 bool bk=0; for(int i=0;i&lt;=n-1;i++) &#123; int fx=belg[i*2],fy=belg[i*2+1]; if(fx==fy) bk=1; v[mymin(fx,fy)]=1; &#125; if(bk) &#123;puts("bad luck");continue;&#125; for(int i=1;i&lt;=n-1;i++) output(v[belg[2*i]]?2*i+1:2*i);//得出新郎，输出新娘 puts(""); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 31 poj1112 Team Them Up!9.18 难度2请先思考后再展开 题目关键：直接认识 在本题中，单一的单向边是没有意义的，应转化为双向边因为这个直接到达有点麻烦，如果取补图，边的意义就是【不能在相同的组中】此时成功产生了互斥关系，可以二分图染色，如果不是二分图，直接无解 当然我们染色出来的只是其中一种解对于每个联通块，都是可以取反的那么现在相当于一个有序二元组，目标就是让人数差最小01背包dp一下，转移很快，滚不滚没关系 32 zoj1654/HEOI2016/TJOI2016 游戏9.18 难度2请先思考后再展开 又没看出来……先想了想网络流，肯定不对因为是双向边，想了想二分图，感觉不对，因为我选，下一个不选，并不代表再下一个会选然后想想2-sat，有点像，但不知道怎么满足最大…… 看了看tag，我去，最大独立集好像有道理，但不应该是一般图吗？再想想……哦因为排斥关系是行或列的，所以没有奇环…… 然后就连样例都过不去了……随便考虑一行多个点，然后就会有奇环凉了 lxj提示说和草地排水很像一下得到启发，分行块和列块，把点化作边那么每个点最多连一条边，那么就是一个二分图匹配]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Arc101D】Median of Medians]]></title>
    <url>%2Fposts%2Ff4a4.html</url>
    <content type="text"><![CDATA[Source and JudgeArc101D Record1h Analysis请先思考后再展开 题意：给一个长度为$n$的数列，把每个子串的中位数组成新的序列，求其中位数做法1：枚举$l$和$r$，然后排序组成中位数，时间复杂度$O(n^2log_2n)$做法2：枚举$now$，再枚举$l$和$r$，统计比它小的数量考虑其贡献，时间复杂度$O(n^3)$正解（大小逻辑关系的运用不一定完全相同）： 二分答案，难点在于如何判定问题：答案是否 $\leq mid$ 不难想到，可以判定 $\leq mid$ 的数字，$其贡献 \geq \lfloor \frac{n(n+1)}{4} \rfloor +1$ ，对于每个区间，用类似的思路，考虑是否会被”堵住“，$小于等于的数量&gt;大于的数量$，用前缀和优化一下，$(a_r-a_{l-1})-(b_r-b_{l-1})&gt;0$，为了方便，$c_{l-1}&lt;c_r$ 现在看起来复杂度是$O(n^2log_2n)$，但是显然可以用数据结构如树状数组优化，变成$O(nlog_2^2n)$ 细节：爆int，一开始完全没注意到 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; const int MAXN=110000; int n; int tr[2*MAXN]; int lowbit(int x) &#123;return x&amp;-x;&#125; void change(int d) &#123; d+=MAXN; while(d&lt;2*MAXN) tr[d]++,d+=lowbit(d); &#125; int sum(int d) &#123; d+=MAXN; int ans=0; while(d&gt;=1) ans+=tr[d],d-=lowbit(d); return ans; &#125; int a[MAXN],b[MAXN]; int c[MAXN]; typedef long long ll;//debug 爆int bool check(int now) &#123; for(int i=1;i&lt;=n;i++) c[i]=c[i-1]+(a[i]&lt;=now?1:-1);//1小于等于,-1大于 memset(tr,0,sizeof tr);//debug change(c[0]);//debug ll tot=0;//&lt;=now的数，产生的贡献 for(int r=1;r&lt;=n;r++) &#123; //c[r]-c[l-1]&gt;0 =&gt; c[l-1]&lt;c[r] (l-1&lt;r) tot+=sum(c[r]-1); change(c[r]); &#125; return tot&gt;=ll(n+1)*n/4+1; &#125; void main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); int l=1,r=1e9,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)/2; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟赛2总结]]></title>
    <url>%2Fposts%2F80fa.html</url>
    <content type="text"><![CDATA[题目 比赛经历开局听说是看谁破百请吃饭的毒瘤题集不愧是tkj出得题（后来听栋老师说，都是煞笔题） 先看t1，fff是什么东西？狗狗协会？因为有spj，尝试找突破口手推不出-1的情况，尝试用rand帮我，所以码了个暴力，结果n到25也搞不出-1的点看来可能根本就没有-1的情况了那感觉就没什么突破口了看下一题 天啊看到这种题面和排序有关的题目就虚因为以前遇到过几次，感觉都和”冒泡排序”有关果不其然，我这种不会冒泡排序的人虚死了看下一题 金坷垃？没有任何思路感觉可能要计算几何，或者扫描线之类的东西反正不会…… 难道这把就要挂机了？好像很多人都是这样……各个都说不想交了，直接讲题什么的，毫无耐心现在想想好像只有第二题可以搏一搏了 这种快排好奇特啊能不能直接先把do while的那个跑一跑，然后枚举每个点，看看后面有多少个比它小的（逆序对贡献），然后如果有再+1？这个加入离散化后，可以用树状数组维护 发现过不了大样例啊，对拍一下试试吧2h过去了……发现暴力超级难打不过也不是虚度，因为通过模拟分段的无数细节，对分段性质理解加深了 然后我发现空间炸的一匹，vector也没有用（因为大数据非常良心，是一个dfs链状结构）所以就放弃出大数据的希望了，用来对拍吧 果然逆序对是错误的主要是两个原因：循环先执行再判断、执行复杂度直接算是当前区间长度 怎么办呢想着交个暴力算了 然后，突然灵光一现，发现可以改良因为每一次的复杂度贡献是按照长度来的，然后每个分段，其实就是由【在该数后面的数中比当前小，而且最远那个】和当前，包围起来的此时因为查错，我右边的备用小数据中已经有差不多10个了发现每一个都满足这个性质（一定要先跑一次，单循环冒泡，这样子分段才是明确的） 然后发现这是一个平方级别的做法，不知道能拿多少分先打了先把，很好改试试大样例 ？？居然过了？？当时就激动得一匹因为至少做法正确性没有问题主要还是速度太慢 想办法优化数据结构中好像只有具备结构体能力的splay能搞但当时只有20min了！以我的码力，这是不可能的 咦考虑一个数组（早就离散化了），存下最后那个？那询问还要按值找哦不对是可以用线段树维护最大值的，如果保存距离的话 当时还剩15min火速开始码他们已经打算交了 那几分钟，我的心跳的好快好快手指尖在键盘间笨拙地跳舞熟悉的单点修改区间询问线段树啊，如果码出来，就有ac的希望了那段时间好漫长，但没想到还是打完了途中还差点被没看懂的编译错误卡住，现在想想真的好险 最后还是打完了，顺利过了大样例然后就去吃饭了心里虚的一匹主要是时间太紧了，要不然能对拍一下就好了现在回想起来，还是在暴力上花费太长时间了，虽然那可能是想出正解的基础 这些东西现在回想起来，感觉也很难说清楚吧其实运气成分还是很大比例的而且我这速度，后面的发展也很虚啊三道题，用全部时间，只能做出一道题 吃饭途中得喜报还是顺利ac了感谢上帝……上一次拿rk1已经是省选前了……只是，没有人和我一样兴奋都对自己很失望吗不过这种东西，风水轮流转吧大概像我上次cf，被吊锤，晚上也是难受的很 ————在断网的中午，胡思乱想 T1-Analysis请先思考后再展开 这是一个非常奇妙的做法首先把情侣之间用无向边连接，然后把2i-1和2i连接这样，所有环因为必定是情侣边和相邻边交替的，而且出发边和结束边一定不一样（度只有2）所以只有偶环，也就是说是个二分图所以就可以愉快地染色了 windows本地栈，63000左右如果不是linux，可以考虑手动模拟 T1-Code-Std请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; const int MAXN=110000; int hou[MAXN*2]; struct Edge &#123; int y,g; &#125;e[MAXN*4]; int ln=0; void ins(int x,int y) &#123; ln++; e[ln].y=y;e[ln].g=hou[x]; hou[x]=ln; &#125; int col[MAXN*2]; void dfs(int x,int now) &#123; col[x]=now; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(!col[y]) dfs(y,3-now); &#125; &#125; int a[MAXN],b[MAXN]; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;a[i],&amp;b[i]); ins(a[i],b[i]);ins(b[i],a[i]); &#125; for(int i=1;i&lt;=n;i++) ins(2*i-1,2*i),ins(2*i,2*i-1); for(int i=1;i&lt;=2*n;i++) if(!col[i]) dfs(i,1); for(int i=1;i&lt;=n;i++) printf("%d %d\n",col[a[i]],col[b[i]]); &#125;&#125;;int main()&#123; mine::main();&#125; T2-Analysis请先思考后再展开 原题 Usaco2018 Open Out of SortsLuogu4372Bzoj5277 现在冷静想一想，发现我傻了，根本没有必要用线段树这种这么长的东西因为已经离散化了，直接用数组，维护最后位置，然后搞一个【前缀最大值】就好了这要是因为我们要维护的是位置，而这种东西可以通过比较直接确定在不在后面然后前缀最大值这种东西，当时太紧张，再加上原本的做法是需要动态维护的，所以就没跳出来当然复杂度没有变化 师兄的做法没看懂，不管了反正不一样 UP：讲课的时候被d飞了86 1 3 2 4 5 2 4答案是19虽然答案一样，但画出来的线段完全不对应（据akc研究后说，它的总数值，代表了某种总贡献，只是神仙地把操作后移了） 去膜了发官方题解发现可以这样考虑：对于所谓的快排下去递归冒泡，其实和对整个序列冒泡是等效的那么考虑每个元素的贡献，就是它左右两边的分隔符都出现之前的时间长度注意： 如果在最开始的时候，它就是单个元素，那么也会被统计一次 枚举元素的时候，是按照排序后的位置来找左右两边的 那么现在问题转化为计算n-1个分隔符出现的时间对于在i和i+1之间那个分隔符，它出现时，序列前i个元素已经在其前面了那么现在的关键就是第i大（稳定排序下）那个元素的位置r，要多久才能到i显然现在位于i的那个元素，一定比位于r的那个要大，否则前面已经足够了因为更大，那么每次冒泡，这个泡i一定会把r给换过来，也就是说每次冒泡往前一位所以说从r到i的时间恰恰是r-i T2-Code-Old请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; int qread() &#123; int sum=0; char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') sum=sum*10+c-'0',c=getchar(); return sum; &#125; const int MAXN=110000; int n; int a[MAXN]; struct Nod &#123; int d,p; &#125;s[MAXN]; bool cmp(Nod a,Nod b) &#123;return a.d&lt;b.d;&#125; int rx=0; void lsh() &#123; sort(s+1,s+n+1,cmp); for(int i=1;i&lt;=n;i++) &#123; if(i==1 or s[i-1].d!=s[i].d) rx++; a[s[i].p]=rx; &#125; &#125; struct Meg &#123; int lc,rc; int mx; &#125;p[MAXN*2]; int id=0; int build(int l,int r) &#123; int t=++id; p[t].mx=0; if(l==r) p[t].lc=p[t].rc=0; else &#123; int mid=(l+r)/2; p[t].lc=build(l,mid); p[t].rc=build(mid+1,r); &#125; return t; &#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; void change(int x,int l,int r,int pos,int d) &#123; if(x==0) return; if(l==r) &#123; p[x].mx=mymax(d,p[x].mx); return; &#125; int mid=(l+r)/2; if(pos&lt;=mid) change(p[x].lc,l,mid,pos,d); else change(p[x].rc,mid+1,r,pos,d); p[x].mx=mymax(p[p[x].lc].mx,p[p[x].rc].mx); &#125; int ask(int x,int l,int r,int fl,int fr) &#123; if(x==0) return 0; if(l==fl and r==fr) return p[x].mx; int mid=(l+r)/2; if(fr&lt;=mid) return ask(p[x].lc,l,mid,fl,fr); else if(fl&gt;mid) return ask(p[x].rc,mid+1,r,fl,fr); else return mymax(ask(p[x].lc,l,mid,fl,mid),ask(p[x].rc,mid+1,r,mid+1,fr)); &#125; void main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) s[i].d=a[i]=qread(),s[i].p=i; lsh(); if(n==1) &#123;putchar('0');return;&#125; ll ans=n; for(int i=1;i&lt;=n-1;i++) if(a[i]&gt;a[i+1]) swap(a[i],a[i+1]); build(1,rx); for(int i=n;i&gt;=1;i--) &#123; int j=ask(1,1,rx,1,a[i]-1); if(j&gt;0) ans+=j-i+1; change(1,1,rx,a[i],i); &#125; printf("%lld\n",ans); &#125;&#125;;int main()&#123; mine::main();&#125; T2-Code-Std请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; const int MAXN=110000; struct Nod &#123; int d,p; &#125;p[MAXN]; bool cmp(Nod a,Nod b) &#123;return a.d&lt;b.d or (a.d==b.d and a.p&lt;b.p);&#125; int tot[MAXN]; void main() &#123; int n;scanf("%d",&amp;n); if(n==1) &#123;putchar('0');return;&#125; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i].d),p[i].p=i; sort(p+1,p+n+1,cmp); int r=0;//前i小 for(int i=1;i&lt;=n-1;i++) &#123; r=mymax(r,p[i].p); tot[i]=r-i; &#125; ll ans=0; for(int i=1;i&lt;=n;i++) &#123; int l=tot[i-1],r=tot[i]; if(l==0 and r==0) ans+=1;//do while else ans+=mymax(l,r); &#125; printf("%lld",ans); &#125;&#125;;int main()&#123; mine::main();&#125; T3-Analysis请先思考后再展开 原题 Usaco2018 Jan SprinklersLuogu4184Bzoj5187 首先，最后的可行多边形一定是一个外凸边形那么有一个重要的性质，就是对于这种形状（大概是两个阶梯围成的）然后这种图形的可行解非常好处理，因为对于每个点，它的另一个端点的可行区域就在其左下侧区域中如果要直接暴力的话，现在就可以得到50分了 考虑处理出每一列的up和low表示上下界这个东西的维护，可以考虑先记录一个转折点，然后最后再线性推一推就好了（因为有单调性） 接下来推柿子$$\sum_{i=0}^{n-1}{ \sum_{j=low[i]+1}^{up[i]} 【 \sum_{k=low[i]}^{j-1} i-left[k] 】}$$ $$\sum_{i=0}^{n-1}{ \sum_{j=low[i]+1}^{up[i]} 【 i \times (j-low[i]) - \sum_{k=low[i]}^{j-1} left[k] 】}$$ $$\sum_{i=0}^{n-1}{ i \times \sum_{j=low[i]+1}^{up[i]} 【 (j-low[i]) - \sum_{k=low[i]}^{j-1} left[k] 】}$$ $$\sum_{i=0}^{n-1}【 \frac{ i (up[i]-low[i]) (up[i]-low[i]+1) }{2} - \sum_{j=low[i]+1}^{up[i]} \sum_{k=low[i]}^{j-1} left[k]】$$ $$\sum_{i=0}^{n-1}【 \frac{ i (up[i]-low[i]) (up[i]-low[i]+1) }{2} - \sum_{t=low[i]}^{up[i]-1} left[t] \times (up[i]-t)】$$ $$\sum_{i=0}^{n-1}【 \frac{ i (up[i]-low[i]) (up[i]-low[i]+1) }{2} - up[i] \times \sum_{t=low[i]}^{up[i]-1} left[t] + \sum_{t=low[i]}^{up[i]-1} left[t] \times t】$$ $$\sum_{i=0}^{n-1}【 \frac{ i (up[i]-low[i]) (up[i]-low[i]+1) }{2} - up[i] \times \sum_{t=low[i]}^{up[i]-1} left[t] + \sum_{t=low[i]}^{up[i]-1} left[t] \times t】$$ 所以维护一个前缀和就好了 T3-Code-Std请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//use-v4//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAXN=110000; const int INF=0x3f3f3f3f; const int MOD=1e9+7; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int up[MAXN],low[MAXN],left[MAXN]; ll slf1[MAXN],slf2[MAXN]; void main() &#123; int n;scanf("%d",&amp;n); memset(up,-1,sizeof up); memset(low,63,sizeof low); memset(left,63,sizeof left); for(int i=1;i&lt;=n;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); up[x]=mymax(up[x],y); low[x]=mymin(low[x],y); left[y]=mymin(left[y],x); &#125; int lw=INF; for(int i=0;i&lt;=n-1;i++)//下阶梯 &#123; if(low[i]!=INF) lw=mymin(lw,low[i]); if(lw!=INF) low[i]=lw; &#125; int upp=0; for(int i=n-1;i&gt;=0;i--)//上阶梯 &#123; if(up[i]!=-1) upp=mymax(upp,up[i]); if(upp!=0) up[i]=upp; &#125; int lf=INF; for(int i=0;i&lt;=n-1;i++)//左阶梯 &#123; if(left[i]!=INF) lf=mymin(lf,left[i]); if(lf!=INF) left[i]=lf; &#125; slf1[0]=left[0];slf2[0]=0; for(int t=1;t&lt;=n-1;t++) &#123; slf1[t]=(slf1[t-1]+left[t])%MOD; slf2[t]=(slf2[t-1]+(ll)left[t]*t%MOD)%MOD; &#125; ll ans=0; for(int i=0;i&lt;=n-1;i++) &#123; if(up[i]&gt;=low[i]) ans+=ll(up[i]-low[i])*(up[i]-low[i]+1)/2 %MOD *i; ans%=MOD; if(low[i]&gt;0) ans-=(ll)up[i]*(slf1[up[i]-1]-slf1[low[i]-1]) %MOD; else ans-=(ll)up[i]*slf1[up[i]-1] %MOD; if(low[i]&gt;0) ans+=slf2[up[i]-1]-slf2[low[i]-1]; else if(up[i]&gt;0) ans+=slf2[up[i]-1]; ans=(ans%MOD+MOD)%MOD; &#125; printf("%lld",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【训练】算法竞赛进阶指南-5动态规划]]></title>
    <url>%2Fposts%2F18f8.html</url>
    <content type="text"><![CDATA[本处难度分档以个人实力为参照系难度1：半小时内想出，半小时内ac难度2：半小时想不出，看题解，服气难度3：半小时想不出，看题解，ac后依然觉得难度很大 另外，由于追进度，对于coding部分比较有自信的题目，不再具体实现 0x50 动态规划部分题目 1 5101 LCIS8.22 难度2请先思考后再展开 精妙的做法设 $f(i,j)$ 表示以b[j]结尾，匹配到i的最长LCIS$a_i \neq b_j,f(i,j)=f(i-1,j)$$a_i=b_j,f(i,j)=max_{0&lt;k&lt;j,b_k&lt;b_j} f(i-1,k)+1$$a_i=b_j,f(i,j)=max_{0&lt;k&lt;j,b_k&lt;a_i} f(i-1,k)+1$乍一看是$n^3$级别的，但其实k的位置是可以动态维护的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; const int MAXN=3100; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int a[MAXN],b[MAXN]; int f[MAXN][MAXN]; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;b[i]); for(int i=1;i&lt;=n;i++) &#123; int k=0;//0&lt;k&lt;j for(int j=1;j&lt;=n;j++) &#123; if(a[i]!=b[j]) f[i][j]=f[i-1][j]; else f[i][j]=f[i-1][k]+1; if(b[j]&lt;a[i] and f[i-1][j]&gt;f[i-1][k]) k=j; &#125; &#125; int ans=0; for(int i=1;i&lt;=n;i++) ans=mymax(ans,f[n][i]); printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125; 2 5105 Cookies8.22 难度2请先思考后再展开 好题对于决策的分配，可以从等效状态直接转移抓住【排序后分配额递减】和【饼干至少1】的特性同时怒气值是根据相对大小产生的，所以可以整体少1设 $f(i,j)$ 表示给前i个人j块饼干的花费 决策1，所有人减少1块（当$j-i \geq i$）$$f(i,j)=f(i,j-i)$$决策2，后k个人（包括i）都是1块$$f(i,j)=min_{k=1}^{i-1} { f(i-k,j-k) + (i-k) \times \sum_{t=i-k+1}^i g[t] }$$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=40,MAX_M=5100; int g[MAX_N]; ll s[MAX_N];//前缀和 int pos[MAX_N]; bool cmp(int x,int y) &#123;return g[x]&gt;g[y];&#125; ll f[MAX_N][MAX_M]; int fm[MAX_N][MAX_M]; int n,m; int ans[MAX_N]; void output(int a,int b) &#123; if(a==0 and b==0) return; int k=fm[a][b]; if(k==0) &#123; output(a,b-a); for(int i=1;i&lt;=n;i++) ans[pos[i]]++; &#125; else &#123; output(a-k,b-k); for(int i=a-k+1;i&lt;=a;i++) ans[pos[i]]=1; &#125; &#125; void main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;g[i]),pos[i]=i; sort(pos+1,pos+n+1,cmp); memset(f,0x3f,sizeof f); f[0][0]=0; for(int i=1;i&lt;=n;i++) &#123; s[i]=s[i-1]+g[pos[i]]; for(int j=i;j&lt;=m;j++) &#123; if(j-i&gt;=i) f[i][j]=f[i][j-i],fm[i][j]=0; for(int k=1;k&lt;=i;k++) &#123; ll nx=f[i-k][j-k]+ll(i-k)*(s[i]-s[i-k+1-1]); if(f[i][j]&gt;nx) f[i][j]=nx,fm[i][j]=k; &#125; &#125; &#125; printf("%lld\n",f[n][m]); output(n,m); for(int i=1;i&lt;=n;i++) printf("%d ",ans[i]); &#125;&#125;;int main()&#123; mine::main();&#125; 3 poj1015 Jury Compromise8.22 难度2请先思考后再展开 把差值作为体积，和作为权值，跑背包难点在于回溯刚开始在外层跑第几个物品，然后发现会出现一种情况，即使倒着枚举已选数量：现在使用过的物品，可能把当前依赖的那个位置给更新掉，不符合01背包所以改成在里面枚举，这样每次强行判断一下就好了如果要稍微降低代码复杂度，同时剪剪枝（其实也就是20），可以考虑刷表法 话说跟风akc，第一次用宏对于这道题是真的爽123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=210,MAX_M=30; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; #define f(i,j) F[i][550+(j)] #define fm(i,j) Fm[i][550+(j)] int F[MAX_M][1100]; int Fm[MAX_M][1100]; int h[MAX_N],w[MAX_N]; int person[MAX_M]; void main() &#123; int ct=0; while(1) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); if(n==0 and m==0) break; printf("Jury #%d\n",++ct); for(int i=1;i&lt;=n;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); h[i]=x-y;w[i]=x+y; &#125; memset(F,-1,sizeof F); f(0,0)=0; for(int i=0;i&lt;=m-1;i++) for(int val=-500;val&lt;=500;val++) if(f(i,val)&gt;=0)//刷表法更方便 for(int k=1;k&lt;=n;k++) if(f(i+1,val+h[k])&lt;f(i,val)+w[k])//剪枝 &#123; bool bk=0; int a=i,b=val; while(a!=0) &#123; int t=fm(a,b); if(t==k) &#123;bk=1;break;&#125; a--;b-=h[t]; &#125; if(bk) continue;//判重 f(i+1,val+h[k])=f(i,val)+w[k]; fm(i+1,val+h[k])=k; &#125; int v; for(int val=0;val&lt;=500;val++) &#123; if(f(m,-val)&gt;=f(m,val) and f(m,-val)&gt;=0) &#123;v=-val;break;&#125; if(f(m,val)&gt;=f(m,-val) and f(m,val)&gt;=0) &#123;v=val;break;&#125; &#125; int p=0,d=0; int now=m; while(now&gt;0) &#123; int k=fm(now,v); person[now]=k; p+=(h[k]+w[k])/2;d+=(w[k]-h[k])/2; now--;v-=h[k]; &#125; sort(person+1,person+m+1); printf("Best jury has value %d for prosecution and value %d for defence:\n",p,d); for(int i=1;i&lt;=m;i++) printf(" %d",person[i]); printf("\n\n");//debug 空行 &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 4 poj1742 Coins8.22 难度2请先思考后再展开 楼教主的题耶二进制拆分法解决多重背包问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=110,MAX_M=110000; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int bin[20]; int a[MAX_N],b[MAX_N]; int w[MAX_N*20]; bool f[MAX_M]; void main() &#123; bin[0]=1;for(int i=1;i&lt;20;i++) bin[i]=bin[i-1]&lt;&lt;1; while(1) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); if(n==0 and m==0) break; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;b[i]); int tot=0; for(int i=1;i&lt;=n;i++) &#123; int p=0;while(bin[p+1]-1&lt;b[i]) p++; int r=b[i]-(bin[p]-1);p--; for(int j=0;j&lt;=p;j++) w[++tot]=bin[j]*a[i]; w[++tot]=r*a[i]; &#125; memset(f,0,sizeof f); f[0]=1; for(int i=1;i&lt;=tot;i++) for(int j=m;j&gt;=w[i];j--) f[j]|=f[j-w[i]]; int ans=0; for(int i=1;i&lt;=m;i++) ans+=f[i]; printf("%d\n",ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 5 USACO2005 Jan Gold Naptime8.23 难度2请先思考后再展开 环形的dp，并且不能使用克隆法（会重复使用）对于这种决策能自动补全的题目，可以用一种巧妙的做法————二次扫描 设 $f(i,j,0/1)$ 表示处理到第i个小时，已经休息了j个小时，当前醒/睡状态下，最大的休息值先不考虑从昨晚就开始睡觉的情况 初始值为负无限（剔除非法状态，例如休息0正在睡）$f(1,0,0)=f(1,1,1)=0$$f(i,j,0)=f(i-1,j,0)$$f(i,j,1)=max{ f(i-1,j-1,0),f(i-1,j-1,1)+w_i }$$ans1=max{ f(n,m,0),f(n,m,1) }$那么昨晚就开始睡觉怎么办？$f(1,0,0)=0,f(1,1,1)=w_1$强行重新跑一次，自动拼接$ans2=f(n,m,1)$ $ANS=max{ ans1,ans2 }$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=4000; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int n,m; int w[MAX_N]; int f[2][MAX_N][2];//滚动 void dp() &#123; for(int i=2;i&lt;=n;i++) for(int j=0;j&lt;=mymin(i,m);j++) &#123; f[i&amp;1][j][0]=mymax(f[(i-1)&amp;1][j][0],f[(i-1)&amp;1][j][1]); if(j&gt;0) f[i&amp;1][j][1]=mymax( f[(i-1)&amp;1][j-1][0],f[(i-1)&amp;1][j-1][1]+w[i] ); &#125; &#125; void main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]); memset(f,-63,sizeof f);//debug 剔除非法状态 f[1][0][0]=f[1][1][1]=0; dp(); int ans1=mymax(f[n&amp;1][m][0],f[n&amp;1][m][1]); memset(f,-63,sizeof f); f[1][0][0]=0;f[1][1][1]=w[1]; dp(); printf("%d",mymax(ans1,f[n&amp;1][m][1])); &#125;&#125;;int main()&#123; mine::main();&#125; 6 CF24D Broken robot8.23 难度2请先思考后再展开 注意题意细节，一开始看题看错了： 不能向上 可以到最后一行任意位置 停在原地的选择也算是一种行动，要计算步数 如果向左是非法选择，那么随机的时候不会考虑那边非常有趣的思路：用高斯消元解决局部依赖性的dp 分n个阶段去dp同样用倒推解决期望问题$f(i,j)=f(i,j)/4+f(i,j-1)/4+f(i,j+1)/4+f(i+1,j)/4+1$其中 $f(i+1,j)$ 是定值$\frac{3}{4}f(i,j)-\frac{1}{4}f(i,j-1)-\frac{1}{4}f(i,j+1)=f(i+1,j)/4+1$每个阶段列出一个 m个m元方程组，浮点高斯消元求解即可 就这么水？呵呵复杂度是$n^3$ ，不tle才怪主要是高斯消元太慢了考虑通过题目性质改良123456@@@@@ @@@ @@@ @@@ @@ 形状一定是这样的然后可以这样搞：第一遍，顺着，第i行消第i+1的第i元，变成这样123456@@ @@ @@ @@ @@ @ 第二遍，倒着，第i行消第i-1行的第i个 然后就完美了虽然大部分是自己想的，但还是有akc的一点提示，以及lxj的一点题意解释（懒得看）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=1100; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; double f[MAX_N][MAX_N]; int m; double a[MAX_N][MAX_N],b[MAX_N]; void guass2()//针对此题的形状 &#123; for(int i=1;i&lt;=m-1;i++) &#123; double t=a[i+1][i]/a[i][i]; a[i+1][i]=0; a[i+1][i+1]-=a[i][i+1]*t; b[i+1]-=b[i]*t; &#125; for(int i=m;i&gt;=2;i--) &#123; double t=a[i-1][i]/a[i][i]; a[i-1][i]=0; b[i-1]-=b[i]*t; &#125; &#125; void main() &#123; int n,stx,sty;scanf("%d%d%d%d",&amp;n,&amp;m,&amp;stx,&amp;sty); if(m==1) &#123; printf("%d",(n-stx)*2); return;//f(i,j)/2=f(i+1,j)/2+1 &#125; for(int i=n-1;i&gt;=stx;i--) &#123; for(int j=1;j&lt;=m;j++) &#123; if(1==j or j==m) &#123; a[j][j]=2; if(j&gt;1) a[j][j-1]=-1; if(j&lt;m) a[j][j+1]=-1; b[j]=f[i+1][j]+3; &#125; else &#123; a[j][j]=3; if(j&gt;1) a[j][j-1]=-1; if(j&lt;m) a[j][j+1]=-1; b[j]=f[i+1][j]+4; &#125; &#125; guass2(); for(int j=1;j&lt;=m;j++) if(a[j][j]!=0) f[i][j]=b[j]/a[j][j],a[j][j]=0; &#125; printf("%.10lf",f[stx][sty]); &#125;&#125;;int main()&#123; mine::main();&#125; 7 noi2001 炮兵阵地8.26 难度2请先思考后再展开 关键是状态怎么精妙地表示一开始想着用6进制数，炸得很主要是没有考虑到十字的影响很小计算第i+1行，只要考虑第i-1和第i行，确保它们分别与运算都是0（反映列的上下影响两个）同时可以预处理出每个行内合法的状态，也就是没有两个相邻的距离小于3（反映行）这个状态量非常小，极限88个，可以放心搞时间复杂度$O(n |S|^3)$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=110; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; int mysqr(int x) &#123;return x*x;&#125; int bin[20]; int n,m; int tot,S[100],siz[100];//状态，1的数量，极限88个 void pre() &#123; bin[0]=1;for(int i=1;i&lt;=m;i++) bin[i]=bin[i-1]*2; tot=0; for(int s=0;s&lt;=bin[m]-1;s++) &#123; int lst=-5,tmp=0; bool bk=1; for(int j=0;j&lt;=m-1;j++) if(s&amp;bin[j]) &#123; tmp++; if(j-lst&lt;=2) bk=0; else lst=j; &#125; if(bk) S[++tot]=s,siz[tot]=tmp; &#125; &#125; int mp[110]; bool okay(int i,int k) &#123; return (mp[i]|S[k])==mp[i]; &#125; int f[110][100][100]; int dp() &#123; memset(f,-1,sizeof f); for(int i=1;i&lt;=tot;i++) for(int j=1;j&lt;=tot;j++) if((S[i]&amp;S[j])==0 and okay(1,i) and okay(2,j)) f[2][i][j]=siz[i]+siz[j]; for(int now=2;now&lt;=n-1;now++)//刷表法 for(int i=1;i&lt;=tot;i++) for(int j=1;j&lt;=tot;j++) if(f[now][i][j]&gt;=0) for(int k=1;k&lt;=tot;k++) if(okay(now+1,k) and (S[i]&amp;S[k])==0 and (S[j]&amp;S[k])==0) f[now+1][j][k]=mymax(f[now+1][j][k],f[now][i][j]+siz[k]); int ans=0; for(int i=1;i&lt;=tot;i++) for(int j=1;j&lt;=tot;j++) if((S[i]&amp;S[j])==0 and okay(n-1,i) and okay(n,j)) ans=mymax(ans,f[n][i][j]); return ans; &#125; char str[20]; void main() &#123; scanf("%d%d",&amp;n,&amp;m); pre(); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",str); for(int j=0;j&lt;=m-1;j++) if(str[j]=='P') mp[i]|=bin[j]; &#125; if(n==1) &#123; int mx=0; for(int i=1;i&lt;=tot;i++) if(okay(1,i)) mx=mymax(mx,siz[i]); printf("%d",mx); &#125; else printf("%d",dp()); &#125;&#125;;int main()&#123; mine::main();&#125; 8 5702 Count The Repetitions8.27 难度2请先思考后再展开 神仙好题看到字符串的“生成”就虚的要死但其实字符串长度很短，可以暴力搞具体等会讲 问题可以转化成，用 $s(s_1,n_1)$ 能生成的 $s(s_2,m’)$ 使m’最大答案即最大的 $n_2 \times m \leq m’$ 因为m’是能拆分二进制的，那么考虑能否用s1来拼出只要有解，那么从某个位置开始的连续一段，花费一些字符长度，总是能拼出来的那么记录具体花费（考虑到题目中的生成是不能跳跃的，那么花费代价是很明确的，也没有任何决策可言）$f(x,p)$ 表示在s1的x开始，需要花费多少个字符，才能生成$s(s_2,2^p)$对于p=0的起始状态，可以直接暴力尝试s2的每个字符，然后如果为了找一个字符连续找了一圈，那么无解，这个地方的复杂度是$100^3$ 倍增的转移就非常简单了（为了方便，字符串从0开始）这时候先假设s1是无限长的，后面拆分的时候再考虑最终长度限制，因为现在还不明确$f(x,p)=f(x,p-1)+f( x+f(x,p-1) \% |s_1|,p-1 )$ 对于每次拆分，设x为当前用到什么地方，限制$x \leq n_1 \times |s_1|$然后x从0开始，lyd不知道干嘛居然还枚举x的起点，这样显然是没意义的……然后就没有然后了 本题ch上数据有错，多了个大括号在输入文件中，用cin可以规避简易前往leetcode4661234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=110; const int INF=0x3f3f3f3f; ll f[MAX_N][40]; int n1,n2; char s2[MAX_N],s1[MAX_N]; void solve() &#123; int len2=strlen(s2),len1=strlen(s1); memset(f,0,sizeof f); //暴力计算f(st,0) for(int st=0;st&lt;=len1-1;st++) &#123; int now=st; for(int i=0;i&lt;=len2-1;i++)//s2 &#123; int tot=0;//s1 while(s1[now]!=s2[i]) &#123; now=(now+1)%len1; if(++tot&gt;=len1) &#123;puts("0");return;&#125;//debug &#125; now=(now+1)%len1;f[st][0]+=tot+1; &#125; &#125; //预处理转移 for(int p=1;p&lt;=30;p++) for(int x=0;x&lt;=len1-1;x++) f[x][p]=f[x][p-1]+f[(f[x][p-1]+x)%len1][p-1]; //二进制拆分 ll now=0,ans=0; for(int p=30;p&gt;=0;p--) if(now+f[now%len1][p]&lt;=n1*len1) now+=f[now%len1][p],ans+=1&lt;&lt;p; printf("%lld\n",ans/n2); &#125; void main() &#123; while(scanf("%s%d%s%d",s2,&amp;n2,s1,&amp;n1)!=EOF) solve(); &#125;&#125;;int main()&#123; mine::main();&#125; 9 poj3017 Cut the Sequence8.27 难度2请先思考后再展开 $f(i)=min{ f(j)+mx(j+1,i) },sum(j+1,i) \leq M,0 \leq j&lt;i$这个柿子的可以用队列维护，但难以维护单调性 但是有一个结论：对于一个 $j$ ，若 $j$ 可能是最优决策，则不仅要满足$sum(j+1,i) \leq M$还要满足下列其中一个条件： $a_j=max(j,i)$ （单调递减性） $sum(j,i)&gt;M$ （也就是说 $j+1$ 是满足条件中最小的 ）证明：首先如果意会一下，就是在满足条件下，以max结果分割，每段最左边的那个原因是，如果存在一个满足条件的 $j-1$ ，并且和 $j$ 在同一段中，那么再考虑f的单调性（显然多一个数字不会更小），显然 $j-1$ 不会比 $j$ 差 上面两种情况可以分开考虑和继承对于情况2，可以尺取法线性维护（每个 $i$ 只有一个）对于情况1，维护一个 $a$ 单调递减的队列不难发现，对于单调队列中的每个元素，其 $mx(j+1,i)$ 就是下一个元素的a然后，由于条件1，在每次插入 $a_i$ 并维护单调性后，每个决策的大小是不会变的（除了单调队列最后一个元素，因为此时它还没有下一个元素）等维护完以后，再把倒数第二个决策插入到二叉堆里面，取最大更新即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=110000; const int INF=0x3f3f3f3f; int bin[20]; ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125; int n; int a[MAX_N]; int p[MAX_N];//单调队列对应位置 multiset&lt;ll&gt; q; ll f[MAX_N]; void main() &#123; ll m;scanf("%d%lld",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); if(a[i]&gt;m) &#123;puts("-1");return;&#125; &#125; int l=1,r=1; p[1]=1;f[1]=a[1]; ll sum=a[1];int low=1; for(int i=2;i&lt;=n;i++) &#123; //update sum+=a[i]; while(sum&gt;m) sum-=a[low++]; while(l&lt;=r and p[l]&lt;low) &#123; if(l&lt;r) q.erase(q.find( f[p[l]]+a[p[l+1]] )); l++; &#125; //push while(l&lt;=r and a[p[r]]&lt;=a[i]) &#123; if(l&lt;r) q.erase(q.find( f[p[r-1]]+a[p[r]] )); r--; &#125; p[++r]=i;if(l&lt;r) q.insert(f[p[r-1]]+a[p[r]]); //dp f[i]=f[low-1]+a[p[l]]; if(l&lt;r) f[i]=mymin(f[i],*q.begin()); &#125; printf("%lld",f[n]); &#125;&#125;;int main()&#123; mine::main();&#125; 10 5A01 任务安排18.27 难度2请先思考后再展开 最初的想法，基本上是$O(750000^2 n)$$f(i,ed)=min{ f(j,\leq ed-s-sumT[i]+sumT[j])+ed \times (sumC[i]-sumC[j]) }$其实可以把第二维转化为分段数量，简化状态，时间$O(n^3)$$f(i,t)=min{ f(j,t-1)+(S \times t+sumT[i]) \times (sumC[i]-sumC[j]) }$ 然后有一个神奇的经典思想，叫做“费用提前计算”，就是把当前决策产生的后效性现在就计算，这样子，如果某次决策比不过别人，没有后效性之后是不用任何担心的，再也不会更优$f(i)=min{ f(j)+sumT[i] \times (sumC[i]-sumC[j])+S \times (sumC[n]-sumC[j]) }$时间$O(n^2)$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=5100; const int INF=0x3f3f3f3f; ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125; ll sumT[MAX_N],sumC[MAX_N]; ll f[MAX_N]; void main() &#123; int n,S;scanf("%d%d",&amp;n,&amp;S); for(int i=1;i&lt;=n;i++) &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); sumT[i]=sumT[i-1]+a;sumC[i]=sumC[i-1]+b; &#125; memset(f,63,sizeof f); f[0]=0; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;i;j++) f[i]=mymin(f[i], f[j]+sumT[i]*(sumC[i]-sumC[j])+(sumC[n]-sumC[j])*S ); printf("%lld",f[n]); &#125;&#125;;int main()&#123; mine::main();&#125; 11 ioi2002 Batch Scheduling8.27 难度2请先思考后再展开 $f(i)=min{ f(j)+sumT[i] \times (sumC[i]-sumC[j])+S \times (sumC[n]-sumC[j]) }$把min去除，把关于j的值看做变量$【f(j)】=【sumT[i]+S】\times sumC[j]+【f(i)-sumT[i] \times sumC[i]-S \times sumC[n]】$看起来像一个一次函数$y=kx+b$ 未完待续……12 CF559C Gerald and Giant Chess8.28 难度2请先思考后再展开 看到黑色棋子这么少，一定是用总方案数-非法情况得到答案然后就想着，如果统计每个黑色格子经过的数量，用容斥原理统计的话，怎么计算出多个黑色的情况？显然是无法暴力枚举的，然后就懵逼了 其实，这是因为状态的设计有问题，导致同一条路径被多次计算重新设计状态，设$f(x)$表示以黑格子x作为某条【经过黑格子的路径】的第一个黑格子，这样，每条路径只会被它第一个黑格子统计，这样就能不重不漏了至于任意走的时候的方案数，可以参考前面讲到的多重集全排列 $$f(i)=C_{x_i+y_i-2}^{x_i-1} - \sum_{{ j|x_j \leq x_i 且 y_j \leq y_i }} f(j) \times C_{x_i-x_j+y_i-y_j}^{x_i-x_j} $$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=2100; const ll MOD=1e9+7; ll qpower(ll a,ll e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=ans*a%MOD; a=a*a%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll fac[210000],invfac[210000];//debug 开太小了，因为x+y ll C(int n,int m) &#123; return fac[n]*invfac[m]%MOD*invfac[n-m]%MOD; &#125; struct Nod &#123; int x,y; &#125;p[MAX_N]; bool cmp(Nod a,Nod b) &#123; return a.x&lt;b.x or (a.x==b.x and a.y&lt;b.y); &#125; ll f[MAX_N]; void main() &#123; fac[0]=1;invfac[0]=1; for(int i=1;i&lt;=200000;i++) fac[i]=fac[i-1]*i%MOD,invfac[i]=qpower(fac[i],MOD-2); int h,w,n;scanf("%d%d%d",&amp;h,&amp;w,&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].x,&amp;p[i].y); sort(p+1,p+n+1,cmp); p[n+1].x=h;p[n+1].y=w;//等价 for(int i=1;i&lt;=n+1;i++) &#123; f[i]=C(p[i].x+p[i].y-2,p[i].x-1); for(int j=1;j&lt;=i-1;j++) if(p[j].x&lt;=p[i].x and p[j].y&lt;=p[i].y) &#123; f[i]-=f[j]*C(p[i].x-p[j].x+p[i].y-p[j].y,p[i].x-p[j].x)%MOD; f[i]=(f[i]%MOD+MOD)%MOD; &#125; &#125; printf("%I64d",(f[n+1]%MOD+MOD)%MOD); &#125;&#125;;int main()&#123; mine::main();&#125; poj1737 Connected Graph8.28 难度2请先思考后再展开 通常而言，计数类dp需要划分结构来继承，但现在处理的“连通无向图”很难划分所以现在考虑能否算出【任意无向图数量-不连通的无向图数量】任意无向图数量显然为$2^{n(n-1)/2}$对于不连通的无向图数量，可以划分出多个联通块又是运用某个不知名的经典思想，只分割出单一的一个来避免重复计数，剩下的内部还是任意（不能和分割出来的连通） 设 $f(i)$ 表示一个大小为n的连通无向图数量$f(i)=2^{i(i-1)/2}-\sum_{j=1}^{i-1} f(j) \times C_{i-1}^{j-1} \times 2^{(i-j)(i-j-1)/2}$代码略 CEOI2002 A decorative fence8.28 难度3请先思考后再展开 整体思路：因为要找第k大，依次枚举每个位置，枚举在这上面放什么，然后计算如果这样放，后面的方案数T如果$k \leq T$，那么证明这是正确的，继续往下找，否则$k-=T$这个思想在【树状数组、各种平衡树中找第k大】等应用中都有体现，不过本题没法也没必要分治 具体而言，设当前位置为i，并假设现在放了一块长度为h的木板作为0低位1高位高低位在第一个确定以后，就是轮流的了，所以说第一个要特判那么怎么计算方案数呢？设 $f(i,j,0/1)$ 表示用i个木板，其中最左边那个在其中是第i小且作为0低位1高位，的方案数那么此时就是$f[n-i+1][h在剩下中的排名][递推出的当前高低位]$ 注意到我们用排名而不是具体的值来表示这样子就不用考虑左边用剩下什么，而只要考虑高低位所需要的相对大小关系就好了（类似离散化）而且因为和具体的值没有关系，放在外面预处理也是可以的 这个dp方程也不是太好想可以从放入后的结果考虑，然后思考什么状态能转移过来：在插入后，最左边那个的排名是j如果是低位，那么插入后的排名，可以在它右边的就是 j+1~i ，还原到i-1时就是 j~i-1$f(i,j,0)=\sum_{p=j}^{i-1} f(i-1,p,1)$如果是低位，那么插入后的排名，可以在它右边的就是 1~j-1 ，还原到i-1时依旧是 1~j-1$f(i,j,1)=\sum_{p=1}^{j-1} f(i-1,p,0)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=30; const int INF=0x3f3f3f3f; ll f[MAX_N][MAX_N][2]; void preDP() &#123; f[1][1][0]=f[1][1][1]=1; for(int i=2;i&lt;=20;i++) &#123; for(int j=1;j&lt;=i;j++) &#123; for(int p=j;p&lt;=i-1;p++) f[i][j][0]+=f[i-1][p][1]; for(int p=1;p&lt;=j-1;p++) f[i][j][1]+=f[i-1][p][0]; &#125; &#125; &#125; void main() &#123; preDP(); int T;scanf("%d",&amp;T); while(T--) &#123; int n;ll k;scanf("%d%lld",&amp;n,&amp;k); int last,now; for(last=1;last&lt;=n;last++)//第一个（要从小到大） &#123; now=1; if(k&gt;f[n][last][1])//由于第一位已经确定，字典序由第二位决定，先下降 &#123; k-=f[n][last][1],now=0; if(k&gt;f[n][last][0]) &#123;k-=f[n][last][0];continue;&#125; &#125; break; &#125; printf("%d",last); bool v[30];memset(v,0,sizeof v);v[last]=1; for(int i=2;i&lt;=n;i++)//填第i位,n^3 &#123; now^=1; for(int len=1;len&lt;=n;len++)//要从小到大 &#123; if(v[len]) continue; if(now and last&gt;len) continue; if(!now and last&lt;len) continue; int tot=0;for(int j=1;j&lt;=len-1;j++) if(!v[j]) tot++; if(k&lt;=f[n-i+1][tot+1][now]) &#123;v[len]=1;last=len;printf(" %d",len);break;&#125; else k-=f[n-i+1][tot+1][now]; &#125; &#125; puts(""); &#125; return; &#125;&#125;;int main()&#123; mine::main();&#125; poj3208 Apocalypse Someday8.28 难度2请先思考后再展开 运用和上一道题类似的思想考虑每一个位置，枚举其数字，将后面能够让当前数字变成魔鬼数有多少种方案 而要称为魔鬼数，需要考虑三点： 前面部分最后连续的6的数量（也可能已经是魔鬼数，此时后面可以任意填） 这一位是否是6（衔接、延长） 后面的方案 这里后面的方案同样是预处理，但又要考虑到其前面6的个数以下内容包含前导0设 $f(i)$ 表示i位魔鬼数的数量$g(i,0/1/2)$ 表示最后有连续 $0/1/2$ 个6，但不是魔鬼数的数量（避免重复） 显然有如下柿子$f(i)=g(i-1,2)+10\times f(i-1)$$g(i,0)=g(i-1,0)+g(i-1,1)+g(i-1,2)$$g(i,1)=g(i-1,0)$$g(i,2)=g(i-1,1)$ 但要注意边界$g(0,0)=1$本来直接写出了i=1的情况错了，好想是因为后面要用到，而不仅预处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=30; const int INF=0x3f3f3f3f; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int f[20],g[20][3]; void preDP() &#123; g[0][0]=1;//debug 不止预处理，拆分的时候也要用到 for(int i=1;i&lt;=10;i++) &#123; g[i][0]=9*(g[i-1][0]+g[i-1][1]+g[i-1][2]); g[i][1]=g[i-1][0]; g[i][2]=g[i-1][1]; f[i]=g[i-1][2]+10*f[i-1]; &#125; &#125; void main() &#123; preDP(); int T;scanf("%d",&amp;T); while(T--) &#123; int k;scanf("%d",&amp;k); int ln=3;while(k&gt;f[ln]) ln++;//确保第一个不会选出0 int lst=0;//3表示已经是 for(int now=ln;now&gt;=1;now--) &#123; for(int i=0;i&lt;=9;i++) &#123; int num=f[now-1];//有多少种填法能让整个数是魔鬼数 if(lst==3) num+=g[now-1][0]+g[now-1][1]+g[now-1][2]; else if(i==6) &#123; if(lst&gt;=0) num+=g[now-1][2]; if(lst&gt;=1) num+=g[now-1][1]; if(lst&gt;=2) num+=g[now-1][0]; &#125; if(k&gt;num) &#123;k-=num;continue;&#125; if(lst&lt;3) &#123; if(i==6) lst++; else lst=0; &#125; printf("%d",i); break; &#125; &#125; puts(""); &#125; return; &#125;&#125;;int main()&#123; mine::main();&#125; Ahoi2009 同类分布8.28 难度2请先思考后再展开 本来觉得是一道神题学完数位dp后，就觉得是一道水题了（主要是太套路，太常规）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=30; const int INF=0x3f3f3f3f; ll f[20][170][170]; bool v[20][170][170]; int ed; int num[20]; ll dec[20];//%ed下 ll calc(int ln,int sum,int r,bool mask)//长度，剩下和，余数，顶位 &#123; if(sum&lt;0) return 0; if(ln&lt;=0) return sum==0 and r==0; if(!mask and v[ln][sum][r]) return f[ln][sum][r]; ll tot=0; int mx=mask?num[ln]:9; for(int now=0;now&lt;=mx;now++) tot+=calc(ln-1,sum-now,(( r-now*dec[ln-1] )%ed+ed)%ed,mask and now==mx); if(!mask) v[ln][sum][r]=1,f[ln][sum][r]=tot; return tot; &#125; ll solve(ll x) &#123; int n=0;while(x&gt;0) num[++n]=x%10,x/=10; ll ans=0; for(ed=1;ed&lt;=9*n;ed++) &#123; dec[0]=1;for(int i=1;i&lt;20;i++) dec[i]=dec[i-1]*10%ed; memset(v,0,sizeof v); ans+=calc(n,ed,0,1); &#125; return ans; &#125; void main() &#123; ll a,b;scanf("%lld%lld",&amp;a,&amp;b); printf("%lld",solve(b)-solve(a-1)); &#125;&#125;;int main()&#123; mine::main();&#125; ###8.28 难度2请先思考后再展开 12 ###8.28 难度2请先思考后再展开 12 0x5E 动态规划练习部分题目 USACO2002 Feb BUY LOW, BUY LOWER8.24 难度2请先思考后再展开 难点在于统计和去重很不好想的做法：先处理出f，接着重新枚举一次，根据刚才的转移路径来统计答案为了避免重复，碰到相同的数就break，因为前面的部分是无法直接更新自己的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=5100; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int a[MAX_N]; int f[MAX_N],c[MAX_N]; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); a[0]=0x3f3f3f3f; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=i-1;j++) if(a[j]&gt;a[i]) f[i]=mymax(f[i],f[j]+1); c[0]=1; for(int i=1;i&lt;=n;i++) for(int j=i-1;j&gt;=0;j--) &#123; if(a[j]==a[i]) break;//前面部分交给j if(a[j]&gt;a[i] and f[j]+1==f[i]) c[i]+=c[j];//转移 &#125; int ans=0;for(int i=1;i&lt;=n;i++) ans=mymax(ans,f[i]); int count=0;for(int i=1;i&lt;=n;i++) if(f[i]==ans) count+=c[i]; printf("%d %d",ans,count); &#125;&#125;;int main()&#123; mine::main();&#125; poj1722 SUBTRACT8.24 难度3请先思考后再展开 非常好的一道题，思考难度略大 （就是说我太菜不会做） 转化题目：把两个数做差后合并，就是打负号后再打括号那么相当于把整个数列，在空位写符号，问能否得到目标数T 题目特性：由于值域很小（-10000~10000），考虑一个可加可减的背包$f(i,ed)$ 表示考虑到第i位，能否得到d，-1表示不行，0表示在$i-1和i$ 之间用+，1表示-因为有spj，能找到解就好还原路径也非常简单 求解：合并的做法也很巧妙每次把连续的一段+，打上括号，也就变成了-然后随便地把第一位连续输出长度个即可这样把所有+处理完，只剩-，那么同样直接把第一个位置连续地输出就好了 对了，注意第一个符号不能是+，否则没法变成-1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=110; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int a[MAX_N]; #define f(i,j) F[i][10000+j] int F[MAX_N][21000]; int sign[MAX_N];//0=+,1=- void main() &#123; int n,ed;scanf("%d%d",&amp;n,&amp;ed); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); memset(F,-1,sizeof F); f(1,a[1])=2;//任意的可行 for(int i=1;i&lt;=n-1;i++)//刷表法更方便 for(int d=-10000;d&lt;=10000;d++) if(f(i,d)&gt;=0) &#123; if(i&gt;1) f(i+1,d+a[i+1])=0;//debug 第一个不能是+ f(i+1,d-a[i+1])=1; &#125; for(int i=n;i&gt;=2;i--) &#123; sign[i-1]=f(i,ed); if(sign[i-1]) ed+=a[i]; else ed-=a[i]; &#125; int nown=n-1,ln=0; for(int i=n-1;i&gt;=1;i--) &#123; if(!sign[i]) ln++;//+ else &#123; nown-=ln; while(ln--) printf("%d\n",i+1); ln=0; &#125; &#125; nown-=ln; while(ln&gt;0) printf("%d\n",ln),ln--; while(nown&gt;0) printf("1\n"),nown--; &#125;&#125;;int main()&#123; mine::main();&#125; noi2001 陨石的秘密8.24 难度2请先思考后再展开 非常巧妙地dp设计之前听嘎爷讲过类似的题目，就是通过一个小小的容斥表示状态这样具体转移的时候只要关心一个上或下限就好了以本题为例，设$f(d,a,b,c)$ 表示$深度 \leq d$ ，同时各个括号分别用a、b、c对时，其可行方案数这样答案就是$f(D,A,B,C)-f(D-1,A,B,C)$ 转移的时候，可以通过简单的乘法原理，分成两边后，考虑右边那个的外层是什么，然后累加起来这样子就能够保证右边那个一定是一个块，而不是多个块，避免了重复这一点之前也见过，把一个多子树的问题，每次只抽出一个子树，其他递归下去考虑，一样的道理$$f(d,a,b,c)= \\f(d,a,b,c-k-1) \times f(d-1,0,0,k) + \\f(d,a,b-j-1,c-k) \times f(d-1,0,j,k) + \\f(d,a-i-1,b-j,c-k) \times f(d-1,i,j,k)$$时间复杂度$O(A^6 \times D)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=110; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; const int MOD=11380; int f[40][20][20][20]; void dp(int d,int a,int b,int c)//美观 &#123; if(a==0 and b==0 and c==0) &#123;f[d][a][b][c]=1;return;&#125; int tmp=0; for(int k=0;k&lt;=c-1;k++)//() tmp=(tmp+f[d][a][b][c-k-1]*f[d-1][0][0][k])%MOD; for(int j=0;j&lt;=b-1;j++)//[] for(int k=0;k&lt;=c;k++)//() tmp=(tmp+f[d][a][b-j-1][c-k]*f[d-1][0][j][k])%MOD; for(int i=0;i&lt;=a-1;i++)//&#123;&#125; for(int j=0;j&lt;=b;j++)//[] for(int k=0;k&lt;=c;k++)//() tmp=(tmp+f[d][a-i-1][b-j][c-k]*f[d-1][i][j][k])%MOD; f[d][a][b][c]=tmp; &#125; void main() &#123; int A,B,C,D;scanf("%d%d%d%d",&amp;A,&amp;B,&amp;C,&amp;D); f[0][0][0][0]=1; for(int d=1;d&lt;=D;d++) for(int a=0;a&lt;=A;a++) for(int b=0;b&lt;=B;b++) for(int c=0;c&lt;=C;c++) dp(d,a,b,c); //debug 又被三目运算符坑了 int ans=f[D][A][B][C]-(D&gt;0?f[D-1][A][B][C]:0); printf("%d",(ans%MOD+MOD)%MOD); &#125;&#125;;int main()&#123; mine::main();&#125; noi1999 棋盘分割8.25 难度2请先思考后再展开 一开始看错题目了，好像是因为以前见过那样的题目：每次切都是产生切剩下的部分的代销（像合并果子？）那样的话，平均值不固定会非常难处理，于是就跑去膜题解了才发现自己沙茶了（这也可能是没有样例解释的锅）其实是指切n-1刀，最后是n个块，那么其实拼起来就是原本的块，所以平均值是固定的 稍微化简一下柿子（挺意外还有化简这回事……以后题目中见到柿子都要试一试）$ans^2$$=\frac{1}{n}( \sum (xi-\overline x)^2 )$$=\frac{1}{n}( \sum (xi^2-2 x_i \overline x+\overline x^2) )$$=\frac{1}{n}( \sum xi^2 - 2sum\overline x + \sum \overline x^2)$$=\sum xi^2/n - \overline x^2$ 代码实现就非常简单了，先二维前缀和预处理，设$f(n,a,b,c,d)$ 表示当前还有多少次，以及当前区间记忆化搜索，转移的时候枚举端点比较即可 poj1390 Blocks8.26 难度2请先思考后再展开 显然先缩点 一开始想了一个贪心的做法，每次选择一个地方消除，分治，并顺便暴力地合并左右两边来更新答案然后发现连样例都过不去，以后应该先对着样例模拟一次的……所以现在的主要问题还是新块合并的处理 一个非常难想的延后处理法：设$f(l,r,k)$ 表示处理l到r的区间，同时存在一个本来不连续的长度为k的块和r相连且颜色相同 直接合并，$f(l,r,k)=f(l,r-1,0)+(k+len_r)^2$ 把k交给前面的某个t（$col_t=col_r$）处理，$f(l,r,k)=f(l,t,k+len_r)+f(t+1,r-1,0)$ 很巧妙地通过增加维，解决了新区间合并的问题其中也含有部分贪心的思想（例如直接把r也交给t处理） 时间复杂度方面不好估计，可能比赛的话，会感觉自己打了一个部分分？然后出来就ac了主要是因为颜色方面的限制，不会跑满（颜色块的不相同和转移时颜色的相同互斥）极限数据如121212121，可以自己造来跑一跑12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=210; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; int mysqr(int x) &#123;return x*x;&#125; int a[MAX_N]; int col[MAX_N],len[MAX_N]; int f[MAX_N][MAX_N][MAX_N];bool v[MAX_N][MAX_N][MAX_N]; int dp(int l,int r,int k) &#123; if(l&gt;r) return 0; if(l==r) return mysqr(len[r]+k); if(v[l][r][k]) return f[l][r][k]; v[l][r][k]=1; int ans=0; ans=mymax(ans,dp(l,r-1,0)+mysqr(k+len[r])); for(int t=l;t&lt;=r-1;t++) if(col[t]==col[r]) ans=mymax(ans,dp(l,t,k+len[r])+dp(t+1,r-1,0)); return f[l][r][k]=ans; &#125; void main() &#123; int T;scanf("%d",&amp;T); int ct=0; while(T--) &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); int cnt=1;col[1]=a[1];len[1]=1; for(int i=2;i&lt;=n;i++) if(a[i-1]!=a[i]) col[++cnt]=a[i],len[cnt]=1; else len[cnt]++; memset(v,0,sizeof v); printf("Case %d: %d\n",++ct,dp(1,cnt,0)); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; hdu2196 Computer8.26 难度2请先思考后再展开 二次剩余，时间复杂度n为了求出，一个数列中除了某个数以外，其他数的最大值，维护一下次大值即可大概算是小技巧 总之第一次求出子树内距离，第二次从父亲处继承信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=11000; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; int mysqr(int x) &#123;return x*x;&#125; struct Nod &#123; int hou; int mx; &#125;p[MAX_N]; struct Edge &#123; int y,c,g; &#125;e[MAX_N*2]; int ln; void ins(int x,int y,int c) &#123; e[++ln]=(Edge)&#123;y,c,p[x].hou&#125;; p[x].hou=ln; &#125; void dfs1(int x,int fa) &#123; p[x].mx=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dfs1(y,x); p[x].mx=mymax(p[x].mx,p[y].mx+e[k].c); &#125; &#125; void dfs2(int x,int fa,int mx) &#123; int mx1=0,mx2=0;//最大和次大值 for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; if(p[y].mx+e[k].c&gt;mx1) mx2=mx1,mx1=p[y].mx+e[k].c; else if(p[y].mx+e[k].c&gt;mx2) mx2=p[y].mx+e[k].c; //忘记判断，与mx2的关系 &#125; p[x].mx=mymax(p[x].mx,mx); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; int t=mx1;if(p[y].mx+e[k].c==t) t=mx2; dfs2(y,x,mymax(t,mx)+e[k].c); &#125; &#125; void main() &#123; int n; while(scanf("%d",&amp;n)!=EOF) &#123; ln=0;for(int i=1;i&lt;=n;i++) p[i].hou=0; for(int i=2;i&lt;=n;i++) &#123; int fa,c;scanf("%d%d",&amp;fa,&amp;c); ins(fa,i,c);ins(i,fa,c); &#125; dfs1(1,0); dfs2(1,0,0); for(int i=1;i&lt;=n;i++) printf("%d\n",p[i].mx); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 直径结论，时间复杂度nlogn这东西的证明等，自行搜索本博客“直径”123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=11000; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; int mysqr(int x) &#123;return x*x;&#125; struct Nod &#123; int hou; int dis,dep; &#125;p[MAX_N]; struct Edge &#123; int y,c,g; &#125;e[MAX_N*2]; int ln; void ins(int x,int y,int c) &#123; e[++ln]=(Edge)&#123;y,c,p[x].hou&#125;; p[x].hou=ln; &#125; void dfs(int x,int fa) &#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; p[y].dis=p[x].dis+e[k].c; dfs(y,x); &#125; &#125; int bin[20]; int f[MAX_N][20]; void pre(int x,int fa) &#123; f[x][0]=fa;for(int i=1;i&lt;20;i++) f[x][i]=f[f[x][i-1]][i-1]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; p[y].dis=p[x].dis+e[k].c; p[y].dep=p[x].dep+1; pre(y,x); &#125; &#125; int LCA(int x,int y) &#123; if(p[x].dep&lt;p[y].dep) swap(x,y); for(int i=19;i&gt;=0;i--) if(p[x].dep-p[y].dep&gt;=bin[i]) x=f[x][i]; if(x==y) return x; for(int i=19;i&gt;=0;i--) if(p[x].dep&gt;=bin[i] and f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0]; &#125; int getdis(int x,int y) &#123; return p[x].dis+p[y].dis-2*p[LCA(x,y)].dis; &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;20;i++) bin[i]=bin[i-1]&lt;&lt;1; int n; while(scanf("%d",&amp;n)!=EOF) &#123; memset(f,0,sizeof f); ln=0;for(int i=1;i&lt;=n;i++) p[i].hou=0; for(int i=2;i&lt;=n;i++) &#123; int fa,c;scanf("%d%d",&amp;fa,&amp;c); ins(fa,i,c);ins(i,fa,c); &#125; int a=1;p[1].dis=0;dfs(1,0); for(int i=1;i&lt;=n;i++) if(p[i].dis&gt;p[a].dis) a=i; int b=a;p[a].dis=0;dfs(a,0); for(int i=1;i&lt;=n;i++) if(p[i].dis&gt;p[b].dis) b=i; p[1].dis=0;p[1].dep=1;pre(1,0); for(int i=1;i&lt;=n;i++) printf("%d\n", mymax(getdis(i,a),getdis(i,b)) ); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; HNOI2011 XOR和路径8.26 难度2请先思考后再展开 xor是对整数的运算，所以无法求出期望递推式如果把每个位置拆分（还是那个套路，二进制运算，不同数位间互不影响）那么只要考虑每个数位位置是1的概率，就能求出期望（权值确定，为1） 依旧是倒推，设$f(x)$ 表示当前x到n，异或和这一位是1的概率当$w_i=0$，$f(x)+=f(y)/tot$当$w_i=1$，$f(x)+=(1-f(y))/tot=1/tot-f(y)/tot$然后高斯消元即可 这道题卡精度，eps简易设置为1e-8123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=110; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; int mysqr(int x) &#123;return x*x;&#125; const double eps=1e-8; bool iszero(double x) &#123;return x&gt;=-eps and x&lt;=eps;&#125; int tot[MAX_N]; int hou[MAX_N]; struct Edge &#123; int y,c,g; &#125;e[21000]; int ln=0; void ins(int x,int y,int c) &#123; e[++ln]=(Edge)&#123;y,c,hou[x]&#125;; hou[x]=ln; tot[x]++; &#125; int bin[40]; double a[MAX_N][MAX_N],b[MAX_N]; void gauss(int n,int m) &#123; for(int i=1;i&lt;=m;i++) &#123; int nx=0;for(int j=i;j&lt;=n;j++) if(!iszero(a[j][i])) &#123;nx=j;break;&#125; swap(b[nx],b[i]);for(int k=1;k&lt;=m;k++) swap(a[nx][k],a[i][k]); for(int j=1;j&lt;=n;j++) &#123; if(i==j or iszero(a[j][i])) continue; double t=a[j][i]/a[i][i]; b[j]-=b[i]*t;for(int k=1;k&lt;=m;k++) a[j][k]-=a[i][k]*t; &#125; &#125; &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; int n,m;scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);if(x!=y) ins(y,x,c);//debug 自环不能建双向边 &#125; double ans=0; for(int now=0;now&lt;=30;now++) &#123; memset(a,0,sizeof a); memset(b,0,sizeof b); //f(n)=0 for(int x=1;x&lt;=n-1;x++) &#123; a[x][x]=tot[x]; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(e[k].c&amp;bin[now]) &#123; b[x]+=1; if(y!=n) a[x][y]+=1; &#125; else if(y!=n) a[x][y]-=1; &#125; &#125; gauss(n-1,n-1); ans+=b[1]/a[1][1]*bin[now]; &#125; printf("%.3Lf",ans); &#125;&#125;;int main()&#123; mine::main();&#125; SCOI2010 股票交易8.29 难度2请先思考后再展开 设 $f(i,k)$ 表示在第i天，拥有k个股票的最大现金答案即 $max f(T,1…maxp)$可能从 $f(j \leq i-w-1,k2 \leq maxp)$ 转移注意到第二维、决策都和第一维没有关系可以考虑一个经典的做法：把最优值后置，减少转移时间也就是说，直接取值 $f(i-w-1,k2 \leq maxp)$ 或者 $f(i-1,k)$时间复杂度为$O(n^3)$ 在这种连log都不能要，必须省掉一个n的时候，不妨考虑一下单调性①买入$f(i,k)=max { f(i-w-1,k2 \geq k-As_i)+k2 \times Ap_i }-k \times Ap_i$②卖出$f(i,k)=max { f(i-w-1,k2 \geq k+Bs_i)+k2 \times Bp_i }-k \times Bp_i$ 编号越大，贡献范围越大，维护一个编号递增，贡献递减的单调队列即可无脑开2n个单调队列，继承于i-w-1，维护i，时空都是完全没毛病的代码略 USACO2006 Nov Silver Round Numbers8.29 难度1请先思考后再展开 按照套路来就好了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=40; const int INF=0x3f3f3f3f; int num[MAX_N]; int f[MAX_N][MAX_N][MAX_N]; bool v[MAX_N][MAX_N][MAX_N]; int calc(int ln,int now0,int now1,bool iszero,bool top) &#123; if(ln==0) return now0&gt;=now1; if(!iszero and !top and v[ln][now0][now1]) return f[ln][now0][now1]; int mx=top?num[ln]:1; int cnt=0; for(int now=0;now&lt;=mx;now++) cnt+=calc(ln-1,now0+( iszero?0:(now==0) ),now1+(now==1),iszero and (now==0),top and (now==mx)); if(!iszero and !top) v[ln][now0][now1]=1,f[ln][now0][now1]=cnt; return cnt; &#125; int solve(int t) &#123; int ln=0;while(t&gt;0) num[++ln]=t%2,t/=2; return calc(ln,0,0,1,1); &#125; void main() &#123; int l,r;scanf("%d%d",&amp;l,&amp;r); printf("%d",solve(r)-solve(l-1)); &#125;&#125;;int main()&#123; mine::main();&#125; ###8.28 难度2请先思考后再展开 12]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF1025C】Plasticine zebra]]></title>
    <url>%2Fposts%2Ff525.html</url>
    <content type="text"><![CDATA[Source and JudgeCF1025C Record1h Analysis请先思考后再展开 要不是因为比赛的时候被第二题卡，还是能做出来的……说多都是泪 然后我的做法和机房其他人都不一样就是从操作的实际意义入手，发现等于没有翻转例如形如 ab|cd 这样的字符串，得到所谓的ba|dc但其实本质上，就是把后面那个放到前面，cd|ab，然后再整体倒过来然后不难发现，整体倒过来没有任何意义所以每次操作其实就是把后面的一段放到前面去，相当于跑一个环状的东西 所以说，只需要枚举一个起点，然后向后延伸就好了比赛还剩五分钟的时候，感觉需要平方级别回去的路上立刻就想到，其实维护一个双指针就好了 总而言之这道题真的很好想从操作入手，思考本质就是了 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; char s[210000]; bool check(int i,int j) &#123; return ((j-i)%2==0 and s[i]==s[j]) or ((j-i)%2==1 and s[i]!=s[j]); &#125; void main() &#123; scanf("%s",s+1); int n=strlen(s+1); for(int i=n+1;i&lt;=n+n;i++) s[i]=s[i-n]; int ans=1,r=1; for(int l=1;l&lt;=n;l++) &#123; if(r&lt;l) r=l; while(r&lt;=l+n-1 and check(l,r)) r++; r--; //printf("%d %d\n",l,r); ans=mymax(ans,r-l+1); &#125; printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-8最小表示法]]></title>
    <url>%2Fposts%2F8435.html</url>
    <content type="text"><![CDATA[在循环同构的n个字符串中，找出字典序最小的一个，就是最小表示法。 具体做法我们没有必要直接排序（n^2暴力或者nlogn哈希），因为我们的目的只是找到最小那一个所以换个思路，试图找到绝对不可能的部分 举例定义B[i]表示从i开始的字符串（可以通过在后面复制一段来代替）对于任意i和j，一个个比较下去，直到出现i+k和j+k不同为止假设i+k更大，则我们可以排除B[i]的可能性，因为存在更小的B[j] 重点来了！由于这个神奇的位置k，以及我们目的的特殊性可以直接确定对于所有B[i~i+k]，都不是最小表示因为存在一个B[j~j+k]，每当碰到那个i+k，都会有相同结果 所以我们可以直接跳过 具体实现双指针i和j，确保i&lt;j，直接比较，出现不同直接跳过如果i=j，则j++；如果完全没有差别，任何B[i]都是最小表示；如果任何一个到达n之后，意味着另一个是最小表示 复杂度分析比较消耗时间k，但同时也跳过了k那么总时间不变，两个字符串最多2n，所以复杂度是O(n)]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>最小表示法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SCOI2007】降雨量]]></title>
    <url>%2Fposts%2F20bf.html</url>
    <content type="text"><![CDATA[Source and JudgeSCOI2007luogu2471bzoj1067poj2637 Record1h Analysis请先思考后再展开 裸题就是情况有点多 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; const int MAXN=51000,MAXM=11000; const int INF=0x3f3f3f3f; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int bin[20]; int lg[MAXN+MAXM+MAXM]; struct LSH &#123; int d,p; &#125;ls[MAXN+MAXM+MAXM]; bool cmp(LSH a,LSH b) &#123;return a.d&lt;b.d;&#125; int rx; int n,m; int val[MAXN+MAXM+MAXM];//离散化结果 int yz[MAXN+MAXM+MAXM];//原值 void lsh() &#123; for(int i=1;i&lt;=n+m+m;i++) ls[i].p=i; sort(ls+1,ls+n+m+m+1,cmp);rx=0; for(int i=1;i&lt;=n+m+m;i++) &#123; if(i==1 or ls[i-1].d!=ls[i].d) yz[++rx]=ls[i].d; val[ls[i].p]=rx; &#125; &#125; int rain[MAXN]; int know[MAXN+MAXM+MAXM]; int mx[20][MAXN+MAXM+MAXM]; void pre() &#123; memset(know,0,sizeof know); for(int i=1;i&lt;=rx;i++) mx[0][i]=-INF; for(int i=1;i&lt;=n;i++) know[val[i]]=1,mx[0][val[i]]=rain[i]; for(int i=1;i&lt;=rx;i++) know[i]+=know[i-1]; for(int k=1;k&lt;20;k++) for(int i=1;i&lt;=rx-bin[k]+1;i++) mx[k][i]=mymax(mx[k-1][i],mx[k-1][i+bin[k-1]]); &#125; int get(int l,int r) &#123; if(l&gt;r) return -INF-1; int k=lg[r-l+1]; return mymax(mx[k][l],mx[k][r-bin[k]+1]); &#125; int solve(int y,int x) &#123; if(y&gt;x) return 2; if(y==x) return 1; int fy=get(y,y),fx=get(x,x); int have=know[x]-know[y-1],ln=yz[x]-yz[y]+1; if(fy==-INF and fx==-INF) return 0; else if(fy==-INF) &#123; if(ln==2 or get(y+1,x-1)&lt;fx) return 0; else return 2; &#125; else if(fx==-INF) &#123; if(ln==2 or get(y+1,x-1)&lt;fy) return 0; else return 2; &#125; else &#123; if(fy&gt;=fx and get(y+1,x-1)&lt;fx) &#123; if(have==ln) return 1; else return 0; &#125; else return 2; &#125; return -1; &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;20;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;MAXN+MAXM+MAXM;i++) lg[i]=lg[i&gt;&gt;1]+1; while(1) &#123; scanf("%d",&amp;n);if(n==0) break; for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;ls[i].d,&amp;rain[i]); scanf("%d",&amp;m);for(int i=1;i&lt;=m;i++) scanf("%d%d",&amp;ls[n+i].d,&amp;ls[n+m+i].d); lsh(); pre(); for(int i=1;i&lt;=m;i++) &#123; int ans=solve(val[n+i],val[n+m+i]); if(ans==0) puts("maybe"); else if(ans==1) puts("true"); else if(ans==2) puts("false"); else puts("ERROR"); &#125; puts(""); &#125; &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度1</tag>
        <tag>st表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟赛1总结]]></title>
    <url>%2Fposts%2F4f83.html</url>
    <content type="text"><![CDATA[题目 T1-Analysis请先思考后再展开 这是一道当时感觉很神，后来感觉很签到的好题关键在于，判断是否是n的倍数把加0看做乘以10，加1看做乘以10再加1这里运用到了一个技巧————用余数表示再通过记忆化，能够把原本【2的次幂】的复杂度，降低到n具体的实现可以用bfs路径的记录，可以以余数为索引，记录从哪个余数继承过来当然无脑string也行，毕竟就是一个等差数列的复杂度 T1-Code-Std请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAXN=1100000; int MOD; int from[MAXN]; int ans[MAXN],tot; void add(int x) &#123; int nx=from[x]; ans[++tot]=!( (nx*10%MOD)==x ); &#125; queue&lt;int&gt; q; void bfs() &#123; q.push(1); while(!q.empty()) &#123; int x=q.front();q.pop(); for(int i=0;i&lt;=1;i++) &#123; int nx=(x*10+i)%MOD; if(from[nx]&lt;0) &#123; from[nx]=x; q.push(nx); &#125; &#125; &#125; if(from[0]&lt;0) puts("-1"); else &#123; tot=0;add(0); int now=from[0]; while(now&gt;1) add(now),now=from[now]; ans[++tot]=1;//debug 漏了 &#125; &#125; void main() &#123; freopen("a.in","r",stdin); freopen("a.out","w",stdout); memset(from,-1,sizeof from); scanf("%d",&amp;MOD); bfs(); for(int i=tot;i&gt;=1;i--) putchar('0'+ans[i]); &#125;&#125;;int main()&#123; mine::main();&#125; T2-Analysis请先思考后再展开 考虑用dp来预处理神仙转化问题：【把原本的串取反，允许修改k的配额，能得到多少个目标串】设$f(S,i,k)$为，当前状态为S，处理到第i位，剩下可分配额为k，后面能够得到多少个目标串计数类dp，显然是倒推的$f(S,i,k)=f(S,i+1,k)+【k&gt;=w_i】f(S^bin[i],i+1,k-w_i)$ T2-Code-Std请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; const int MAXN=16,MAXM=510000; int n; int w[MAXN]; int ct[1&lt;&lt;MAXN]; int f[1&lt;&lt;MAXN][MAXN][40]; int bin[MAXN]; char s[MAXN]; int read() &#123; scanf("%s",s); int now=0; for(int j=0;j&lt;=n-1;j++) if(s[n-j-1]=='1') now+=bin[j]; return now; &#125; void main() &#123; freopen("b.in","r",stdin); freopen("b.out","w",stdout); bin[0]=1;for(int i=1;i&lt;MAXN;i++) bin[i]=bin[i-1]&lt;&lt;1; int m,q;scanf("%d%d%d",&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]); for(int i=1;i&lt;=m;i++) ct[bin[n]-1-read()]++;//取反 for(int i=n+1;i&gt;=1;i--) for(int s=0;s&lt;=bin[n]-1;s++) for(int k=0;k&lt;=30;k++) &#123; if(i==n+1) f[s][i][k]=ct[s]; else &#123; f[s][i][k]=f[s][i+1][k]; if(k&gt;=w[i]) f[s][i][k]+=f[s^bin[n-i]][i+1][k-w[i]]; &#125; &#125; while(q--) &#123; int now=read(),k;scanf("%d",&amp;k); printf("%d\n",f[now][1][k]); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; T3-Analysis请先思考后再展开 原题：cf_R495_div_d然后我的代码其实如果加上快读就卡过去了，大概0.5s的速度……毕竟我的快速check函数，还是下了一番功夫的，从【面积】下降到【最大编号】 先说说我的想法：1.设计一个check函数表示在n乘m的矩阵中，数字i出现了几次（假设(1,1)=1）然后这个东西很多人是暴力【面积】做的其实可以通过找规律，分类讨论一下，降到【最大编号】 2.确认一个最大的完美正方形，每次调用check函数计算数字的需求量，然后判合法性 3.经过上一步，已经保证这个正方形会贴边了，这样我们就能直接把它在那条边上移动（注意交换n和m）最后还是分4个块，然后调用check判合法性 讲讲正解和我不同的部分：1.通过一层层向外枚举，得到第一个不能完美菱形的数字，这个数字就是0的x坐标可以这样考虑：x在外面，则高度为x-1~0，也就是x个然后做法的话，其实可以直接每层数字，数量+4，而我硬生生调用一个函数来计算……当然因为这个在外面，所以速度可以很随便，只是不那么优美 2.在枚举出矩阵的形状后，可以直接把最大那个数字mx放在(n,m)的位置，因为即使它在其他的角落，矩阵也能翻转过来这样的好处在于，最大曼哈顿距离确定为$mx=n-x+m-y$移项后得到$y=n+m-x-mx$，也就是说能够直接得出y这样就省去了枚举y的时间了 现在复杂度就是$O(\sqrt n \times check复杂度)$而check复杂度就是$\sum_{i=1 to \sqrt n} i+n/i$根据等差数列和调和级数$n/2+nlog_2 \sqrt n$ 当然你要是暴力，问题不大，因为实际上外面的循环不会到满的根号，毕竟约数个数不会太大根据我打的表，一千万内最多的也只有448个 T3-Code-Old请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; const int MAXN=1000001; int c[MAXN]; int need[MAXN]; inline int check(int n,int m,int i) &#123; if(n&gt;m) swap(n,m); if(i&lt;=n) return i; if(i&lt;=m) return n; if(i&lt;=m+n-1) return (n+m-1)-i+1; return 0; &#125; int k=2; bool okay() &#123; for(int i=1;i&lt;=k+k;i++) if(check(k/2+1,k/2,i)*4&gt;c[i]) return 0; return 1; &#125; int ansx,ansy; bool trying(int n,int m) &#123; int need; int midx=k/2+1; for(int tx=1;tx&lt;=m-k+1;tx++) &#123; int midy=tx+k/2+1-1; //printf("%d %d %d %d\n",n,m,midx,midy); int mxx=mymax(n-midx,midx-1)+mymax(m-midy,midy-1)+5; bool bk=0; for(int i=1;i&lt;=mxx;i++) &#123; need=check(midx,midy,i+1)+check(n-midx,midy,i)+check(midx,m-midy,i)+check(n-midx,m-midy,i-1); if(need!=c[i]) &#123;bk=1;break;&#125; if(need==0) break; &#125; if(bk==0) &#123; ansx=midx,ansy=midy; return 1; &#125; &#125; return 0; &#125; int read() &#123; int x=0; char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while('0'&lt;=c and c&lt;='9') x=x*10+c-'0',c=getchar(); return x; &#125; void main() &#123; freopen("c.in","r",stdin); freopen("c.out","w",stdout); int mx;scanf("%d",&amp;mx); for(int i=1;i&lt;=mx;i++) &#123; int x;scanf("%d",&amp;x); c[x]++; &#125; while(k*k&lt;=mx) &#123; if(!okay()) break; k++; &#125; k--; for(int n=1;n*n&lt;=mx;n++) &#123; if(mx%n!=0) continue; int m=mx/n; if(trying(n,m)) &#123;printf("%d %d\n%d %d",n,m,ansx,ansy);return;&#125; if(trying(m,n)) &#123;printf("%d %d\n%d %d",m,n,ansx,ansy);return;&#125; &#125; puts("-1"); &#125;&#125;;int main()&#123; mine::main();&#125; T3-Code-Std请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; const int MAXN=1000001; int c[MAXN]; int check(int n,int m,int i) &#123; if(n&gt;m) swap(n,m); if(i&lt;=n) return i; if(i&lt;=m) return n; if(i&lt;=m+n-1) return (n+m-1)-i+1; return 0; &#125; int mxnum=0; int ansx,ansy; bool trying(int n,int m) &#123; ansy=n+m-mxnum-ansx; int mxx=mymax(n-ansx,ansx-1)+mymax(m-ansy,ansy-1)+5; bool bk=1; for(int i=1;i&lt;=mxx;i++) &#123; int need; need=check(ansx,ansy,i+1)+check(n-ansx,ansy,i)+ check(ansx,m-ansy,i)+check(n-ansx,m-ansy,i-1); if(need!=c[i]) &#123;bk=0;break;&#125; if(need==0) break; &#125; if(bk) printf("%d %d\n%d %d",n,m,ansx,ansy); return bk; &#125; int read() &#123; int x=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while('0'&lt;=c and c&lt;='9') x=x*10+c-'0',c=getchar(); return x; &#125; void main() &#123; int mx;scanf("%d",&amp;mx); for(int i=1;i&lt;=mx;i++) &#123; int t=read(); mxnum=mymax(mxnum,t); c[t]++; &#125; if(c[0]!=1) &#123;puts("-1");return;&#125;//debug 0很烦人 ansx=1; int need=4; while(c[ansx]&gt;=need) need+=4,ansx++; for(int n=1;n*n&lt;=mx;n++) &#123; if(mx%n!=0) continue; int m=mx/n; if(trying(n,m) or trying(m,n)) return; &#125; puts("-1"); &#125;&#125;;int main()&#123; mine::main();&#125; T4-Analysis请先思考后再展开 又是一道很好的脑力题$a_i &amp; a_j =0$其实就是没有同时对应存在的1 依然是巧妙地转化题目：用个数组记录合法性【取反后a】存在合法解a并且因为【有合法解性】是可以传递的所以倒着递推（像背包？），枚举每个数字，每个【有合法解性】的数字，把某个1去掉后，都能从a得到合法解 T4-Code-Std请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; const int MAXN=1100000; int bin[30]; int a[MAXN]; bool b[MAXN]; void main() &#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; int n;scanf("%d",&amp;n); int mx=bin[20]-1; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]),b[a[i]^mx]=1; for(int s=mx;s&gt;=1;s--) &#123; if(!b[s]) continue; for(int i=0;i&lt;=19;i++) if(s&amp;bin[i]) b[s^bin[i]]=1; &#125; for(int i=1;i&lt;=n;i++) printf("%d ",b[a[i]]); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【国家集训队】礼物]]></title>
    <url>%2Fposts%2F1774.html</url>
    <content type="text"><![CDATA[Source and Judge国家集训队CF_R503_div1_A Record5h Analysis请先思考后再展开 拓展lucas裸题直接算$\prod C_n^{wi} \% p$，但每次要减少n时间复杂度$O(\sqrt N + plog_p n)$ 调试了一天……好多细节 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; ll qpower(ll a,ll e,ll MOD) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=ans*a%MOD; a=a*a%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y) &#123; if(b==0) &#123;x=1,y=0;return a;&#125; ll tx,ty;ll d=exgcd(b,a%b,tx,ty); x=ty;y=tx-(a/b)*ty; return d; &#125; ll inv(ll a,ll MOD) &#123; ll x,y;exgcd(a,MOD,x,y); x=(x%MOD+MOD)%MOD; return x; &#125; ll fac(int n,ll p,ll MOD) &#123; if(n&lt;=0) return 1; ll ans=1; ll t=n/MOD; for(int i=1;i&lt;=MOD-1;i++) if((i%p)!=0) ans=ans*i%MOD; //debug 这里不要调用一次fac，会导致重复计算剩下的 ans=qpower(ans,t,MOD); for(int i=t*MOD+1;i&lt;=n;i++) if((i%p)!=0) ans=ans*i%MOD; return ans*fac(n/p,p,MOD)%MOD;//debug 忘记去除p后，还会有东西剩下来 &#125; ll smallC(ll m,ll n,ll p,ll MOD) &#123; ll num=0; for(ll pk=p;pk&lt;=n;pk*=p) num+=n/pk; for(ll pk=p;pk&lt;=m;pk*=p) num-=m/pk; for(ll pk=p;pk&lt;=(n-m);pk*=p) num-=(n-m)/pk; ll ans=qpower(p,num,MOD);//不互质的烦恼 ans=ans*fac(n,p,MOD)%MOD; ans=ans*inv(fac(m,p,MOD),MOD)%MOD; ans=ans*inv(fac(n-m,p,MOD),MOD)%MOD; return ans; &#125; ll C(ll m,ll n,ll MOD)//exLucas &#123; ll ans=0;ll tmp=MOD; for(int p=2;p*p&lt;=tmp;p++) &#123; int pk=1; while(tmp%p==0) tmp/=p,pk*=p; if(pk&gt;1) (ans+=smallC(m,n,p,pk) *(MOD/pk)%MOD *inv(MOD/pk,pk) %MOD)%=MOD;//CRT &#125; if(tmp&gt;1) (ans+=smallC(m,n,tmp,tmp) *(MOD/tmp)%MOD *inv(MOD/tmp,tmp) %MOD)%=MOD; return ans; &#125; int w[10]; void main() &#123; int MOD;scanf("%d",&amp;MOD); int n,m;scanf("%d%d",&amp;n,&amp;m); ll tot=0; for(int i=1;i&lt;=m;i++) scanf("%d",&amp;w[i]),tot+=w[i]; if(tot&gt;n) puts("Impossible"); else &#123; ll ans=1; for(int i=1;i&lt;=m;i++) ans=ans*C(w[i],n,MOD)%MOD,n-=w[i]; printf("%lld",ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>逆元</tag>
        <tag>Lucas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF1019A】Elections]]></title>
    <url>%2Fposts%2F1dd8.html</url>
    <content type="text"><![CDATA[Source and JudgeCF1019A Record2h Analysis请先思考后再展开 比赛的时候乱想了一个贪心，没有足够的码力实现，而且应该是错误的 曾经想到枚举出最后的数量ed，然后不知道怎么利用其实这样以后，一下就能判断出，比ed高或相同的部分都要去掉，而且一定是选小的。而且，这样以后如果还没达到ed，选择什么地方都和决策没有关系了，直接选最小的即可时间复杂度O(n^2) 其实现在回想起来，又是【把最重要的一点想到后懵逼】系列 还有就是akc说满足三分性，不过反正题目没卡这个，就不管了反正时间优秀的一匹 Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; struct Nod &#123; int c; int a,b; &#125;p[3100]; int all; bool cmp(Nod a,Nod b) &#123;return a.c&lt;b.c;&#125; int n,m; ll s[3100][3100];int sz[3100]; ll f(int ed) &#123; ll ans=0; int now=sz[1]; for(int i=2;i&lt;=m;i++) if(sz[i]&gt;=ed) &#123; int t=sz[i]-ed+(ed!=0);//debug 当ed=0，数组越界 ans+=s[i][t],now+=t; &#125; for(int i=1;i&lt;=all;i++) &#123; if(now&gt;=ed) break;//debug 前面可能已经达到ed,不能用== if(p[i].b&lt;=sz[p[i].a]-ed+1) continue; ans+=p[i].c;now++; &#125; return ans; &#125; void main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; int p,c;scanf("%d%d",&amp;p,&amp;c); s[p][++sz[p]]=c; &#125; all=0; for(int i=2;i&lt;=m;i++) &#123; sort(s[i]+1,s[i]+sz[i]+1); for(int j=1;j&lt;=sz[i];j++) &#123; p[++all].c=s[i][j],p[all].a=i,p[all].b=j; s[i][j]+=s[i][j-1]; &#125; &#125; sort(p+1,p+all+1,cmp); ll mi=(1ll&lt;&lt;60); for(int ed=sz[1];ed&lt;=n;ed++) &#123; ll t=f(ed); if(t&lt;mi) mi=t; &#125; printf("%I64d",mi); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC9】小h的树]]></title>
    <url>%2Fposts%2Ff894.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC9 Record1h Analysis请先思考后再展开 这也是一道好题把dp和树结构的性质等结合在了一起 找点性质：因为要遍历每一个点，而且还是个树结构不难发现每条边最多遍历2次 先考虑特殊情况，k=n那么每条边都要遍历，而且“有点难发现”最后只被遍历一次的会是一条链答案就是$2 \times 边总长-链长度$所以为了答案最小，取直径…… 然后推广一下，有些边可以不经过了发现其实就是选取一个子树结构，让【上面说的值】最小然后我们维护的东西是满足可加性的，只要保证一条链 接下来对于我来说有些难度，但可能对大佬来说是一个套路就是搞一个树形dp，考虑直径的出现情况因为满足可加性，设 $f(x,k,0/1/2)$ 表示在x的子树中选k个（根节点必选）最后的下标，表示直径端点出现情况然后在dp的过程中，枚举y，根据直径端点出现情况考虑x到y这条边的贡献情况 感觉这个dp状态的设计还是灰常关键的 最后要证明这个复杂度方法灰常奇特啊就是把枚举siz看做是枚举其子树内每个节点那么对于每个点对，只会在其lca处被枚举到 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; const int INF=0x3f3f3f3f; const int MAXN=3100; int hou[MAXN]; int siz[MAXN]; struct Edge &#123; int y,c,g; &#125;e[MAXN*2]; int ln=0; void ins(int x,int y,int c) &#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=hou[x];hou[x]=ln; &#125; int K; int f[MAXN][MAXN][3]; //f[x&gt;0][k][0/1/2]分别表示在x的子树选k个点（根节点必选） //并且直径在其内部端点数为0、1、2时，选出的最小数结构花费 void dp(int x,int fa) &#123; siz[x]=1; f[x][1][0]=0;f[x][1][1]=0;f[x][1][2]=0; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dp(y,x); for(int k1=mymin(K,siz[x]);k1&gt;=1;k1--) &#123; for(int k2=mymin(siz[y],K-k1);k2&gt;=1;k2--) &#123; f[x][k1+k2][0]=mymin(f[x][k1+k2][0],f[x][k1][0]+f[y][k2][0]+e[k].c*2); f[x][k1+k2][1]=mymin(f[x][k1+k2][1],f[x][k1][1]+f[y][k2][0]+e[k].c*2); f[x][k1+k2][1]=mymin(f[x][k1+k2][1],f[x][k1][0]+f[y][k2][1]+e[k].c);//向上 f[x][k1+k2][2]=mymin(f[x][k1+k2][2],f[x][k1][0]+f[y][k2][2]+e[k].c*2); f[x][k1+k2][2]=mymin(f[x][k1+k2][2],f[x][k1][1]+f[y][k2][1]+e[k].c);//向左 f[x][k1+k2][2]=mymin(f[x][k1+k2][2],f[x][k1][2]+f[y][k2][0]+e[k].c*2); &#125; &#125; siz[x]+=siz[y]; &#125; &#125; void main() &#123; memset(f,63,sizeof f); int n;scanf("%d%d",&amp;n,&amp;K); for(int i=1;i&lt;=n-1;i++) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);ins(y,x,c); &#125; dp(1,0); int ans=INF; for(int i=1;i&lt;=n;i++) if(siz[i]&gt;=K) ans=mymin(ans,f[i][K][2]); printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF1025D】Recovering BST]]></title>
    <url>%2Fposts%2F7565.html</url>
    <content type="text"><![CDATA[Source and JudgeCF1025D Record1h Analysis请先思考后再展开 这道题出得灰常好再次%一发rose大爷首先，所谓BST就是吓唬人的联想一下splay，其中序遍历不变这道题同样如此甚至都帮你排好序了然后就不知道怎么解决了…… 其实可以继续在中序遍历中做文章因为这是一个一维的序列然后在一颗子树中，其实是连续的一段（完全忘记的我……） 考虑一下区间dp然后有个小性质：我的父亲一定在当前区间的旁边，毕竟当初就是这样分开的而且，这棵树的根节点是可以随便取的 具体实现的话，枚举出当前子树的根节点x，与rt判断是否合法，然后向下用记忆化会灰常方便设f(l,r,op)表示可行性，然后op表示rt在那一侧就好了 Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; int gcd(int a,int b) &#123;return b==0?a:gcd(b,a%b);&#125; int a[710]; bool f[710][710][2]; bool v[710][710][2]; bool dp(int l,int r,int op) &#123; if(l&gt;r) return 1; if(v[l][r][op]) return f[l][r][op]; v[l][r][op]=1; int rt=op?r+1:l-1; for(int x=l;x&lt;=r;x++) if(gcd(a[x],a[rt])!=1 and dp(l,x-1,1) and dp(x+1,r,0)) return f[l][r][op]=1; return f[l][r][op]=0; &#125; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); if(dp(2,n,0)) puts("Yes"); else puts("No"); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP17 D2T3】列队]]></title>
    <url>%2Fposts%2F1613.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2017 提高组 D2T3Loj2319Luogu3960 Problem【Description】Sylvia 是一个热爱学习的女♂孩子。前段时间，Sylvia 参加了学校的军训。众所周知，军训的时候需要站方阵。Sylvia 所在的方阵中有n×m名学生，方阵的行数为 n，列数为 m。为了便于管理，教官在训练开始时，按照从前到后，从左到右的顺序给方阵中 的学生从 1 到 n×m 编上了号码（参见后面的样例）。即：初始时，第 i 行第 j 列 的学生的编号是(i−1)×m+j。然鹅在练习方阵的时候，经常会有学生因为各种各样的事情需要离队。在一天 中，一共发生了 q件这样的离队事件。每一次离队事件可以用数对(x,y)(1≤x≤n,1≤y≤m)描述，表示第 x 行第 y 列的学生离队。在有学生离队后，队伍中出现了一个空位。为了队伍的整齐，教官会依次下达 这样的两条指令： 向左看齐。这时第一列保持不动，所有学生向左填补空缺。不难发现在这条 指令之后，空位在第 x 行第 m 列。 向前看齐。这时第一行保持不动，所有学生向前填补空缺。不难发现在这条 指令之后，空位在第 n 行第 m 列。教官规定不能有两个或更多学生同时离队。即在前一个离队的学生归队之后， 下一个学生才能离队。因此在每一个离队的学生要归队时，队伍中有且仅有第 n 行 第 m 列一个空位，这时这个学生会自然地填补到这个位置。因为站方阵真的很无聊，所以 Sylvia 想要计算每一次离队事件中，离队的同学 的编号是多少。注意：每一个同学的编号不会随着离队事件的发生而改变，在发生离队事件后 方阵中同学的编号可能是乱序的。【Input】输入共 q+1 行。第 1 行包含 3 个用空格分隔的正整数 n,m,q，表示方阵大小是 n 行 m 列，一共发 生了 q 次事件。接下来 q 行按照事件发生顺序描述了 q 件事件。每一行是两个整数 x,y，用一个空 格分隔，表示这个离队事件中离队的学生当时排在第 x 行第 y 列。【Output】按照事件输入的顺序，每一个事件输出一行一个整数，表示这个离队事件中离队学 生的编号。【Limited conditions】数据保证每一个事件满足 1≤x≤n,1≤y≤m【Sample input】2 2 31 12 21 2【Sample output】114【Sample explanation】列队的过程如上图所示，每一行描述了一个事件。 在第一个事件中，编号为 1 的同学离队，这时空位在第一行第一列。接着所有同学 向左标齐，这时编号为 2 的同学向左移动一步，空位移动到第一行第二列。然后所有同 学向上标齐，这时编号为 4 的同学向上一步，这时空位移动到第二行第二列。最后编号 为 1 的同学返回填补到空位中。 Record2h Analysis请先思考后再展开 如果把每次排队，抽象成操作【删除】和【寻找某一行或者一列的第k个】那么显然就是要用数据结构维护了可以说这是一道我见过最不裸的数据结构题反正我是没有独立看出来的能力的 但这个二维的矩阵要怎么维护呢？如果说每行都开一个，那么每次向前看起的时候，最后一列向前移动了一位也就是说我们需要插入、删除n次？显然是不可能的 其实向前的列只有最后一列，所以我们可以把行上的操作类比到最后一列上也就是说，把最后一列单独维护，前面的n行，每行只维护m-1个元素就好了 接下来把操作具体化一下，设出队的人坐标为(x,y)：①y=m【把最后一列的第x个删除并获得id】，【将id插入到最后一列的最后】②y&lt;m【把第x行的第y个删除并获得id】，【将id插入到最后一列的最后】【把最后一列的第x个删除并获得id】，【将id插入到第x行的最后】 还有一点就是，由于矩阵很大，不能直接存储，需要用一些手段动态利用空间 基于以上考虑，决定使用的数据结构思路一：平衡树，我只会splay思路二：线段树【%rose_max大爷，想到了这么神的做法】 平衡树很好理解，操作很常规，主要是怎么压缩空间然后我自己想了个做法，结果tm到处都是这样做的……就是把连续的节点用二元组(st,tot)表示，需要的时候分裂开就好了找第k大就用siz来找就好了 至于线段树的做法，借鉴主席树的思想，动态开点，只产生链对于找第k大，还是用siz，但这一次是用【线段树下标差-被删除数量】来搞然后删除数量，就用一个sum维护即可因为后面还要插入，所以预先每个线段树开n+q的范围这样的空间复杂度是nlogn，比splay多个log，但是时间理论上会小常数 不过实际情况是，我写的splay总时间和线段树一样，约10000ms，但单点最大1500ms，而线段树是1000ms在极限时间相同的情况下，xgc和rose的线段树总时间只有6000ms对比了一下，也没发现什么不同…… Code1请先思考后再展开 splay123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=310000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;struct Nod&#123; int f,son[2]; ll siz; ll id,tot;//起始编号、连续长度 Nod() &#123; f=son[0]=son[1]=0; &#125;&#125;p[MAXN*(2+4)];int ln=0;struct Splay&#123; void update(int x) &#123; p[x].siz=p[x].tot; int lc=p[x].son[0],rc=p[x].son[1]; if(lc&gt;0) p[x].siz+=p[lc].siz;//debug tot if(rc&gt;0) p[x].siz+=p[rc].siz;//debug tot &#125; void rotate(int x,int w) &#123; int f=p[x].f,ff=p[f].f; if(p[ff].son[0]==f) p[ff].son[0]=x; else p[ff].son[1]=x; p[x].f=ff; int son=p[x].son[w]; p[f].son[1-w]=son; if(son&gt;0) p[son].f=f; p[x].son[w]=f; p[f].f=x; update(f); update(x); &#125; int root; void splay(int x,int rt) &#123; while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(ff==rt) &#123; if(p[f].son[0]==x) rotate(x,1); else rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==0) root=x; &#125; void add(int fa,int w,ll id,int tot) &#123; int now=++ln; p[now].f=fa;p[fa].son[w]=now; p[now].id=id;p[now].tot=tot; update(now); &#125; void insert_wei(ll id,ll tot) &#123; if(root==0) &#123; root=++ln; p[root].id=id;p[root].tot=tot; update(root);//debug &#125; else &#123; int now=root;while(p[now].son[1]&gt;0) now=p[now].son[1]; add(now,1,id,tot); splay(ln,0); &#125; &#125; int findk(ll &amp;k)//返回编号 &#123; int now=root; while(1) &#123; int lc=p[now].son[0]; ll lcc=(lc&gt;0)?p[lc].siz:0; if(k&lt;=lcc) now=lc; else if(k&gt;lcc+p[now].tot) k-=lcc+p[now].tot,now=p[now].son[1]; else &#123;k-=lcc;return now;&#125; &#125; &#125; void del(int now) &#123; splay(now,0); int lc=p[now].son[0],rc=p[now].son[1]; if(lc==0 and rc==0) &#123; //debug ln=0不能用！ root=0; &#125; else if(lc&gt;0 and rc==0) &#123; root=lc; p[root].f=0; &#125; else if(lc==0 and rc&gt;0) &#123; root=rc; p[root].f=0; &#125; else &#123; int nx=lc;while(p[nx].son[1]&gt;0) nx=p[nx].son[1]; splay(nx,now); root=nx;p[root].f=0; p[rc].f=root;p[root].son[1]=rc; update(root); &#125; &#125; ll delk_getid(ll k) &#123; int now=findk(k); //printf("%lld %lld\n",p[now].id,k); k=p[now].id+k-1; if(p[now].tot==1) del(now); else if(k==p[now].id) &#123; p[now].id++; p[now].tot--;//debug 漏了这句话，导致推移 splay(now,0); &#125; else if(k==p[now].id+p[now].tot-1) &#123; p[now].tot--; splay(now,0); &#125; else &#123; ll backup=p[now].tot; p[now].tot=k-1-p[now].id+1; int rc=p[now].son[1]; p[now].son[1]=0; add(now,1,k+1,backup-p[now].tot-1); p[ln].son[1]=rc;p[rc].f=ln; splay(ln,0); &#125; return k; &#125;&#125;s[MAXN];int main()&#123; int n,m,q;scanf("%d%d%d",&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=n;i++) &#123; s[i].insert_wei( ll(i-1)*m+1 ,m-1); s[0].insert_wei( (ll)i*m,1);//最后一列 &#125; while(q--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); if(y==m) &#123; ll id=s[0].delk_getid(x); printf("%lld\n",id); s[0].insert_wei(id,1); &#125; else &#123; ll id=s[x].delk_getid(y); printf("%lld\n",id); s[0].insert_wei(id,1); id=s[0].delk_getid(x); s[x].insert_wei(id,1); &#125; &#125;&#125; Code2请先思考后再展开 线段树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=610000;//totconst int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;struct Nod&#123; int lc,rc; int sum;//删除数量 ll id; Nod() &#123; lc=rc=sum=0; id=0; &#125;&#125;p[2*MAXN*17];//2*tot+2*tot*log(tot)int ln=0;int rt[MAXN],ed[MAXN];void change(int &amp;now,int l,int r,int pos,int c,ll id)&#123; if(now==0) now=++ln; p[now].sum+=c; if(l==r) &#123; p[now].id=id;return; &#125; int mid=(l+r)/2; if(pos&lt;=mid) change(p[now].lc,l,mid,pos,c,id); else change(p[now].rc,mid+1,r,pos,c,id);&#125;int tmp;//局部编号，外面还原ll findk(int now,int l,int r,int k,int &amp;pos)//返回编号，pos为下标&#123; if(now==0) &#123;tmp=pos=l+k-1;return 0;&#125; if(l==r) &#123;pos=l;tmp=l+k-1;return p[now].id;&#125; int mid=(l+r)/2; int left=mid-l+1-p[p[now].lc].sum;//debug 不能对0节点特判（习惯……） if(k&lt;=left) return findk(p[now].lc,l,mid,k,pos); else return findk(p[now].rc,mid+1,r,k-left,pos);&#125;int main()&#123; int n,m,q;scanf("%d%d%d",&amp;n,&amp;m,&amp;q); int tot1=m+q,tot2=n+q;//debug 原本用了动态的，然后还忘记分开来 ed[0]=n;for(int i=1;i&lt;=n;i++) ed[i]=m-1;//长度 while(q--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); if(y==m) &#123; int pos; ll id=findk(rt[0],1,tot2,x,pos); change(rt[0],1,tot2,pos,1,0);//delete if(id==0) id=(ll)tmp*m; printf("%lld\n",id); change(rt[0],1,tot2,++ed[0],0,id); &#125; else &#123; int pos; ll id=findk(rt[x],1,tot1,y,pos); change(rt[x],1,tot1,pos,1,0);//delete if(id==0) id=ll(x-1)*m+tmp; printf("%lld\n",id); change(rt[0],1,tot2,++ed[0],0,id); id=findk(rt[0],1,tot2,x,pos); change(rt[0],1,tot2,pos,1,0);//delete if(id==0) id=(ll)tmp*m; change(rt[x],1,tot1,++ed[x],0,id); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SDOI2013】随机数生成器]]></title>
    <url>%2Fposts%2F41a1.html</url>
    <content type="text"><![CDATA[Source and JudgeSDOI2013Luogu3306Bzoj3122 Record2h Analysis请先思考后再展开 随便推推柿子，发现有通项公式$x_i=a^{i-1}x_1 + b(1+a+a^2…+a^{i-2}) (\mod p)$$x_i=a^{i-1}x_1 + b \times (a^{i-1}-1) \times inv(a-1) (\mod p)$注意0没有逆元，所以要特判a=1的情况，即一个带模等差数列，解一个同余方程即可而对于普遍情况，可以BSGS，而且不用拓展，因为已经保证p是素数，而且a小于p Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; const int INF=0x3f3f3f3f; typedef long long ll; typedef unsigned long long ull; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; const int MAXN=610000; ll Mod; ll gcd(ll a,ll b) &#123;return (b==0)?a:gcd(b,a%b);&#125; ll qpower(ll a,ll e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=(ans*a)%Mod; a=(a*a)%Mod;e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll x) &#123;return qpower(x,Mod-2);&#125; map&lt;ll,int&gt; hash; int BSGS(ll a,ll b) &#123; hash.clear();//debug ll m=ceil(sqrt( (double)Mod )); ll t=a,now=1; for(int j=0;j&lt;=m;j++) hash[ b*now%Mod ]=j,now=now*t%Mod; t=qpower(a,m),now=t; for(int i=1;i&lt;=m;i++) &#123; if(hash.count(now)) return (i*m-hash[now])+1; now=now*t%Mod; &#125; return -1; &#125; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; ll a,b,st,ed;scanf("%lld%lld%lld%lld%lld",&amp;Mod,&amp;a,&amp;b,&amp;st,&amp;ed); if(st==ed) &#123;puts("1");continue;&#125;//debug 柿子要求天数&gt;1 if(a==0) &#123;puts( (b==ed)?"2":"-1" );continue;&#125;//debug if(a==1)//debug 相当于除以0 &#123; if(b==0) puts("-1"); else &#123; //st+b*x=ed (mod Mod) ll ans=((ed-st)%Mod+Mod)%Mod; printf("%lld\n",ans*inv(b)%Mod+1); &#125; continue; &#125; //if( gcd(st+b*inv(a-1),Mod)!=1 ) &#123;puts("-1");continue;&#125; //debug st+b*inv(a-1)这个柿子，本来想着要丢到逆元里面，所以不能% //但其实，一是应该在除过去之前就被%，二是它可能比Mod大 int ans=BSGS(a,(ed+b*inv(a-1)%Mod)*inv(st+b*inv(a-1)%Mod)%Mod); printf("%d\n",ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>BSGS</tag>
        <tag>难度2</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP17 D2T2】宝藏]]></title>
    <url>%2Fposts%2F301d.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2017 提高组 D2T2Loj2318Luogu3959 Problem【Description】参与考古挖掘的小明得到了一份藏宝图，藏宝图上标出了 n 个深埋在地下的宝藏屋， 也给出了这 n 个宝藏屋之间可供开发的 m 条道路和它们的长度。小明决心亲自前往挖掘所有宝藏屋中的宝藏。但是，每个宝藏屋距离地面都很远， 也就是说，从地面打通一条到某个宝藏屋的道路是很困难的，而开发宝藏屋之间的道路 则相对容易很多。小明的决心感动了考古挖掘的赞助商，赞助商决定免费赞助他打通一条从地面到某 个宝藏屋的通道，通往哪个宝藏屋则由小明来决定。在此基础上，小明还需要考虑如何开凿宝藏屋之间的道路。已经开凿出的道路可以 任意通行不消耗代价。每开凿出一条新道路，小明就会与考古队一起挖掘出由该条道路 所能到达的宝藏屋的宝藏。另外，小明不想开发无用道路，即两个已经被挖掘过的宝藏 屋之间的道路无需再开发。新开发一条道路的代价是：L×KL代表这条道路的长度，K代表从赞助商帮你打通的宝藏屋到这条道路起点的宝藏屋所经过的 宝藏屋的数量（包括赞助商帮你打通的宝藏屋和这条道路起点的宝藏屋） 。请你编写程序为小明选定由赞助商打通的宝藏屋和之后开凿的道路，使得工程总代 价最小，并输出这个最小值。【Input】第一行两个用空格分离的正整数 n,m ，代表宝藏屋的个数和道路数。接下来 m 行，每行三个用空格分离的正整数，分别是由一条道路连接的两个宝藏 屋的编号（编号为 1−n ），和这条道路的长度 v 。【Output】一个正整数，表示最小的总代价。【Limited conditions】1≤n≤12， 0≤m≤1000， v≤500000【Sample input 1】4 51 2 11 3 31 4 12 3 43 4 1【Sample output 1】4【Sample input 2】4 51 2 11 3 31 4 12 3 43 4 2【Sample output 2】5【Sample explanation】无 Record3h去年比赛的时候想了半天，没想出什么数据能卡贪心地最小生成树然后就被卡到了45分 Analysis请先思考后再展开 rose曾经提出的做法:用$f[S][now][dep]$表示当点的状态为S，现在在now且深度为dep时的最优结果那么把不同种起点方式塞进去之后，就可以转移复杂度为$2^n \times n \times n \times n$ 看起来没有任何问题，对吧？我一开始也是这样认为的，就是一直心里有种别扭的感觉后来想半天终于发现，因为把其他点的信息舍去了，再也不能从别的点出发转移了 正解是状压dp这次的状压灰常独特呢反正我是没见过…… 设$f[dep][S]$表示当前的状态是S，最大深度是dep时的最小代价然后枚举每个状态进行转移的时候，每次直接添加一个点集，直接全部作为新的一层至于代价，考虑到题目的特殊性，树的结构具体如何无关紧要，只和每个节点的深度有关既然如此，只要预处理出每个节点添加到一个点集中的代价，再预处理成点集即可 然后让我们分析一下复杂度大致上=dp时枚举dep的时间 × 所有状态转移时枚举【补集的子集】的时间花费那么其实枚举【补集的子集】就是枚举子集 如果直接从循环量看，一定是比$O(2^n \times 2^n)=2亿$少的当然按照akc在省选后的教训，这个也可能跑出灰常多的分数但这个时间到底是多少呢？ 因为这东西是和rose一起xjb想出来的，不一定严谨而且好像和别的大佬看起来不一样？考虑按照【含0数量】分类$2^12 \times C_12^0$$2^11 \times C_12^1$……$2^6 \times C_12^6$……$2^1 \times C_12^11$$2^0 \times C_12^12$ 那么最大的显然是$2^6 \times C_12^6&lt;=60000$那么它们的总和$&lt; 60000*12=720000$所以总复杂度就是8640000 UP 晚上：问了问师兄，得出了和网上大佬相同的结论对于这种连续的枚举子集问题，复杂度其实是$O(3^n)$对于每个数位，只有3种情况，原本是0，原本是1枚举子集成0，原本是1枚举子集成1当然这种复杂度的前提是精准找到那个位置 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;ull mymin(ull x,ull y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int bin[15];const int MAXS=1&lt;&lt;12;int n,maxs;int dis[15][15];int v[15];//原本位置ull value[15][MAXS];//点=&gt;集int cost[MAXS][MAXS];//集=&gt;集void pre()//3^n*n&#123; memset(value,63,sizeof value); for(int s=0;s&lt;=maxs;s++) &#123; for(int i=0;i&lt;=n-1;i++) if(s&amp;bin[i]) for(int j=0;j&lt;=n-1;j++) if( (s&amp;bin[j])==0 ) value[j][s]=mymin(value[j][s],dis[i][j]); for(int s2=(maxs-s);s2&gt;0;s2=(s2-1)&amp;(maxs-s))//枚举补集的子集 for(int i=0;i&lt;=n-1;i++) if(s2&amp;bin[i]) cost[s2][s]+=value[i][s]; &#125;&#125;ull f[15][MAXS];void dp()//n*3^n&#123; memset(f,63,sizeof f); for(int i=0;i&lt;=n-1;i++) f[1][bin[i]]=0; for(int dep=1;dep&lt;=n;dep++) for(int s=1;s&lt;=maxs;s++)//debug 不能是0 for(int s2=(maxs-s);s2&gt;0;s2=(s2-1)&amp;(maxs-s))//枚举补集的子集 f[dep+1][s|s2]=mymin(f[dep+1][s|s2],f[dep][s]+(ull)cost[s2][s]*dep);&#125;int main()&#123; bin[0]=1;for(int i=1;i&lt;15;i++) bin[i]=bin[i-1]&lt;&lt;1; int m;scanf("%d%d",&amp;n,&amp;m); memset(dis,63,sizeof dis); for(int i=1;i&lt;=m;i++) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); x--;y--; if(dis[x][y]&gt;c) dis[x][y]=dis[y][x]=c; &#125; maxs=bin[n]-1; pre(); dp(); ull ans=INF; for(int dep=1;dep&lt;=n;dep++) ans=mymin(ans,f[dep][maxs]); printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>dp</tag>
        <tag>状压</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Abc104-D】We Love ABC]]></title>
    <url>%2Fposts%2Ff88a.html</url>
    <content type="text"><![CDATA[Source and JudgeArc100-D Problem【Description】给出一个字符串，只有A,B,C和通配符?答案为：枚举出各种情况，每种情况，不同位置三元组满足(A,B,C)，其数量之和【Input】字符串s【Output】输出和，模1e9+7【Limited conditions】|s|&lt;=10^5【Sample input 1】A??C【Sample output 1】8【Sample input 2】ABCBC【Sample output 2】3【Sample input 3】????C?????B??????A???????【Sample output 3】979596887【Sample explanation】无 Record30min刚长途旅游完只有abc Analysis请先思考后再展开 第一次想出D因为同样的三元组，可能会多次统计直接枚举每个b和?，考虑其贡献即可 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;const ll MOD=1e9+7;char s[MAXN];ll a[MAXN],c[MAXN],wen[MAXN];ll three[MAXN];int main()&#123; three[0]=1;for(int i=1;i&lt;MAXN;i++) three[i]=(three[i-1]*3)%MOD; scanf("%s",s+1); int len=strlen(s+1); for(int i=1;i&lt;=len;i++) &#123; a[i]=a[i-1]+(s[i]=='A'); c[i]=c[i-1]+(s[i]=='C'); wen[i]=wen[i-1]+(s[i]=='?'); &#125; ll ans=0; for(int i=1;i&lt;=len;i++) if(s[i]=='B') &#123; ans+=a[i-1]*(c[len]-c[i])%MOD*three[wen[len]]%MOD;ans%=MOD;//(a,b,c) ans+=wen[i-1]*(c[len]-c[i])%MOD*three[wen[len]-1]%MOD;ans%=MOD;//(?,b,c) ans+=a[i-1]*(wen[len]-wen[i])%MOD*three[wen[len]-1]%MOD;ans%=MOD;//(a,b,?) ans+=wen[i-1]*(wen[len]-wen[i])%MOD*three[wen[len]-2]%MOD;ans%=MOD;//(?,b,?) &#125; else if(s[i]=='?') &#123; ans+=a[i-1]*(c[len]-c[i])%MOD*three[wen[len]-1]%MOD;ans%=MOD;//(a,?,c) ans+=wen[i-1]*(c[len]-c[i])%MOD*three[wen[len]-2]%MOD;ans%=MOD;//(?,?,c) ans+=a[i-1]*(wen[len]-wen[i])%MOD*three[wen[len]-2]%MOD;ans%=MOD;//(a,?,?) ans+=wen[i-1]*(wen[len]-wen[i])%MOD*three[wen[len]-3]%MOD;ans%=MOD;//(?,?,?) &#125; printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【训练】算法竞赛进阶指南-3数学30题]]></title>
    <url>%2Fposts%2F82f7.html</url>
    <content type="text"><![CDATA[本处难度分档以个人实力为参照系难度1：半小时内想出，半小时内ac难度2：半小时想不出，看题解，服气难度3：半小时想不出，看题解，ac后依然觉得难度很大 0x30 数学题目 1 poj2689 Prime Distance7.19 难度2请先思考后再展开 有一个很妙的做法：采用类似埃筛的方法筛素数所以只要线性预处理出前面$\sqrt R$内的素数p，然后在后面搞一搞就好了 复杂度计算：$$O(\sum_{质数p \leq \sqrt R} \frac{R-L}{p})$$然后根据什么调和级数之类的东西，$1+1/2+1/3+1/4….1/n ≈ log_2 n$所以说复杂度就大概是$O((R-L) \times log_2 \sqrt R)$ 最后提醒各位特判一下1并且数组的下标是相对位置，错了好多次123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=310;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;const int MAXNUM=100000;int pr=0,prime[MAXNUM];bool v[MAXNUM];void pre()&#123; for(int i=2;i&lt;MAXNUM;i++) &#123; if(!v[i]) prime[++pr]=i; for(int j=1;j&lt;=pr and i*prime[j]&lt;MAXNUM;j++) &#123; v[i*prime[j]]=1; if(i%prime[j]==0) break; &#125; &#125;&#125;bool bk[1100000];int main()&#123; pre(); int l,r; while(scanf("%d%d",&amp;l,&amp;r)!=EOF) &#123; memset(bk,1,sizeof bk); if(l==1) bk[0]=0;//debug for(int i=1;i&lt;=pr;i++) for(int j=l/prime[i];j&lt;=r/prime[i];j++) if(l&lt;=j*prime[i] and j&gt;1) bk[j*prime[i]-l]=0;//debug bool two=0; int mix=0,miy=INF,mxx=0,mxy=0,lst=0; for(int i=0;i&lt;=r-l;i++) &#123; if(!bk[i]) continue; int tmp=l+i; if(lst&gt;0 and tmp-lst&lt;miy-mix) mix=lst,miy=tmp,two=1; if(lst&gt;0 and tmp-lst&gt;mxy-mxx) mxx=lst,mxy=tmp,two=1; lst=tmp; &#125; if(two) printf("%d,%d are closest, %d,%d are most distant.\n",mix,miy,mxx,mxy); else puts("There are no adjacent primes."); &#125;&#125; 2 3101 阶乘分解7.19 难度1请先思考后再展开 枚举素数p，考虑贡献，对于次幂为1，有$\frac{n}{p}$个对于次幂为t，有$\frac{n}{p^t}$个，新贡献恰好为$\frac{n}{p^t}$所以，枚举每个素数，然后以log的时间计算贡献即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1100000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;const int MAXNUM=1000000;int pr=0,prime[MAXNUM];bool v[MAXNUM];void pre()&#123; for(int i=2;i&lt;MAXNUM;i++) &#123; if(!v[i]) prime[++pr]=i; for(int j=1;j&lt;=pr and i*prime[j]&lt;MAXNUM;j++) &#123; v[i*prime[j]]=1; if(i%prime[j]==0) break; &#125; &#125;&#125;int main()&#123; pre(); int n;scanf("%d",&amp;n); for(int k=1;k&lt;=pr;k++) &#123; int tot=0; for(ll kn=prime[k];kn&lt;=n;kn*=prime[k]) tot+=n/kn; if(tot&gt;0) printf("%d %d\n",prime[k],tot); &#125;&#125; 3 HAOI2007 反素数8.6 难度2请先思考后再展开 找找反素数共有的性质吧 性质1：如果约数个数相同，根据性质，应该取最小的 性质2：素因子只有2,3,5,7,11,13,17,19,23证明：回忆约数个数公式，只与每个素数的次幂有关。如果使用更大的素因子，前面这9个中至少有一个空缺（否则超出题目范围）如果用这个空缺替换，次幂不变，会得到更小的数字，违背性质1 性质3：若将反素数表示为$2^{k_2} \times3^{k_3} \times5^{k_5} \times7^{k_7} \times11^{k_{11}} \times13^{k_{13}} \times17^{k_{17}} \times19^{k_{19}} \times23^{k_{23}}$则$k_2 \geqk_3 \geqk_5 \geqk_7 \geqk_{11} \geqk_{13} \geqk_{17} \geqk_{19} \geqk_{23} \geq0$证明：如果不递减，把某个逆序对交换后，可以得到相同约数下更小的数字，违背性质1 最后用dfs枚举一下就好了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int mxn;int mxg=1,ans=1;//最小const int p[10]=&#123;0,2,3,5,7,11,13,17,19,23&#125;;int k[10];void dfs(int now,int nowg,int num)&#123; if(num&gt;mxn) return; if(now==10) &#123; if(nowg&gt;mxg) mxg=nowg,ans=num; else if(nowg==mxg and num&lt;ans) ans=num;//debug，不能保证数字递增 return; &#125; int tmp=1; for(int i=0;i&lt;=k[now-1] and tmp&lt;=mxn and ll(num)*tmp&lt;=mxn;i++)//debug num写成now &#123; k[now]=i; dfs(now+1,nowg*(i+1),num*tmp); tmp*=p[now]; &#125;&#125;int main()&#123; scanf("%d",&amp;mxn); k[0]=30; dfs(1,1,1); printf("%d",ans);&#125; 4 CQOI2007 余数求和8.6 难度1请先思考后再展开 先化简柿子$ans=\sum_{i=1}^n k-\lfloor \frac{k}{i} \rfloor \times i=nk - \sum_{i=1}^k \lfloor \frac{k}{i} \rfloor \times i$这是因为当i&gt;k时，结果就是k 然后这东西初看时线性的，还是会超时如果有经验的话，可以一眼看出用一个技巧解决详见套路集锦中枚举方法3本来不知道怎么算复杂度，反正比k小，曾经听说期望根号现在已经把书上的证明补充上去了，其实也不复杂 总之就这样枚举过去，等差数列推推柿子就好了12345678910111213141516171819202122232425262728293031323334#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int main()&#123; int n,k;scanf("%d%d",&amp;n,&amp;k); ll ans=ll(n)*k; for(int i=1;i&lt;=k and i&lt;=n;)//debug 也要判n &#123; int lst=k/(k/i); if(lst&gt;n) lst=n;//debug ans-=ll(k/i)*(i+lst)*(lst-i+1)/2;//debug long long i=lst+1; &#125; printf("%lld",ans);&#125; 5 poj3090 Visible Lattice Points8.7 难度2请先思考后再展开 先分析题目，不难发现要求的是gcd(1~n,1~n)=1的数量 那么可以直接用莫比乌斯反演12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;const int MAXNUM=1001;int prime[MAXNUM],pr=0;bool v[MAXNUM];int mu[MAXNUM];void pre()&#123; mu[1]=1; for(int i=2;i&lt;MAXNUM;i++) &#123; if(!v[i]) prime[++pr]=i,mu[i]=-1; for(int j=1;j&lt;=pr and i*prime[j]&lt;MAXNUM;j++) &#123; v[i*prime[j]]=1; if(i%prime[j]==0) break;//mu=0 else mu[i*prime[j]]=-mu[i]; &#125; &#125; for(int i=1;i&lt;MAXNUM;i++) mu[i]+=mu[i-1];&#125;int main()&#123; pre(); int T;scanf("%d",&amp;T);int ct=0; while(T--) &#123; int n;scanf("%d",&amp;n); int f1=0; for(int i=1;i&lt;=n;) &#123; int lst=n/(n/i); int F=(n/i)*(n/i); f1+=(mu[lst]-mu[i-1])*F; i=lst+1; &#125; printf("%d %d %d\n",++ct,n,2+f1); &#125;&#125; 那么我们尝试用欧拉搞一搞其实就是因为长宽相同，那么对于每一列，累加一下欧拉就好了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;const int MAXNUM=1001;int prime[MAXNUM],pr=0;bool v[MAXNUM];int phi[MAXNUM];void pre()&#123; phi[1]=1; for(int i=2;i&lt;MAXNUM;i++) &#123; if(!v[i]) prime[++pr]=i,phi[i]=i-1; for(int j=1;j&lt;=pr and i*prime[j]&lt;MAXNUM;j++) &#123; v[i*prime[j]]=1; if(i%prime[j]==0) &#123; phi[i*prime[j]]=phi[i]*prime[j]; break; &#125; else phi[i*prime[j]]=phi[i]*(prime[j]-1); &#125; &#125;&#125;int main()&#123; pre(); int T;scanf("%d",&amp;T);int ct=0; while(T--) &#123; int n;scanf("%d",&amp;n); int ans=0; for(int i=2;i&lt;=n;i++) ans+=phi[i]; printf("%d %d %d\n",++ct,n,3+ans*2); &#125;&#125; 6 poj3696 The Luckiest number8.7 难度3请先思考后再展开 x个8连在一起的数字，可以用$\frac{8}{9} (10^x-1)$表示那么题目要求$L | \frac{8}{9} (10^x-1)$等效于$9L | 8(10^x-1)$设$d=gcd(L,8)$假设条件满足，那么L中的偶因子是8的约数两边同时除以d后，左边不再有偶因子，则右边剩下的偶因子没有意义$\frac{9L}{d} | 10^x-1$转化成$10^x=1 (\mod \frac{9L}{d})$ 当$gcd(10,\frac{9L}{d})=1$时，根据中欧拉函数与欧拉定理的定理8，可枚举其约数，快速幂判断即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;ll gcd(ll x,ll y) &#123;return (y==0)?x:gcd(y,x%y);&#125;ll qmul(ll a,ll e,ll Mod)&#123; ll ans=0; while(e&gt;0) &#123; if(e&amp;1) ans=(ans+a)%Mod; e&gt;&gt;=1;a=(a+a)%Mod; &#125; return ans;&#125;ll qpower(ll a,ll e,ll Mod)&#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=qmul(ans,a,Mod); e&gt;&gt;=1;a=qmul(a,a,Mod); &#125; return ans;&#125;ll getphi(ll tmp)&#123; ll phi=tmp; for(ll i=2;i*i&lt;=tmp;i++) if(tmp%i==0) &#123; while(tmp%i==0) tmp/=i; phi=phi/i*(i-1);//debug phi*(i-1)/i 这里可能爆 &#125; if(tmp&gt;1) phi=phi/tmp*(tmp-1);//debug return phi;&#125;int main()&#123; int ct=0; while(1) &#123; int L;scanf("%d",&amp;L); if(L==0) break; printf("Case %d: ",++ct); ll tmp=(ll)L*9/gcd(L,8); if(gcd(10,tmp)==1) &#123; ll phi=getphi(tmp); ll ans=phi; for(ll i=1;i*i&lt;=phi;i++) if(phi%i==0) &#123; if(i&lt;ans and qpower(10,i,tmp)==1) ans=i; if(i*i!=phi and phi/i&lt;ans and qpower(10,phi/i,tmp)==1) ans=phi/i; &#125; printf("%lld\n",ans); &#125; else puts("0"); &#125;&#125; 7 bzoj2973 1801 石头游戏8.10 难度1请先思考后再展开 脑残题但是题目居然不说清楚：如果操作违法，要把它丢掉还有就是一些sb错误，耽误了一个早上123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; const int INF=0x3f3f3f3f; typedef long long ll; typedef unsigned long long ull; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; int n,m; struct Matrix &#123; ll a[100][100]; Matrix() &#123; memset(a,0,sizeof a); &#125; &#125;; Matrix pre() &#123; Matrix ans; for(int i=1;i&lt;=90;i++) ans.a[i][i]=1; return ans; &#125; Matrix cheng(Matrix a,Matrix b) &#123; Matrix c; for(int i=1;i&lt;=90;i++) for(int j=1;j&lt;=90;j++) for(int k=1;k&lt;=90;k++) c.a[i][j]+=a.a[i][k]*b.a[k][j]; return c; &#125; Matrix qpower(Matrix a,int e) &#123; Matrix ans=pre(); while(e&gt;0) &#123; if(e&amp;1) ans=cheng(ans,a); a=cheng(a,a);e&gt;&gt;=1; &#125; return ans; &#125; int gcd(int a,int b) &#123;return (b==0)?a:gcd(b,a%b);&#125; int lcm(int a,int b) &#123;return a/gcd(a,b)*b;&#125; Matrix op[100]; int calc(int x,int y) &#123;return (x-1)*m+y;&#125; void main() &#123; int ti,act;scanf("%d%d%d%d",&amp;n,&amp;m,&amp;ti,&amp;act); char mp[10][10]; for(int i=1;i&lt;=n;i++) scanf("%s",mp[i]+1); int tlen=1; char oper[10][10];int oplen[10]; for(int i=0;i&lt;=act-1;i++) &#123; scanf("%s",oper[i]+1); oplen[i]=strlen(oper[i]+1); tlen=lcm(tlen,oplen[i]); &#125; int now[10];for(int i=0;i&lt;=act-1;i++) now[i]=1;//debug 忘记初始化 Matrix all=pre(); for(int s=1;s&lt;=tlen;s++) &#123; op[s]=pre(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; int id=mp[i][j]-'0',t=now[id]; if(isdigit(oper[id][t])) op[s].a[calc(i,j)][n*m+1]=oper[id][t]-'0'; else if(oper[id][t]=='D') op[s].a[calc(i,j)][calc(i,j)]=0; else//推 &#123; op[s].a[calc(i,j)][calc(i,j)]=0; int nx=i,ny=j; if(oper[id][t]=='N') nx--;if(oper[id][t]=='S') nx++; if(oper[id][t]=='W') ny--;if(oper[id][t]=='E') ny++; if(1&lt;=nx and nx&lt;=n and 1&lt;=ny and ny&lt;=m) op[s].a[calc(nx,ny)][calc(i,j)]=1; &#125; &#125; all=cheng(op[s],all); for(int i=0;i&lt;=act-1;i++) if( (++now[i])==oplen[i]+1) now[i]=1;//debug 本来写(++now[i])==oplen[i] &#125; Matrix st;st.a[n*m+1][1]=1; Matrix tmp=pre();for(int s=ti%tlen;s&gt;=1;s--) tmp=cheng(tmp,op[s]); st=cheng( cheng(tmp,qpower(all,ti/tlen)) ,st); ll ans=0; for(int i=1;i&lt;=n*m;i++) if(st.a[i][1]&gt;ans) ans=st.a[i][1]; printf("%lld",ans); &#125;&#125;;int main()&#123; mine::main();&#125; 8 JSOI2008 球形空间产生器8.10 难度2请先思考后再展开 先推推柿子如果把n+1个点，与球心的距离表示出来，会得出一个多元二次方程组为了变成一次，考虑把相邻的相减$\sum (a_{i,j}-x_j)^2-(a_{i+1,j}-x_j)^2=0$$\sum 2(a_{i+1,j}-a_{i,j})x_j=\sum a_{i+1,j}^2-a_{i,j}^2$然后高斯消元就好了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; double myabs(double x) &#123;return x&gt;0?x:-x;&#125; const double eps=1e-8; const int MAXN=20; double p[MAXN][MAXN]; double a[MAXN][MAXN],b[MAXN];//系数、常数 void gauss(int n) &#123; for(int i=1;i&lt;=n;i++)//目标为xi &#123; int nx=-1; for(int j=i;j&lt;=n;j++) if(myabs(a[j][i])&gt;eps) &#123;nx=j;break;&#125; if(nx&lt;0) continue; swap(b[i],b[nx]);for(int k=1;k&lt;=n;k++) swap(a[i][k],a[nx][k]); for(int j=1;j&lt;=n;j++) &#123; if(i==j) continue; double t=a[j][i]/a[i][i];//确保分母不为0 b[j]-=b[i]*t;for(int k=i;k&lt;=n;k++) a[j][k]-=a[i][k]*t; &#125; &#125; &#125; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n+1;i++) for(int j=1;j&lt;=n;j++) scanf("%lf",&amp;p[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; a[i][j]=2*(p[i+1][j]-p[i][j]); b[i]+=p[i+1][j]*p[i+1][j]-p[i][j]*p[i][j]; &#125; gauss(n); for(int i=1;i&lt;=n;i++) printf("%.3lf ",b[i]/a[i][i]); &#125;&#125;;int main()&#123; mine::main();&#125; 9 poj1830 开关问题8.10 难度2请先思考后再展开 如果把异或看做是不进位的加法，那么就很好理解了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; const int MAXN=40; int n; int p[MAXN][MAXN]; int a[MAXN][MAXN],b[MAXN];//系数、常数 bool iszero(int i) &#123; for(int j=1;j&lt;=n;j++) if(a[i][j]&gt;0) return 0; return 1; &#125; int gauss() &#123; for(int i=1;i&lt;=n;i++) &#123; int nx=-1; for(int j=i;j&lt;=n;j++) if(a[j][i]&gt;0) &#123;nx=j;break;&#125; if(nx&lt;0) continue; swap(b[i],b[nx]);for(int k=1;k&lt;=n;k++) swap(a[i][k],a[nx][k]); for(int j=1;j&lt;=n;j++) &#123; if(i==j or !a[j][i]) continue; b[j]^=b[i];for(int k=i;k&lt;=n;k++) a[j][k]^=a[i][k]; &#125; &#125; int tot=0;//主元 for(int i=1;i&lt;=n;i++) if(!iszero(i)) tot++; else if(b[i]!=0) return -1; return 1&lt;&lt;(n-tot); &#125; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; memset(a,0,sizeof a); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) a[i][i]=1,scanf("%d",&amp;b[i]); for(int i=1;i&lt;=n;i++) &#123;int t;scanf("%d",&amp;t);b[i]^=t;&#125; while(1) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); if(x==0 and y==0) break; a[y][x]=1;//debug 要反过来 &#125; int ans=gauss(); if(ans&gt;0) printf("%d\n",ans); else puts("Oh,it's impossible~!!"); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 10 JLOI2015 装备购买8.11 难度2请先思考后再展开 卡精度，要开long double所以决定以后无脑long double了hh 为了做第二问，贪心地每次找最小的作为主元证明不会，但是我构造不出反例本来以为找到一个：3 23 04 45 02 1 3但其实，经过消元，第一行不会是0如果非要是0，那么第二行一定是第一行的倍数，则也能反过来……（感觉我表述得乱七八糟，意会一下吧）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; #define double long double double myabs(double x) &#123;return x&gt;0?x:-x;&#125; const double eps=1e-8; int n,m; double a[510][510],c[510]; int tot=0;double sum=0; void gauss() &#123; for(int i=1;i&lt;=m;i++) &#123; int nx=-1; for(int j=tot+1;j&lt;=n;j++) if(myabs(a[j][i])&gt;eps) if(nx&lt;0 or c[nx]&gt;c[j]) nx=j; if(nx&lt;0) continue; tot++;sum+=c[nx]; for(int k=1;k&lt;=m;k++) swap(a[tot][k],a[nx][k]); swap(c[tot],c[nx]);//debug 漏了 for(int j=1;j&lt;=n;j++) &#123; if(tot==j or myabs(a[j][i])&lt;=eps) continue; double t=a[j][i]/a[tot][i]; for(int k=i;k&lt;=m;k++) a[j][k]-=a[tot][k]*t; &#125; &#125; &#125; void main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%Lf",&amp;a[i][j]); for(int i=1;i&lt;=n;i++) scanf("%Lf",&amp;c[i]); gauss(); printf("%d %.0Lf",tot,sum); &#125;&#125;;int main()&#123; mine::main();&#125; 11 Hdu3949 XOR8.11 难度2请先思考后再展开 key：高斯消元后，得到的简化阶梯形矩阵，具有一个重要的性质————对于主元i，该列上唯一的1在这上面所以说，在其他相同的情况下，选i一定比不选要大所以说，可以把k按二进制拆分，按位，对应于要不要选择第i行 细节：注意0，线性基可以通过【自己异或自己】得出，但本题不行所以说特判一下最后的矩阵，就好了，具体自己分析 最后补充一下【异或线性基组合出来的数（即span张成）互不相同】的证明：假设有一个柿子，左右两边都是异或出来的数字，把左边留下某一个，其他移项到右边，那么出现，那个数字能被其他数字表示出，则违反线性基定义 顺便说说异或能移项的证明：把两边同时异或那个数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; ll bin[70]; int n; bool zero; ll a[11000]; int tot;//线性基长度 void gauss() &#123; zero=0;tot=0; for(int i=60;i&gt;=0;i--) &#123; int nx=tot+1; while( !(a[nx]&amp;bin[i]) and nx&lt;=n ) nx++; if(nx&gt;n) continue; tot++;swap(a[tot],a[nx]); for(int k=1;k&lt;=n;k++) if(k!=tot and a[k]&amp;bin[i]) a[k]^=a[tot]; &#125; if(tot&lt;n) zero=1; &#125; ll solve() &#123; ll k;scanf("%lld",&amp;k); if(zero) k--;//能产生0时，k=1得0，k=2得最小 if(k&gt;bin[tot]-1) return -1;//去除【什么都不选的情况】 ll ans=0; for(int i=0;i&lt;=tot-1;i++) if(k&amp;bin[i]) ans^=a[tot-i]; return ans; &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;=60;i++) bin[i]=bin[i-1]&lt;&lt;1; int T;scanf("%d",&amp;T); for(int ct=1;ct&lt;=T;ct++) &#123; printf("Case #%d:\n",ct); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); gauss(); int q;scanf("%d",&amp;q); while(q--) printf("%lld\n",solve()); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 12 3602 Counting Swaps8.13 难度3请先思考后再展开 多重集组合数 假如写出前面的几个数（谁会这样啊……都退出柿子了，也好像化简不出什么）：1,1,3,16,125会发现$s[n]=n^{n-2}$ 对于k个长度分别为l1,l2,…,lk的环$ans=\prod s[l_1]s[l_2]…s[l_k]\frac{(n-k)!}{(l_1-1)!(l_2-1)!…(l_k-1)!}$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAXN=110000; const int MOD=1e9+9; ll fac[MAXN]; ll qpower(ll a,int e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=ans*a%MOD; a=a*a%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y) &#123; if(b==0) &#123; x=1;y=0; return a; &#125; ll tx,ty; ll d=exgcd(b,a%b,tx,ty); x=ty; y=tx-(a/b)*ty; return d; &#125; ll inv(ll a) &#123; ll x,y; exgcd(a,MOD,x,y); return (x%MOD+MOD)%MOD; &#125; int p[MAXN]; bool v[MAXN]; int getsiz(int x) &#123; int now=p[x],tot=1; v[x]=1; while(now!=x) &#123; v[now]=1; tot++; now=p[now]; &#125; return tot; &#125; void main() &#123; fac[0]=1;for(int i=1;i&lt;MAXN;i++) fac[i]=fac[i-1]*i%MOD; int T;scanf("%d",&amp;T); while(T--) &#123; memset(v,0,sizeof v); int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i]); ll ans=1;int tot=0; for(int i=1;i&lt;=n;i++) if(!v[i]) &#123; int l=getsiz(i);tot++; ans=ans*qpower(l,l-2)%MOD; ans=ans*inv(fac[l-1])%MOD; &#125; printf("%lld\n",ans*fac[n-tot]%MOD); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 13 CF451E Devu and Flowers8.16 难度2请先思考后再展开 多重集组合数裸题，讲解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const ll MOD=1e9+7; ll qpower(ll x,ll e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll x) &#123;return qpower(x,MOD-2);&#125; ll C(ll m,ll n)//O(m) &#123; if(m&lt;0 or n&lt;0 or m&gt;n) return 0; ll ans=1; for(ll t=n;t&gt;=n-m+1;t--) ans=ans*(t%MOD)%MOD; ll s=1;for(ll t=2;t&lt;=m;t++) s=s*t%MOD; return ans*inv(s)%MOD; &#125; ll a[30]; int bin[30]; void main() &#123; bin[0]=1;for(int i=1;i&lt;30;i++) bin[i]=bin[i-1]&lt;&lt;1; int n;ll m;scanf("%d%I64d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%I64d",&amp;a[i]); ll ans=0; for(int s=0;s&lt;=bin[n]-1;s++) &#123; int num=0; ll M=n-1,N=(ll)n-1+m;//debug n转longlong for(int i=0;i&lt;=n-1;i++) if(s&amp;bin[i]) N-=a[i+1]+1,num++;//debug a[i] if(num&amp;1) ans-=C(M,N); else ans+=C(M,N); ans%=MOD; &#125; printf("%I64d",(ans+MOD)%MOD); &#125;&#125;;int main()&#123; mine::main();&#125; 14 POI2007 ZAP-Queries8.16 难度1请先思考后再展开 莫比乌斯反演裸题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAXNUM=51000; bool v[MAXNUM]; int pr=0,prime[MAXNUM]; int mu[MAXNUM]; void pre() &#123; mu[1]=1; for(int i=2;i&lt;MAXNUM;i++) &#123; if(!v[i]) prime[++pr]=i,mu[i]=-1; for(int j=1;j&lt;=pr and (ll)i*prime[j]&lt;MAXNUM;j++) &#123; v[i*prime[j]]=1; if(i%prime[j]==0) &#123;mu[i*prime[j]]=0;break;&#125; mu[i*prime[j]]=-mu[i]; &#125; &#125; for(int i=2;i&lt;MAXNUM;i++) mu[i]+=mu[i-1]; &#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; void main() &#123; pre(); int q;scanf("%d",&amp;q); while(q--) &#123; int a,b,d;scanf("%d%d%d",&amp;a,&amp;b,&amp;d); int n=a/d,m=b/d;if(n&gt;m) swap(n,m); ll ans=0; for(ll d=1;d&lt;=n;) &#123; int lst=mymin(n/(n/d),m/(m/d)); ans+=ll(mu[lst]-mu[d-1])*(n/d)*(m/d); d=lst+1; &#125; printf("%lld\n",ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 15 3801 Rainbow的信号8.16 难度2请先思考后再展开 求期望位运算的特性在于，不同的二进制位之间没有影响所以为了方便统计，先枚举每一个位，然后分类讨论 线性枚举r①and如果出现了0，就是0那么最后一个0把前面l的取值范围分成两半，其中只有后面的部分有贡献所以记录一下lst0②or如果出现1，就是1和and同理，记录lst1③xor这个稍微麻烦一些，因为取值涉及到1出现个数的奇偶性那么把按照1的出现次数，分奇偶，形成交替的区间那么只有贡献为奇数的区间是有用的用c0、c1分别记录偶数区间和奇数区间的总长度即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; #define double long double int bin[40]; int a[110000]; void main() &#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); double xor1=0,and1=0,or1=0; for(int k=0;k&lt;=29;k++) &#123; int lst0=0,lst1=0;//上一个 int c1=0,c0=0;//奇偶区间 for(int r=1;r&lt;=n;r++) &#123; int now=a[r]&amp;bin[k]; //l=r if(now) xor1+=bin[k],and1+=bin[k],or1+=bin[k]; //l&lt;r if(now) &#123; xor1+=2.0*c0*bin[k]; and1+=2.0*(r-lst0-1)*bin[k];//lst0+1~r or1+=2.0*(r-1)*bin[k];//1~lst1 &#125; else &#123; xor1+=2.0*c1*bin[k]; or1+=2.0*lst1*bin[k];//1~lst1 &#125; //update if(now) lst1=r; else lst0=r; if(now) swap(c1,c0),c1++; else c0++; &#125; &#125; printf("%.3Lf %.3Lf %.3Lf",xor1/n/n,and1/n/n,or1/n/n); &#125;&#125;;int main()&#123; mine::main();&#125; 16 3802 绿豆蛙的归宿8.16 难度2请先思考后再展开 期望的线性性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; const int MAXN=110000,MAXM=210000; struct Nod &#123; int hou; int ru; int backup; Nod() &#123; hou=ru=0; &#125; &#125;p[MAXN]; struct Edge &#123; int y,c,g; &#125;e[MAXM]; int ln=0; void ins(int x,int y,int c) &#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; p[y].ru++; &#125; double E[MAXM]; int sta[MAXN]; void topsort(int st) &#123; int top=0;sta[++top]=st; while(top&gt;0) &#123; int x=sta[top--]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; p[y].ru--; E[y]+=(E[x]+e[k].c)/p[y].backup; if(!p[y].ru) sta[++top]=y; &#125; &#125; &#125; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); ins(b,a,c); &#125; for(int i=1;i&lt;=n;i++) p[i].backup=p[i].ru; topsort(n); printf("%.2lf",E[1]); &#125;&#125;;int main()&#123; mine::main();&#125; 17 3803 扑克牌8.16 难度2请先思考后再展开 本来写的是倒着dp，好像被卡边界了结果tm改成记忆化搜索就过了？？1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; double mymin(double x,double y) &#123;return x&lt;y?x:y;&#125; int A,B,C,D; double f[20][20][20][20][5][5]; bool v[20][20][20][20][5][5]; double dp(int a,int b,int c,int d,int x,int y) &#123; if(v[a][b][c][d][x][y]) return f[a][b][c][d][x][y]; v[a][b][c][d][x][y]=1; double &amp;ans=f[a][b][c][d][x][y]; int aa=a+(x==1)+(y==1),bb=b+(x==2)+(y==2),cc=c+(x==3)+(y==3),dd=d+(x==4)+(y==4); if(aa&gt;=A and bb&gt;=B and cc&gt;=C and dd&gt;=D) return ans=0; int left=54-aa-bb-cc-dd; if(a&lt;13) ans+=(dp(a+1,b,c,d,x,y)+1)*(13-a)/left; if(b&lt;13) ans+=(dp(a,b+1,c,d,x,y)+1)*(13-b)/left; if(c&lt;13) ans+=(dp(a,b,c+1,d,x,y)+1)*(13-c)/left; if(d&lt;13) ans+=(dp(a,b,c,d+1,x,y)+1)*(13-d)/left; if(x==0) &#123;double mi=1000;for(int i=1;i&lt;=4;i++) &#123;mi=mymin(mi,dp(a,b,c,d,i,y));&#125;ans+=(mi+1)/left;&#125; if(y==0) &#123;double mi=1000;for(int i=1;i&lt;=4;i++) &#123;mi=mymin(mi,dp(a,b,c,d,x,i));&#125;ans+=(mi+1)/left;&#125; return ans; &#125; void main() &#123; scanf("%d%d%d%d",&amp;A,&amp;B,&amp;C,&amp;D); int p1=(A&gt;13)?A-13:0,p2=(B&gt;13)?B-13:0,p3=(C&gt;13)?C-13:0,p4=(D&gt;13)?D-13:0; if(p1+p2+p3+p4&gt;2) puts("-1.000"); else printf("%.3lf",dp(0,0,0,0,0,0)); &#125;&#125;;int main()&#123; mine::main();&#125; 18 poj2311 Cutting Game8.17 难度2请先思考后再展开 博弈不过，如果出现(1,1)，并定义为必败态，本身没有问题但考虑只有一行或一列的情况，会把两个有向图游戏异或起来，然后对方就会“努力翻盘”，导致本来游戏早就结束，却被“莫名其妙翻盘了”所以要跳过这些状态，并早点判断出必败态：(2,2)和(2,3)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; int sg[210][210]; bool v[210][210]; bool b[410];//每次产生不同，最多只有400个 int SG(int n,int m) &#123; if(n&gt;m) swap(n,m); if(v[n][m]) return sg[n][m]; v[n][m]=1; if(n==1 and m==1) return sg[n][m]=0; //if(n==2 and m==2) return sg[n][m]=0; //if(n==2 and m==3) return sg[n][m]=0; memset(b,0,sizeof b); for(int k=2;k&lt;=n-2;k++) b[ SG(k,m)^SG(n-k,m) ]=1; for(int k=2;k&lt;=m-2;k++) b[ SG(n,k)^SG(n,m-k) ]=1; int now=0;while(b[now]) now++; return sg[n][m]=now; &#125; void main() &#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)!=EOF) &#123; if(SG(n,m)&gt;0) puts("WIN"); else puts("LOSE"); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 0x3B 数学练习题目 19 SDOI2012 Longge的问题8.17 难度2请先思考后再展开 按照反素数的思路，只考虑前面几个素数，按照约数个数公式dfs最终得出，在int范围内约数最多约1500个 那么，如果枚举约数s，把它作为gcd的结果$\sum s \times 【gcd(1 \to n,n)=s的个数】$$\sum s \times 【gcd(1 \to n/s)=1的个数】$$\sum s \times \varphi (n/s)$12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; ll phi(ll x) &#123; ll ans=x; for(ll t=2;t*t&lt;=x;t++) &#123; if(x%t!=0) continue; while(x%t==0) x/=t; ans=ans/t*(t-1); &#125; if(x&gt;1) ans=ans/x*(x-1); return ans; &#125; void main() &#123; ll n;scanf("%lld",&amp;n); ll ans=0; for(ll k=1;k*k&lt;=n;k++) &#123; if(n%k!=0) continue; ans+=k*phi(n/k); if(k*k!=n) ans+=n/k*phi(k); &#125; printf("%lld",ans); &#125;&#125;;int main()&#123; mine::main();&#125; 20 bzoj1477 poj1061 青蛙的约会8.17 难度1请先思考后再展开 同余方程组裸题t(n-m)+kL=x-y1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y) &#123; if(b==0) &#123;x=1,y=0;return a;&#125; ll tx,ty;ll d=exgcd(b,a%b,tx,ty); x=ty;y=tx-(a/b)*ty; return d; &#125; void main() &#123; ll x,y,m,n,L;scanf("%lld%lld%lld%lld%lld",&amp;x,&amp;y,&amp;m,&amp;n,&amp;L); ll A=n-m,B=L,K=x-y; ll tx,ty; ll d=exgcd(A,B,tx,ty);//t(n-m)+kL=x-y if(K%d!=0) puts("Impossible"); else &#123; tx=tx*(K/d); ll t=B/d; printf("%lld",(tx%t+t)%t); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 21 3B04 Xiao 9*大战朱最学8.17 难度1请先思考后再展开 同余方程组裸题12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y) &#123; if(b==0) &#123;x=1,y=0;return a;&#125; ll tx,ty;ll d=exgcd(b,a%b,tx,ty); x=ty;y=tx-(a/b)*ty; return d; &#125; void main() &#123; int n;scanf("%d",&amp;n); ll a1,b1;scanf("%lld%lld",&amp;a1,&amp;b1); for(int i=2;i&lt;=n;i++) &#123; ll a2,b2;scanf("%lld%lld",&amp;a2,&amp;b2); ll A=a1,B=a2,K=b2-b1; ll k1,k2;ll d=exgcd(A,B,k1,k2); k1=k1*(K/d); ll t=B/d;k1=(k1%t+t)%t; b1=k1*a1+b1; a1=a1*a2; &#125; printf("%lld",b1); &#125;&#125;;int main()&#123; mine::main();&#125; 22 SDOI2011 计算器8.17 难度2请先思考后再展开 裸题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; ll qpower(ll x,ll e,ll MOD) &#123; ll ans=1;x%=MOD; while(e&gt;0) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y) &#123; if(b==0) &#123;x=1,y=0;return a;&#125; ll tx,ty;ll d=exgcd(b,a%b,tx,ty); x=ty;y=tx-(a/b)*ty; return d; &#125; void solve2(ll A,ll B,ll K) &#123; ll x,y;ll d=exgcd(A,B,x,y); if(K%d!=0) puts("Orz, I cannot find x!"); else &#123; x*=(K/d); ll t=B/d; printf("%lld\n",(x%t+t)%t); &#125; &#125; map&lt;ll,ll&gt; hash; void solve3(ll A,ll z,ll MOD) &#123; if(A%MOD==0) &#123;puts("Orz, I cannot find x!");return;&#125;//debug A%=MOD;z%=MOD; hash.clear(); ll t=ceil(sqrt( (double)MOD )); ll now=z;for(ll b=0;b&lt;=t;b++) hash[now]=b,now=now*A%MOD; ll tmp=qpower(A,t,MOD); now=tmp; for(ll a=1;a&lt;=t;a++) &#123; if(hash.count(now)) &#123;printf("%lld\n",a*t-hash[now]);return;&#125; now=now*tmp%MOD; &#125; puts("Orz, I cannot find x!"); &#125; void main() &#123; int T,k;scanf("%d%d",&amp;T,&amp;k); while(T--) &#123; ll y,z,p;scanf("%lld%lld%lld",&amp;y,&amp;z,&amp;p); if(k==1) printf("%lld\n",qpower(y,z,p)); else if(k==2) solve2(y,p,z); else solve3(y,z,p); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 23 hdu5015 233 Matrix8.17 难度1请先思考后再展开 矩阵乘法裸题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const ll MOD=10000007; struct Matrix &#123; ll a[30][30]; Matrix() &#123;memset(a,0,sizeof a);&#125; &#125;; const int N=20; Matrix pre() &#123; Matrix ans; for(int i=0;i&lt;=N;i++) ans.a[i][i]=1; return ans; &#125; Matrix cheng(Matrix a,Matrix b) &#123; Matrix ans; for(int i=0;i&lt;=N;i++) for(int j=0;j&lt;=N;j++) for(int k=0;k&lt;=N;k++) ans.a[i][j]=(ans.a[i][j]+a.a[i][k]*b.a[k][j]%MOD)%MOD; return ans; &#125; Matrix qpower(Matrix x,int e) &#123; Matrix ans=pre(); while(e&gt;0) &#123; if(e&amp;1) ans=cheng(ans,x); x=cheng(x,x);e&gt;&gt;=1; &#125; return ans; &#125; void main() &#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)!=EOF) &#123; Matrix st;st.a[0][0]=0; for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;st.a[i][0]); st.a[++n][0]=233;st.a[++n][0]=1; Matrix op; for(int i=0;i&lt;=n-2;i++) &#123; for(int j=1;j&lt;=i;j++) op.a[i][j]=1; op.a[i][n-1]=1; &#125; op.a[n-1][n-1]=10;op.a[n-1][n]=3;//233=&gt;2333 op.a[n][n]=1;//1=&gt;1 st=cheng(qpower(op,m),st); printf("%lld\n",st.a[n-2][0]); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 24 poj2947 Widget Factory8.18 难度1请先思考后再展开 带模数的高斯消元123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; int qpower(int x,int e,int MOD) &#123; int ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; int inv(int x,int MOD) &#123;return qpower(x,MOD-2,MOD);&#125; int a[310][310],b[310],MOD=7; bool iszero(int x,int m) &#123; for(int i=1;i&lt;=m;i++) if(a[x][i]) return 0; return 1; &#125; void gauss(int n,int m) &#123; int tot=0; for(int i=1;i&lt;=m;i++)//目标 &#123; int nx=-1; for(int j=tot+1;j&lt;=n;j++) if(a[j][i]) &#123;nx=j;break;&#125; if(nx&lt;0) continue; tot++;swap(b[tot],b[nx]);for(int k=1;k&lt;=m;k++) swap(a[tot][k],a[nx][k]); for(int j=1;j&lt;=n;j++) &#123; if(tot==j or !a[j][i]) continue; int x=a[j][i],y=a[tot][i]; for(int k=1;k&lt;=m;k++) &#123; a[tot][k]=a[tot][k]*x%MOD; a[j][k]=a[j][k]*y-a[tot][k]; a[j][k]=(a[j][k]%MOD+MOD)%MOD; &#125; b[tot]=b[tot]*x%MOD; b[j]=b[j]*y%MOD-b[tot]; b[j]=(b[j]%MOD+MOD)%MOD; &#125; &#125; for(int i=1;i&lt;=n;i++) if(iszero(i,m) and b[i]!=0) &#123;puts("Inconsistent data.");return;&#125; if(tot!=m) &#123;puts("Multiple solutions.");return;&#125; for(int i=1;i&lt;=m-1;i++) &#123;int t=b[i]*inv(a[i][i],MOD)%MOD;printf("%d ",t&gt;=3?t:t+7);&#125; int t=b[m]*inv(a[m][m],MOD)%MOD;printf("%d\n",t&gt;=3?t:t+7);//debug 题目条件，3~9 &#125; char s[20]; int getday() &#123; scanf("%s",s+1); if(s[1]=='M') return 1;//MON if(s[3]=='E') return 2;//TUE if(s[1]=='W') return 3;//WED if(s[2]=='H') return 4;//THU if(s[1]=='F') return 5;//FRI if(s[2]=='A') return 6;//SAT return 7; &#125; void main() &#123; while(1) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); if(n==0 and m==0) break; memset(a,0,sizeof a);//debug for(int i=1;i&lt;=m;i++) &#123; int k;scanf("%d",&amp;k); int t1=getday(),t2=getday(); b[i]=((t2-t1+1)%MOD+MOD)%MOD; while(k--) &#123; int t;scanf("%d",&amp;t); a[i][t]=(a[i][t]+1)%MOD; &#125; &#125; gauss(m,n); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 25 WC2011 最大XOR和路径8.18 难度2请先思考后再展开 这道神题的关键在于 利用异或的抵消性质当然交换、结合律也稍微要用到 对于一个路径，其实就是由链和在上面重叠的环组成这样以后，你会发现，能对最终答案产生影响的就是一条链和几个环因为对于重叠的部分或者为了到达环而经过的边（如果原路返回）被自己抵消了因为这是一个无向图，如果有多条可选的链，而最优的不是这一条，那当前这一条和它组成了一个环，所以说枚举环的时候异或一下，自己就又被抵消了，变成了那条链 所以说，随便找一个链，找一些环放上去，让异或和最大想到异或和会想到线性基那怎么找环呢？dfs去找不难想到，但枚举起点复杂度过高其实直接从1开始就好了，对于一个结束的环，可以把当前值异或从起点到这里的代价这样又抵消掉了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAXN=51000; ll bin[61]; ll bs[61]; void insert(ll now) &#123; for(int i=60;i&gt;=0;i--) if(now&amp;bin[i]) &#123; if(bs[i]&lt;0) &#123; bs[i]=now; for(int j=60;j&gt;i;j--) if(bs[j]&amp;bin[i]) bs[j]^=now;//回代 break; &#125; else now^=bs[i]; &#125; &#125; struct Nod &#123; int hou; bool v; ll sum; Nod() &#123; hou=0; sum=0; v=0; &#125; &#125;p[MAXN]; struct Edge &#123; int y,g; ll c; &#125;e[MAXN*4]; int ln=0; void ins(int x,int y,ll c) &#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; &#125; void dfs(int x,ll now) &#123; p[x].v=1;p[x].sum=now; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].v) insert(now^e[k].c^p[y].sum); else dfs(y,now^e[k].c); &#125; &#125; ll solve(ll now) &#123; for(int i=60;i&gt;=0;i--) if(bs[i]&gt;=0 and (now^bs[i])&gt;now) now=now^bs[i]; return now; &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;=60;i++) bin[i]=bin[i-1]&lt;&lt;1; int n,m;scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; int x,y;ll c;scanf("%d%d%lld",&amp;x,&amp;y,&amp;c); ins(x,y,c);ins(y,x,c); &#125; memset(bs,-1,sizeof bs); dfs(1,0); printf("%lld",solve(p[n].sum)); &#125;&#125;;int main()&#123; mine::main();&#125; 26 CQOI2013 新Nim游戏8.19 难度2请先思考后再展开 根据博弈的基本知识，普通nim游戏在异或和=0的时候必败，否则必胜那么只要能确保后手无法在第二回合把异或和变成0，那么就胜利 异或和基本上就和线性基有关了，主要是因为，对于异或线性基，其异或空间除了0，其他的表示方法中每个元素最多用一次 什么情况下，能够把异或和变成0？就是在某一次插入x中，发现无法插入因为这意味着，里面的东西能够表示出x这个时候，当前线性基 xor x=0，后手只要把后面取走就好了我们的应对策略是把x取走（因为线性基内部，无法表示出0，否则违背定义） 那怎么求第一问，让取走的东西总数最小呢？有一个精妙的贪心：按照从大到小考虑这个可以用微扰证明，如果某个位置能用小也能用大，我们用了大，不会让答案更差，因为线性基能否插入和其他位置无关1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; int bin[40]; int bs[40]; bool insert(int now) &#123; for(int i=40;i&gt;=0;i--) if(now&amp;bin[i]) &#123; if(bs[i]&lt;0) &#123;bs[i]=now;return 1;&#125; now^=bs[i]; &#125; return 0; &#125; int a[110]; void main() &#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; memset(bs,-1,sizeof bs); int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); sort(a+1,a+n+1); ll ans=0,sum=0; for(int i=n;i&gt;=1;i--) &#123; sum+=a[i]; if(!insert(a[i])) ans+=a[i]; &#125; if(ans==sum) puts("-1"); else printf("%lld",ans); &#125;&#125;;int main()&#123; mine::main();&#125; Sdoi2016 排列计数8.29 难度2请先思考后再展开 同学提醒这道题漏掉了……所以就没有编号了 把其中m个固定后，剩下的就是错排发现题目要求的是$C_n^m \times D_{n-m}$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=1100000; const ll INF=0x3f3f3f3f; const ll MOD=1e9+7; ll fac[MAX_N]; ll D[MAX_N]; ll qpower(ll x,ll e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll x) &#123;return qpower(x,MOD-2);&#125; ll C(int n,int m) &#123;return fac[n]*inv(fac[m])%MOD*inv(fac[n-m])%MOD;&#125; void main() &#123; fac[0]=1;for(int i=1;i&lt;MAX_N;i++) fac[i]=fac[i-1]*i%MOD; D[0]=1;D[1]=0;D[2]=1;for(int i=3;i&lt;MAX_N;i++) D[i]=(D[i-1]+D[i-2])%MOD*(i-1)%MOD; int T;scanf("%d",&amp;T); while(T--) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); printf("%lld\n",C(n,m)*D[n-m]%MOD); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 27 poj3904 Sky Code8.20 难度1请先思考后再展开 莫反裸题一开始没想到F(d)那么好求……复杂度$O(n \sqrt n)$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; ll C(ll n)//C(4,n) &#123; return n*(n-1)*(n-2)*(n-3)/24; &#125; const int MAXNUM=11000; bool v[MAXNUM]; int pr=0,prime[MAXNUM]; int mu[MAXNUM]; void pre() &#123; mu[1]=1; for(int i=2;i&lt;MAXNUM;i++) &#123; if(!v[i]) prime[++pr]=i,mu[i]=-1; for(int j=1;j&lt;=pr and (ll)i*prime[j]&lt;MAXNUM;j++) &#123; v[i*prime[j]]=1; if(i%prime[j]==0) &#123;mu[i*prime[j]]=0;break;&#125; mu[i*prime[j]]=-mu[i]; &#125; &#125; &#125; int fd[MAXNUM]; void main() &#123; pre(); int n; while(scanf("%d",&amp;n)!=EOF) &#123; memset(fd,0,sizeof fd); for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); for(int j=1;j*j&lt;=t;j++) &#123; if(t%j!=0) continue; fd[j]++; if(j*j!=t) fd[t/j]++; &#125; &#125; ll ans=0; for(int i=1;i&lt;=10000;i++) ans+=mu[i]*C(fd[i]); printf("%lld\n",ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 28 3B13/CF167B/bzoj4636 守卫者的挑战8.20 难度1请先思考后再展开 概率dp裸题但是有很多细节，中文题目不是很清楚 必须n个都尝试过，最后再离开 某一时刻可以装不下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; double f[210][210][410]; //f(i,vec,k)=【i次开始之前，赢了vec次，当前背包剩余空间为k-200】的概率 int p[210],a[210]; void main() &#123; int n,L,K;scanf("%d%d%d",&amp;n,&amp;L,&amp;K); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); if(K&gt;200) K=200;//debug f[1][0][200+K]=1; for(int i=1;i&lt;=n;i++) for(int vec=0;vec&lt;=i-1;vec++) for(int bg=-200;bg&lt;=200;bg++) &#123; f[i+1][vec+1][200+mymin(bg+a[i],200)]+=f[i][vec][200+bg]*p[i]/100; f[i+1][vec][200+bg]+=f[i][vec][200+bg]*(100-p[i])/100;//fail &#125; double ans=0; for(int i=L;i&lt;=n;i++) for(int j=0;j&lt;=200;j++) ans+=f[n+1][i][200+j]; printf("%.6lf",ans); &#125;&#125;;int main()&#123; mine::main();&#125; 29 poj2976 Dropping tests8.20 难度2请先思考后再展开 01分数规划裸题浮点二分果然练得还是太少了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAXN=1100; const double eps=1e-4; int n,k; ll a[MAXN],b[MAXN]; double tmp[MAXN]; bool check(double L) &#123; for(int i=1;i&lt;=n;i++) tmp[i]=(double)a[i]-L*b[i]; sort(tmp+1,tmp+n+1); double sum=0; for(int i=k+1;i&lt;=n;i++) sum+=tmp[i]; return sum&gt;=0; &#125; void main() &#123; while(1) &#123; scanf("%d%d",&amp;n,&amp;k);if(n==0 and k==0) break; for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]),a[i]*=100; for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;b[i]); double l=0,r=100,ans=-1; while(l&lt;=r+eps)//l&lt;r &#123; double mid=(l+r)/2; if(check(mid)) ans=mid,l=mid+eps; else r=mid-eps; &#125; printf("%d\n",int(round(ans))); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 30 poj1704 Georgia and Bob8.20 难度2请先思考后再展开 这是一道传说中的阶梯博弈其实就是转化为nim游戏 首先，把两堆石子两两捆绑（奇数堆的时候，把第1堆和边界0捆绑）然后如果每组石子内部，后面的向前移，最多移动就是空格数量所以如果不考虑前面那个的移动情况，就是一个nim游戏 所以对于先手，如果他是赢家，一定按照nim来这个时候如果后手突然移动前面，那么先手把后面那个等距离向前移动，就能还原出相同局面，而且一定能实现而如果先手是输家，那么和上面同理无法改变结局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; int sg[11000]; bool v[11000]; bool b[11000]; int SG(int x) &#123; if(v[x]) return sg[x]; v[x]=1; memset(b,0,sizeof b); for(int y=0;y&lt;=x-1;y++) b[SG(y)]=1; int now=0;while(b[now]) now++; return sg[x]=now; &#125; int a[1100]; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); sort(a+1,a+n+1); int now=0; if(n%2==1) &#123; for(int i=1;i&lt;=n;i+=2) now^=SG(a[i]-a[i-1]-1); &#125; else &#123; for(int i=2;i&lt;=n;i+=2) now^=SG(a[i]-a[i-1]-1); &#125; if(now&gt;0) puts("Georgia will win"); else puts("Bob will win"); &#125; &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷18年7月月赛比赛总结]]></title>
    <url>%2Fposts%2Fb37c.html</url>
    <content type="text"><![CDATA[洛谷18年7月月赛比赛总结题目 比赛经历先把第一题做了然后第二题wa了几次，蹲坑的时候忽然灵光一现想到了漏洞……然后就挂机了……和以前没什么区别 T1_Analysis请先思考后再展开 先离散化一下，统计每个数出现个数如果剩下一个的时候，判断素数即可 看了题解发现原来我的代码是有漏洞的没有考虑，最后没有数字的情况（没有把t初始化为1），然后居然ac了 T1_Code_原请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;bool isprime(ll x)&#123; if(x&lt;=1) return 0; if(x==2) return 1; for(ll i=2;i*i&lt;=x;i++) if(x%i==0) return 0; return 1;&#125;struct Nod&#123; ll d; int p;&#125;a[MAXN*2],b[MAXN*2];bool cmp(Nod x,Nod y) &#123;return x.d&lt;y.d;&#125;ll yz[MAXN*2];//oldint mx;int n,m;void lsh()&#123; memcpy(b,a,sizeof a); sort(b+1,b+n+m+1,cmp); mx=1;yz[mx]=b[1].d;a[b[1].p].d=mx; for(int i=2;i&lt;=n+m;i++) &#123; if(b[i-1].d!=b[i].d) mx++; yz[mx]=b[i].d;a[b[i].p].d=mx; &#125;&#125;int c[MAXN*2];bool check()&#123; bool bk=0; ll t;//这里应该改成1 for(int i=1;i&lt;=mx;i++) &#123; if(c[i]&gt;0) &#123; if(bk==0) &#123; if(c[i]&gt;1) return 0; bk=1,t=yz[i]; &#125; else if(bk) return 0; &#125; &#125; //printf("mx=%d\n",mx); return isprime(t);&#125;int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i].d),a[i].p=i; for(int i=1;i&lt;=m;i++) scanf("%lld",&amp;a[n+i].d),a[n+i].p=n+i; lsh(); memset(c,0,sizeof c); for(int i=1;i&lt;=n;i++) if(yz[a[i].d]&gt;1) c[a[i].d]++; for(int i=n+1;i&lt;=n+m;i++) if(yz[a[i].d]&gt;1) c[a[i].d]--; if(check()) puts("YES"); else puts("NO"); &#125;&#125; T2_Analysis请先思考后再展开 一眼贪心模拟显然碰到连续两个跳过的点，就失败但是一开始写成了【连续两个小段失败】，其实可能只是跳过中间那个点就行还有一个细节漏了，就是不能跳过m-1 T2_Code_原请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int n,m,s;int w[MAXN];bool v[MAXN];int ans[MAXN],tot=0;bool check()&#123; int now=0; bool fail=0; int nx=1; while(now&lt;m+1) &#123; int dis=w[nx]-w[now]; if(dis&lt;s) &#123; if(nx==m+1 or fail) return 0; fail=1; nx++; &#125; else &#123; now=nx; nx++; v[now]=1; ans[++tot]=now; fail=0; &#125; &#125; while(now&gt;0) &#123; int nx=now-1;while(nx&gt;0 and v[nx]) nx--; int dis=w[now]-w[nx]; if(dis&lt;s) return 0; v[nx]=1; now=nx; ans[++tot]=now; &#125; for(int i=0;i&lt;=m+1;i++) if(!v[i]) return 0; puts("YES"); for(int i=1;i&lt;=tot;i++) printf("%d ",ans[i]); return 1;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;s); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;w[i]); w[0]=0;w[m+1]=n; if(!check()) puts("NO");&#125; T3_Analysis请先思考后再展开 当时想了1h都没有思路只是想到通过差分和贪心，面对一个局面时可以线性地判断然后就在想方设法【线性扫时间，通过利用残留信息logn判断】然后就实在想不到什么残留信息可以用…… 强行伏笔：一直奇怪那个r给出来有什么用（可能是用来迷惑人的？）然后题目下面一大堆限制条件，以为只是用来手算范围的其实有一个隐藏的特性：$R_i&gt;=i$所以说一次成功后，后面的都能成功，也就是满足二分性（不一定是一个完美的函数，但最后一定都是成功）（让我联想到化学反应的结束图像） 实话说我经常会这样害怕毒瘤题面 T3_Code_std请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=510000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int n,m,k,mx;int a[MAXN],c[MAXN];struct Nod&#123; int w,x,v;&#125;b[MAXN];int check(int mid)&#123; memcpy(c,a,sizeof a); for(int i=1;i&lt;=mid;i++) c[b[i].x]-=b[i].v,c[b[i].x+1]+=b[i].v; int ans=0,tot=0; for(int i=1;i&lt;=n;i++) &#123; tot+=c[i]; if(tot&lt;1) &#123; ans+=(1-tot); c[i]+=(1-tot); if(i+k&lt;=n) c[i+k]-=(1-tot);//debug 2分的小细节！ tot+=(1-tot); &#125; &#125; return ans;&#125;int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;mx); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=n;i&gt;=1;i--) a[i]-=a[i-1];//差分 for(int i=1;i&lt;=mx;i++) &#123;int t;scanf("%d",&amp;t);&#125; for(int i=1;i&lt;=m;i++) scanf("%d%d%d",&amp;b[i].w,&amp;b[i].x,&amp;b[i].v); b[m+1].w=INF; int ans; int l=0,r=m; while(l&lt;=r) &#123; int mid=(l+r)/2; int tot=check(mid); if(tot&gt;=b[mid+1].w) l=mid+1; else ans=tot,r=mid-1; &#125; printf("%d",ans);&#125; T4_Analysis请先思考后再展开 有关区间最小值，有这样一个套路:先用一个递减的单调栈，分别从前往后和从后往前，求出l[i]和r[i]表示第一个比a[i]大的位置，则l[i]+1~r[i]-1中间，用到的最大值都是a[i] 考虑枚举这个最大值位置，然后枚举左右中数量少的那一边的端点这样另一个端点的取值范围就确定了，静态主席树即可，当然树状数组+离散化+二分查找也行。这样做的话读者可能认为复杂度是$O(n^2 log_2 n)$的，无异于【预处理st表+暴力枚举端点】的复杂度 然鹅，这种做法的复杂度其实是$O(n log_2^2 n)$的证明：对于每个i，它能够把l[i]~r[i]分成两半，分出来后，下一层级的j不能跨越出去所以说每次选取少的那一边，$枚举量 \leq log_2 n$换句话说，这些查询区间的总量是nlogn个，可以用set查重 至于空间，如果用树状数组或者线段树，不离散化的话，复杂度是m至于主席树，因为是静态的，前缀和形式，动态开点则变成nlogm，大大降低 debug:有一个漏洞，就是相同的数会多次作为最大值我的想法灰常暴力：set判重，不影响复杂度，由于区间不多，空间也不大而优秀的rose就有更劲的方法：全覆盖时强行保证只用最左边的具体而言，左边延伸到比x大或相等的，右边延伸到比x大的这样它们右端点相通，但左端点不会重复覆盖 T4_Code_std请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int dd[MAXN],top;//存储位置int n;int a[MAXN],l[MAXN],r[MAXN];//debug l和r定义不同，确保最大值中只用最左边那个！void pre_lr()&#123; //debug l[i]-1是&gt;=a[i]的 top=1;dd[top]=1;l[1]=1; for(int i=2;i&lt;=n;i++) &#123; while(top&gt;0 and a[dd[top]]&lt;a[i]) top--; l[i]=(top&gt;0)?dd[top]+1:1;//debug 可能空 dd[++top]=i; &#125; //debug r[i]+1是&gt;a[i]的 top=1;dd[top]=n;r[n]=n; for(int i=n-1;i&gt;=1;i--) &#123; while(top&gt;0 and a[dd[top]]&lt;=a[i]) top--; r[i]=(top&gt;0)?dd[top]-1:n;//debug 可能空 dd[++top]=i; &#125;&#125;struct Nod&#123; int lc,rc; int c; Nod() &#123; lc=rc=0; c=0; &#125;&#125;p[MAXN*40];int rt[MAXN];int id=0;void add(int &amp;x,int l,int r,int d,int o)&#123; if(l&gt;r) return; if(!x) x=++id; p[x].c+=o; if(l==r) return; int mid=(l+r)/2; if(d&lt;=mid) add(p[x].lc,l,mid,d,o); else add(p[x].rc,mid+1,r,d,o);&#125;void merg(int x,int &amp;y)&#123; if(x==0) return; if(y==0) &#123;y=x;return;&#125; p[y].c+=p[x].c; merg(p[x].lc,p[y].lc); merg(p[x].rc,p[y].rc);&#125;int calc(int x,int l,int r,int d)//&lt;=d&#123; if(l&gt;r or x==0) return 0; if(l==r and l==d) return p[x].c; int lc=p[x].lc,rc=p[x].rc,mid=(l+r)/2; if(d&lt;=mid) return calc(lc,l,mid,d); else return p[lc].c+calc(rc,mid+1,r,d);&#125;const int MAXNUM=1000000000;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++) &#123; add(rt[i],1,MAXNUM,a[i],1); merg(rt[i-1],rt[i]); &#125; pre_lr(); ll ans=0; for(int mid=1;mid&lt;=n;mid++) &#123; int fl=l[mid],fr=r[mid]; if(mid-fl&lt;fr-mid)//left &#123; for(int i=fl;i&lt;=mid;i++) &#123; int d=a[mid]/a[i]; ans+=calc(rt[fr],1,MAXNUM,d)-calc(rt[mid-1],1,MAXNUM,d); &#125; &#125; else//right &#123; for(int j=mid;j&lt;=fr;j++) &#123; int d=a[mid]/a[j]; ans+=calc(rt[mid],1,MAXNUM,d)-calc(rt[fl-1],1,MAXNUM,d); &#125; &#125; &#125; printf("%lld",ans);&#125; T5_Analysis请先思考后再展开 看到“凸包”两个字就想跑……]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【USACO2009 NOV Gold】灯]]></title>
    <url>%2Fposts%2F3fa9.html</url>
    <content type="text"><![CDATA[Source and JudgeUSACO2009 NOV GoldBzoj1770Luogu2962 Problem【Description】贝希和她的闺密们在她们的牛棚中玩游戏。但是天不从人愿，突然，牛棚的电源跳闸了，所有的灯都被关闭了。贝希是一个很胆小的女生，在伸手不见拇指的无尽的黑暗中，她感到惊恐，痛苦与绝望。她希望您能够帮帮她，把所有的灯都给重新开起来！她才能继续快乐地跟她的闺密们继续玩游戏！牛棚中一共有N盏灯，编号为1到N。这些灯被置于一个灰常複杂的网络之中。有M条很神奇的无向边，每条边连接两盏灯。每盏灯上面都带有一个开关。当按下某一盏灯的开关的时候，这盏灯本身，还有所有有边连向这盏灯的灯的状态都会被改变。状态改变指的是：当一盏灯是开著的时候，这盏灯被关掉；当一盏灯是关著的时候，这盏灯被打开。问最少要按下多少个开关，才能把所有的灯都给重新打开。数据保证至少有一种按开关的方案，使得所有的灯都被重新打开。【Input】第一行：兩個空格隔開的整數：N和M。第二到第M+1行：每一行有兩個由空格隔開的整數，表示兩盞燈被一條無向邊連接在一起。 沒有一條邊會出現兩次。【Output】一個單獨的整數，表示要把所有的燈都打開時，最少需要按下的開關的數目。【Limited conditions】1 &lt;= N &lt;= 351 &lt;= M &lt;= 595【Sample input】5 61 21 34 23 42 55 3【Sample output】3【Sample explanation】一共有五盞燈。燈1、燈4和燈5都連接著燈2和燈3。按下在燈1、燈4和燈5上面的開關。 Record1h细节很多…… Analysis请先思考后再展开 高斯消元的做法以后再补吧现在讲讲怎么用折半搜索艹过去 其实其核心思想就是把指数暴力地拆开，低消耗地合并起来得到答案左边从起点过来，而右边则从终点过来，找到一个重叠状态（有时是对应状态，例如这道题是相反数）用其中一边去找另外一边记录下来的答案（小就用数组，大就存下来二分查找） 以这道题为例，随便分成两边，右边记录答案（用数组，存储从终点过来需要多少步）左边暴力后，找右边的相反数答案，相加即可 最后再反思点拨一下：虽然产生的状态是2^35量级的，但其不同状态数量只有2^17个人认为这也是折半搜索的精髓之体现 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=40;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int n,m;ll f[MAXN];ll ed;ll bin[MAXN];map&lt;ll,int&gt; mp;//leftint ans=INF;void dfs(int x,int step,ll now,bool right)&#123; if(now==ed) ans=mymin(ans,step);//debug else if(!right and x&gt;n/2) &#123; ll tmp=mp[now]; if(tmp==0 or tmp&gt;step) mp[now]=step; //if(!mp.count(now)) mp[now]=step; //else if(step&lt;mp[now]) mp[now]=step; &#125; else if(right and x&gt;n-1) &#123; if(mp.count(ed-now)) ans=mymin(ans,step+mp[ed-now]); &#125; else &#123; dfs(x+1,step,now,right); dfs(x+1,step+1,now^f[x],right); &#125;&#125;int main()&#123; bin[0]=1;for(int i=1;i&lt;=35;i++) bin[i]=bin[i-1]*2; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;=n-1;i++) f[i]=bin[i]; while(m--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); x--;y--;//debug f[x]+=bin[y];f[y]+=bin[x]; &#125; ed=bin[n]-1; dfs(0, 0,0,0); dfs(n/2+1,0,0,1); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
        <tag>难度2</tag>
        <tag>折半搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[佛山2015市选2比赛总结]]></title>
    <url>%2Fposts%2F88c1.html</url>
    <content type="text"><![CDATA[佛山2015市选2比赛总结题目 比赛经历看一遍题目发现是做过的题，但当时没有讲，做了和没做一样然后感觉当时多少分现在可能也差不多了【flag】一年过去sa依然不会，因为这不是noip的范围，然后省选计划还没到哪里……这就是所谓知识盲区吧，虽然知道但也没办法，手头上还有不少任务于是就安心爆零吧…… 评测经历T2的stl怎么fail了?少了40暴力分然后T3居然忘记删除输出调试了，少了20暴力分其实当时也想过要不要检查，但是今天本来就没多少分，不想检查了最后[0/100]+[10/100]+[0/100]+[0/100]=10/400两天差距甚大啊，直接加上了“倒数”两个字，变成了倒数rk2……%xgc今天翻盘遥遥领先 T1_Analysis请先思考后再展开 据说这是一道很套路的sg题目主要就是学会sg有个核心公式（以后补教程）$$sg(i)=mex { sg(i-j)|gcd(i,j)=1 }$$然后这个$gcd(i,i-j)=1$然后取值的话不太好想，但证明其正确性灰常简单如果是质数，sg=质数序数+1如果是合数，sg=sg(最小质因数)+1 然后按照套路（异或）起来就好了 T1_Code_std请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int MAXNUM=1000001;int pr=0,prime[100000];int sg[MAXNUM];bool v[MAXNUM];void pre()&#123; memset(v,1,sizeof v); sg[1]=1;//定义 for(int i=2;i&lt;MAXNUM;i++) &#123; if(v[i]) prime[++pr]=i,sg[i]=pr+1; for(int j=1;j&lt;=pr and i*prime[j]&lt;MAXNUM;j++) &#123; v[i*prime[j]]=0; sg[i*prime[j]]=sg[prime[j]];//最小的【与其互质】 if(i%prime[j]==0) break; &#125; &#125;&#125;int main()&#123; freopen("stone.in","r",stdin); freopen("stone.out","w",stdout); pre(); int T;scanf("%d",&amp;T); while(T--) &#123; int n;scanf("%d",&amp;n); int ans=0; for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); ans^=sg[t]; &#125; if(ans==0) puts("Bob"); else puts("Alice"); &#125;&#125; T2_Analysis请先思考后再展开 sam和sa都不会……hash好像也没什么必要吧反正弃了 T3_Analysis请先思考后再展开 主要思路是，进行了前面的第一轮后，就变成一个子问题找规律神题，细节很多，不想写 T4_Analysis请先思考后再展开 没人会的神题……]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[佛山2015市选1比赛总结]]></title>
    <url>%2Fposts%2F4bc4.html</url>
    <content type="text"><![CDATA[佛山2015市选1比赛总结题目 比赛经历先切了T3、T4，回头发现T1很简单，最后杠T2%akc，100分钟想完所有题然后码完巨大心理压力有木有然后rose和我一起杠T2，没什么想法，只能打个暴力 评测经历wocT4的MLE是什么鬼，一度心态爆炸，明明算过的原来是师兄空间只开了64mb最后[100/100]+[0/98]+[63/99]+[98/98]=261/395最后混了个初三rk2%ch文件名打错，实际比我高20,屈居rk3%lhp做过原题虐场，306全场最高 T1_Analysis请先思考后再展开 对于后面的点，没有人覆盖它，只能自己解决问题的从这些点入手，倒推即可 T1_Code_原请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=100;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int mp[MAXN][MAXN];char s[MAXN];int main()&#123; freopen("change.in","r",stdin); freopen("change.out","w",stdout); int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",s+1); for(int j=1;j&lt;=m;j++) mp[i][j]=s[j]-'0'; &#125; int ans=0; for(int i=n;i&gt;=1;i--) for(int j=m;j&gt;=1;j--) &#123; if(mp[i][j]) &#123; ans++; for(int a=1;a&lt;=i;a++) for(int b=1;b&lt;=j;b++) mp[a][b]=1-mp[a][b]; &#125; &#125; printf("%d",ans);&#125; T2_Analysis请先思考后再展开 这道题考的时候写了个暴力搜索+hash判重，然后成功炸空间其实这题的正解违背【数据范围自适应】定律：把矩阵的元素加起来…… 其实不是很会证明，但大概可以猜个结论？比如说因为总是偶数个，所以最优解不会有浪费？反正没分 然后一个价值30分的细节：有种情况是，点虽然独立，但没有边和它相连，这种情况的话是不算非法的……很难想到啊 T2_Code_原请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=60;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int n;struct Nod&#123; int mp[MAXN][MAXN]; int now,p;&#125;;set&lt;ull&gt; has;const ull base=131;bool bk;ull gethas(Nod x)&#123; ull ans=x.now; bk=1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; ans=ans*base+x.mp[i][j]; if(x.mp[i][j]!=0 and x.mp[i][j]&lt;=9) bk=0; &#125; return ans;&#125;queue&lt;Nod&gt; q;int bfs()&#123; while(!q.empty()) &#123; Nod now=q.front();q.pop(); int x=now.now; for(int y=1;y&lt;=n;y++) if(x!=y and now.mp[x][y]&lt;=9) &#123; Nod nx=now;nx.p=now.p+1;nx.now=y; if(nx.mp[x][y]&gt;0) nx.mp[x][y]--; ull hs=gethas(nx); if(bk) return nx.p; if(has.count(hs)) continue; has.insert(hs);q.push(nx); &#125; &#125; return -1;&#125;char str[MAXN];int main()&#123; freopen("snow.in","r",stdin); freopen("snow.out","w",stdout); int T;scanf("%d",&amp;T); while(T--) &#123; Nod st;st.p=0; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",str+1); for(int j=1;j&lt;=n;j++) &#123; st.mp[i][j]=str[j]-'0'; if(st.mp[i][j]==0) st.mp[i][j]=10; &#125; &#125; has.clear(); while(!q.empty()) q.pop(); q.push(st);has.insert( gethas(st) ); printf("%d\n",bfs()); &#125;&#125; T2_Code_std请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=60;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int fa[MAXN];int findfa(int x)&#123; if(fa[x]!=x) fa[x]=findfa(fa[x]); return fa[x];&#125;void join(int x,int y)&#123; int fx=findfa(x),fy=findfa(y); if(fx!=fy) fa[fx]=fy;&#125;int n;char str[MAXN];int main()&#123; freopen("snow.in","r",stdin); freopen("snow.out","w",stdout); int T;scanf("%d",&amp;T); while(T--) &#123; scanf("%d",&amp;n); int ans=0; for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=n;i++) &#123; scanf("%s",str+1); bool bk2=0; for(int j=1;j&lt;=n;j++) &#123; int t=str[j]-'0'; if(t&gt;0) ans+=t,join(i,j),bk2=1; &#125; if(!bk2) fa[i]=0;//debug 特判独立点 &#125; bool ok=1; int rt=findfa(1); for(int i=2;i&lt;=n;i++) if(findfa(i)!=rt and fa[i]&gt;0) ok=0; if(!ok) puts("-1"); else printf("%d\n",ans); &#125;&#125; T3_Analysis请先思考后再展开 一眼查分约束然后就被一个关键句卡了：“栋栋给的分数都是0到10000的正整数” 真的不知道怎么做了这道题其实题意也很不清晰呀弃了 T3_Code_原请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=11000,MAXM=410000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int n;struct Nod&#123; int hou; int dis; int ru; bool v; Nod() &#123; hou=v=0; ru=0; //dis=INF; dis=-INF; &#125;&#125;p[MAXN];struct Edge&#123; int y,g,c;&#125;e[MAXM];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln;&#125;queue&lt;int&gt; q;int spfa()&#123; q.push(1);p[1].dis=0;p[1].v=1;p[1].ru++; while(!q.empty()) &#123; int x=q.front();q.pop(); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dis&lt;p[x].dis+e[k].c) //if(p[y].dis&gt;p[x].dis+e[k].c) &#123; p[y].dis=p[x].dis+e[k].c; if(!p[y].v) &#123; p[y].v=1; q.push(y); p[y].ru++; if(p[y].ru&gt;n) return -1; &#125; &#125; &#125; p[x].v=0; &#125; return 1;&#125;int main()&#123; freopen("grade.in","r",stdin); freopen("grade.out","w",stdout); int m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; int a,b,x;scanf("%d%d%d",&amp;a,&amp;b,&amp;x); //ins(a,b,-x); ins(b,a,x); &#125; if(spfa()&lt;0) printf("impossible"); else printf("%d",p[n].dis);&#125; T4_Analysis请先思考后再展开 网络流即可记得要拆点！akc和hanks_o都忘记了 T4_Code_原请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=40;const int INF=0x3f3f3f3f;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int getid(int x,int y) &#123;return (x-1)*30+y;&#125;queue&lt;int&gt; q;int hou[5000];struct Edge&#123; int y,g,c; int oth;&#125;e[8000000];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=hou[x];hou[x]=ln; ln++; e[ln].y=x;e[ln].c=0; e[ln].g=hou[y];hou[y]=ln; e[ln-1].oth=ln;e[ln].oth=ln-1;&#125;int st,ed;int h[5000];bool bfs()&#123; memset(h,0,sizeof h);h[st]=1; q.push(st); while(!q.empty()) &#123; int x=q.front();q.pop(); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(e[k].c&gt;0 and h[y]==0) &#123; h[y]=h[x]+1; q.push(y); &#125; &#125; &#125; return h[ed]&gt;0;&#125;int dfs(int x,int f)&#123; if(x==ed) return f; int out=0; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(e[k].c&gt;0 and h[y]==h[x]+1 and out&lt;f) &#123; int tmp=dfs(y,mymin(f-out,e[k].c)); out+=tmp;e[k].c-=tmp;e[e[k].oth].c+=tmp; &#125; &#125; if(out==0) h[x]=0; return out;&#125;int n,m,k;int mp[MAXN][MAXN];struct Node&#123; int x,y,p; Node(int a=0,int b=0,int c=0) &#123;x=a,y=b,p=c;&#125;&#125;;queue&lt;Node&gt; q2;const int tx[4]=&#123;0,0,-1,1&#125;;const int ty[4]=&#123;-1,1,0,0&#125;;bool v[MAXN][MAXN];void make(int stx,int sty)&#123; memset(v,0,sizeof v); q2.push( Node(stx,sty,0) ); while(!q2.empty()) &#123; Node now=q2.front();q2.pop(); if(now.p&gt;=k) continue; int x=now.x,y=now.y; for(int t=0;t&lt;=3;t++) &#123; int nx=x+tx[t],ny=y+ty[t]; if(1&lt;=nx and nx&lt;=n and 1&lt;=ny and ny&lt;=m and !v[nx][ny]) &#123; if(mp[nx][ny]==1) q2.push( Node(nx,ny,now.p+1) ); if(mp[nx][ny]==3) ins(2000+getid(stx,sty),3000+getid(nx,ny),1); if(mp[nx][ny]==4) ins(getid(nx,ny),1000+getid(stx,sty),1); v[nx][ny]=1; &#125; &#125; &#125;&#125;char str[MAXN];int main()&#123; freopen("jobs.in","r",stdin); freopen("jobs.out","w",stdout); int T;scanf("%d",&amp;T); while(T--) &#123; ln=0;memset(hou,0,sizeof hou); scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",str+1); for(int j=1;j&lt;=m;j++) &#123; if(str[j]=='X') mp[i][j]=0; if(str[j]=='.') mp[i][j]=1; if(str[j]=='W') mp[i][j]=2; if(str[j]=='G') mp[i][j]=3; if(str[j]=='S') mp[i][j]=4; &#125; &#125; st=0;ed=4000; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; if(mp[i][j]==2) &#123; make(i,j); ins(1000+getid(i,j),2000+getid(i,j),1); &#125; if(mp[i][j]==3) ins(3000+getid(i,j),ed,1); if(mp[i][j]==4) ins(st,getid(i,j),1); &#125; int ans=0; while(bfs()) ans+=dfs(st,INF); printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【置顶】gdb命令备忘]]></title>
    <url>%2Fposts%2F7de4.html</url>
    <content type="text"><![CDATA[gdb命令备忘 1显示代码list 1,1000 2查看调用参数info args 3查看局部变量info locals 4查看函数栈bt]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【训练】算法竞赛进阶指南-1基本数据结构21题]]></title>
    <url>%2Fposts%2F7248.html</url>
    <content type="text"><![CDATA[本处难度分档以个人实力为参照系难度1：半小时内想出，半小时内ac难度2：半小时想不出，看题解，服气难度3：半小时想不出，看题解，ac后依然觉得难度很大 0x10 基本数据结构题目 1 hdu4699 Editor7.3 难度1请先思考后再展开 要特判非法情况，这个是题目没有说明清楚的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=1100000;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int a[MAXN],sum[MAXN],mx[MAXN],top;void push(int d)&#123; a[++top]=d; sum[top]=sum[top-1]+d; mx[top]=mymax(mx[top-1],sum[top]);&#125;void pop()&#123; top--;&#125;int ign[MAXN],igntp;//ignore元素栈char s[10];int main()&#123; int Q; while(scanf("%d",&amp;Q)!=EOF) &#123; top=0;sum[0]=0; mx[0]=-0x3f3f3f3f;//debug igntp=0; while(Q--) &#123; scanf("%s",s); if(s[0]=='I') &#123; int d;scanf("%d",&amp;d); push(d); &#125; if(s[0]=='D') pop(); if(s[0]=='L') if(top&gt;0) ign[++igntp]=a[top--]; if(s[0]=='R') if(igntp&gt;0) push(ign[igntp--]); if(s[0]=='Q') &#123; int k;scanf("%d",&amp;k); printf("%d\n",mx[k]); &#125; &#125; &#125;&#125; 2 poj2559 Largest Rectangle in a Histogram7.3 难度2请先思考后再展开 看到提示用单调栈，大概是想通了但发现我只会暴力地确定右端点后，枚举左端点来统计答案 看了发题解，发现大概思路差不多，主要就是统计答案的方法如果从右端点开始考虑，其左端点是不定的但如果稍微换个角度，利用一下单调性，可以发现：对于一个左端点，其最优的右端点只有一个，那就是在其存在时期内最后那个 所谓存在时期，就是它从进入到弹出期间我们可以考虑在它被弹出的时候再统计答案，而这时候，新矩形一定比它小所以从它到【第一个被当前新矩形弹出的矩形】之间，就是当前高度下的最优宽度所以边弹出，边累加宽度并统计答案即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=110000;typedef long long ll;ll mymax(ll a,ll b) &#123;return a&gt;b?a:b;&#125;struct Nod&#123; int h,w;&#125;a[MAXN];//单调递增int h[MAXN];int main()&#123; while(1) &#123; int n;scanf("%d",&amp;n);if(n==0) break; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;h[i]); h[++n]=0; int top=0;ll ans=0; for(int i=1;i&lt;=n;i++) &#123; if(a[top].h&lt;=h[i]) &#123; a[++top].h=h[i];a[top].w=1; &#125; else &#123; int wid=0; while(top&gt;0 and a[top].h&gt;h[i]) &#123; wid+=a[top].w; ans=mymax(ans,ll(a[top].h)*wid); top--; &#125; a[++top].h=h[i];a[top].w=wid+1;//debug 漏了 &#125; &#125; printf("%lld\n",ans); &#125;&#125; 3 poj2259 hdu1387 Team Queue7.3 难度2请先思考后再展开 偷懒，用了链表然后看题，一是会有0，完全没注意就用了0表示空二是多一个空行，读题时看到，写题时忘记回想起不久前中考时也有这个毛病或许应该写下这种注意点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=1100;int ps[MAXN];//位置struct Nod&#123; int a;//所属小组 int nxt;&#125;p[MAXN*MAXN];char s[20];int main()&#123; int cas=0; while(1) &#123; memset(ps,-1,sizeof ps); //debug 没注意到正常编号中有0，所以空应该用-1表示 int n;scanf("%d",&amp;n);if(n==0) break; for(int i=1;i&lt;=n;i++) &#123; int c;scanf("%d",&amp;c); while(c--) &#123; int t;scanf("%d",&amp;t); p[t].a=i;p[t].nxt=-1; &#125; &#125; int qst=-1,qed=-1;//队尾 printf("Scenario #%d\n",++cas); while(1) &#123; scanf("%s",s); if(s[0]=='E') &#123; int t;scanf("%d",&amp;t); int k=ps[p[t].a]; if(k&gt;-1) &#123; p[t].nxt=p[k].nxt; p[k].nxt=t; if(qed==k) qed=t; &#125; else &#123; if(qst==-1) qst=t; if(qed&gt;-1) p[qed].nxt=t; qed=t; &#125; ps[p[t].a]=t; &#125; if(s[0]=='D') &#123; printf("%d\n",qst); if(qst==qed) qed=-1; if(qst==ps[p[qst].a]) ps[p[qst].a]=-1; qst=p[qst].nxt; &#125; if(s[0]=='S') break; &#125; putchar('\n');//debug &#125;&#125; 4 bzoj2457 双端队列7.3 难度3请先思考后再展开 思考难度很大因为 要按照顺序处理数字，而又涉及大小关系，直接线性处理是不可能的考虑把数列排序一波（也可以从数据范围上观察得出）然后记录下标思考能够放在同一个双端队列里，需要满足的特性 结论：在同一个双端队列，对于编号最前的，比它大的要在它后面出现，比它小的也要在后面出现，而且与它的差越大，与它的距离差就应该越大如果用图像来表示，把排序后的数列，排名为x，原坐标为y，则必须是一个单谷图像 所以，大致上的流程就是：排序， 按从小到大处理数列，记录递增或递减趋势，记录有多少个图像但还有个细节：对于排名也就是大小一样的数，它们的原坐标顺序是可以任意排列的为了尽量减少单谷数量，对于大小相同的一段，内部在单调时最优。所以只要记录每一段的最大和最小值，任意变形来贪心地连接起来就好了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=210000;struct Nod&#123; int d,p;&#125;a[MAXN];bool cmp(Nod a,Nod b) &#123;return a.d&lt;b.d or (a.d==b.d and a.p&lt;b.p);&#125;int nx=0,mi[MAXN],mx[MAXN];int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i].d),a[i].p=i; sort(a+1,a+n+1,cmp); mi[1]=1; for(int i=1;i&lt;=n;i++) if(i==1 or a[i-1].d!=a[i].d) &#123; mx[nx]=a[i-1].p; mi[++nx]=a[i].p; &#125; mx[nx]=n; bool up=1; int ans=0,ed=0x3f3f3f3f; for(int i=1;i&lt;=nx;i++) &#123; if(up) &#123; if(ed&lt;mi[i]) ed=mx[i]; else up=0,ans++,ed=mi[i]; &#125; else//down &#123; if(ed&gt;mx[i]) ed=mi[i]; else up=1,ed=mx[i]; &#125; &#125; printf("%d",ans);&#125; 5 1201 最大子序和7.3 难度1请先思考后再展开 这道题初看像是有限制条件的最大子段和，然鹅方法完全不一样首先，因为有长度限制，在枚举右端点的过程中，需要把左端点向右移那么因为和可以表示为sum[i]-sum[j-1],i-j+1&lt;=m因为我们的右端点是固定的，所以只要搞出一个符合条件中最小的sum[j-1]即可 稍微提醒一下，一定要明确是sum[j-1]而不是sum[j]，逻辑差别很大然后就wa了多次……12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=310000;const int INF=0x3f3f3f3f;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int sum[MAXN];struct Nod&#123; int d; int p;&#125;a[MAXN];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;sum[i]); sum[i]+=sum[i-1]; &#125; int ans=0; int l=1,r=1; a[1].d=0,a[1].p=0; //debug,sum[i]-sum[j-1]，重点是【j-1】而不是【j】 for(int i=1;i&lt;=n;i++) &#123; while(l&lt;=r and i-a[l].p&gt;m) l++;//debug,i-j+1&lt;=m,i-(j-1)&lt;=m ans=mymax(ans,sum[i]-sum[a[l].p]); while(l&lt;=r and a[r].d&gt;=sum[i]) r--; a[++r].d=sum[i];a[r].p=i; &#125; printf("%d",ans);&#125; 6 poj3349 Snowflake Snow Snowflakes7.4 难度2请先思考后再展开 这道题是真的毒瘤本来用hash判重，然后丢到set里面结果不是hash被卡wa就是stl被卡tle 总之，不得不用hash表，第一次写这玩意，以前只会理论各种tle，抄了很多书上的代码，改了改类型、模数，才卡了过去1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int now[6];const int Mod=100003;int gethash()&#123; int has=1; for(int i=0;i&lt;=5;i++) if(now[i]!=0) has=( ll(has)*now[i] )%Mod; //debug,爆int for(int i=0;i&lt;=5;i++) has=(has+now[i])%Mod; return has;&#125;struct HashTable&#123; int a[6]; int nxt; HashTable() &#123; nxt=0; &#125;&#125;a[MAXN];int head[Mod+10];int id=0;bool equal(int t,int op)&#123; for(int i=0;i&lt;=5;i++) for(int j=0;j&lt;=5;j++) &#123; int s; for(s=0;s&lt;=5;s++) if(a[t].a[(i+s+6)%6]!=now[(j+s*op+6)%6]) break; if(s==6) return 1; &#125; return 0;&#125;int main()&#123; int n;scanf("%d",&amp;n); while(n--) &#123; for(int i=0;i&lt;=5;i++) scanf("%d",&amp;now[i]); int has=gethash(); for(int t=head[has];t&gt;0;t=a[t].nxt) if(equal(t,1) or equal(t,-1)) &#123; printf("Twin snowflakes found."); return 0; &#125; a[++id].nxt=head[has]; memcpy(a[id].a,now,sizeof now); head[has]=id; &#125; printf("No two snowflakes are alike.");&#125; 7 1401 兔子与兔子7.4 难度1请先思考后再展开 裸题12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=1100000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;ull has[MAXN];const ull Base=13331;ull bs[MAXN];ull gethash(int l,int r)&#123; return has[r]-has[l-1]*bs[r-l+1];&#125;char s[MAXN];int main()&#123; scanf("%s",s+1); int len=strlen(s+1); bs[0]=1; for(int i=1;i&lt;=len;i++) &#123; bs[i]=bs[i-1]*Base; has[i]=has[i-1]*Base+s[i]; &#125; int m;scanf("%d",&amp;m); while(m--) &#123; int a,b,c,d;scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d); if(gethash(a,b)==gethash(c,d)) printf("Yes\n"); else printf("No\n"); &#125;&#125; 8 poj1961 Period7.4 难度1请先思考后再展开 经典题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=1100000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;char s[MAXN];int nxt[MAXN];void prekmp(int len)&#123; int j=0;nxt[1]=0; for(int i=2;i&lt;=len;i++)//debug，从2开始，否则不符合定义 &#123; while(j&gt;0 and s[j+1]!=s[i]) j=nxt[j]; if(s[j+1]==s[i]) j++; nxt[i]=j; &#125;&#125;int main()&#123; int cas=0; while(1) &#123; int len;scanf("%d",&amp;len);if(len==0) break; scanf("%s",s+1); prekmp(len); printf("Test case #%d\n",++cas); for(int i=1;i&lt;=len;i++) if(i-nxt[i]&gt;0 and (i%(i-nxt[i]))==0 and nxt[i]&gt;0) printf("%d %d\n",i,i/(i-nxt[i])); putchar('\n');//debug &#125;&#125; 9 1602 The XOR Largest Pair7.4 难度1请先思考后再展开 居然对了！虽然不是1a，因为有个地方，得到的是int，就re了思路：把所有数转化成二进制，用类似字典树的结构存储对于i，先统计答案，i是其中一个，贪心地找另一个具体来说，贪心地从高位开始，尽量往反方向走，累计答案当然是在不行还是要走正方向统计完后，把这个串加入到字典树中供后人用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=4000000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int bin[40];struct Trie&#123; int son[2];&#125;p[MAXN];int id=0;void clear(int x)&#123; p[x].son[0]=p[x].son[1]=-1;&#125;int now[40];void add()&#123; int x=0; for(int i=30;i&gt;=0;i--) &#123; if(p[x].son[now[i]]&lt;0) &#123; p[x].son[now[i]]=++id; clear(id); &#125; x=p[x].son[now[i]]; &#125;&#125;int solve()&#123; int x=0,ans=0; for(int i=30;i&gt;=0;i--) &#123; int nx=p[x].son[ 1-now[i] ]; if(nx&gt;0) &#123; ans+=bin[i]; x=nx; &#125; else if(p[x].son[now[i]]&gt;0) x=p[x].son[now[i]]; else break; &#125; return ans;&#125;int main()&#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]*2; int n;scanf("%d",&amp;n); clear(0); int ans=0; for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); for(int j=0;j&lt;=30;j++) now[j]=( t&amp;bin[j] )&gt;0;//debug 原本是int if(i&gt;1) ans=mymax(ans,solve()); add(); &#125; printf("%d",ans);&#125; 10 poj3764 The xor-longest Path7.4 难度2请先思考后再展开 想了一个小时，看到题解前半段的那一刻，难受的一匹原来和上一题是一样的！ x到y路径上xor和=x到根xor和 xor y到根xor和这基于同一个数xor自己，得到0，而0 xor 任何数=任何数 然鹅，自己在思考的时候，却想着还要xor lca(x,y)到根因为感觉那部分只出现了一次，神tm自己想再补上一次……感觉这给我的教训是要多动笔写下来，这样不容易错我才不会说这是因为笔被我整天乱扔，摔断墨了……自作自受吧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int bin[40];struct Trie&#123; int son[2];&#125;tr[4000000];int id=0;void clear(int x)&#123; tr[x].son[0]=tr[x].son[1]=-1;&#125;int now[40];void add()&#123; int x=0; for(int i=30;i&gt;=0;i--) &#123; if(tr[x].son[now[i]]&lt;0) &#123; tr[x].son[now[i]]=++id; clear(id); &#125; x=tr[x].son[now[i]]; &#125;&#125;int solve()&#123; int x=0,ans=0; for(int i=30;i&gt;=0;i--) &#123; int nx=tr[x].son[ 1-now[i] ]; if(nx&gt;0) ans+=bin[i],x=nx; else if(tr[x].son[now[i]]&gt;0) x=tr[x].son[now[i]]; else break; &#125; return ans;&#125;struct Nod&#123; int hou; int dis;&#125;p[MAXN];struct Edge&#123; int y,c,g;&#125;e[MAXN*2];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln;&#125;void dfs(int x,int fa)&#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; p[y].dis=p[x].dis xor e[k].c; dfs(y,x); &#125;&#125;int main()&#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]*2; int n; while(scanf("%d",&amp;n)!=EOF) &#123; p[1].dis=0;ln=0; for(int i=1;i&lt;=n;i++) p[i].hou=0; for(int i=1;i&lt;=n-1;i++) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); x++;y++; ins(x,y,c);ins(y,x,c); &#125; dfs(1,0); id=0;clear(0); int ans=0; for(int i=1;i&lt;=n;i++) &#123; for(int j=0;j&lt;=30;j++) now[j]=( p[i].dis&amp;bin[j] )&gt;0; if(i&gt;1) ans=mymax(ans,solve()); add(); &#125; printf("%d\n",ans); &#125;&#125; 11 poj1456 Supermarket7.4 难度3请先思考后再展开 一开始写了个错误的贪心：直接按照过期排序，第二关键字是价值但这样就考虑不了【过期冲突，价值极大】的情况 先明确：如果现在是第t天，则应卖出能卖出的前t大有一个套路，能够给限定数量的局部贪心后悔药：维护一个大小为t的堆，堆顶是最不优秀的元素，尝试替换来修正原方案12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=11000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;struct Nod&#123; int p,d; friend bool operator &gt; (Nod a,Nod b) &#123;return a.p&gt;b.p;&#125;&#125;a[MAXN];bool cmp(Nod a,Nod b) &#123; return a.d&lt;b.d; &#125;priority_queue&lt; Nod,vector&lt;Nod&gt;,greater&lt;Nod&gt; &gt; q;int main()&#123; int n; while(scanf("%d",&amp;n)!=EOF) &#123; for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;a[i].p,&amp;a[i].d); sort(a+1,a+n+1,cmp); for(int i=1;i&lt;=n;i++) &#123; int siz=q.size(); if(siz&lt;a[i].d) q.push(a[i]); else if(a[i].p&gt;q.top().p) q.pop(),q.push(a[i]); &#125; int ans=0; while(!q.empty()) ans+=q.top().p,q.pop(); printf("%d\n",ans); &#125;&#125; 12 poj2442 Sequence7.5 难度3请先思考后再展开 1.既然跟大小有关，先把每个序列排好序，确认了最小答案 2.因为直接枚举方案会超时这是因为产生了很多因为过大而无用的状态 这就用到了一个新套路（又被akc轻松想出）把所有最小值组成一个方案，放进堆里面通过堆进行决策的同时，基于堆的最优性进行拓展因为我们已经排好了序，拓展只是某个指针的前移此时复杂度是$O( n^2 \times log(nm) )$濒临超时 3.然鹅，上述方案有个致命的问题两个不同的状态可能拓展出相同的状态感觉强行hash判重也可以，不过没必要 4.有一个不那么好想的方法（或许利用了答案要求的数量和序列长度相同这个特性）先把两个序列合并，把得到的前n个作为一个新的序列然后像同余方程组那样逐个合并。而且，由于每次只处理两个数列，可以用bool判重解决上面的问题 复杂度$O( m \times n \times 2 \times log(n) )$，飞快 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=2100;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int n;int a0[MAXN],a1[MAXN];struct Nod&#123; int i,j; Nod(int x=0,int y=0) &#123;i=x,j=y;&#125; friend bool operator &gt; (Nod x,Nod y) &#123; return a0[x.i]+a1[x.j]&gt;a0[y.i]+a1[y.j]; &#125;&#125;;priority_queue&lt; Nod,vector&lt;Nod&gt;,greater&lt;Nod&gt; &gt; q;bool v[MAXN][MAXN];void add(int i,int j)&#123; if(!v[i][j]) &#123; v[i][j]=1; q.push( Nod(i,j) ); &#125;&#125;int tmp[MAXN];void merg()&#123; memset(v,0,sizeof v);//debug 每次merg前，而不是每组数据 while(!q.empty()) q.pop(); add(1,1); for(int i=1;i&lt;=n;i++) &#123; Nod tp=q.top();q.pop(); tmp[i]=a0[tp.i]+a1[tp.j]; if(tp.i+1&lt;=n) add(tp.i+1,tp.j); if(tp.j+1&lt;=n) add(tp.i,tp.j+1); &#125; memcpy(a0,tmp,sizeof tmp);&#125;int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; int m;scanf("%d%d",&amp;m,&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a0[i]); sort(a0+1,a0+n+1); for(int t=2;t&lt;=m;t++) &#123; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a1[i]); sort(a1+1,a1+n+1); merg(); &#125; for(int i=1;i&lt;=n;i++) printf("%d ",a0[i]); putchar('\n'); &#125;&#125; 13 CTSC2007 数据备份 &amp; bzoj2151 种树7.5 难度2请先思考后再展开 这道题一年多以前做过，当时并没有blog然后我yy着就和远古时期的我产生了共鸣，回忆起了一个细节：在堆中进行可后悔决策然鹅完全没有思路虽然顺便又把一个关键性质想到了：不会有线路的重叠，故只会和旁边产生关系 如果想到这里，想必大佬们都能快速的想到怎么做然后我还是蒙逼状态，尽管我又把一个关键的图画了出来：四个点之间的连线x-1、x、x+1 是不是觉得我灰常无可救药？都已经把所有前提想到了，还是不会…… 事实上：有一种贪心策略：每次找最短的一条边，然后把它两边的删除但这样其实很容易举出反例，例如4,2,4,100000 怎么办？引入后悔机制，不要急着排除两边相反，在堆种放入一个c[x-1]+c[x+1]-c[x]也就是说，如果我再选择了一次，那么我就是花费两条边，把x-1和x+1建好了当然如果没有再被拿出，意味着没必要 细细思考，不难发现这样能同时满足互斥的两种状态决策总而言之，听起来灰常有道理，只不过不好想到【据说是一种模型，靠积累】 还有一些细节 如果我们放进去的被拿出来，意味着建两条边，那还是要找左右两侧的更远的边，在堆中去除因为要延长伸展，用链表比较方便 去除可以用可删堆，但还要确保编号相同；用set就灰常不方便了，毕竟是结构体；还有种方法是判断其是否和外界数据不同，表示其过时，直接弹出123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;struct Nod&#123; int d,x; Nod(int a=0,int b=0) &#123; d=a,x=b; &#125; friend bool operator &gt; (Nod a,Nod b) &#123; return a.d&gt;b.d; &#125;&#125;;priority_queue&lt; Nod,vector&lt;Nod&gt;,greater&lt;Nod&gt; &gt; q;int s[MAXN];int l[MAXN],r[MAXN];int main()&#123; int n,k;scanf("%d%d",&amp;n,&amp;k); int lst=0; for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); s[i]=t-lst;lst=t; if(i&gt;1) q.push( Nod(s[i],i) ); l[i]=i-1;r[i]=i+1; &#125; //边界哨兵节点 l[2]=1;s[1]=INF; r[n]=n+1;s[n+1]=INF; int ans=0; while(k--) &#123; while(q.top().d!=s[q.top().x]) q.pop();//old Nod now=q.top();q.pop(); int x=now.x,left=l[x],right=r[x]; //后悔药 s[x]=s[left]+s[right]-s[x];//debug 忘记更新s[x]，直接塞进去了 q.push( Nod(s[x],x) ); //删除左右 l[x]=l[left];r[l[left]]=x; r[x]=r[right];l[r[right]]=x; s[left]=INF;s[right]=INF; //统计答案 ans+=now.d; &#125; printf("%d",ans);&#125; 14 NOI2015 荷马史诗bzoj4198 luogu2168 uoj130 loj21327.5 难度2请先思考后再展开 入门好题，教程：【OI之路】09经典问题-3哈夫曼树 唯一不同的是第二问，要求最大深度最小构造哈夫曼树的时候，我们只是保证了带权路径长度和最小但当我们面对两个相同权值，但是一个下面的最大深度大的和小的这个时候，如果先合并下面的最大深度大的，答案会更大而先合并小的，就能把后面的机会留下了，从而减小了树的最大深度 具体做法很简单，重载堆的比较函数时，把下面的最大深度作为第二关键字，优先小的就好了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;struct Nod&#123; ll w; int c;//最大深度 Nod(ll a=0,int b=0) &#123;w=a,c=b;&#125; friend bool operator &gt; (Nod a,Nod b) &#123; return a.w&gt;b.w or (a.w==b.w and a.c&gt;b.c); &#125;&#125;;priority_queue&lt; Nod,vector&lt;Nod&gt;,greater&lt;Nod&gt; &gt; q;int main()&#123; int n,k;scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) &#123; ll t;scanf("%lld",&amp;t); q.push( Nod(t,0) ); &#125; while( (int(q.size())-1)%(k-1)!=0 ) q.push( Nod(0,0) ); ll ans=0; while(1) &#123; ll tot=0; int mxdep=0; for(int i=1;i&lt;=k;i++) &#123; Nod now=q.top();q.pop(); mxdep=mymax(mxdep,now.c); tot+=now.w; &#125; ans+=tot; if(q.empty()) &#123; printf("%lld\n%d",ans,mxdep+1); break; &#125; q.push( Nod(tot,mxdep+1) ); &#125;&#125; 0x18 基本数据结构练习题目 15 1801 括号画家7.6 难度1请先思考后再展开 考细节……应自己构造数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;char s[MAXN];int sta[MAXN],top=0;int main()&#123; scanf("%s",s+1);int len=strlen(s+1); int ans=0; int lst=0; for(int i=1;i&lt;=len;i++) &#123; int now; if(s[i]=='&#123;') now=0; if(s[i]=='&#125;') now=5; if(s[i]=='[') now=1; if(s[i]==']') now=4; if(s[i]=='(') now=2; if(s[i]==')') now=3; if(now&lt;=2) sta[++top]=now; else &#123; if(top&gt;0 and sta[top]+now==5) lst+=2,top--; else ans=mymax(ans,lst),lst=0,sta[++top]=now; &#125; &#125; printf("%d",ans=mymax(ans,lst));&#125; 16 poj1964 City Game7.6 难度2请先思考后再展开 骚操作预处理出每个点最大向上高度然后看作是二维的Largest Rectangle in a Histogram……1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=1100;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;struct Nod&#123; int h,w; Nod(int a=0,int b=0) &#123;h=a,w=b;&#125;&#125;a[MAXN];int up[MAXN][MAXN];char c[10];int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); int ans=0; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; scanf("%s",c); up[i][j]=(c[0]=='F')?1+up[i-1][j]:0; &#125; up[i][m+1]=0; int top=1;a[1]=Nod(up[i][1],1); for(int j=2;j&lt;=m+1;j++) &#123; int wid=0; while(top&gt;0 and a[top].h&gt;=up[i][j])//debug 判top&gt;0 &#123; wid+=a[top].w; ans=mymax(ans,a[top--].h*wid); &#125; a[++top]=Nod(up[i][j],wid+1); &#125; &#125; printf("%d\n",3*ans); &#125;&#125; 17 NOI1999 内存分配7.6 难度2请先思考后再展开 打了一大半很多细节问题先放着代码吧复杂度估计$O(n \sqrt n)$（如果块状链表）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=11000;const int INF=0x3f3f3f3f;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;struct Lb&#123; int st,ed;//内存 //应该改成ln形式 Lb(int a=0,int b=0) &#123;st=a,ed=b;&#125;&#125;a[MAXN*20];int tou,ll[MAXN*20],rr[MAXN*20];int id=0;struct Task&#123; int st,ln;//内存 int tst,ti;//时间 friend bool operator &gt; (Task a,Task b) &#123;return a.tst+a.ti&gt;b.tst+b.ti;&#125;&#125;;priority_queue&lt; Task,vector&lt;Task&gt;,greater&lt;Task&gt; &gt; q;Task fail[MAXN];int fl=1,fr=0;int ans=0;void pop_update()&#123; Task now=q.top();q.pop(); int nowed=now.st+now.ln-1;//内存 ans=now.tst+now.ti-1; int x=tou; while(x&gt;0) &#123; int rx=rr[x],rrx=rr[rx]; int ma=0; if(x==tou) &#123; if(nowed+1==a[x].st)//debug 特判新的tou &#123; a[x].st=now.st; ma=x; &#125; else if(nowed&lt;a[x].st) &#123; tou=++id;//debug 原id++ rr[tou]=x;ll[x]=tou; a[tou].st=now.st;a[tou].ed=now.st+now.ln-1;//debug 漏了 ma=tou; &#125; &#125; else if(rx==0) &#123; if(a[x].ed+1==now.st) &#123; a[x].ed=nowed; ma=x; &#125; else &#123; a[++id].st=now.st;a[id].ed=nowed; rr[x]=id;ll[id]=x; ma=id; &#125; &#125; else &#123; if(a[x].ed+1==now.st and nowed+1==a[rx].st)//二合一 &#123; a[x].ed=a[rx].ed;ll[x]=rrx;ll[rrx]=x; ma=x; &#125; else if(a[x].ed+1==now.st) &#123; a[x].ed=nowed; ma=x; &#125; else if(nowed+1==a[rx].st) &#123; a[rx].st=now.st; ma=rx; &#125; else if(a[x].ed&lt;now.st and nowed&lt;a[rx].st) &#123; a[++id].st=now.st;a[id].ed=nowed; rr[x]=id;ll[id]=x;ll[rx]=id;rr[id]=rx; ma=id; &#125; &#125; if(ma&gt;0) &#123; while(fl&lt;=fr and a[ma].ed-a[ma].st+1&gt;=fail[fl].ln)//debug 写成&lt;= &#123; fail[fl].st=a[ma].st;fail[fl].tst=now.tst+now.ti-1+1;//debug q.push(fail[fl]);a[ma].st+=fail[fl++].ln; &#125; if(a[ma].st&gt;a[ma].ed)//空 &#123; if(ma==tou) &#123; &#125; rr[ll[ma]]=rr[ma];ll[rr[ma]]=ll[ma]; if(ma==tou and rr[tou]&gt;0) tou=rr[ma];//debug 特判tou，避免环 &#125; return; &#125; x=rx; &#125;&#125;void try_push(int tst,int ln,int ti)&#123; int x=tou; while( x&gt;0 ) &#123; int lx=ll[x],rx=rr[x]; if( a[x].ed-a[x].st+1&gt;=ln )//succeed &#123; Task tmp; tmp.st=a[x].st,tmp.ln=ln; tmp.tst=tst,tmp.ti=ti; q.push(tmp); a[x].st += ln; if(a[x].st&gt;a[x].ed and x!=tou)//空 &#123; rr[lx]=rx; ll[rx]=lx; &#125; return; &#125; x=rx; &#125; fail[++fr].ln=ln; fail[fr].ti=ti;&#125;int main()&#123; int n;scanf("%d",&amp;n); tou=++id; a[tou]=Lb(0,n-1); ll[tou]=0,rr[tou]=0; while(1) &#123; int tst,ln,ti;scanf("%d%d%d",&amp;tst,&amp;ln,&amp;ti); if(tst==0 and ln==0 and ti==0) break; while(!q.empty() and q.top().tst+q.top().ti-1&lt;tst) pop_update(); try_push(tst,ln,ti); &#125; while(!q.empty()) pop_update(); printf("%d\n%d",ans+1,fr);//debug 要求所有彻底结束 //printf("fl=%d fr=%d",fl,fr);&#125; 18 1806 Matrix7.7 难度2请先思考后再展开 第一次二维hash，所以学了下题目的特性在于a和b固定，所以可以直接预处理出每个矩阵的hash然后排个序，后面的询问就灰常快了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=1100;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int n,m,a,b;const ull Base1=131;const ull Base2=13331;int cnt=0;ull sum[MAXN*MAXN];char s[MAXN];ull h[MAXN][MAXN];int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;a,&amp;b); ull b1a=1;for(int i=1;i&lt;=a;i++) b1a*=Base1;//Base1^a ull b2b=1;for(int i=1;i&lt;=b;i++) b2b*=Base2;//Base2^b for(int i=1;i&lt;=n;i++) &#123; scanf("%s",s+1); for(int j=1;j&lt;=m;j++) &#123; h[i][j]=h[i-1][j]*Base1+h[i][j-1]*Base2-h[i-1][j-1]*Base1*Base2+s[j]-'0'; if(i&gt;=a and j&gt;=b) sum[++cnt]=(h[i][j]-h[i-a][j]*b1a)-(h[i][j-b]-h[i-a][j-b]*b1a)*b2b; &#125; &#125; sort(sum+1,sum+cnt+1); int q;scanf("%d",&amp;q); while(q--) &#123; for(int i=1;i&lt;=a;i++) &#123; scanf("%s",s+1); for(int j=1;j&lt;=b;j++) h[i][j]=h[i-1][j]*Base1+h[i][j-1]*Base2-h[i-1][j-1]*Base1*Base2+s[j]-'0'; &#125; int t=lower_bound(sum+1,sum+cnt+1,h[a][b])-sum; printf("%d\n",sum[t]==h[a][b]); &#125;&#125; 19 1807 Necklace7.7 难度1请先思考后再展开 最小表示法裸题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=1100000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int len;char s[2][MAXN*2];int getmin(int w)&#123; int a=1,b=2; while(1) &#123; if(a==b) b++; if(a&gt;b) swap(a,b); if(b&gt;len) return a; bool bk=1;//相同 for(int k=0;k&lt;=len-1;k++) &#123; if(s[w][a+k]&lt;s[w][b+k]) &#123;b=b+k+1;bk=0;break;&#125; else if(s[w][a+k]&gt;s[w][b+k]) &#123;a=a+k+1;bk=0;break;&#125; &#125; if(bk) return 1; &#125;&#125;int main()&#123; scanf("%s%s",s[0]+1,s[1]+1);len=strlen(s[0]+1); for(int i=1;i&lt;=len;i++) s[0][len+i]=s[0][i],s[1][len+i]=s[1][i]; int k0=getmin(0),k1=getmin(1); for(int i=0;i&lt;=len-1;i++) if(s[0][k0+i]!=s[1][k1+i]) &#123; puts("No"); return 0; &#125; puts("Yes");for(int i=0;i&lt;=len-1;i++) printf("%c",s[0][k0+i]);&#125; 20 poj2185 Milking Grid7.8 难度2请先思考后再展开 有关kmp与最小覆盖的前置知识，请搜索kmp查看教程 然后一开始猜一手结论，行取max，列同样，居然ac了其实后来我和mocha经过探讨发现，max是不正确的（例如6和9，除非问题改成陶陶的名字），应该取lcm UP 2018.7.11其实lcm也是错误的反例8 2AABBBBAAAAABBAAA 正确的方法应该是强行比较的kmp（hash也行，快一点）代码已更正123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=1100000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int n,m;char s[11000][110];int nxt[11000];bool cmp1(int col1,int col2)&#123; for(int row=1;row&lt;=n;row++) if(s[row][col1]!=s[row][col2]) return 0; return 1;&#125;int getnext1()&#123; nxt[1]=0; for(int i=2;i&lt;=m;i++) &#123; int j=nxt[i-1]; while(j&gt;0 and !cmp1(j+1,i)) j=nxt[j]; nxt[i]=j+cmp1(j+1,i); &#125; return m-nxt[m];&#125;bool cmp2(int row1,int row2)&#123; for(int col=1;col&lt;=m;col++) if(s[row1][col]!=s[row2][col]) return 0; return 1;&#125;int getnext2()&#123; nxt[1]=0; for(int i=2;i&lt;=n;i++) &#123; int j=nxt[i-1]; while(j&gt;0 and !cmp2(j+1,i)) j=nxt[j]; nxt[i]=j+cmp2(j+1,i); &#125; return n-nxt[n];&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%s",s[i]+1); printf("%d",getnext1()*getnext2());&#125; 21 bzoj2288 生日礼物7.9 难度2请先思考后再展开 有一个灰常关键的步骤：由贪心知，连续的正数、负数一定是同时选取的所以可以直接合并起来考虑 把正数的段计数，我们的任务就是，在花费最少的前提下，把正数减少到m及以下减少的方法有两个，一是选取一个正数，然后把相邻的负数合并起来（因为必须要连续），代价为正数值二是选取一个负数，把相邻的正数合并，这样代价是负数绝对值综上所述，我们可以把所有数的绝对值放到小根堆里面，统计正数的数量，每次弹出直到数量在m以下即可 还有两个细节 三个数合并之后，正负性是没有意义的，我们前面是为了统计tot并确保算法正确性 对于边缘的负数，要予以忽略！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;struct Num&#123; int d,pos; Num(int t,int p) &#123;d=t,pos=p;&#125; friend bool operator &gt; (Num a,Num b) &#123;return myabs(a.d)&gt;myabs(b.d);&#125;&#125;;int f[MAXN];//值int l[MAXN],r[MAXN];//链表priority_queue&lt; Num,vector&lt;Num&gt;,greater&lt;Num&gt; &gt; q;void del(int x)&#123; f[x]=INF; r[l[x]]=r[x]; l[r[x]]=l[x];&#125;int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); int ans=0,tot=0,cnt=0; for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); if( i&gt;1 and (t&gt;0)==(f[cnt]&gt;0) ) f[cnt]+=t; else f[++cnt]=t; &#125; for(int i=1;i&lt;=cnt;i++) &#123; if(f[i]&gt;0) tot++,ans+=f[i]; q.push( Num(f[i],i) ); l[i]=i-1;r[i]=i+1; &#125; while(tot&gt;m) &#123; tot--;//debug 要在前面 while(!q.empty() and q.top().d!=f[q.top().pos]) q.pop();//old Num now=q.top();q.pop(); int x=now.pos,lx=l[x],rx=r[x]; if( (l[x]!=0 and r[x]!=cnt+1) or f[x]&gt;0 ) &#123; ans-=myabs(f[x]); f[x]=f[lx]+f[x]+f[rx]; q.push( Num(f[x],x) ); del(lx);del(rx);//删除 &#125; else tot++;//忽略边缘负数 &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【训练】算法竞赛进阶指南-2搜索13题]]></title>
    <url>%2Fposts%2F9d2f.html</url>
    <content type="text"><![CDATA[本处难度分档以个人实力为参照系难度1：半小时内想出，半小时内ac难度2：半小时想不出，看题解，服气难度3：半小时想不出，看题解，ac后依然觉得难度很大 0x20 搜索题目 1 2101 可达性统计7.9 难度2请先思考后再展开 一开始以为是统计 siz 的sb题原来是我sb了，因为会有重复，那么只能把每个点能到达的统计下来了而且因为是有向的，必须要按照拓扑序（建反边）来统计用bitset统计，查询1的个数即可 复杂度的话，时间是$O(n^2/32)$，空间是128MB12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=31000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;struct Nod&#123; int hou; int ru; Nod() &#123; hou=ru=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXN];int ln=0;void ins(int x,int y)&#123; ln++; e[ln].y=y;e[ln].g=p[x].hou; p[x].hou=ln; p[y].ru++;&#125;int lst[MAXN],top=0;bitset&lt;MAXN&gt; f[MAXN];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); ins(y,x); &#125; for(int i=1;i&lt;=n;i++) &#123; f[i][i]=1; if(p[i].ru==0) lst[++top]=i; &#125; while(top&gt;0) &#123; int x=lst[top--]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; f[y]=f[y]|f[x]; p[y].ru--; if(p[y].ru==0) lst[++top]=y; &#125; &#125; for(int i=1;i&lt;=n;i++) printf("%d\n",f[i].count());&#125; 2 2201 小猫爬山7.10 难度2请先思考后再展开 这道题引发了我对暴搜方式的思考：如果用车来找猫，就有次序性；而反过来，新车选择就会减少，次序也固定123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=20;int n,w;int ans=MAXN;int use[MAXN];int c[MAXN];void dfs(int now,int cnt)&#123; if(cnt&gt;=ans) return;//最优化剪枝 if(now&gt;n) &#123;ans=cnt;return;&#125; for(int i=1;i&lt;=cnt;i++) if(use[i]+c[now]&lt;=w) &#123; use[i]+=c[now]; dfs(now+1,cnt); use[i]-=c[now]; &#125; use[cnt+1]=c[now]; dfs(now+1,cnt+1);&#125;bool cmp(int x,int y) &#123;return x&gt;y;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;w); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;c[i]); sort(c+1,c+n+1,cmp);//减少选择 dfs(1,0); printf("%d",ans);&#125; 3 poj2676 poj3074 Sudoku7.10 难度2请先思考后再展开 poj2676 0mspoj3074 tle，精A12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=20;const int INF=0x3f3f3f3f;int mp[MAXN][MAXN];bitset&lt;10&gt; hang[MAXN],lie[MAXN],block[MAXN];int getid(int x,int y) &#123; return ((x-1)/3)*3+(y-1)/3+1; &#125;int tot;int fx,fy;void getnxt()&#123; int ans=INF; for(int i=1;i&lt;=9;i++) for(int j=1;j&lt;=9;j++) if(mp[i][j]==0) &#123; int t=(hang[i]&amp;lie[j]&amp;block[getid(i,j)]).count(); if(ans&gt;t) ans=t,fx=i,fy=j; &#125;&#125;bool bk;void dfs(int now)&#123; if(bk) return; if(now&gt;tot) &#123; for(int i=1;i&lt;=9;i++) &#123; for(int j=1;j&lt;=9;j++) printf("%d",mp[i][j]); putchar('\n'); &#125; //putchar('\n'); bk=1; return; &#125; getnxt();//debug 原本直接用fx、fy，后果严重，查错很久！ int x=fx,y=fy,id=getid(x,y); for(int t=1;t&lt;=9;t++) if(hang[x][t] and lie[y][t] and block[id][t]) &#123; hang[x][t]=lie[y][t]=block[id][t]=0; mp[x][y]=t; dfs(now+1); mp[x][y]=0; hang[x][t]=lie[y][t]=block[id][t]=1; &#125;&#125;char str[MAXN*MAXN];int main()&#123; int T;scanf("%d",&amp;T); while(T--) //while(1) &#123; tot=0; for(int i=1;i&lt;=9;i++) hang[i].set(),lie[i].set(),block[i].set(); //scanf("%s",str+1); if(str[1]=='e') break; for(int i=1;i&lt;=9;i++) &#123; scanf("%s",str+1); for(int j=1;j&lt;=9;j++) &#123; int now=str[j]-'0'; //int now=(str[(i-1)*9+j]=='.')?0:str[(i-1)*9+j]-'0'; mp[i][j]=now; if(now&gt;0) hang[i][now]=lie[j][now]=block[getid(i,j)][now]=0; else tot++; &#125; &#125; bk=0;dfs(1); &#125;&#125; 4 poj1011 luogu1120 Sticks7.11 难度3请先思考后再展开 去掉次序性的套路：强行限制大小关系，例如我选择了递减 由于值的数量比个数少，可以把值映射一下，方便查找，至于可用性可以直接更改数量然后这个方法包含了一个剪枝——同值不再考虑 书上的一个剪枝一直没有理解，就是当空的时候，检验前面决策具体而言是尝试每一个木棒，任何一个失败都意味着前面决策错误然后我的策略是毫不犹豫地选择最大的本来是一直坚信其优越性的，直到惊觉我的做法，发现决策的错误要在以后的层，多出了很多无用枝123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=100;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int sum,mx,k;int n;int c[MAXN];//映射bool okay;void dfs(int done,int now,int lst)//强制递减&#123; if(done==sum/k) okay=1; if(okay) return; int t=mymin(lst,k-now);//debug 原本 k-lst if(lst==INF) t=mx; for(;t&gt;0;t--) &#123; if(c[t]==0) continue; c[t]--; if(now+t==k) dfs(done+1,0,INF); else dfs(done,now+t,t); c[t]++; if(!okay and (now==0 or now+t==k)) return;//现在失败，前面有问题 //大剪枝，因为耗时大部分都是失败的结果，否则已经结束了 //now==0：空的，塞东西后失败，迟早会用到 //now+t==k：大的块一定不会比【小的拼起来一样长】的更有用，因为不能拆开 &#125;&#125;int main()&#123; while(1) &#123; scanf("%d",&amp;n); if(n==0) break; memset(c,0,sizeof c); mx=sum=0; for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); if(t&lt;=50) &#123; sum+=t; mx=mymax(mx,t); c[t]++; &#125; &#125; int ans=INF; for(int t=1;t&lt;=sqrt(sum);t++) if(sum%t==0) &#123; k=t; if(k&gt;=mx) &#123; okay=0;dfs(0,0,INF); if(okay) ans=mymin(ans,k); &#125; k=sum/t; if(k!=t and k&gt;=mx) &#123; okay=0;dfs(0,0,INF); if(okay) ans=mymin(ans,k); &#125; &#125; printf("%d\n",ans); &#125;&#125; 5 poj1190 生日蛋糕7.12 难度2请先思考后再展开 剪枝 最优化剪枝nows&gt;=ans 可行性剪枝Ri&gt;=1+2(m-i)Hi&gt;=1+2(m-i) 最小化可行性剪枝nown+getmin()&gt;n 最大化可行性剪枝nown+getmax()&lt;n 最后一个剪枝特tm难想到首先，如果要剪枝，肯定要把上面部分的东西表示出来N表示去掉$\pi$的体积，S表示去掉$\pi$的表面积 $$N_后=\sum_{i=now}^m R_i^2 H_i$$ $$S_后=2 \times \sum_{i=now}^m R_i H_i$$ 所谓剪枝，可以考虑不等式【据说接下来的是高中数学灰常恶心的东西：不等式的缩放】 加入元$R_{now-1}$（很难想）$$S_后=\frac{2}{R_{now-1}}\times\sum_{i=now}^m R_i H_i R_{now-1}$$ 把右边部分缩放一下由于$R_{now-1} &gt; R_i$ $$S_后 \frac{2}{R_{now-1}}\times\sum_{i=now}^m R_i^2 H_i$$ 联系一下体积$$S_后&gt; \frac{2}{R_{now-1}} \times N_剩$$ 因为前面几个剪枝，只有一个是关于【有关答案的表面积】的那么可以说$S_后$一定比某个值大可以最优化剪枝一波，条件：$$S_现+\frac{2}{R_{now-1}} \times N_剩&gt;=ans$$ 最后就是碰到搜索要无脑倒序循环123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=20;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int n,m;int r[MAXN],h[MAXN];int mi[MAXN];ll getmx(int x)&#123; ll sum=0,rr=r[x-1],hh=h[x-1]; for(int i=x;i&lt;=m;i++) sum+=(rr+i)*(rr+i)*(hh+i); return sum;&#125;int ans=INF;void dfs(int nows,int nown,int x)&#123; if(nows+r[1]*r[1]&gt;=ans) return; if(x==m+1) &#123; if(nown==n) ans=nows+r[1]*r[1]; return; &#125; //if(nown+mi[m-x+1]&gt;n) return; //if(getmx(x)+nown&lt;n) return; 会拖慢 if(r[1]*r[1]+nows+2*(n-nown)/r[x-1]&gt;=ans) return; for(int ri=mymin(sqrt(n-mi[m-x]-nown),r[x-1]-1);ri&gt;=1+(m-x);ri--)//debug，sqrt部分没想到 &#123; int hmx=(n-mi[m-x]-nown)/(ri*ri);//最小化可行性剪枝的变形 if(x==m) &#123; r[x]=ri;h[x]=hmx; if(hmx&lt;=h[x-1]-1) dfs(nows+2*ri*hmx,nown+ri*ri*hmx,x+1); continue; &#125; for(int hi=mymin(hmx,h[x-1]-1);hi&gt;=1+(m-x);hi--) &#123; r[x]=ri;h[x]=hi; dfs(nows+2*ri*hi,nown+ri*ri*hi,x+1); &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) mi[i]=i*i*i; r[0]=100+1;h[0]=20000+1; dfs(0,0,1); if(ans==INF) ans=0; printf("%d",ans);&#125; 6 poj2248 Addition Chains7.12 难度1请先思考后再展开 迭代加深这个东西第一次看到感觉它虽然比bfs慢一些，但其优势在于便于还原状态、不用大量空间来存储状态1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int ed;int ln;int a[MAXN];bool v[MAXN];bool dfs(int now)&#123; if(a[now-1]==ed) &#123; for(int i=1;i&lt;=now-1;i++) printf("%d ",a[i]); return 1; &#125; if(now&gt;ln) return 0; memset(v,0,sizeof v); for(int i=now-1;i&gt;=1;i--) for(int j=now-1;j&gt;=i;j--) &#123; a[now]=a[i]+a[j]; if(v[a[now]] or a[now]&gt;ed or a[now]&lt;=a[now-1]) continue; v[a[now]]=1; if(dfs(now+1)) return 1; &#125; return 0;&#125;int main()&#123; a[1]=1; while(1) &#123; scanf("%d",&amp;ed); if(ed==0) break; for(ln=1;ln&lt;=100;ln++) if(dfs(2)) break; printf("\n"); &#125;&#125; 7 2401 送礼物7.13 难度2请先思考后再展开 其实通常面对一个决策与顺序无关，而且不卡log的题目，排序一下都不亏其实看不出这个正解和折半搜索有什么关系但是灰常鬼畜啊hh主要思路来自【指数级爆搜】把问题分成两边（已排序），搜索左右两边，然后通过枚举左边的结果，二分查找右边的这样子复杂度就被硬生生变成了$O(2^{n/2} log_2 2^{n/2})$ 折半搜索还有道体现得更明显的题目：灯然后我们通过折半，把取值的数量从2^45变成最坏2^22，其实还不少，所以要剪枝 可恶啊卡我的set……1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=50;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int w,n;int a[MAXN];int ans=0;//set&lt;int&gt; f;//leftint f[1&lt;&lt;25],cnt=0;//leftvoid dfs(int x,int now,bool right)&#123; if(!right and x&gt;n/2) f[++cnt]=now;//f.insert(now); else if(right and x&gt;n) &#123; //int t=*( --upper_bound(f.begin(),f.end(),w-now) );//&lt;=w-now int t=f[upper_bound(f+1,f+cnt+1,w-now)-f-1]; ans=mymax(ans,t+now); &#125; else &#123; dfs(x+1,now,right); if(ll(now)+a[x]&lt;=w) dfs(x+1,now+a[x],right); &#125;&#125;int main()&#123; scanf("%d%d",&amp;w,&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); sort(a+1,a+n+1);reverse(a+1,a+n+1); dfs(1,0,0); sort(f+1,f+cnt+1); cnt=unique(f+1,f+cnt+1)-f-1; dfs(n/2+1,0,1); printf("%d",ans);&#125; 8 2601 电路维修7.14 难度2请先思考后再展开 最巧妙的地方：把决策转化为边，边权为代价于是就变成了最短路问题 spfa一直tle……试一试书上的新做法，以为多特别所以没有打p[x].v=0，一直wa123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=510;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int n,m;int calc(int x,int y) &#123;return (x-1)*MAXN+y;&#125;struct Nod&#123; int hou; int dis; bool v;&#125;p[MAXN*MAXN];struct Edge&#123; int y,c,g;&#125;e[MAXN*MAXN*2*2];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; ln++; e[ln].y=x;e[ln].c=c; e[ln].g=p[y].hou;p[y].hou=ln;&#125;deque&lt;int&gt; q;int bfs(int st,int ed)&#123; p[st].v=1;q.push_back(st);p[st].dis=0; while(!q.empty()) &#123; int x=q.front();q.pop_front(); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dis&gt;p[x].dis+e[k].c) &#123; p[y].dis=p[x].dis+e[k].c; if(!p[y].v) &#123; p[y].v=1; if(e[k].c) q.push_back(y); else q.push_front(y); &#125; &#125; &#125; p[x].v=0;//debug &#125; return p[ed].dis;&#125;char s[MAXN];int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; ln=0; for(int i=1;i&lt;MAXN*MAXN;i++) &#123; p[i].v=0; p[i].hou=0; p[i].dis=INF; &#125; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",s+1); for(int j=1;j&lt;=m;j++) &#123; ins( calc(i,j),calc(i+1,j+1),(s[j]=='/') ); ins( calc(i+1,j),calc(i,j+1),(s[j]!='/') ); &#125; &#125; int ans=bfs(calc(1,1),calc(n+1,m+1)); if(ans==INF) puts("NO SOLUTION"); else printf("%d\n",ans); &#125;&#125; 9 poj3635 Full Tank?7.17 难度1请先思考后再展开 本来以为可以dfs去记忆化然鹅这样是错的，因为不能保证第一次就是最优解……话说bfs的复杂度其实灰常悬，可能数据水？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1100,MAXM=21000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int a[MAXN];int hou[MAXN];struct Edge&#123; int y,c,g;&#125;e[MAXM];int ln=0;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=hou[x];hou[x]=ln;&#125;int full,st,ed;struct Nod&#123; int x,oil; int cost; Nod(int a=0,int b=0,int c=0) &#123;x=a,oil=b,cost=c;&#125; friend bool operator &gt; (Nod a,Nod b) &#123;return a.cost&gt;b.cost;&#125;&#125;;bool v[MAXN][110];priority_queue&lt; Nod,vector&lt;Nod&gt;,greater&lt;Nod&gt; &gt; q;int bfs()&#123; memset(v,0,sizeof v); while(!q.empty()) q.pop(); q.push( Nod(st,0,0) );//题目中说是空箱 while(!q.empty()) &#123; Nod now=q.top();q.pop(); int x=now.x,oil=now.oil,cost=now.cost; if(x==ed) return cost; if(v[x][oil]) continue; v[x][oil]=1; if(oil&lt;full) q.push( Nod(x,oil+1,cost+a[x]) ); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(oil&gt;=e[k].c) q.push( Nod(y,oil-e[k].c,cost) ); &#125; &#125; return -1;&#125;int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); while(m--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); x++;y++; ins(x,y,c);ins(y,x,c); &#125; int T;scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d%d",&amp;full,&amp;st,&amp;ed); st++;ed++; int ans=bfs(); if(ans&lt;0) puts("impossible"); else printf("%d\n",ans); &#125;&#125; 10 poj2449 Remmarguts’ Date7.17 难度2请先思考后再展开 key：第k次出堆，得到第k小的解akc眼中的模版题 不过最后奇奇怪怪mle先放着吧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1100,MAXM=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int st,ed,K;int hou[MAXN];bool v[MAXN];int f[MAXN];//估价函数struct Edge&#123; int y,c,g;&#125;e[MAXM];int ln=0;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=hou[x];hou[x]=ln;&#125;queue&lt;int&gt; lst;void spfa()&#123; memset(f,63,sizeof f);//debug 忘记了…… lst.push(ed);v[ed]=1;f[ed]=0; while(!lst.empty()) &#123; int x=lst.front();lst.pop(); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(f[y]&gt;f[x]+e[k].c) &#123; f[y]=f[x]+e[k].c; if(!v[y]) v[y]=1,lst.push(y); &#125; &#125; v[x]=0; &#125;&#125;int tot[MAXN];//次数struct Nod&#123; int x,dis; Nod(int a=0,int b=0) &#123;x=a,dis=b;&#125; friend bool operator &gt; (Nod a,Nod b) &#123;return a.dis+f[a.x]&gt;b.dis+f[b.x];&#125;&#125;;priority_queue&lt; Nod,vector&lt;Nod&gt;,greater&lt;Nod&gt; &gt; q;int solve()&#123; q.push( Nod(st,0) ); while(!q.empty()) &#123; Nod now=q.top();q.pop(); int x=now.x; tot[x]++; if(tot[x]&gt;K) continue; if(x==ed and tot[x]==K) return now.dis; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(tot[y]&lt;K) q.push( Nod(y,now.dis+e[k].c) ); &#125; &#125; return -1;&#125;int xx[MAXM],yy[MAXM],cc[MAXM];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;xx[i],&amp;yy[i],&amp;cc[i]); ins(yy[i],xx[i],cc[i]); &#125; scanf("%d%d%d",&amp;st,&amp;ed,&amp;K); if(st==ed) K++;//好像是必须要走??? spfa(); ln=0;memset(hou,0,sizeof hou); for(int i=1;i&lt;=m;i++) ins(xx[i],yy[i],cc[i]); printf("%d",solve());&#125; 11 poj3460 Booksort7.17 难度3请先思考后再展开 A=堆+bfs+估价IDA=迭代dfs+估价 最难的就是怎么估价了目标是有序，但我们不能用【逆序对数量】，因为每次消除量是不确定的观察题目性质，每次操作都是对连续的一段进行的再有序的情况下，每个数都有一个正确的后继而每次操作最多消除3个错误后继数不过要向上取整 顺便再介绍一下折半搜索怎么做：先考虑每次决策的分支量如果选a本，有n-a+1种，可以插n-a处同时对于前移，必定有一种后移方案与其等效，所以只后移分支数$ \sum_{a=1}^{n-1} (n-a+1) \times (n-a) /2 = 560 $普通dfs是4次方，折半一下，就变成了平方级别可以用hash+map存储结果，第二次的时候对应找到，然后累计即可总而言之复杂度$O(560^2 log_2 560^2)$ wa了一次，忘记判断完美情况了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=20;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int n;int mxdep;bool bk;void dfs(int now[MAXN],int step)&#123; if(bk) return; int f=0; for(int i=1;i&lt;n;i++) if(now[i+1]!=now[i]+1) f++; f=int( ceil(double( f+(now[n]!=n) )/3.0) ); if(f==0) &#123;bk=1;return;&#125; if(step+f&gt;mxdep) return; for(int a=1;a&lt;=n-1;a++) &#123; for(int st=1;st&lt;=n-a+1;st++) &#123; int ed=st+a-1; for(int nw=ed+1;nw&lt;=n;nw++) &#123; //第一段 1~st-1 //第二段 ed+1~nw //第三段 st~ed //第四段 nw+1~n int nx[MAXN],cnt=0; for(int i=1;i&lt;=st-1;i++) nx[++cnt]=now[i]; for(int i=ed+1;i&lt;=nw;i++) nx[++cnt]=now[i]; for(int i=st;i&lt;=ed;i++) nx[++cnt]=now[i]; for(int i=nw+1;i&lt;=n;i++) nx[++cnt]=now[i]; dfs(nx,step+1); &#125; &#125; &#125;&#125;int a[MAXN];int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); bk=0; for(mxdep=0;mxdep&lt;=4;mxdep++)//debug 完美情况 &#123; dfs(a,0); if(bk) break; &#125; if(bk) printf("%d\n",mxdep); else puts("5 or more"); &#125;&#125; 0x29 搜索练习题目 12 poj3700 Missile Defence System7.18 难度2请先思考后再展开 先给出一份比较显然的做法，一组组找尽力加上了两个剪枝： 仅当没东西选的时候再结束 当前能被now到nx中间的覆盖时，延迟搜索123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=60;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int n;int a[MAXN];bool v[MAXN];bool bk;int mxdep;void dfs(int cnt,int tot,int now,int up)&#123; if(bk) return; if(cnt&gt;mxdep) return; if(tot==n) &#123;bk=1;return;&#125; bool b=0; int mi=INF,mx=0; for(int nx=now+1;nx&lt;=n;nx++) &#123; if(v[nx]) continue; if(up==0 and (a[now]&lt;a[nx] or a[nx]&lt;mx)) continue; if(up==1 and (a[now]&gt;a[nx] or a[nx]&gt;mi)) continue; b=1;mi=mymin(mi,a[nx]);mx=mymax(mx,a[nx]); v[nx]=1; if(up&lt;0) dfs(cnt,tot+1,nx,0),dfs(cnt,tot+1,nx,1); else dfs(cnt,tot+1,nx,up); v[nx]=0; &#125; if(!b) &#123; for(int nx=1;nx&lt;=n;nx++) if(!v[nx]) &#123; v[nx]=1; dfs(cnt+1,tot+1,nx,-1); v[nx]=0; break; &#125; &#125;&#125;int main()&#123; while(1) &#123; scanf("%d",&amp;n);if(n==0) break; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); bk=0; for(mxdep=1;mxdep&lt;=n;mxdep++) &#123; memset(v,0,sizeof v); v[1]=1;dfs(1,1,1,-1); if(bk) break; &#125; printf("%d\n",mxdep); &#125;&#125; 然鹅这样依然会tle原因大概是叉太多了?其实想到这么多剪枝，但方向大概都是错误的 正解是考虑元素，分配组（这大概也是一个套路）这样的话只要贪心地找最不优秀但符合条件的即可顺利变成二叉，然后迭代加深也没意义了，最优性剪枝即可代码就不写了 13 poj1945 Power Hungry Cows7.18 难度2请先思考后再展开 网上到处都是打表和玄学（其实错误）剪枝来一股IDA*清流吧因为感性地感觉次数不会太多，迭代一下重点是这个估价函数不难猜出最优解一定先倍增上去再微调的那么如果只考虑倍增，实现容易又能满足$f(s) \leq g(s)$的定义 不过有一个应该是正确的剪枝，不太会证明如果P的约数中没有【x和y的最大公约数】，则返回大概原因是，无论怎么操作，得到的数一定是包含这个【x和y的最大公约数】吧想想，好像无论加减都是如此。这个还是挺妙的 官方数据：19997 1815151 1711111 1710007 165123 145111 151234 131024 101023 111010 1231 6然后在这些数据中，没有卡掉一种错误做法：假设较小值不会超过50反例：18673，答案应该是17然后打表发现其实是6160？听别人说的 顺便吐槽一句lyd的代码是打特判过的，根本错误的做法 反正我是没卡过去所有数据都是正确的 IDA*12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=60;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int gcd(int x,int y)&#123; return (y==0)?x:gcd(y,x%y);&#125;int P;int f(int x,int y)&#123; if(y==P) return 0; int ans=0; while(x&lt;P) x*=2,ans++; return ans;&#125;bool bk=0;int mxdep;void dfs(int x,int y,int step)&#123; if(bk) return; if(x&lt;y) swap(x,y); if(x&gt;=2*P) return; if(x==0) return; if(P%gcd(x,y)!=0) return; if(step+f(x,y)&gt;mxdep) return; if(x==P or y==P) &#123;bk=1;return;&#125; //x+y dfs(x+y,x,step+1);dfs(x+y,y,step+1); //x-y dfs(x-y,x,step+1),dfs(x-y,y,step+1); //x+x dfs(x+x,x,step+1);dfs(x+x,y,step+1); //y+y dfs(y+y,x,step+1);dfs(y+y,y,step+1);&#125;int main()&#123; scanf("%d",&amp;P); for(mxdep=0;mxdep&lt;=P;mxdep++) &#123; dfs(1,0,0); if(bk) break; &#125; printf("%d",mxdep);&#125; A*，稍微快一点点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=60;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int gcd(int x,int y)&#123; return (y==0)?x:gcd(y,x%y);&#125;int P;int f(int x,int y)&#123; if(y==P) return 0; int ans=0; while(x&lt;P) x*=2,ans++; return ans;&#125;set&lt;ull&gt; has;ull gethas(ull x,ull y)&#123; return x*13331+y;&#125;struct Nod&#123; int x,y; int step,cost; Nod(int a=0,int b=0,int c=0,int d=0) &#123;x=a,y=b,step=c,cost=d;&#125; friend bool operator &gt; (Nod a,Nod b) &#123;return a.step+a.cost&gt;b.step+b.cost;&#125;&#125;;priority_queue&lt; Nod,vector&lt;Nod&gt;,greater&lt;Nod&gt; &gt; q;void push(int x,int y,int step)&#123; if(x&lt;y) swap(x,y); if(x&gt;=2*P) return; if(x==0) return; if(P%gcd(x,y)!=0) return; ull hs=gethas(x,y); if(has.count(hs)) return; has.insert(hs); q.push( Nod(x,y,step,f(x,y)) );&#125;int bfs()&#123; q.push( Nod(1,0,0,f(1,0)) ); has.insert( gethas(1,0) ); while(!q.empty()) &#123; Nod now=q.top();q.pop(); int x=now.x,y=now.y,step=now.step; if(x==P or y==P) return step; push(x+y,x,step+1);push(x+y,y,step+1);//x+y push(x-y,x,step+1),push(x-y,y,step+1);//x-y push(x+x,x,step+1);push(x+x,y,step+1);//x+x push(y+y,x,step+1);push(y+y,y,step+1);//y+y &#125; return -1;&#125;int main()&#123; scanf("%d",&amp;P); printf("%d",bfs());&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Arc100-D】Equal_Cut]]></title>
    <url>%2Fposts%2F6a1c.html</url>
    <content type="text"><![CDATA[Source and JudgeArc100-D Problem【Description】给出一个长度为n的数列，要求分成4段非空数列每段数列的和，其中【最大-最小】最小为多少？【Input】第一行为n第二行n个数，表示数列【Output】输出最小差【Limited conditions】4&lt;=n&lt;=2000001&lt;=a[i]&lt;=10^9【Sample input 1】53 2 4 1 2【Sample output 1】2【Sample input 2】1010 71 84 33 6 47 23 25 52 64【Sample output 2】36【Sample input 3】71 2 3 1000000000 4 5 6【Sample output 3】999999994【Sample explanation】无 Record1h Analysis请先思考后再展开 被rose操烂……这是一个贪心，而且感觉上很不科学，但是却又可以证明 假如我们枚举断点1，后面的两个端点会灰常麻烦，所以走到了死胡同然后rose用他的做法ac了……逻辑上讲，不妨换个切入点，考虑枚举中间的断点2先只考虑左边①最大值在左边 那么缩短A和B的差，会更优②最小值在左边 同上③A和B都不是最大值或最小值，那么缩短A和B的差，不会让答案更差上述情况都不是绝对的，可能移动时变成了另外一种情况但做法都是相同的，就是在平均值旁边“摇摆” 那具体怎么实现？如果直接二分查找也没问题，不过因为断点1和断点3都是递增的，所以可以“暴力”地移动却能达到O(n)的复杂度 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=210000;typedef long long ll;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;ll mymax(ll x,ll y) &#123;return x&gt;y?x:y;&#125;int n;ll sum[MAXN];int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;sum[i]); sum[i]+=sum[i-1]; &#125; ll ans=1ll&lt;&lt;60; //1~mid1,mid1+1~mid2,mid+1~mid3,mid3+1~n int mid1=1,mid3=3; for(int mid2=2;mid2&lt;=n-2;mid2++) &#123; while( sum[mid1]&lt;sum[mid2]-sum[mid1] ) mid1++; while( sum[mid3]-sum[mid2]&lt;sum[n]-sum[mid3] ) mid3++; ll A,B,C,D; A=sum[mid1],B=sum[mid2]-sum[mid1]; C=sum[mid3]-sum[mid2],D=sum[n]-sum[mid3]; ans=mymin(ans,mymax( mymax(A,B),mymax(C,D) )-mymin( mymin(A,B),mymin(C,D) )); A=sum[mid1-1],B=sum[mid2]-sum[mid1-1]; C=sum[mid3]-sum[mid2],D=sum[n]-sum[mid3]; ans=mymin(ans,mymax( mymax(A,B),mymax(C,D) )-mymin( mymin(A,B),mymin(C,D) )); A=sum[mid1],B=sum[mid2]-sum[mid1]; C=sum[mid3-1]-sum[mid2],D=sum[n]-sum[mid3-1]; ans=mymin(ans,mymax( mymax(A,B),mymax(C,D) )-mymin( mymin(A,B),mymin(C,D) )); A=sum[mid1-1],B=sum[mid2]-sum[mid1-1]; C=sum[mid3-1]-sum[mid2],D=sum[n]-sum[mid3-1]; ans=mymin(ans,mymax( mymax(A,B),mymax(C,D) )-mymin( mymin(A,B),mymin(C,D) )); &#125; printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【训练】算法竞赛进阶指南-0基本算法23题]]></title>
    <url>%2Fposts%2Fcfc5.html</url>
    <content type="text"><![CDATA[本处难度分档以个人实力为参照系难度1：半小时内想出，半小时内ac难度2：半小时想不出，看题解，服气难度3：半小时想不出，看题解，ac后依然觉得难度很大 0x00 基本算法题目 1 0103 最短Hamilton路径6.27 难度1请先思考后再展开 没难度，虽然一开始灰常尴尬地没注意到终点必须是n-11234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;const int MAXN=21;int f[MAXN][1&lt;&lt;MAXN];int mp[MAXN][MAXN];int bin[MAXN];int main()&#123; bin[0]=1;for(int i=1;i&lt;MAXN;i++) bin[i]=bin[i-1]&lt;&lt;1; int n;scanf("%d",&amp;n); for(int i=0;i&lt;=n-1;i++) for(int j=0;j&lt;=n-1;j++) scanf("%d",&amp;mp[i][j]); int tot=bin[n]-1;//0~tot memset(f,0x3f,sizeof f); f[0][bin[0]]=0; for(int S=1;S&lt;tot;S++) &#123; for(int ed=0;ed&lt;=n-1;ed++)//内 &#123; if( !(S&amp;bin[ed]) ) continue; for(int x=0;x&lt;=n-1;x++)//外 &#123; if(S&amp;bin[x]) continue; f[x][ S+bin[x] ]=mymin(f[x][ S+bin[x] ],f[ed][S]+mp[x][ed]); &#125; &#125; &#125; printf("%d",f[n-1][tot]);&#125; 2 费解的开关6.28 难度2请先思考后再展开 关键性质：如果从某个格子的状态考虑，它的状态取决于它被覆盖了多少次的奇偶性1而与次序无关！所以说先点还是后点没有意义，只需要知道要点哪里就是了；同理，重复点也是没有用的。 那么第一行的点击方式就确定下来了，接下来一行行消除然后为了把第一行的1消除，只能按第二行的对应点，以此类推123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int mp[5][5];int now[5][5];void change(int x,int y)&#123; if(x&gt;=0 and x&lt;=4 and y&gt;=0 and y&lt;=4) now[x][y]^=1;&#125;void press(int x,int y)&#123; change(x-1,y); change(x,y-1);change(x,y);change(x,y+1); change(x+1,y);&#125;int bin[10];char s[10];int main()&#123; bin[0]=1;for(int i=1;i&lt;=5;i++) bin[i]=bin[i-1]&lt;&lt;1; int T;scanf("%d",&amp;T); while(T--) &#123; for(int i=0;i&lt;=4;i++) &#123; scanf("%s",s); for(int j=0;j&lt;=4;j++) mp[i][j]=s[j]-'0'; &#125; int mi=7; for(int l1=0;l1&lt;=bin[5]-1;l1++) &#123; memcpy(now,mp,sizeof now); int ans=0; for(int j=0;j&lt;=4;j++) if(l1&amp;bin[j]) press(0,j),ans++; for(int i=1;i&lt;=4;i++) for(int j=0;j&lt;=4;j++) if(now[i-1][j]==0) press(i,j),ans++; if(now[4][0]+now[4][1]+now[4][2]+now[4][3]+now[4][4]==5 and ans&lt;mi) mi=ans; &#125; if(mi!=7) printf("%d\n",mi); else printf("-1\n"); &#125;&#125; 3 [HNOI2003]激光炸弹6.28 难度1见这里激光炸弹 poj3263 Tallest Cow6.28 难度2请先思考后再展开 开始想着查分约束，但是很慢而且没法确保最高点定值，建图也很麻烦实在没有思路看了发题解感觉这种贪心的方式很恶心，而且题意实在太不清晰了（理解分析能力？） 其实就是，假设所有人都是最高点然后因为相互看到必须中间都小于，所以不会交叉（括号序列）所以可以统计被覆盖次数，由于小于的传递性，这个削弱次数直接取-1然后必须要去重，否则无意义削弱1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;const int MAXN=11000;struct Nod&#123; int l,r;&#125;s[MAXN];bool cmp(Nod a,Nod b) &#123;return a.l&lt;b.l or (a.l==b.l and a.r&lt;b.r);&#125;int cf[MAXN];int main()&#123; int n,mx,h,q;scanf("%d%d%d%d",&amp;n,&amp;mx,&amp;h,&amp;q); for(int i=1;i&lt;=q;i++) &#123; scanf("%d%d",&amp;s[i].l,&amp;s[i].r); if(s[i].l&gt;s[i].r) swap(s[i].l,s[i].r); &#125; sort(s+1,s+q+1,cmp); for(int i=1;i&lt;=q;i++) &#123; //去重 if(s[i].l==s[i-1].l and s[i].r==s[i-1].r) continue; cf[s[i].l+1]--;cf[s[i].r]++; &#125; int sum=0; for(int i=1;i&lt;=n;i++) &#123; sum+=cf[i]; printf("%d\n",h+sum); &#125;&#125; 4 poj1845 Sumdiv6.28 难度2以前的原题这里 5 poj3889 Fractal Streets6.28 难度2请先思考后再展开 看到这个分形图就有点慌主要难点就是怎么把编号换成坐标，而且这个编号还是连续的然后随便写了几个，找不到规律膜了膜题解 其实，正是因为这是分形，可以递归求解这个旋转，其实是可以对坐标操作一下的，具体自己推+找规律然后其实它总是从左上到右上到右下到左下的所以可以直接按照编号的大小确定属于哪个区域123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;double mysqr(double x) &#123;return x*x;&#125;int bin[30];struct Nod&#123; int x,y; Nod(int a=0,int b=0) &#123;x=a,y=b;&#125;&#125;;Nod calc(int n,int old)&#123; if(n==0) return Nod(1,1); int wid=bin[n-1],sq=wid*wid;//小 边长和面积 if(old&lt;=sq)//左上 &#123; Nod tmp=calc(n-1,sq-old+1);//找规律得new=sq-old+1 return Nod(tmp.y,wid-tmp.x+1); &#125; else if(old&lt;=2*sq)//右上 &#123; old-=sq; Nod tmp=calc(n-1,old); return Nod(tmp.x,wid+tmp.y); &#125; else if(old&lt;=3*sq)//右下 &#123; old-=2*sq; Nod tmp=calc(n-1,old); return Nod(wid+tmp.x,wid+tmp.y); &#125; else//左下 &#123; old-=3*sq; Nod tmp=calc(n-1,sq-old+1);//找规律得new=sq-old+1 return Nod(wid+(wid-tmp.y+1),tmp.x); &#125;&#125;int main()&#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; int T;scanf("%d",&amp;T); while(T--) &#123; int n,st,ed;scanf("%d%d%d",&amp;n,&amp;st,&amp;ed); Nod a=calc(n,st),b=calc(n,ed); double d=sqrt(mysqr(a.x-b.x)*100+mysqr(a.y-b.y)*100); printf("%d\n",int(round(d))); &#125;&#125; 6 poj2018 Best Cow Fences6.28 难度2请先思考后再展开 首先用二分，判定是否有满足条件的一段，平均值&gt;=mid然后最精妙的地方就是所有数-mid这样就从【与长度有关的平均值】变成了【与长度无关的和】直观点就是，如今$$sum=s[i]-s[j],0 \le j \le i-L$$如果sum&gt;=0，那么就满足条件 显然在s[j]最小时最优，二每新计算一个i，都带来一个新的j所以记录前面的最小值就好了 至于卡精度这种事……精A罢12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=110000;typedef long long ll;int n,L;int a[MAXN];ll s[MAXN];bool check(int mid)&#123; for(int i=1;i&lt;=n;i++) s[i]=s[i-1]+a[i]-mid; int mi=s[0]; for(int i=L;i&lt;=n;i++)//new &#123; if(s[i-L]&lt;mi) mi=s[i-L];//new if(s[i]-mi&gt;=0) return 1; &#125; return 0;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;L); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]),a[i]*=1000; int l=0,r=2000000,ans; while(l&lt;=r) &#123; int mid=(l+r)/2; if(check(mid)) ans=mid,l=mid+1; else r=mid-1; &#125; printf("%d",ans);&#125; 7 cf670-C Cinema6.28 难度1请先思考后再展开 离散化裸题居然是c题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=210000;struct Nod&#123; int d,p;&#125;ls[MAXN*3];bool cmp(Nod a,Nod b) &#123;return a.d&lt;b.d;&#125;int a[MAXN];int ct[MAXN*3];//统计struct Movie&#123; int q,w; int p;&#125;mv[MAXN];bool cmp2(Movie a,Movie b)&#123; return (ct[a.q]&gt;ct[b.q]) or (ct[a.q]==ct[b.q] and ct[a.w]&gt;ct[b.w]);&#125;int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;ls[i].d),ls[i].p=i; int m;scanf("%d",&amp;m); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;ls[n+i].d),ls[n+i].p=n+i; for(int i=1;i&lt;=m;i++) scanf("%d",&amp;ls[n+m+i].d),ls[n+m+i].p=n+m+i; int tot=n+m+m;sort(ls+1,ls+tot+1,cmp); int nw=0; for(int i=1;i&lt;=tot;i++) &#123; if(ls[i-1].d!=ls[i].d) nw++; if(ls[i].p&lt;=n) a[ls[i].p]=nw; else if(ls[i].p&lt;=n+m) mv[ls[i].p-n].q=nw; else mv[ls[i].p-n-m].w=nw; &#125; for(int i=1;i&lt;=n;i++) ct[a[i]]++; for(int i=1;i&lt;=m;i++) mv[i].p=i; sort(mv+1,mv+m+1,cmp2); printf("%d",mv[1].p);&#125; 8 bzoj3032 七夕祭6.28 难度1请先思考后再展开 中位数这个东西前面已经讲过了，具体请搜索“中位数”典型特征就是能左能右或者类似的相反方向 把所有a-=平均数，这个操作还是掌握了点的看起来a[1]直接=0，其实这是因为总体和=0，没有直接用，这个问题和akc研究了挺久 然后由于等差数列，可能爆int12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=110000;typedef long long ll;ll myabs(ll x) &#123;return x&gt;0?x:-x;&#125;ll c1[MAXN],c2[MAXN];int main()&#123; int n,m,q;scanf("%d%d%d",&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=q;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); c1[x]++;c2[y]++; &#125; bool ok1=(q%n==0),ok2=(q%m==0); if(ok1 and ok2) printf("both "); else if(ok1 and !ok2) printf("row "); else if(!ok1 and ok2) printf("column "); else printf("impossible"); if(ok1 or ok2) &#123; ll sum=0; if(ok1) &#123; for(int i=1;i&lt;=n;i++) c1[i]-=q/n; c1[1]=0;for(int i=2;i&lt;=n;i++) c1[i]=c1[i-1]-c1[i]; sort(c1+1,c1+n+1); ll tmp=c1[n/2+1]; for(int i=1;i&lt;=n;i++) sum+=myabs(-c1[i]+tmp); &#125; if(ok2) &#123; for(int i=1;i&lt;=m;i++) c2[i]-=q/m; c2[1]=0;for(int i=2;i&lt;=m;i++) c2[i]=c2[i-1]-c2[i]; sort(c2+1,c2+m+1); ll tmp=c2[m/2+1]; for(int i=1;i&lt;=m;i++) sum+=myabs(-c2[i]+tmp); &#125; printf("%lld",sum); &#125;&#125; 9 poj3784 Running Median6.29 难度1请先思考后再展开 原来，1.5亿是能跑的……这个对顶堆的做法也是蛮有意思的，稍微比树状数组少log，比splay少常数12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=110000;priority_queue&lt; int,vector&lt;int&gt;,less&lt;int&gt; &gt; q1;priority_queue&lt; int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; while(!q1.empty()) q1.pop(); while(!q2.empty()) q2.pop(); int tmp,n;scanf("%d%d",&amp;tmp,&amp;n); printf("%d %d\n",tmp,(n+1)/2); int ct=0; for(int i=1;i&lt;=n;i++) &#123; int d;scanf("%d",&amp;d); if(q1.size()&gt;0 and d&lt;=q1.top()) q1.push(d); else q2.push(d); if(q1.size()&gt;=q2.size()+2) q2.push(q1.top()),q1.pop(); if(q1.size()+2&lt;=q2.size()) q1.push(q2.top()),q2.pop(); if(i%2==1) &#123; if(q1.size()&gt;q2.size()) printf("%d ",q1.top()); else printf("%d ",q2.top()); ct++;if(ct==10) ct=0,putchar('\n'); &#125; &#125; putchar('\n'); &#125;&#125; 第k大数这方法挺有意思的应该就是eth_element的原理吧就是无序数列中，O(2n)找其实就是n+n/2+n/4+…….1&lt;=2n原理就是类似二分排序，但是没必要两边都进入，而是只进入其中一边蛮好理解的 10 poj2299 Ultra-QuickSort6.29 难度2请先思考后再展开 原来相邻比较和交换就是冒泡排序呀那么每次交换的时候，都消除了一个逆序对答案就是其个数了练习一下归并12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=510000;typedef long long ll;int a[MAXN],b[MAXN];ll mergsort(int l,int r)&#123; if(l&gt;=r) return 0; int mid=(l+r)&gt;&gt;1; ll ans=mergsort(l,mid)+mergsort(mid+1,r); int nw=l,q=l,w=mid+1; while(q&lt;=mid and w&lt;=r) &#123; if(a[q]&lt;=a[w]) b[nw]=a[q++]; else b[nw]=a[w++],ans+=mid-q+1; nw++; &#125; while(q&lt;=mid) b[nw++]=a[q++]; while(w&lt;=r) b[nw++]=a[w++]; for(int i=l;i&lt;=r;i++) a[i]=b[i]; return ans;&#125;int main()&#123; while(1) &#123; int n;scanf("%d",&amp;n); if(n==0) break; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); printf("%lld\n",mergsort(1,n)); &#125;&#125; 11 hihocoder 1384 Genius ACM6.29 难度3请先思考后再展开 类似于满足二分性，不过用倍增会更快，特别是当k小的时候然后直接暴力地排序会tle，可以用归并来合并a数组=原本值b数组=排好序值c数组=合并后，用于尝试，成功则copy回b数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=510000;typedef long long ll;ll mysqr(ll x) &#123;return x*x;&#125;int m;int bin[40];int a[MAXN],b[MAXN],c[MAXN];void merge(int l,int mid,int r)//到c中&#123; int nw=l,q=l,w=mid+1; while(q&lt;=mid and w&lt;=r) &#123; if(b[q]&lt;=b[w]) c[nw]=b[q++]; else c[nw]=b[w++]; nw++; &#125; while(q&lt;=mid) c[nw++]=b[q++]; while(w&lt;=r) c[nw++]=b[w++];&#125;ll calc(int l,int r)&#123; ll sum=0; int num=0; while(num&lt;m and r-l+1&gt;=2) &#123; num++; sum+=mysqr(c[r]-c[l]); l++;r--; &#125; return sum;&#125;int main()&#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]*2; int T;scanf("%d",&amp;T); while(T--) &#123; int n;ll k;scanf("%d%d%lld",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); int L=1,ans=0; while(L&lt;=n)//新的一段 &#123; int R=L,len=1; b[L]=a[L];//debug while(len&gt;0 and R&lt;=n) &#123; //保证有序 for(int i=R+1;i&lt;=R+len;i++) b[i]=a[i]; //sort(b+L,b+R+len+1); TLE sort(b+R+1,b+R+len+1);merge(L,R,R+len); if(calc(L,R+len)&lt;=k) &#123; for(int i=L;i&lt;=R+len;i++) b[i]=c[i]; R+=len,len*=2;//succeed &#125; else len/=2; while(R+len&gt;n and len&gt;0) len/=2; &#125; ans++; L=R+1; &#125; printf("%d\n",ans); &#125;&#125; 12 poj3614 Sunscreen6.29 难度2请先思考后再展开 不愧是我最虚的贪心 把牛用mx[x]递增排序，每次选最小的 归纳法证明：对于a=sp[t1]，b=sp[t2]已知mi[x]&lt;=a&lt;b&lt;=mx[x]&lt;=mx[y]则对于y，可能【ab可】、【a不可b可】、【ab不可】任何一种，选a 不会更差 同理，把mi[x]递减排序，每次选最大的也行123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=3100;struct Cow&#123; int mi,mx;&#125;p[3100];bool cmp(Cow a,Cow b) &#123;return a.mx&lt;b.mx;&#125;int ct[1100];//数量bool tryit(int l,int r)&#123; for(int i=l;i&lt;=r;i++) if(ct[i]&gt;0) &#123; ct[i]--; return 1; &#125; return 0;&#125;int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].mi,&amp;p[i].mx); for(int i=1;i&lt;=m;i++) &#123; int a,b; scanf("%d%d",&amp;a,&amp;b); ct[a]+=b; &#125; sort(p+1,p+n+1,cmp); int ans=0; for(int i=1;i&lt;=n;i++) ans+=tryit(p[i].mi,p[i].mx); printf("%d",ans);&#125; 13 poj3190 Stall Reservations6.29 难度2请先思考后再展开 先按照开始时间把牛排序然后如果以房间为导向，二分查找可行牛，就要解决删除的问题，然后就懵了（其实这个也是错的） 如果以牛为导向去安排，随便放进一个能放的房间就行了证明：假如有两个房间a和b，ed[a]&lt;ed[b]由于后面的开始时间会更后，所以选择a，不会更优 不过这样是平方级别的既然是随便就好，搞个小根堆，这样选择的开销就很小了 回顾一下，关键还是以开始时间排序这个操作，并且要按照这个来安排而不是作为有序数列来二分查找12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=51000;struct Cow&#123; int l,r; int p;&#125;p[MAXN];bool cmp(Cow a,Cow b) &#123;return a.l&lt;b.l;&#125;struct Room&#123; int id,ed; Room(int a=0,int b=0) &#123;id=a,ed=b;&#125; friend bool operator &gt; (Room a,Room b) &#123;return a.ed&gt;b.ed;&#125;&#125;c[MAXN];priority_queue&lt; Room,vector&lt;Room&gt;,greater&lt;Room&gt; &gt; q;//小根堆int ans[MAXN];int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].l,&amp;p[i].r),p[i].p=i; sort(p+1,p+n+1,cmp); int tot=1;q.push(Room(1,0)); for(int i=1;i&lt;=n;i++) &#123; Room a=q.top();q.pop(); if(a.ed&lt;p[i].l) a.ed=p[i].r,ans[p[i].p]=a.id; else q.push(Room(++tot,p[i].r)),ans[p[i].p]=tot; q.push(a); &#125; printf("%d\n",tot); for(int i=1;i&lt;=n;i++) printf("%d\n",ans[i]);&#125; 14 poj1328 Radar Installation6.30 难度2请先思考后再展开 计算出能覆盖每个岛的圆的圆点区间，用最少的点覆盖每个区间把区间按照左端点排序，然后如果无重叠，重新开始，否则可以把覆盖点“挪”到重叠区域 不过思考的时候漏了一种情况：就是重叠的话可能是包含关系 对于那些重叠但是不包含的，可能在后面还会和别人重叠但同样是因为贡献只有1，所以选择前面 不会更差12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=1100;const double eps=1e-7;double mymin(double x,double y) &#123;return x&lt;y?x:y;&#125;struct Seg&#123; double l,r;&#125;p[MAXN];bool cmp(Seg a,Seg b) &#123;return a.l&lt;b.l-eps;&#125;int solve(int n,int R)&#123; bool error=0; for(int i=1;i&lt;=n;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); if(y&gt;R) error=1;//return -1; debug double t=sqrt(R*R-y*y);//底边 p[i].l=double(x)-t,p[i].r=double(x)+t; &#125; if(error) return -1; sort(p+1,p+n+1,cmp); int ans=1; double ed=p[1].r; for(int i=2;i&lt;=n;i++) &#123; if(ed&lt;p[i].l-eps) ans++,ed=p[i].r; else ed=mymin(ed,p[i].r);//debug 区间包含 &#125; return ans;&#125;int main()&#123; int T=0; while(1) &#123; int n,R;scanf("%d%d",&amp;n,&amp;R);if(n==0) break; printf("Case %d: %d\n",++T,solve(n,R)); &#125;&#125; 15 国王游戏6.30 难度2原题 16 poj2054 Color a Tree6.30 难度3请先思考后再展开 先给出一个贪心：每次在能染色的点中找最大的然鹅这是错误的，举个简单的反例：在一个极小节点下有一个极大节点 反思一下，这是因为【必须先染父亲才能染儿子】这个条件但是我们依然可以推出一个结论：【对于非根的最大点，必定在父亲染完后立刻染色】所以说，其实可以把那两个节点看作一个节点不过这个节点的权值是多少才能不影响接下来的判断呢？ 结论2：【合并后的节点，权值为其平均值】证明：网上的证明普遍不堪入目，书上的也半斤八两后来终于在poj的远古评论里看到，简单得令人感动 设有权值a节点和b1~bn的合并节点如果a在前，优势是na如果a在后，优势是b1~bn的和那么按照结论一的步骤，我们每次都要比较权值大小则比较：【公共部分+na】与【公共部分+b1~bn的和】由于我们不能把所有的a改成na，考虑算出一个通用的权值则比较：【a】与【b1~bn的和/n】也就是平均数了另外，如果感性地理解，其实就是把【晚一点染色的影响】均摊了 总之，合并后，它和一个普通的点是没有区别的，可以继续合并合并时，还要用指针存储顺序，最后按照决策计算答案即可 然后有一点是忘记了：最大点不一定是叶子节点（脑海中喜欢这样想，人性的懒惰？）所以要把fa改掉 然后我不会nlogn怎么写……可删堆怕是用不了的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=1100;struct Nod&#123; int fa; int sum;//权值和 int tot;//数量 int ed;//末端 friend bool operator &lt; (Nod a,Nod b) &#123; //return a.sum/a.tot&lt;b.sum/b.tot; return a.sum*b.tot&lt;b.sum*a.tot; &#125;&#125;p[MAXN];int nxt[MAXN];//指针int a[MAXN];int main()&#123; p[0].sum=0;p[0].tot=1;//mi while(1) &#123; int n,rt;scanf("%d%d",&amp;n,&amp;rt);if(n==0) break; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n-1;i++) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); p[y].fa=x; &#125; p[rt].fa=0; for(int i=1;i&lt;=n;i++) &#123; p[i].sum=a[i],p[i].tot=1; p[i].ed=i;//st其实就是自己编号，不用记录 &#125; for(int ok=0;ok&lt;n-1;ok++)//不会写nlogn &#123; int mx=0; for(int i=1;i&lt;=n;i++) if(i!=rt and p[mx]&lt;p[i]) mx=i; int f=p[mx].fa; p[f].sum+=p[mx].sum;p[f].tot+=p[mx].tot; nxt[p[f].ed]=mx;p[f].ed=p[mx].ed; //debug mx不一定是叶子节点 for(int i=1;i&lt;=n;i++) if(p[i].fa==mx) p[i].fa=f; p[mx].sum=0;p[mx].tot=1; &#125; int ans=0; for(int T=1,x=rt;T&lt;=n;T++,x=nxt[x]) ans+=T*a[x]; printf("%d\n",ans); &#125;&#125; 0x08「基本算法」练习题目 17 poj2965 The Pilots Brothers’ refrigerator7.1 难度24乘4的矩阵，每个格子一个开关，+关-开每次操作改变第i行和第j列求所有开的最小操作数，并输出具体操作请先思考后再展开 又忘记这类问题的顺序无关性了……不过复杂度上bfs是可以的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=16,MAXS=71000;int bin[30];bool mp[5][5],mp2[5][5];bool ps[5][5],ansps[5][5];bool check()&#123; for(int i=1;i&lt;=4;i++) for(int j=1;j&lt;=4;j++) if(!mp2[i][j]) return 0; return 1;&#125;int main()&#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]*2; for(int i=1;i&lt;=4;i++) &#123; char s[10];scanf(&quot;%s&quot;,s+1); for(int j=1;j&lt;=4;j++) mp[i][j]=(s[j]==&apos;-&apos;); &#125; int tot=(1&lt;&lt;16)-1,ans=20; for(int i=0;i&lt;=tot;i++) &#123; memcpy(mp2,mp,sizeof mp); int step=0; for(int x=1;x&lt;=4;x++) for(int y=1;y&lt;=4;y++) &#123; ps[x][y]=i&amp;bin[ (x-1)*4+y-1 ]; if(ps[x][y]) &#123; step++; for(int i=1;i&lt;=4;i++) mp2[i][y]^=1; for(int j=1;j&lt;=4;j++) if(j!=y) mp2[x][j]^=1; &#125; &#125; if(check() and step&lt;ans) ans=step,memcpy(ansps,ps,sizeof ps); &#125; printf(&quot;%d\n&quot;,ans); for(int i=1;i&lt;=4;i++) for(int j=1;j&lt;=4;j++) if(ansps[i][j]) printf(&quot;%d %d\n&quot;,i,j);&#125; 18 poj3714 Raid7.2 难度2请先思考后再展开 kd-tree裸题好久没打了，练练手，果然炸……12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=110000;const double INF=double(1ll&lt;&lt;60)*double(1ll&lt;&lt;60);void cmax(int &amp;a,int b) &#123;if(a&lt;b) a=b;&#125;void cmin(int &amp;a,int b) &#123;if(a&gt;b) a=b;&#125;double mymin(double a,double b) &#123;return a&lt;b?a:b;&#125;double mysqr(double x) &#123;return x*x;&#125;struct Nod&#123; int d[2];//坐标 int l[2],r[2];//范围 int son[2];&#125;p[MAXN];int D;bool cmp(Nod a,Nod b) &#123;return a.d[D]&lt;b.d[D];&#125;int build(int l,int r,int ds)&#123; if(l&gt;r) return 0; int mid=(l+r)/2; D=ds;//debug 漏了 nth_element(p+l,p+mid,p+r+1,cmp); p[mid].l[0]=p[mid].r[0]=p[mid].d[0]; p[mid].l[1]=p[mid].r[1]=p[mid].d[1]; int lson=p[mid].son[0]=build(l,mid-1,1-ds); int rson=p[mid].son[1]=build(mid+1,r,1-ds); //debug 分治时要去掉mid if(lson) &#123; cmin(p[mid].l[0],p[lson].l[0]);cmin(p[mid].l[0],p[rson].l[0]); cmax(p[mid].r[0],p[lson].r[0]);cmax(p[mid].r[0],p[rson].r[0]); &#125; if(rson) &#123; cmin(p[mid].l[1],p[lson].l[1]);cmin(p[mid].l[1],p[rson].l[1]); cmax(p[mid].r[1],p[lson].r[1]);cmax(p[mid].r[1],p[rson].r[1]); &#125; return mid;&#125;double gg(double a,double b) &#123;return a*a+b*b;&#125;double calc(int x,int y,int now)&#123; double ans=0;//debug 用了int if(x&lt;p[now].l[0]) ans+=mysqr(p[now].l[0]-x); if(x&gt;p[now].r[0]) ans+=mysqr(x-p[now].r[0]); if(y&lt;p[now].l[1]) ans+=mysqr(p[now].l[1]-y); if(y&gt;p[now].r[1]) ans+=mysqr(y-p[now].r[1]); return ans;&#125;double ans;void findmin(int now,int x,int y)&#123; if(now==0) return; ans=mymin( ans,gg(x-p[now].d[0],y-p[now].d[1]) ); int lc=p[now].son[0],rc=p[now].son[1]; double lf=lc?calc(x,y,lc):INF; double rf=rc?calc(x,y,rc):INF; if(lf&gt;rf) swap(lc,rc),swap(lf,rf); if(lf&lt;ans) findmin(lc,x,y); if(rf&lt;ans) findmin(rc,x,y);&#125;int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].d[0],&amp;p[i].d[1]); int rt=build(1,n,0); ans=INF; for(int i=1;i&lt;=n;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); findmin(rt,x,y); &#125; printf("%.3lf\n",sqrt(ans)); &#125;&#125; 19 bzoj1271 luogu4403 秦腾与教学评估7.2 难度2请先思考后再展开 真的没想到这个【具体位置个数】居然可以转化为【点个数前缀和的奇偶性】上来所以就可以二分了 然后就是在bzoj和luogu上的官方数据，疑似总人数爆int，没有满足题意12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=210000;typedef long long ll;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;struct Nod&#123; int st,ed,d;&#125;a[MAXN];int n;ll calc(ll mx)&#123; ll ans=0; for(int i=1;i&lt;=n;i++) if(a[i].st&lt;=mx) ans+=( mymin(a[i].ed,mx)-a[i].st )/a[i].d+1; return ans;&#125;int main()&#123; int T;scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d%d&quot;,&amp;a[i].st,&amp;a[i].ed,&amp;a[i].d); ll l=1,r=(1ll&lt;&lt;31)-1,ans=-1; while(l&lt;=r) &#123; ll mid=(l+r)/2; if(calc(mid)%2==1) ans=mid,r=mid-1; else l=mid+1; &#125; if(ans&lt;0) printf(&quot;Poor QIN Teng:(\n&quot;); //if(ans&lt;0) printf(&quot;There&apos;s no weakness.\n&quot;); else printf(&quot;%lld %lld\n&quot;,ans,calc(ans)-calc(ans-1)); &#125;&#125; 20 poj3179 Corral the Cows7.2 难度2请先思考后再展开 同样是无法存储的大坐标这一次的操作是离散化，因为没想到这个，就把前缀和否定掉了……然后就是常规的但其实我不熟练的双点法，虽然昨晚打比赛还用过咧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=510,MAXF=11000;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;struct Nod&#123; int x,y;&#125;p[MAXN];bool cmpx(Nod a,Nod b) &#123;return a.x&lt;b.x;&#125;bool cmpy(Nod a,Nod b) &#123;return a.y&lt;b.y;&#125;int sx,sy;//最大离散值int fx[MAXF],fy[MAXF];//原值int E,n;int sum[MAXN][MAXN];bool check(int now)&#123; int a=1,b=1;//x while(fx[b+1]-fx[a]+1&lt;=now and b+1&lt;=sx) b++; while(1) &#123; int c=1,d=1;//y while(fy[d+1]-fy[c]+1&lt;=now and d+1&lt;=sy) d++; while(1) &#123; int ans=sum[b][d]-sum[b][c-1]-sum[a-1][d]+sum[a-1][c-1]; if(ans&gt;=E) return 1; d++;if(d&gt;sy) break; while(fy[d]-fy[c]+1&gt;now and c+1&lt;=d) c++; &#125; b++;if(b&gt;sx) break; while(fx[b]-fx[a]+1&gt;now and a+1&lt;=b) a++; &#125; return 0;&#125;int c[MAXN][MAXN];//数量int main()&#123; scanf(&quot;%d%d&quot;,&amp;E,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;p[i].x,&amp;p[i].y); sort(p+1,p+n+1,cmpx); for(int i=1;i&lt;=n;i++) &#123; if(p[i-1].x!=p[i].x) fx[++sx]=p[i].x; p[i].x=sx; &#125; sort(p+1,p+n+1,cmpy); for(int i=1;i&lt;=n;i++) &#123; if(p[i-1].y!=p[i].y) fy[++sy]=p[i].y; c[p[i].x][p[i].y=sy]++; &#125; //debug 忽略1导致fx[1]没赋值 for(int i=1;i&lt;=sx;i++) for(int j=1;j&lt;=sy;j++) sum[i][j]=c[i][j]+sum[i][j-1]+sum[i-1][j]-sum[i-1][j-1]; int l=1,r=10000,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)/2; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf(&quot;%d&quot;,ans);&#125; 21 poj1723 SOLDIERS7.2 难度2请先思考后再展开 一道很好地融合了贪心的题目至少好过七夕祭这种强行二维题 y直接中位数是没有问题的了主要是有个贪心没有想到：为了解决起点不确定问题，直接设一个起点然后把原数组贪心后a[i]对应st+i-1，并且是一一对应否则造成没有意义的花费这样达到最优解1234567891011121314151617181920212223#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=11000;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int a[MAXN],b[MAXN];int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;a[i],&amp;b[i]); int ans=0; sort(a+1,a+n+1);for(int i=1;i&lt;=n;i++) a[i]-=i-1; sort(a+1,a+n+1);for(int i=1;i&lt;=n;i++) ans+=myabs(a[i]-a[n/2+1]); sort(b+1,b+n+1);for(int i=1;i&lt;=n;i++) ans+=myabs(b[i]-b[n/2+1]); printf("%d",ans);&#125; 22 poj1050 To the Max7.2 难度2请先思考后再展开 裸题，枚举l、r，就能顺利转化了（又是想不到）可能因为是远古题吧而且如今这个数据规模暴力是很快过去的，没常数嘛，改成n=300就好很多1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=110;int mp[MAXN][MAXN];int sum[MAXN][MAXN];//行前缀和int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; scanf("%d",&amp;mp[i][j]); sum[i][j]=sum[i][j-1]+mp[i][j]; &#125; int ans=0; for(int l=1;l&lt;=n;l++)//最大子矩阵和 for(int r=l;r&lt;=n;r++) &#123; int s=0; for(int i=1;i&lt;=n;i++)//最大子段和 &#123; s+=sum[i][r]-sum[i][l-1]; if(s&lt;0) s=0; if(ans&lt;s) ans=s; &#125; &#125; printf("%d",ans);&#125; 23 hdu4864 Task7.2 难度2请先思考后再展开 兼顾策略和实现的贪心好题 观察题目，发现重要性质 价值中，时间的优先级绝对大于等级 价值只和任务有关，和具体机器无关 结论 优先考虑时间 应该用任务去找机器 具体而言 把任务和机器按照时间从小到大排序，从大到小枚举任务（经典套路之尽量从小范围开始） 对于每个任务，可以确定一个区间满足时间的条件,区间左端点单调递减 由于性质2，这样我们就顺利地 消除了时间、等级对决策的直接影响 由于比现在耗时更大的任务已经解决，则选择时间最大的机器 不会使结果更差 至于机器的等级，直接使用满足条件但等级最小的，反正和价值无关，减少浪费 找的时候，两种方法，一是维护一个set这样不用打splay，二是统计某个等级的出现数量，因为等级比较少（之所以能这样又是用了性质2） 综上所述，时间复杂度约O(nlogn)对于结论2，可以再补充一个理由：如果用机器找任务，就不能消除时间对决策的直接影响就是说，当我们确定一个区间时，有两个参考量，毕竟会影响价值而我们现在就只用考虑等级，所以才能直接决定1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=110000;typedef long long ll;struct Nod&#123; int x,y;&#125;ma[MAXN],ta[MAXN];bool cmp(Nod a,Nod b) &#123;return a.x&lt;b.x or (a.x==b.x and a.y&lt;b.y);&#125;int c[110];int main()&#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)!=EOF) &#123; memset(c,0,sizeof c); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;ma[i].x,&amp;ma[i].y); for(int i=1;i&lt;=m;i++) scanf("%d%d",&amp;ta[i].x,&amp;ta[i].y); sort(ma+1,ma+n+1,cmp);sort(ta+1,ta+m+1,cmp); int tot=0;ll ans=0; int l=n+1; for(int i=m;i&gt;=1;i--)//task &#123; while(ma[l-1].x&gt;=ta[i].x and l-1&gt;=1) c[ ma[--l].y ]++; for(int j=ta[i].y;j&lt;=100;j++) if(c[j]&gt;0) &#123; c[j]--; tot++; ans+=ta[i].x*500+ta[i].y*2; break; &#125; &#125; printf("%d %lld\n",tot,ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[激光炸弹]]></title>
    <url>%2Fposts%2F2726.html</url>
    <content type="text"><![CDATA[Source and JudgeHNOI2003Bzoj1218Luogu2280 Problem【Description】一种新型的激光炸弹，可以摧毁一个边长为R的正方形内的所有的目标。现在地图上有n个目标，用整数Xi,Yi( 其值在[0,5000] )表示目标在地图上的位置，每个目标都有一个价值。激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆破范围，即那个边长为R的正方形的边必须和x，y轴平行。若目标位于爆破正方形的边上，该目标将不会被摧毁。【Input】输入文件的第一行为正整数n和正整数R，接下来的n行每行有3个正整数，分别表示xi,yi,vi【Output】输出文件仅有一个正整数，表示一颗炸弹最多能炸掉地图上总价值为多少的目标。【Limited conditions】N&lt;=10000结果不会超过32767【Sample input】2 10 0 11 1 1【Sample output】1【Sample explanation】无 Record30min Analysis请先思考后再展开 脑残题二维前缀和早知道不单独一篇文章了…… Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;const int MAXN=5100;int mp[MAXN][MAXN];int main()&#123; int n,R;scanf("%d%d",&amp;n,&amp;R); while(n--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); mp[x+1][y+1]+=c; &#125; n=5001; for(int a=1;a&lt;=n;a++) for(int b=1;b&lt;=n;b++) mp[a][b]+=mp[a][b-1]+mp[a-1][b]-mp[a-1][b-1]; //左上( c-R+1,d-R+1 ) //右下( c,d ) int mx=0; for(int c=n;c&gt;=1;c--) for(int d=n;d&gt;=1;d--) &#123; int a=mymax(c-R,0),b=mymax(d-R,0); mp[c][d]=mp[c][d]-mp[c][b]-mp[a][d]+mp[a][b]; mx=mymax(mx,mp[c][d]); &#125; printf("%d",mx);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP17 D1T3】逛公园]]></title>
    <url>%2Fposts%2Ff27c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2017 提高组 D1T3Loj2316Luogu3953 Problem【Description】策策同学特别喜欢逛公园。公园可以看成一张 N 个点 M 条边构成的有向图，且没有 自环和重边。其中1号点是公园的入口， N 号点是公园的出口，每条边有一个非负权值， 代表策策经过这条边所要花的时间。策策每天都会去逛公园，他总是从1号点进去，从 N 号点出来。策策喜欢新鲜的事物，它不希望有两天逛公园的路线完全一样，同时策策还是一个 特别热爱学习的好孩子，它不希望每天在逛公园这件事上花费太多的时间。如果 1号点 到 N 号点的最短路长为 d ，那么策策只会喜欢长度不超过 d+K 的路线。策策同学想知道总共有多少条满足条件的路线，你能帮帮它吗？为避免输出过大，答案对 P 取模。如果有无穷多条合法的路线，请输出 −1 。【Input】第一行包含一个整数 T , 代表数据组数。接下来 TTT 组数据，对于每组数据： 第一行包含四个整数 N,M,K,P ，每两个整数之间用一个空格隔开。接下来 MMM 行，每行三个整数 ai,bi,ci ，代表编号为 ai,bi​ 的点之间有一条权值为 ci​ 的有向边，每两个整数之间用一个空格隔开。【Output】输出文件包含 T 行，每行一个整数代表答案。【Limited conditions】T&lt;=5,n&lt;=10^5,m&lt;=2*10^5,k&lt;=50有0边1≤P≤10^9,1≤ai​,bi​≤N,0≤ci​≤1000 。数据保证：至少存在一条合法的路线。【Sample input】25 7 2 101 2 12 4 04 5 22 3 23 4 13 5 21 5 32 2 0 101 2 02 1 0【Sample output】3-1【Sample explanation】最短路为 3 。 1 – 5, 1 – 2 – 4 – 5, 1 – 2 – 3 – 5 为 3 条合法路径。 Record1h Analysis请先思考后再展开 通常计数问题可以考虑dp 在本题中，最难的地方在于考虑路径的长度是一个区间，而不是仅仅最短路；我们可以把K看作一个配额，然后我们在路径上进行分配设(x,a)是在x点，使用了a的配额后的路径计数然后显然(y,b)=能到达的(x,a)的和因为配额是单调递增的，所以把配额看作类似时间的东西，按照它来分层那么大致上，dp的转移是定向的 但到底怎么转移呢？由于做题太少，并没有思路请教队长后get到了新姿势：把转移建成边，拓扑dp至于环的存在，由于大致是单向的，所以跨层不会有环如果出现了环，必定在同一层，也就是0环，按照题意输出-1即可不过要确保这个0环是对最短路有影响的，所以跑一遍反图 这样搞一搞后，luogu时间还是差一点的，但保底70为什么呢？反思一下复杂度是nk的，应该完全没有问题====如果非要对此尝试提升（如果考场上显然没有这一步）考虑在转移的时候就进行一下可行性剪枝，直接去除无效转移边这样就达到了灰常优秀的时间了（这属于常数优化吧） Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int MAXN=110000,MAXM=210000,MAXK=60;const int INF=0x3f3f3f3f;int n,K,MOD;int calc(int x,int a) &#123; return (x-1)*(K+1)+a; &#125;struct Nod&#123; int hou[2]; int dis[2]; bool v; Nod() &#123; v=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,c,g;&#125;e[MAXM*2];int ln;void ins(int x,int y,int c,int w)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou[w]; p[x].hou[w]=ln;&#125;void init()&#123; int m;scanf("%d%d%d%d",&amp;n,&amp;m,&amp;K,&amp;MOD); ln=0;for(int i=1;i&lt;=n;i++) p[i].hou[0]=p[i].hou[1]=0; while(m--) &#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); ins(a,b,c,0);ins(b,a,c,1); &#125;&#125;queue&lt;int&gt; q;void spfa(int st,int w)&#123; for(int i=1;i&lt;=n;i++) p[i].dis[w]=INF; p[st].dis[w]=0; p[st].v=1;q.push(st); while(!q.empty()) &#123; int x=q.front(); for(int k=p[x].hou[w];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dis[w]&gt;p[x].dis[w]+e[k].c) &#123; p[y].dis[w]=p[x].dis[w]+e[k].c; if(!p[y].v) &#123; p[y].v=1; q.push(y); &#125; &#125; &#125; p[x].v=0;q.pop(); &#125;&#125;struct DP&#123; int hou; int ru; int ans;&#125;p2[MAXN*MAXK];struct Edge2&#123; int y,g;&#125;e2[MAXM*MAXK];int ln2;void ins2(int x,int y)&#123; ln2++; p2[y].ru++; e2[ln2].y=y; e2[ln2].g=p2[x].hou; p2[x].hou=ln2;&#125;void make_graph()&#123; ln2=0;//debug!! for(int i=0;i&lt;=calc(n,K);i++) p2[i].hou=p2[i].ru=p2[i].ans=0; p2[0].ans=1; for(int x=1;x&lt;=n;x++) &#123; for(int k=p[x].hou[0];k&gt;0;k=e[k].g) &#123; int y=e[k].y; for(int a=0;a&lt;=K;a++) &#123; int b=p[x].dis[0]+a+e[k].c-p[y].dis[0];//debug 改数组，忘dis下标 if(b&lt;=K and p[x].dis[0]+a+e[k].c+p[y].dis[1]&lt;=p[n].dis[0]+K) //debug 可行性剪枝 ins2( calc(x,a),calc(y,b) ); else break; &#125; &#125; &#125;&#125;int sta[MAXN*MAXK];int solve()&#123; int top=0; for(int i=0;i&lt;=calc(n,K);i++) if(p2[i].ru==0) sta[++top]=i; int sum=0; while(top&gt;0) &#123; int x=sta[top--]; sum++; for(int k=p2[x].hou;k&gt;0;k=e2[k].g) &#123; int y=e2[k].y; p2[y].ans=(p2[y].ans+p2[x].ans)%MOD; p2[y].ru--; if(p2[y].ru==0) sta[++top]=y; &#125; &#125; if(sum&lt;n*(K+1)) return -1; int ans=0; for(int i=calc(n,0);i&lt;=calc(n,K);i++) ans=(ans+p2[i].ans)%MOD; return ans;&#125;int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; init(); spfa(1,0);spfa(n,1); make_graph(); printf("%d\n",solve()); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>难度2</tag>
        <tag>拓扑</tag>
        <tag>dp</tag>
        <tag>分层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP17 D1T2】时间复杂度]]></title>
    <url>%2Fposts%2F25a7.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2017 提高组 D1T2Loj2364Luogu3952 Problem【Description】小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。A++语言的循环结构如下：F i x y 循环体E其中F i x y表示新建变量 i （变量 i 不可与未被销毁的变量重名）并初始化为 x ， 然后判断 i 和 y 的大小关系，若 i 小于等于 y 则进入循环，否则不进入。每次循环结束后 iii 都会被修改成 i+1 ，一旦 i 大于 y 终止循环。x 和 y 可以是正整数（ x 和 y 的大小关系不定）或变量 n 。 n 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100。“E”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“O”表示通常意义下“Θ”的概念。【Input】输入文件第一行一个正整数 t ，表示有 t （ t≤10 ）个程序需要计算时间复杂度。 每个程序我们只需抽取其中 F i x y和E即可计算时间复杂度。注意：循环结构允许嵌套。接下来每个程序的第一行包含一个正整数 L 和一个字符串， L 代表程序行数，字符 串表示这个程序的复杂度，O(1)表示常数复杂度，O(n^w)表示复杂度为 n^w ，其中w是一个小于100的正整数（输入中不包含引号），输入保证复杂度只有O(1)和O(n^w) 两种类型。接下来 L 行代表程序中循环结构中的F i x y或者 E。 程序行若以F开头，表示进入一个循环，之后有空格分离的三个字符（串）i x y， 其中 i 是一个小写字母（保证不为 n ），表示新建的变量名， x 和 y 可能是正整数或 n ，已知若为正整数则一定小于 100。程序行若以E开头，则表示循环体结束。【Output】输出文件共 t 行，对应输入的 t 个程序，每行输出Yes或No或者ERR（输出中不包含引号），若程序实际复杂度与输入给出的复杂度一致则输出Yes，不一致则输出No，若程序有语法错误，则输出ERR（其中语法错误只有:① F 和 E 不匹配②新建的变量与已经存在但未被销毁的变量重复两种情况） 。注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 ERR。【Limited conditions】1≤a,b≤1,000,000,000输入数据保证存在小凯无法准确支付的商品。【Sample input】82 O(1)F i 1 1E2 O(n^1)F x 1 nE1 O(1)F x 1 n4 O(n^2)F x 5 nF y 10 nEE4 O(n^2)F x 9 nEF y 2 nE4 O(n^1)F x 9 nF y n 4EE4 O(1)F y n 4F x 9 nEE4 O(n^2)F x 1 nF x 1 10EE【Sample output】YesYesERRYesNoYesYesERR【Sample explanation】无 Record1h Analysis请先思考后再展开 大模拟，不解释考场上没有出数据，过了大数据就信仰杠T1去了结果蜜汁ac感受一下…… 印象中，当时有个小bug就是ce了不能直接break，因为还要输入，调试了好一会儿还有就是，代码中有个地方写错了，但误打误撞没事…… Code1这是比赛代码，留作纪念请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;char ss[50],s1[50];int strtoint()&#123; scanf("%s",s1); if(s1[0]=='n') return 0; int ts=0,len=strlen(s1); for(int i=0;i&lt;=len-1;i++) ts=ts*10+s1[i]-'0'; return ts;&#125;int nm[210];bool us[40];bool isn[210];bool noin[210];int main()&#123; int t;scanf("%d",&amp;t); while(t--) &#123; memset(us,0,sizeof(us)); memset(isn,0,sizeof(isn)); memset(noin,0,sizeof(noin)); int ln;char nn;int w; scanf("%d O(%c",&amp;ln,&amp;nn); if(nn=='1') w=0; else scanf("^%d",&amp;w); scanf(")"); int ans=0; int mxl=0,l=0; int tp=0; bool ce=0; for(int ll=1;ll&lt;=ln;ll++) &#123; scanf("%s",ss); if(ss[0]=='F') &#123; scanf("%s",&amp;ss); int x=strtoint(),y=strtoint(); tp++;if(tp&lt;=0) &#123;ce=1;continue;&#125; if(ce==1) continue; nm[tp]=ss[0]-'a'; if(us[nm[tp]]) ce=1; us[nm[tp]]=1; if(noin[tp-1]) &#123; noin[tp]=1; continue; &#125; if(x==0 and y==0) noin[tp]=0; else if(x!=0 and y==0)//1~n &#123; l++;isn[tp]=1; if(l&gt;mxl) ans+=1,mxl=l; &#125; else if(x==0 and y!=0) noin[tp]=1; else if(x&gt;y) noin[tp]=1; &#125; else &#123; if(ce==1) continue; if(tp&gt;0 and isn[tp]) isn[tp]=0,l--; if(tp&gt;0) us[nm[tp]]=0; noin[tp]=0; tp--; if(tp&lt;0) ce=1; &#125; &#125; if(ce or tp!=0) printf("ERR\n"); else &#123; if(w==ans) printf("Yes\n"); else printf("No\n"); &#125; &#125; //system("pause");&#125; Code2加上大量注释请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;char ss[50],s1[50];int strtoint()&#123; scanf("%s",s1); if(s1[0]=='n') return 0; int ts=0,len=strlen(s1); for(int i=0;i&lt;=len-1;i++) ts=ts*10+s1[i]-'0'; return ts;&#125;int nm[210];//变量名记录bool us[40];//变量名的使用情况bool isn[210];//n的复杂度bool no_in[210];//没有真的进去int main()&#123; int t;scanf("%d",&amp;t); while(t--) &#123; memset(us,0,sizeof(us)); memset(isn,0,sizeof(isn)); memset(no_in,0,sizeof(no_in)); int ln;char nn; scanf("%d O(%c",&amp;ln,&amp;nn); int w; if(nn=='1') w=0; else scanf("^%d",&amp;w); scanf(")"); int ans=0; int mxl=0,l=0;//n^l int tp=0;//深度 bool ce=0; for(int ll=1;ll&lt;=ln;ll++) &#123; scanf("%s",ss); if(ss[0]=='F') &#123; scanf("%s",ss);//变量名 //scanf("%s",&amp;ss);这是当时代码，打错了 int x=strtoint(),y=strtoint(); tp++;if(tp&lt;=0) ce=1; if(ce==1) continue; nm[tp]=ss[0]-'a'; if(us[nm[tp]]) ce=1;//重名 us[nm[tp]]=1; if(no_in[tp-1])//只读入，不干活 &#123; no_in[tp]=1; continue; &#125; isn[tp]=0; if(x==0 and y==0) no_in[tp]=0;//n~n，忽略常数 else if(x!=0 and y==0)//1~n &#123; l++;isn[tp]=1; if(l&gt;mxl) ans+=1,mxl=l; &#125; else if(x==0 and y!=0) no_in[tp]=1;//n~1 else if(x&gt;y) no_in[tp]=1; else no_in[tp]=0;//x~y，忽略常数 &#125; else//收尾 &#123; if(ce==1) continue; if(tp&gt;0) &#123; us[nm[tp]]=0; no_in[tp]=0; if(isn[tp]) l--; &#125; tp--; if(tp&lt;0) ce=1; &#125; &#125; if(ce or tp!=0) puts("ERR"); else if(w==ans) puts("Yes"); else puts("No"); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP17 D1T1】小凯的疑惑]]></title>
    <url>%2Fposts%2F34ee.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2017 提高组 D1T1Loj2363Luogu3951 Problem【Description】小凯手中有两种面值的金币，两种面值均为正整数且彼此互素。每种金币小凯都有无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小凯想知道在无法准确支付的物品中，最贵的价值是多少金币？【Input】输入数据仅一行，包含两个正整数 a 和 b，它们之间用一个空格隔开，表示小凯手中金币的面值。【Output】输出文件仅一行，一个正整数 N ，表示不找零的情况下，小凯用手中的金币不能准确支付的最贵的物品的价值。【Limited conditions】1≤a,b≤1,000,000,000输入数据保证存在小凯无法准确支付的商品。【Sample input】3 7【Sample output】11【Sample explanation】无 Record2h Analysis请先思考后再展开 此题为检验人心态的极好题目，值得推荐然后我就挂了…… 题目条件：$a&gt;0,b&gt;0,gcd(a,b)=1$然后求最大的$ax+by \neq K$ 很容易去想exgcd的做法既然互质，exgcd总是有解的，问题只是在于是否满足$x \geq 0,y \geq 0$那么我们求出x的最小正整数解，试图让y最大，这样就能够验证答案了 题外话：比赛时，通过打表，我发现最大是a+b（要是向别人一样直接发现规律就没有这篇文章了）【然后通过这个让我避免的草哥的遭遇，结果又沉迷卡常去了】 然后？我们似乎陷入了一个狭隘区——验证答案考虑寻找答案？ 首先，条件是不变的（正负性），思想也是不变的（x表示最小非负数解）那么对于$ax+by=K$,作为合法答案，要求$0 \leq x \leq b-1,y&lt;0$注意：这个时候K是我们要求的答案，所以x和y之间的关系变得没有影响则y=-1,x=b-1，得到合法最大值$K=a(b-1)+b(-1)=a \times b -a-b$ Code请先思考后再展开 略]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>精品题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP16 D2T3】愤怒的小鸟]]></title>
    <url>%2Fposts%2Ff5e.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2016 提高组 D2T3Loj2363Uoj265Luogu2831Caioj1580 Problem【Description】Kiana最近沉迷于一款神奇的游戏无法自拔。简单来说，这款游戏是在一个平面上进行的。有一架弹弓位于(0,0)处，每次Kiana可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如y=ax^2+bx的曲线，其中a, b是Kiana指定的参数，且必须满足a&lt;0。当小鸟落回地面（即x轴）时，它就会瞬间消失。在游戏的某个关卡里，平面的第一象限中有n只绿色的小猪，其中第i只小猪所在的坐标为(xi, yi)。如果某只小鸟的飞行轨迹经过了(xi, yi)，那么第i只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行；如果一只小鸟的飞行轨迹没有经过(xi, yi)，那么这只小鸟飞行的全过程就不会对第i只小猪产生任何影响。例如，若两只小猪分别位于(1,3)和(3,3)，Kiana可以选择发射一只飞行轨迹为 y = -x^2 + 4x的小鸟，这样两只小猪就会被这只小鸟一起消灭。而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。这款神奇游戏的每个关卡对Kiana来说都很难，所以Kiana还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在【输入格式】中详述。假设这款游戏一共有T个关卡，现在Kiana想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。【Input】第一行包含一个正整数T，表示游戏的关卡总数。下面依次输入这T个关卡的信息。每个关卡第一行包含两个非负整数n,m，分别 表示该关卡中的小猪数量和Kiana输入的神秘指令类型。接下来的n行中，第i行包含 两个正实数xi, yi，表示第i只小猪坐标为(xi, yi)。数据保证同一个关卡中不存在两只坐标完全相同的小猪。如果m = 0，表示Kiana输入了一个没有任何作用的指令。如果m = 1，则这个关卡将会满足：至多用⌈n/3 + 1⌉只小鸟即可消灭所有小猪。如果m = 2，则这个关卡将会满足：一定存在一种最优解，其中有一只小鸟消灭了至少⌊n/3⌋只小猪。【Output】对每个关卡依次输出一行答案。输出的每一行包含一个正整数，表示相应的关卡中，消灭所有小猪最少需要的小鸟数量。【Limited conditions】保证1&lt;=n&lt;=18，0&lt;=m&lt;=2，0&lt;xi, yi&lt;10，输入中的实数均保留到小数点后两位。【Sample input】75 00.01 0.190.02 0.380.03 0.570.04 0.760.05 0.952 01.00 3.003.00 3.005 21.00 5.002.00 8.003.00 9.004.00 8.005.00 5.002 01.41 2.001.73 3.003 01.11 1.412.34 1.792.98 1.495 02.72 2.722.72 3.143.14 2.723.14 3.145.00 5.0010 07.16 6.282.02 0.388.33 7.787.68 2.097.46 7.865.77 7.448.24 6.724.42 5.115.42 7.798.15 4.99【Sample output】5112236【Sample explanation】无 Record2h卡精度 Analysis请先思考后再展开 前置知识： 中考常规操作之给出两个点，解二次函数y=ax^2+bx 卡精度的eps 然后，这么小的n，又是在noip的环境中，基本就是状压考虑状态压缩dp，然后对于一个s，如果从前往后递推，是可以线性的，因为满足最优子结构，然后前面的已经更新好了 然后一开始傻傻地觉得枚举a和b是灰常多的其实只要枚举两个点，解出一个二次函数就好然后只要预处理出cc，表示枚举两个点，能搞掉的点的集合复杂度就达到了O(2^n×n^2)然后因为多组数据，复杂度炸了 考虑优化掉一个n的方法（其实可以看作一个log般的存在）有一个灰常不显然的特性（很多时候正解都是这样）：因为所有点都在第一象限，对于需要经过的点中【横坐标最左边的】的那个，迟早要被枚举到或者覆盖到的那么与其等着去被覆盖，不如首先枚举那么在dp中，枚举i和j，变成了i确定枚举j这样就达到了无比优秀的O(2^n×n) Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=20,MAXS=1&lt;&lt;20;const double eps=1e-10;//*******************全局定义*******************int bin[MAXN];double xx[MAXN],yy[MAXN];int cc[MAXN][MAXN];int dp[MAXS];//*******************实现*******************double myabs(double x) &#123;return x&gt;0?x:-x;&#125;//*******************主函数*******************int main()&#123; bin[0]=1;for(int i=1;i&lt;MAXN;i++) bin[i]=bin[i-1]&lt;&lt;1; int T;scanf("%d",&amp;T); while(T--) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lf%lf",&amp;xx[i],&amp;yy[i]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; if(i==j) &#123;cc[i][j]=bin[i-1];continue;&#125; cc[i][j]=0; double a1=xx[i]*xx[i],b1=xx[i],c1=yy[i];//a1x+b1y=c1 double a2=xx[j]*xx[j],b2=xx[j],c2=yy[j];//a2x+b2y=c2 if(myabs(a1*b2-a2*b1)&lt;=eps) continue;//分母!=0 double x=(c1*b2-c2*b1)/(a1*b2-a2*b1); double y=(c1-a1*x)/b1;//y=(x)a^2+(y)a if(x&gt;=-eps) continue;//a&lt;0 for(int now=1;now&lt;=n;now++) &#123; double ny=x*xx[now]*xx[now]+y*xx[now]; if(myabs(ny-yy[now])&lt;=eps) cc[i][j]+=bin[now-1]; &#125; &#125; memset(dp,63,sizeof(dp));dp[0]=0; int tot=bin[n]-1;xx[n+1]=20; for(int s=0;s&lt;tot;s++) &#123; int i=n+1;for(int j=1;j&lt;=n;j++) if( (s&amp;bin[j-1])==0 and xx[j]&lt;xx[i]) i=j; for(int j=1;j&lt;=n;j++) dp[s|cc[i][j]]=mymin(dp[s|cc[i][j]],dp[s]+1); &#125; printf("%d\n",dp[tot]); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP16 D2T2】蚯蚓]]></title>
    <url>%2Fposts%2F867.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2016 提高组 D2T2Loj2362Uoj264Bzoj4721Luogu2827Caioj1579 Problem【Description】蛐蛐国里现在共有n只蚯蚓（n为正整数）。每只蚯蚓拥有长度，我们设第i只蚯蚓的长度为ai(i=1, 2, …, n)，并保证所有的长度都是非负整数（即：可能存在长度为0的蚯蚓）。每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数p （是满足0&lt;p&lt;1的有理数）决定，设这只蚯蚓长度为x，神刀手会将其切成两只长度分别为⌊px⌋和x - ⌊px⌋的蚯蚓。特殊地，如果这两个数的其中一个等于0，则这个长度为0的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加q （是一个非负整常数）。蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要m秒才能到来…… （m为非负整数）蛐蛐国王希望知道这m秒内的战况。具体来说，他希望知道：1. m秒内，每一秒被切断的蚯蚓被切断前的长度（有m个数）2. m秒后，所有蚯蚓的长度（有n + m个数）。【Input】第一行包含六个整数n,m,q,u,v,t，其中：n,m,q的意义见【问题描述】；u,v,t均为正整数；你需要自己计算p = u/v (保证0&lt;u&lt;v) t是输出参数，其含义将会在 【输出格式】中解释。第二行包含n个非负整数，为a1, a2, …, an，即初始时n只蚯蚓的长度。同一行中相邻的两个数之间，恰好用一个空格隔开。【Output】第一行输出⌊m/t⌋个整数，按时间顺序，依次输出第t秒，第2t秒，第3t秒……被切断蚯蚓（在被切断前）的长度。第二行输出⌊(n+m)/t⌋个整数，输出m秒后蚯蚓的长度；需要按从大到小的顺序依次输出排名第t，第2t，第3t……的长度。同一行中相邻的两个数之间，恰好用一个空格隔开。即使某一行没有任何数需要输出，你也应输出一个空行。【Limited conditions】1&lt;=n&lt;=10^5，0 &lt;= m &lt;= 7 x 10^6， 0 &lt; u &lt; v &lt;= 10^90 &lt;= q &lt;= 200， 1 &lt;= t &lt;= 71， 0 &lt;= ai &lt;= 10^8。【Sample input 1】3 7 1 1 3 13 3 2【Sample output 1】3 4 4 4 5 5 66 6 6 5 5 4 4 3 2 2【Sample input 2】3 7 1 1 3 23 3 2【Sample output 2】4 4 56 5 4 3 2【Sample input 3】3 7 1 1 3 93 3 2【Sample output 3】//空行2【Sample explanation】在神刀手到来前：3只蚯蚓的长度为3,3,2。1秒后：一只长度为3的蚯蚓被切成了两只长度分别为1和2的蚯蚓，其余蚯蚓的长度增加了1。最终4只蚯蚓的长度分别为(1,2),4,3。括号表示这个位置刚刚有一只蚯蚓被切断2秒后：一只长度为4的蚯蚓被切成了1和3。5只蚯蚓的长度分别为：2,3,(1,3),4。3秒后：一只长度为4的蚯蚓被切断。6只蚯蚓的长度分别为：3,4,2,4,(1,3)。4秒后：一只长度为4的蚯蚓被切断。7只蚯蚓的长度分别为：4,(1,3),3,5,2,4。5秒后：一只长度为5的蚯蚓被切断。8只蚯蚓的长度分别为：5,2,4,4,(1,4),3,5。6秒后：一只长度为5的蚯蚓被切断。9只蚯蚓的长度分别为：（1,4),3,5,5,2,5,4,6。7秒后：一只长度为6的蚯蚓被切断。10只蚯蚓的长度分别为：2,5,4,6,6,3,6,5,(2,4)。所以，7秒内被切断的蚯蚓的长度依次为3,4,4,4,5,5,6。7秒后，所有蚯蚓长度从大到小排序为6,6,6,5,5,4,4,3,2,2 Record3h Analysis请先思考后再展开 首先，一个显而易见的做法：当q=0，搞一个堆，那么每次取最大的出来，切开，然后把另外两端塞回去那这个q怎么处理呢？考虑一个全局常量add，然后就是堆里面所有元素都要加上这个常量，放东西进去的时候，放入的是d-add即可 然鹅这样是mlogm的，只有70分一开始没有抄数据范围，还以为是灰常优秀的做法……其实只是最暴力的 怎么优化呢？这个log有点烦 有没有什么题目的特性被忽略了？割点比值的固定！然后因为每次拿出来的蚯蚓，长度不递增所以切完后，左右两边同类比较的话，也是不递增的，满足单调性所以我们可以直接利用这个单调性，把堆用三个队列代替 具体来说：main队列，left队列，right队列，都满足不递增性质然后每次取得时候，取三个中的最大值即可 coding中煞笔错误： 开头的队列要有序 结束的队列，不能用sort，否则复杂度还是一样的，而是继续利用单调性 被卡了好多次…… 卡精度，题目中的p不要立刻算出来，而是用到再计算 卡最小值，应该设为负无穷，我通常是用其一半的，然后就被卡了…… Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;typedef long long ll;//*******************全局常量*******************const int MAXN=7000000+100000+10;const int INF=0x7fffffff;//*******************全局定义*******************struct Que&#123; int tou,wei; int a[MAXN]; Que() &#123; tou=1,wei=0; &#125; void push(int x) &#123; a[++wei]=x; &#125; void pop() &#123; tou++; &#125; int top() &#123; return a[tou]; &#125;&#125;qq[3];//main,left,right//*******************实现*******************int findmx()&#123; int tmp,mx=-INF; for(int i=0;i&lt;3;i++) if(qq[i].tou&lt;=qq[i].wei and qq[i].top()&gt;mx) tmp=i,mx=qq[i].top(); qq[tmp].pop(); return mx;&#125;//*******************主函数*******************int tmp[MAXN];int main()&#123; int n,m,q,u,v,t;scanf("%d%d%d%d%d%d",&amp;n,&amp;m,&amp;q,&amp;u,&amp;v,&amp;t); qq[0].wei=n;for(int i=1;i&lt;=n;i++) scanf("%d",&amp;qq[0].a[i]); sort(qq[0].a+1,qq[0].a+n+1);reverse(qq[0].a+1,qq[0].a+n+1); for(int ti=1;ti&lt;=m;ti++)//回合 &#123; int add=q*(ti-1); int now=findmx();if(ti%t==0) printf("%d ",now+add); int l=ll(now+add)*u/v,r=(now+add)-l; qq[1].push(l-add-q);qq[2].push(r-add-q); &#125; putchar('\n'); for(int i=1;i&lt;=n+m;i++) &#123; int now=findmx(); if(i%t==0) printf("%d ",now+q*m); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
        <tag>难度2</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP16 D2T2】换教室]]></title>
    <url>%2Fposts%2F8e5c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2016 提高组 D2T2Loj2360Uoj262Bzoj4720Luogu1850Caioj1577 Problem【Description】对于刚上大学的牛牛来说，他面临的第一个问题是如何根据实际情况申请合适的课程。在可以选择的课程中，有2n节课程安排在n个时间段上。在第i (1 &lt;= i &lt;= n)个时间段上，两节内容相同的课程同时在不同的地点进行，其中，牛牛预先被安排在教室ci上课，而另一节课程在教室di进行。在不提交任何申请的情况下，学生们需要按时间段的顺序依次完成所有的n节安排好的课程。如果学生想更换第i节课程的教室，则需要提出申请。若申请通过，学生就可以在第i个时间段去教室di上课，否则仍然在教室ci上课。由于更换教室的需求太多，申请不一定能获得通过。通过计算，牛牛发现申请更换第i节课程的教室时，申请被通过的概率是一个已知的实数ki，并且对于不同课程的申请，被通过的概率是互相独立的。学校规定，所有的申请只能在学期开始前一次性提交，并且每个人只能选择至多m节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室，而不能根据某些课程的申请结果来决定其他课程是否申请；牛牛可以申请自己最希望更换教室的m门课程，也可以 不用完 这m个申请的机会，甚至可以一门课程都不申请。因为不同的课程可能会被安排在不同的教室进行，所以牛牛需要利用课间时间从一间教室赶到另一间教室。牛牛所在的大学有v个教室，有e条道路。每条道路连接两间教室，并且是可以 双向通行 的。由于道路的长度和拥堵程度不同，通过不同的道路耗费的体力可能会有所不同。当第i (1&lt;= i &lt;= n-1)节课结束后，牛牛就会从这节课的教室出发，选择一条耗费体力最少的 路径 前往下一节课的教室。现在牛牛想知道，申请哪几门课程可以使他因在教室间移动耗费的体力值的总和的 期望值 最小，请你帮他求出这个最小值。【Input】第一行四个整数n, m, v, e。n表示这个学期内的时间段的数量；m表示牛牛最多可以申请更换多少节课程的教室；v表示牛牛学校里教室的数量；e表示牛牛的学校里道路的数量。第二行n个正整数，第i (1&lt;=i&lt;=n)个正整数表示ci，即第i个时间段牛牛被安排上课的教室；第三行n个正整数，第i (1&lt;=i&lt;=n)个正整数表示di，即第i个时间段另一间上同样课程的教室；第四行n个实数，第i (1&lt;=i&lt;=n)个实数表示ki，即牛牛申请在第i个时间段更换教室获得通过的概率。接下来e行，每行三个正整数aj，bj，wj，表示有一条双向道路连接教室aj，bj，通过这条道路需要耗费的体力值是wj；【Output】输出一行，包含一个实数，四舍五入精确到小数点后 恰好2位 ，表示答案。你的输出必须和标准输出 完全一样 才算正确。测试数据保证四舍五入后的答案和准确答案的差的绝对值不大于4 x 10^-3。（如果你不知道什么是浮点误差，这段话可以理解为：对于大多数的算法，你可以正常地使用浮点数类型而不用对它进行特殊的处理）【Limited conditions】保证1 &lt;= Ci &lt;= v。保证1&lt;=di&lt;=v。保证0 &lt;= ki &lt;= 1。保证 1 &lt;= n &lt;= 2000，0 &lt;= m &lt;= 2000， 1 &lt;= v &lt;= 300， 0 &lt;= e &lt;= 90000。保证1 &lt;= aj, bj &lt;= v, 1 &lt;= wj &lt;= 100。保证通过学校里的道路，从任何一间教室出发，都能到达其他所有的教室。道路中可能会有多条双向道路连接相同的两间教室。也有可能有道路两端连接的是同一间教室。保证输入的实数最多包含3位小数。【Sample input】3 2 3 32 1 21 2 10.8 0.2 0.51 2 51 3 32 3 1【Sample output】2.80【Sample explanation】无 Record3h Analysis请先思考后再展开 期望=各种情况的【概率×权值】之和意义即尝试无限次后，平均的权值具有线性性所以就dp过去 $$f(i,j,0)=min\left{\begin{matrix}f(i-1,j,0)+dis(c_{i-1},c_i)\f(i-1,j,1)+dis(c_{i-1},c_i)\times (1-k_{i-1})+dis(d_{i-1},c_i)\times k_{i-1}\end{matrix}\right.$$ $$f(i,j,1)=min\left{\begin{matrix}f(i-1,j-1,0)+dis(c_{i-1},c_i)\times (1-k_i)+dis(c_{i-1},d_i)\times k_i\f(i-1,j-1,1)+dis(c_{i-1},c_i)\times (1-k_{i-1}) \times (1-k_i)+dis(c_{i-1},d_i)\times (1-k_{i-1}) \times k_i+dis(d_{i-1},c_i)\times k_{i-1}\times (1-k_i)+dis(d_{i-1},d_i)\times k_{i-1} \times k_i\end{matrix}\right.$$ Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; double mymin(double x,double y) &#123;return x&lt;y?x:y;&#125; const int MAXN=2100; int c[MAXN],d[MAXN]; int mp[310][310]; double p[MAXN]; double f[MAXN][MAXN][2];//f(x,k,0/1)表示考虑到第x个，使用状况为k，当前决策为0/1的期望值 void main() &#123; int n,m,v,e;scanf("%d%d%d%d",&amp;n,&amp;m,&amp;v,&amp;e); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;c[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;d[i]); for(int i=1;i&lt;=n;i++) scanf("%lf",&amp;p[i]); memset(mp,63,sizeof mp); for(int i=1;i&lt;=v;i++) mp[i][i]=0; while(e--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); if(c&lt;mp[x][y]) mp[x][y]=mp[y][x]=c; &#125; for(int k=1;k&lt;=v;k++)//debug 太久没打了，忘记在最前面 for(int i=1;i&lt;=v;i++) for(int j=1;j&lt;=v;j++) mp[i][j]=mymin(mp[i][j],mp[i][k]+mp[k][j]); memset(f,127,sizeof f); f[n][0][0]=f[n][1][1]=0; for(int x=n-1;x&gt;=1;x--) &#123; double cc=mp[c[x]][c[x+1]],cd=mp[c[x]][d[x+1]],dc=mp[d[x]][c[x+1]],dd=mp[d[x]][d[x+1]]; for(int k=0;k&lt;=mymin(n-x+1,m);k++) &#123; f[x][k][0]=mymin( f[x+1][k][0]+cc, f[x+1][k][1]+p[x+1]*cd+(1.0-p[x+1])*cc ); if(k&gt;0) f[x][k][1]=f[x+1][k-1][0]+p[x]*dc+(1.0-p[x])*cc; if(k&gt;1) f[x][k][1]=mymin( f[x][k][1], f[x+1][k-1][1]+p[x]*p[x+1]*dd+p[x]*(1.0-p[x+1])*dc+ (1.0-p[x])*p[x+1]*cd+(1.0-p[x])*(1.0-p[x+1])*cc ); &#125; &#125; double ans=0x3f3f3f3f; for(int k=0;k&lt;=m;k++) ans=mymin(ans,mymin(f[1][k][0],f[1][k][1])); printf("%.2lf",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP16 D1T2】天天爱跑步]]></title>
    <url>%2Fposts%2F9594.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2016 提高组 D1T2Loj2359Uoj261Bzoj4719Luogu1600Caioj1576 Problem【Description】 小C同学认为跑步灰常有趣，于是决定制作一款叫做《天天爱跑步》的游戏。《天天爱跑步》是一个养成类游戏，需要玩家每天按时上线，完成打卡任务。这个游戏的地图可以看作一棵包含n个结点和n - 1条边的树，每条边连接两个结点，且任意两个结点存在一条路径互相可达。树上结点编号为从1到n的连续正整数。现在有m个玩家，第i个玩家的起点为Si，终点为Ti。每天打卡任务开始时，所有玩家 在第0秒 同时从 自己的起点 出发，以 每秒跑一条边 的速度，不间断地沿着最短路径向着 自己的终点 跑去，跑到终点后该玩家就算完成了打卡任务。（由于地图是一棵树，所以每个人的路径是唯一的）小C想知道游戏的活跃度，所以在每个结点上都放置了一个观察员。在结点j的观察员会选择在第Wj秒观察玩家，一个玩家能被这个观察员观察到当且仅当该玩家在第Wj秒也 正好 到达了结点j。小C想知道每个观察员会观察到多少人？注意： 我们认为一个玩家到达自己的终点后该玩家就会结束游戏，他不能等待一段时间后再被观察员观察到。即对于把结点j作为终点的玩家：若他在第Wj秒前到达 终点，则在结点j的观察员 不能观察到 该玩家；若他 正好 在第Wj秒到达终点，则在结点j的观察员 可以观察到 这个玩家。【Input】第一行有两个整数n和m。其中n代表树的结点数量，同时也是观察员的数量， m代表玩家的数量。接下来n - 1行每行两个整数u和v，表示结点u到结点v有一条边。接下来一行n个整数，其中第j个整数为Wj，表示结点j出现观察员的时间。 接下来m行，每行两个整数Si和Ti，表示一个玩家的起点和终点。【Output】输出1行n个整数，第j个整数表示结点j的观察员可以观察到多少人。【Limited conditions】对于所有的数据，保证1 &lt;= Si, Ti &lt;= n，0 &lt;= Wj &lt;= n。【Sample input 1】6 32 31 21 44 54 60 2 5 1 2 31 51 32 6【Sample output 1】2 0 0 1 1 1【Sample input 2】5 31 22 32 41 50 1 0 3 03 11 45 5【Sample output 2】1 2 1 0 1【Sample explanation】无 Record5h Analysis请先思考后再展开 首先，树上路径可以分割为两条链咱们推一推柿子吧，d是深度向上：$d_y+w_y=d_x$向下：$w_y-d_y=d_x-2\times d_{lca}$ 然后发现就是两种值的维护，然后分上下讨论但是怎么维护呢？ 我在晚修的时候忽然想到一种奇淫巧技用到了vector（不喜欢也可以写链表）把上面说的维护的两种值，按照值本身分成数组，然后我们要的就是对同值的编号，对于链上的部分，出现次数+1 那么我是使用树链剖分来搞的用线段树维护的话，空间复杂度是很高的使用灵活的差分，看起来还是一样，但其实我们可以运用vector的特点了，那就是实际总空间灰常小，然后定位的话，就是得到了l和r之后，在保证编号有序的情况下，二分查找一下就好了 那么最后的时候递推一下，累计一下答案，这道题就完成了但是其实细节还是很多的例如一开始忘记对两种情况分开维护之类 现在我们分析一下复杂度空间：$O(n)$，常数10以内时间：$O(nlogn)$，常数3以内吧大概；看起来虽然是log方，但数量灰常少，均摊小然鹅这样优秀的时间复杂度，居然不是很快？好像有些oj还会超时……好迷啊，之前那几个数据结构题也是类似的感觉，nlogn巨慢，不知道是不是复杂度算错？ UP 2018.8.9 rose用的是线段树维护虽然是区间操作，但还是可以动态开点至于复杂度，我们无敌的波老师（hanks_o大爷）有个证明：最多只会有logn层，然后每一次分治的时候，最多会分裂成两段，那么在第i层就分裂成logn段，所以说最多新开log方的节点，而且大概是很难构造的吧 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=310000;//*******************全局定义*******************struct Nod&#123; int hou; int dep; int siz; int son,tp,fa;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXN*2];int ln=0;void ins(int x,int y)&#123; e[++ln]=(Edge)&#123;y,p[x].hou&#125;; p[x].hou=ln;&#125;int w[MAXN];int ans[MAXN];//按dfs序//*******************实现*******************void pre(int x,int fa)&#123; p[x].fa=fa; p[x].dep=p[fa].dep+1; p[x].siz=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; pre(y,x); p[x].siz+=p[y].siz; if(p[y].siz&gt;p[p[x].son].siz) p[x].son=y; &#125;&#125;int id=0;int pos[MAXN],pos2[MAXN];//dfs序编号、原编号int getlca(int x,int y)&#123; while(p[x].tp!=p[y].tp) &#123; if(p[p[x].tp].dep&lt;p[p[y].tp].dep) swap(x,y); x=p[p[x].tp].fa; &#125; return (p[x].dep&lt;p[y].dep)?x:y;&#125;void poufen(int x,int tp)&#123; pos[x]=++id;pos2[id]=x;p[x].tp=tp; if(p[x].son&gt;0) poufen(p[x].son,p[x].tp); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y!=p[x].fa and y!=p[x].son) poufen(y,y); &#125;&#125;vector&lt;int&gt; upbh[MAXN*2],downbh[MAXN*2];//编号vector&lt;int&gt; upcf[MAXN*2],downcf[MAXN*2];//差分void solve()&#123; int st,ed;scanf("%d%d",&amp;st,&amp;ed); int up=p[st].dep+MAXN,down=p[st].dep-2*p[getlca(st,ed)].dep+MAXN; while(p[st].tp!=p[ed].tp) &#123; if(p[p[st].tp].dep&gt;p[p[ed].tp].dep)//向上 &#123; int l=lower_bound(upbh[up].begin(),upbh[up].end(),pos[p[st].tp])-upbh[up].begin(); int r=upper_bound(upbh[up].begin(),upbh[up].end(),pos[st])-upbh[up].begin()-1; upcf[up][l]++; upcf[up][r+1]--; st=p[p[st].tp].fa; &#125; else//向下 &#123; int l=lower_bound(downbh[down].begin(),downbh[down].end(),pos[p[ed].tp])-downbh[down].begin(); int r=upper_bound(downbh[down].begin(),downbh[down].end(),pos[ed])-downbh[down].begin()-1; downcf[down][l]++; downcf[down][r+1]--; ed=p[p[ed].tp].fa; &#125; &#125; if(p[st].dep&gt;p[ed].dep)//向上 &#123; int l=lower_bound(upbh[up].begin(),upbh[up].end(),pos[ed])-upbh[up].begin(); int r=upper_bound(upbh[up].begin(),upbh[up].end(),pos[st])-upbh[up].begin()-1; upcf[up][l]++; upcf[up][r+1]--; &#125; else//向下 &#123; int l=lower_bound(downbh[down].begin(),downbh[down].end(),pos[st])-downbh[down].begin(); int r=upper_bound(downbh[down].begin(),downbh[down].end(),pos[ed])-downbh[down].begin()-1; downcf[down][l]++; downcf[down][r+1]--; &#125;&#125;//*******************主函数*******************int main()&#123; memset(p,0,sizeof(p)); int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; pre(1,0);poufen(1,1); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]); for(int i=1;i&lt;=n;i++) &#123; int x=pos2[i]; int w1=w[x]+p[x].dep+MAXN;if(w1&lt;2*MAXN) upbh[w1].push_back(i),upcf[w1].push_back(0); int w2=w[x]-p[x].dep+MAXN;if(w2&lt;2*MAXN) downbh[w2].push_back(i),downcf[w2].push_back(0); &#125; for(int i=0;i&lt;2*MAXN;i++)//debug upper_bound找不到 &#123; upbh[i].push_back(MAXN-1),upcf[i].push_back(0); downbh[i].push_back(MAXN-1),downcf[i].push_back(0); &#125; for(int i=1;i&lt;=m;i++) solve(); for(int i=0;i&lt;2*MAXN;i++) &#123; int now=0,sz; sz=upbh[i].size(); for(int j=0;j&lt;sz;j++) &#123; now+=upcf[i][j]; ans[ upbh[i][j] ]+=now; &#125; sz=downbh[i].size(); for(int j=0;j&lt;sz;j++) &#123; now+=downcf[i][j]; ans[ downbh[i][j] ]+=now; &#125; &#125; for(int x=1;x&lt;=n;x++) printf("%d ",ans[pos[x]]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP15 D2T3】运输计划]]></title>
    <url>%2Fposts%2Fbb9.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2015 提高组 D2T3Uoj150Bzoj4326Luogu2680Caioj1574 Problem【Description】 公元 2044 年，人类进入了宇宙纪元。L 国有 n个星球，还有 n-1条双向航道，每条航道建立在两个星球之间，这 n-1 条 航道连通了 L 国的所有星球。小 P 掌管一家物流公司，该公司有很多个运输计划，每个运输计划形如：有一艘物 流飞船需要从 ui 号星球沿最快的宇航路径飞行到 vi 号星球去。显然，飞船驶过一条航道是需要时间的，对于航道 j，任意飞船驶过它所花费的时间为 tj，并且任意两艘飞船之间不会产生任何干扰。为了鼓励科技创新，L 国国王同意小 P 的物流公司参与 L 国的航道建设，即允许小 P 把某一条航道改造成虫洞，飞船驶过虫洞不消耗时间。在虫洞的建设完成前小 P 的物流公司就预接了 m个运输计划。在虫洞建设完成后， 这 m 个运输计划会同时开始，所有飞船一起出发。当这 m个运输计划都完成时，小 P 的 物流公司的阶段性工作就完成了。如果小 P 可以自由选择将哪一条航道改造成虫洞，试求出小 P 的物流公司完成阶段性工作所需要的最短时间是多少？【Input】 第一行包括两个正整数 n、m，表示 L 国中星球的数量及小 P 公司预接的运输计划的 数量，星球从 1 到 n 编号。接下来 n-1 行描述航道的建设情况，其中第 ii 行包含三个整数 ai, bi 和 ti，表示第 ii 条双向航道修建在 ai 与 bi 两个星球之间，任意飞船驶过它所花费的时间为 ti。接下来 m行描述运输计划的情况，其中第 j 行包含两个正整数 uj 和 vj，表示第 j个 运输计划是从 uj 号星球飞往 vj号星球。【Output】共 1 行，包含 1 个整数，表示小 P 的物流公司完成阶段性工作所需要的最短时间。【Limited conditions】【Sample input】6 31 2 31 6 43 1 74 3 63 5 53 62 54 5【Sample output】11【Sample explanation】无 Record2h很多变量忘记清零了……code20mincheck2h…… Analysis请先思考后再展开 首先一眼树链剖分是没问题的但我觉得应该会有更有意思的方法吧……不然就不做了看了看题解，还真有居然是树上差分！这东西我大概知道，但是说实话我一直没有用过然后发现我以前的猜测是错误的，它是从深度大的地方向上的（子树和）所以能很轻松地处理路径通过量的统计问题 总结一下： 先搞一搞lca 显然最小化最大值，搞个二分 然后就优化那个被所有【需要优化的路径】经过的边中长度最大者（不是被所有经过的话，就一定不能彻底解决问题），判断是否可行 时间复杂度：O(nlogn)那么理论上是灰常快的但是caioj和uoj都过不去……可能是被卡栈了？不管了无伤大雅 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;void qread(int &amp;x)&#123; x=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') x=x*10+c-'0',c=getchar();&#125;//*******************全局常量*******************const int MAXN=310000;//*******************全局定义*******************struct Nod&#123; int hou; int dep; int dis; int dis2;//与父亲 Nod() &#123; hou=dep=dis=dis2=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,c,g;&#125;e[MAXN*2];int ln=0;void ins(int x,int y,int c)&#123; e[++ln]=(Edge)&#123;y,c,p[x].hou&#125;;p[x].hou=ln;&#125;int n,m;int bin[30];int f[MAXN][30];//*******************实现*******************void dfs(int x,int fa)&#123; f[x][0]=fa;p[x].dep=p[fa].dep+1; for(int i=1;bin[i]&lt;=p[x].dep;i++) f[x][i]=f[f[x][i-1]][i-1]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; p[y].dis=p[x].dis+e[k].c; p[y].dis2=e[k].c; dfs(y,x); &#125;&#125;int lca(int x,int y)&#123; if(p[x].dep&lt;p[y].dep) swap(x,y); for(int i=20;i&gt;=0;i--) if(bin[i]&lt;=p[x].dep-p[y].dep) x=f[x][i]; if(x==y) return x; for(int i=20;i&gt;=0;i--) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0];//上面的循环，曾经以为不用到0，还没错过……&#125;struct Road&#123; int x,y; int lca,length;&#125;s[MAXN];int sum[MAXN];//树上差分，与父亲int ss;int ans;//最长void dfs2(int x,int fa)&#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dfs2(y,x);sum[x]+=sum[y]; &#125; if(sum[x]==ss) ans=mymax(ans,p[x].dis2);&#125;bool check(int mid)&#123; memset(sum,0,sizeof sum);//debug int mxl=0;ss=0; for(int i=1;i&lt;=m;i++) if(s[i].length&gt;mid) &#123; mxl=mymax(mxl,s[i].length); ss++; sum[s[i].x]++; sum[s[i].y]++; sum[s[i].lca]-=2; &#125; ans=0;//debug dfs2(1,0); return mxl-ans&lt;=mid;&#125;//*******************主函数*******************int main()&#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n-1;i++) &#123; int x,y,c;qread(x);qread(y);qread(c); ins(x,y,c);ins(y,x,c); &#125; dfs(1,0); for(int i=1;i&lt;=m;i++) &#123; qread(s[i].x);qread(s[i].y); s[i].lca=lca(s[i].x,s[i].y); s[i].length=p[s[i].x].dis+p[s[i].y].dis-2*p[s[i].lca].dis; &#125; int l=0,r=300000000,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>树链剖分</tag>
        <tag>树上差分</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP15 D2T1】 跳石头]]></title>
    <url>%2Fposts%2F29c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2015 提高组 D2T1Luogu2678Caioj1572 Problem【Description】一年一度的“跳石头”比赛又要开始了!这项比赛将在一条笔直的河道中进行,河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间,有 N 块岩石(不含起点和终 点的岩石)。在比赛过程中,选手们将从起点出发,每一步跳向相邻的岩石,直至到达 终点。为了提高比赛难度,组委会计划移走一些岩石,使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制,组委会至多从起点和终点之间移走 M 块岩石(不能 移走起点和终点的岩石)。【Input】 输入第一行包含三个整数 L，N，M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。接下来 N 行，每行一个整数，第 i 行的整数 Di（0&lt;Di&lt;L）表示第 i 块岩石与 起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同 一个位置。【Output】输出只包含一个整数，即最短跳跃距离的最大值。【Limited conditions】对于 20%的数据,0 ≤ M ≤ N ≤ 10。 对于50%的数据,0 ≤ M ≤ N ≤ 100。对于 100%的数据,0 ≤ M ≤ N ≤ 50,000,1 ≤ L ≤ 1,000,000,000。【Sample input】25 5 2211141721【Sample output】4【Sample explanation】将与起点距离为 2 和 14 的两个岩石移走后,最短的跳跃距离为 4(从与起点距离 17 的岩石跳到距离 21 的岩石,或者从距离 21 的岩石跳到终点)。 Record20min Analysis1请先思考后再展开 首先，看到最值的最值问题，应该先想到二分答案：例如目标答案是A，那么所有距离都要大于等于A 然后就dp转移，f[i]表示到i位置合法的，移动石子的最小值（显然单调递增）然后logn转移即可 这样的复杂度是O(nlognlogn) Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=210000;const int INF=0x3f3f3f3f;//*******************全局定义*******************int n,m;int d[MAXN];int f[MAXN];//*******************实现*******************bool check(int mid)&#123; for(int i=1;i&lt;=n;i++) &#123; //if(mid==1 and i==n) if(d[i]&lt;mid) f[i]=INF; else &#123; int t=upper_bound(d+1,d+i+1,d[i]-mid)-d-1;//&lt;= f[i]=mymin(f[t]+mymax(i-t-1,0),i-1); &#125; &#125; //printf("mid=%d f[n]=%d\n",mid,f[n]); return f[n]&lt;=m;&#125;//*******************主函数*******************int main()&#123; int L;scanf("%d%d%d",&amp;L,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;d[i]); n++;d[n]=L; int l=1,r=1000000000,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,l=mid+1; else r=mid-1; &#125; printf("%d",ans);&#125; Analysis2请先思考后再展开 上面的做法其实还算快，因为出题人并没有去卡然鹅其实可以更快的原谅我脑残了如果从起点开始，找到下一个能跳的地方，跳过去，就好了……这样就省掉了一个log]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP15 D2T2】 子串]]></title>
    <url>%2Fposts%2Fe5d4.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2015 提高组 D2T2Luogu2679Caioj1573 Problem【Description】 有两个仅包含小写英文字母的字符串 A 和 B。现在要从字符串 A 中取出 k 个 互不重叠 的非空子串， 然后把这 k 个子串按照其在字符串 A 中出现的顺序依次连接起来得到一个新的字符串，请问有多少种方案可以使得这个新串与字符串 B 相等？ 注意：子串取出的位置不同也认为是不同的方案。【Input】第一行是三个正整数 n，m，k，分别表示字符串 A 的长度，字符串 B 的长度，以及问题描述中所提到的 k，每两个整数之间用一个空格隔开。第二行包含一个长度为 n 的字符串，表示字符串 A。 第三行包含一个长度为 m 的字符串，表示字符串 B。【Output】输出共一行，包含一个整数，表示所求方案数。(由于答案可能很大，所以这里要求输 出答案对 1,000,000,007 取模的结果。【Limited conditions】对于第 1 组数据:1≤n≤500,1≤m≤50,k=1;对于第 2 组至第 3 组数据:1≤n≤500,1≤m≤50,k=2;对于第 4 组至第 5 组数据:1≤n≤500,1≤m≤50,k=m;对于第 1 组至第 7 组数据:1≤n≤500,1≤m≤50,1≤k≤m;对于第 1 组至第 9 组数据:1≤n≤1000,1≤m≤100,1≤k≤m;对于所有 10 组数据:1≤n≤1000,1≤m≤200,1≤k≤m。【Sample input 1】6 3 1aabaabaab【Sample output 1】2【Sample input 2】6 3 2aabaabaab【Sample output 2】7【Sample input 3】6 3 3aabaabaab【Sample output 3】7【Sample explanation】 Record40min Analysis请先思考后再展开 提高组的字符串……八成是dp那么设$f[i][j][k]=用到A_i，填充到B_j，用了k个段的方案数$然后？？然后就蒙逼了 其实这是因为我们的决策需要把用了$A_i$的和没用的方案数分开来$g[i][j][k]表示用到A_i，填充到B_j，用了k个段的方案数$$f[i][j][k]表示到A_i为止（不一定用），填充到B_j，用了k个段的方案数$那么一下子就可以搞出递推式了： $$g[i][j][k]=\left{\begin{matrix}f[i-1][j-1][k-1]+g[i-1][j-1][k] &amp;(A[i-1]=B[j-1])\0 &amp; (A[i-1] \neq B[j-1])\end{matrix}\right.$$ 然后累计$f[i][j][k]=f[i-1][j][k]+g[i][j][k]$ 但这样会mle哒循环数组就好了 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=1100,MAXM=210;const int MOD=1000000007;const int INF=0x3f3f3f3f;//*******************全局定义*******************char a[MAXN],b[MAXM];int f[2][MAXM][MAXM],g[2][MAXM][MAXM];//*******************实现*******************//*******************主函数*******************int main()&#123; int n,m,k;scanf("%d%d%d",&amp;n,&amp;m,&amp;k); scanf("%s%s",a+1,b+1); int pre=0,now=1; f[pre][0][0]=1; for(int i=1;i&lt;=n;i++) &#123; f[now][0][0]=1;//debug for(int j=1;j&lt;=m;j++) for(int kk=1;kk&lt;=k;kk++) &#123; if(a[i]==b[j]) g[now][j][kk]=(f[pre][j-1][kk-1]+g[pre][j-1][kk])%MOD; else g[now][j][kk]=0; f[now][j][kk]=(f[pre][j][kk]+g[now][j][kk])%MOD; &#125; swap(pre,now); &#125; printf("%d",f[pre][m][k]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP15 D1T2】信息传递]]></title>
    <url>%2Fposts%2F3244.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2015 提高组 D1T2Luogu2312Caioj1568 Problem【Description】有n个同学（编号为1到n）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为i的同学的信息传递对象是编号为Ti同学。游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息，但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？【Input】输入共 2 行。第 1 行包含 1 个正整数 n，表示 n 个人。第 2 行包含 n 个用空格隔开的正整数 T1, T2, … … , Tn，其中第 i 个整数Ti表示编号为 i 的同学的信息传递对象是编号为 Ti 的同学， Ti ≤ n 且 Ti ≠ i。数据保证游戏一定会结束。【Output】输出共 1 行，包含 1 个整数，表示游戏一共可以进行多少轮。【Limited conditions】对于 30%的数据， n ≤ 200；对于 60%的数据，n ≤ 2500；对于 100%的数据，n ≤ 200000。【Sample input】52 4 2 3 1【Sample output】3【Sample explanation】游戏的流程如图所示。当进行完第 3 轮游戏后，4 号玩家会听到 2 号玩家告诉他自己的生日，所以答案为 3。当然，第 3 轮游戏后，2 号玩家、3 号玩家都能从自己的消息来源得知自己的生日，同样符合游戏结束的条件。 Record20min Analysis请先思考后再展开 一眼就是找最小环如果直接暴力枚举是n方级别的考虑题目特性，只有一条出边显然所有强连通都是以环的形式出现的找最小但至少有两个的强连通分量即可 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=210000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int hou; int dfn,low; bool v; Nod() &#123; hou=dfn=0; v=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXN];int ln=0;void ins(int x,int y)&#123; e[++ln]=(Edge)&#123;y,p[x].hou&#125;;p[x].hou=ln;&#125;//*******************实现*******************int id=0;int sta[MAXN],top=0;int siz[MAXN],cnt=0;void tarjan(int x)&#123; p[x].dfn=p[x].low=++id; sta[++top]=x;p[x].v=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y); if(p[y].v) p[x].low=mymin(p[x].low,p[y].low); &#125; if(p[x].dfn==p[x].low) &#123; cnt++; while(1) &#123; int t=sta[top--]; siz[cnt]++; if(t==x) break; &#125; &#125;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); ins(i,t); &#125; for(int i=1;i&lt;=n;i++) if(!p[i].dfn) tarjan(i); int ans=INF; for(int i=1;i&lt;=cnt;i++) if(siz[i]&gt;=2 and siz[i]&lt;ans) ans=siz[i]; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP14 D2T3】解方程]]></title>
    <url>%2Fposts%2Fc8d.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2014 提高组 D2T3Bzoj3751Luogu2312Caioj1568 Problem【Description】已知多项式方程：$$a_0+a_1x+a_2x^2+\cdots+a_nx^n=0$$求这个方程在 $[1,m]$ 内的整数解（$n$ 和 $m$ 均为正整数）。【Input】输入共 $n + 2$ 行。第一行包含 $2$ 个整数 $n, m$，每两个整数之间用一个空格隔开。接下来的 $n+1$ 行每行包含一个整数，依次为 $a_0,a_1,a_2\ldots a_n$。【Output】第一行输出方程在 $[1,m]$ 内的整数解的个数。接下来每行一个整数，按照从小到大的顺序依次输出方程在 $[1,m]$ 内的一个整数解。【Limited conditions】对于 $30\%$ 的数据：$0&lt;n\le 2,|a_i|\le 100,a_n≠0,m&lt;100$。对于 $50\%$ 的数据：$0&lt;n\le 100,|a_i|\le 10^{100},a_n≠0,m&lt;100$。对于 $70\%$ 的数据：$0&lt;n\le 100,|a_i|\le 10^{10000},a_n≠0,m&lt;10^4$。对于 $100\%$ 的数据：$0&lt;n\le 100,|a_i|\le 10^{10000},a_n≠0,m&lt;10^6$。【Sample input 1】2 101-21【Sample output 1】11【Sample input 2】2 102-31【Sample output 2】212【Sample input 3】2 10132【Sample output 3】0【Sample explanation】无 Record40min Analysis请先思考后再展开 一开始想着高精度肯定超时啊然后膜题解，发现自己忘记了这个套路：自然溢出，或者搞多几个模数之前也用过：等价表达式原理还是类似的：如果$f(x)=0$，那么$f(x)\%p=0$，而这个多项式又没有除法 然后用秦九昭就好了这东西之前看到，结果就觉得：煞笔玩意……然后现在居然没想到了感觉这东西和韦达定理是一个道理的…… 但是现在的复杂度大概是1亿的，然后还有个long long的常数5，还有两个模数的常数2有没有很虚的感觉？那怎么办么？随便卡卡常呗随便搞个小模数10007吧，这里面的数字，如果$f(x)=0$，那么后面的部分（即$f(10007\times b+x)$）显然就不用枚举了不知道为什么就快了灰常多呀（好像时间复杂度证明跟拉格朗日定理有关？） Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;//*******************全局常量*******************const int MAXN=1100000;const int MOD[5]=&#123;11261,19997,22877,21893,14843&#125;;//*******************全局定义*******************int a[5][MAXN];bool v[5][MAXN];int ans[MAXN],as=0;//*******************实现*******************int n;bool check(int x,int mod,int *f)&#123; int sum=0; for(int i=n;i&gt;=0;i--) sum=(sum*x%mod+f[i])%mod; return sum==0;&#125;//*******************主函数*******************char s[MAXN];int main()&#123; int m;scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;=n;i++) &#123; scanf("%s",s+1);int ln=strlen(s+1); int fg=1; for(int j=1;j&lt;=ln;j++) &#123; if(s[j]=='-') &#123;fg=-1;continue;&#125; for(int t=0;t&lt;5;t++) a[t][i]=(a[t][i]*10+s[j]-'0')%MOD[t]; &#125; for(int t=0;t&lt;5;t++) a[t][i]*=fg; &#125; for(int t=0;t&lt;5;t++) for(int i=1;i&lt;MOD[t];i++) v[t][i]=check(i,MOD[t],a[t]); for(int i=1;i&lt;=m;i++) if(v[0][i%MOD[0]] and v[1][i%MOD[1]] and v[2][i%MOD[2]] and v[3][i%MOD[3]] and v[4][i%MOD[4]]) ans[++as]=i; printf("%d\n",as); for(int i=1;i&lt;=as;i++) printf("%d\n",ans[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>秦九昭</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP14 D2T2】寻找道路]]></title>
    <url>%2Fposts%2Fbc9.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2014 提高组 D2T2Luogu2296Caioj1567 Problem【Description】 在有向图 G 中，每条边的长度均为 1，现给定起点和终点，请你在图中找一条从起点到 终点的路径，该路径满足以下条件：1. 路径上的所有点的出边所指向的点都直接或间接与终点连通。2. 在满足条件 1 的情况下使路径最短。注意：图 G 中可能存在重边和自环，题目保证终点没有出边。 请你输出符合条件的路径的长度。【Input】 第一行有两个用一个空格隔开的整数 n 和 m，表示图有 n 个点和 m 条边。接下来的 m 行每行 2 个整数 x、y，之间用一个空格隔开，表示有一条边从点 x 指向点y。最后一行有两个用一个空格隔开的整数 s、t，表示起点为 s，终点为 t。【Output】 输出只有一行，包含一个整数，表示满足题目描述的最短路径的长度。如果这样的路径不存在，输出-1。【Limited conditions】对于30%的数据，0&lt;n≤10，0&lt;m≤20；对于60%的数据，0&lt;n≤100，0&lt;m≤2000；对于100%的数据，0&lt;n≤10,000，0&lt;m≤200,000，0&lt;x，y，s，t≤n，x≠t。【Sample input】6 61 21 32 62 54 53 41 5【Sample output】3【Sample explanation】如上图所示，满足条件的路径为1 - &gt;3- &gt;4- &gt;5。注意点2 不能在答案路径中，因为点2连了一条边到点6 ，而点6 不与终点5 连通。 Record20min Analysis请先思考后再展开 sb题 建个反向边 判断连通性 从不联通的地方扫描标记 spfa Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;//*******************全局常量*******************const int MAXN=11000,MAXM=210000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int hou; bool v,ar; int dis; Nod() &#123; hou=0; v=ar=0; dis=INF; &#125;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXM];int ln=0;void ins(int x,int y)&#123; e[++ln]=(Edge)&#123;y,p[x].hou&#125;;p[x].hou=ln;&#125;//*******************实现*******************void dfs(int x)&#123; p[x].ar=p[x].v=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(!p[y].ar) dfs(y); &#125;&#125;queue&lt;int&gt; lst;bool in[MAXN];int spfa(int st,int ed)&#123; if(!p[st].v) return -1; lst.push(st);p[st].dis=0;in[st]=1; while(!lst.empty()) &#123; int x=lst.front();lst.pop(); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dis&gt;p[x].dis+1 and p[y].v) &#123; p[y].dis=p[x].dis+1; if(!in[y]) &#123; in[y]=1; lst.push(y); &#125; &#125; &#125; in[x]=0; &#125; return (p[ed].dis==INF)?-1:p[ed].dis;&#125;//*******************主函数*******************int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); ins(y,x); &#125; int st,ed;scanf("%d%d",&amp;st,&amp;ed); dfs(ed); for(int x=1;x&lt;=n;x++) if(!p[x].ar) for(int k=p[x].hou;k&gt;0;k=e[k].g) p[e[k].y].v=0; printf("%d",spfa(ed,st));&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【GDOI2018 D1T2】【51nod1357】密码锁]]></title>
    <url>%2Fposts%2Ff4f8.html</url>
    <content type="text"><![CDATA[Source and JudgeGDOI2018 D1T2（模数不固定）51nod1357 Problem【Description】有一个密码锁，其有N位，每一位可以是一个0~9的数字，开启密码锁需要将锁上每一位数字转到解锁密码一致。这个类似你旅行用的行李箱上的密码锁，密码锁的每一位其实是一个圆形转盘，上面依次标了0,1，…9,对每一位来说可以正向或者逆向拨动，正向拨动时原有数字x会变成新的数字(x+1 mod 10),例如1-&gt;2，2-&gt;3，9-&gt;0；同理逆向拨动变为(x-1 mod 10)即9-&gt;8,5-&gt;4,0-&gt;9。定义对密码锁的一次操作：选择一个连续的区间[L,R]，可以只包含一位即L==R，将这个区间的所有数字正向拨动或逆向拨动一次，注意要么全部正着拨，要么全逆着。例如：12397正向后变成23408，逆向后变成01286。给出密码锁初始和解锁需要的终止状态，问最少多少次操作能解锁。【Input】多组测试数据，第一行一个整数T，表示测试数据数量每组测试数据有相同的结构构成：每组数据有两行构成，第一行是密码锁的初始状态S，第二行是解锁的终止状态E【Output】每组数据一行输出，即最少需要的操作数。【Limited conditions】1&lt;=len(S)=len(E)&lt;=2500,且都由0~9构成【Sample input】106076071234456737896565159478927782432854574946297839335216760603277426453582937390990599524328132169880751802416449917850055278844124181670313605874031469333653114254419369610778733406822463469353946356056711090437786504862201123112170209094423232218340629042147624501837850000000【Sample output】031066281421811【Sample explanation】无 Record2h这个是比赛的题目，但当时没有做出来然后因为讲课的时候不是那么明确，想做一做（就是想报仇的心态）在知乎上找到了类似的题目，不过都没人做wa了很多次……所以数据特别多，是我买的几组数据 Analysis请先思考后再展开 首先，gdoi的题目是最后要到0，而这里是指定的如何处理这一步呢？其实很好理解，因为每一个位是相对独立互不影响的，那么可以把目标位对其为0，然后把当前串映射过去（其实就是相减一下），那么现在对正确性没有影响的 但是，这道题目有个很迷惑人的地方，在于有模数刚才我们搞出来的当前串a是有负数的，但是我们先不管它 现在有+1和-1两种区间操作，那么一个不那么显然的套路就是差分一下（没想到啊555）那么现在，我们的目标就是，对于得到的差分数组cf，我们要把其中每一个元素变成m的倍数（包括0）而这两个区间操作，现在就变成了对一个数+1，一个数-1 不难发现这道题是一定有解的，因为你可以一个个拧过去我们要利用这个性质，辅助我们去理解这道题那一个个拧过去，其实就是这个+1，下一个-1所以我们的差分数组，长度应该是n+1而且，我们的+1和-1的个数是要相同的 那么对于每一个差分后的数，它都有一个上下界，因为跨越是没有意义的那么显然我们可以取个模，然后如果还是负数的话，把它+m后，其实是等效的 现在的问题就在于，如何分配+1和-1呢？首先明确一个数，只可能增加或减少，而不会重叠，否则答案不会更优（还不理解可以联想一下原问题，对于两个重叠的+1和-1区间，显然可以把中间的去掉，剩下的还是两个） 接下来，我们可以尝试贪心把差分的数字排个序，然后枚举一个断点（在空隙位置），这个断点左边的，也就是比它小的，全部都是要减小的，右边的都是要增加的那么线性地扫描一遍，如果左边的花费能否等于右边的花费，显然这个时候是最优的 Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;//*******************全局常量*******************const int MAXN=3100;const int m=10;//*******************全局定义*******************char st[MAXN],ed[MAXN];//*******************实现*******************int myabs(int x) &#123;return (x&gt;0)?x:-x;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************主函数*******************struct Nod&#123; int cf; int a,b;//下、上&#125;p[MAXN];bool cmp(Nod a,Nod b) &#123;return a.cf&lt;b.cf;&#125;int a[MAXN];int l[MAXN],r[MAXN];int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; scanf("%s%s",st+1,ed+1); int n=strlen(st+1); for(int i=1;i&lt;=n+1;i++) &#123; a[i]=st[i]-ed[i]; p[i].cf=(a[i]-a[i-1])%m; if(p[i].cf&lt;0) p[i].cf+=m;//对应位置 p[i].a=p[i].cf,p[i].b=10-p[i].cf; &#125; sort(p+1,p+n+1+1,cmp); l[0]=0;for(int i=1;i&lt;=n+1;i++) l[i]=l[i-1]+p[i].a; r[n+2]=0;for(int i=n+1;i&gt;=1;i--) r[i]=r[i+1]+p[i].b; int ans=-1; for(int i=1;i&lt;=n+2;i++) if(l[i-1]==r[i]) &#123;ans=l[i-1];break;&#125; printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>贪心</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Sdoi2016】数字配对]]></title>
    <url>%2Fposts%2F6c7a.html</url>
    <content type="text"><![CDATA[Source and JudgeSdoi2016Bzoj4514Luogu4068Loj2031 Problem【Description】有 n 种数字，第 i 种数字是 ai、有 bi 个，权值是 ci。若两个数字 ai、aj 满足，ai 是 aj 的倍数，且 ai/aj 是一个质数，那么这两个数字可以配对，并获得 ci×cj 的价值。一个数字只能参与一次配对，可以不参与配对。在获得的价值总和不小于 0 的前提下，求最多进行多少次配对。【Input】第一行一个整数 n。第二行 n 个整数 a1、a2、……、an。第三行 n 个整数 b1、b2、……、bn。第四行 n 个整数 c1、c2、……、cn。【Output】一行一个数，最多进行多少次配对【Limited conditions】 n≤200，ai≤10^9，bi≤10^5，|ci|≤10^5【Sample input】32 4 82 200 7-1 -2 1【Sample output】4【Sample explanation】无 Record1h Analysis请先思考后再展开 这道题有意思的地方不是构图 首先,对于(i,j),判断能否配对,直接枚举约数要sqrt(a),即使配上线筛也是灰常慢的.考虑条件的特性:多出一个质因数,因为前面有个条件限制着,完全可以看作质因数的幂之和+1所以这个是可以在枚举外面预处理的,然后其实线筛是可以省去的,因为合数已经被前面的筛去了. (st,i),cost=0,flow=b[i](i,j),cost=c[i]*c[j],flow=INF(i,ed),cost=0,flow=b[i]然后跑一下最大费用最大流其实会不会有种杀鸡用牛刀的感觉,毕竟很简单 然鹅最关键的地方在于,这个权值和不能是负数,那么当有一天我们跑出来的最长路乘上哪怕1的流量,已经会导致答案变负数了,显然game over还有一种情况是最长路是负数,那么就要限制一下流量,确保费用是非负数即可. 然后网上有人还要分奇偶,那根本就不是正常人的思维,其实答案直接除二就好,否则显然分配方案不对称的话不会使结果更优. Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;//*******************全局常量*******************const int MAXN=410,MAXM=80000;//*******************全局定义*******************typedef long long ll;const ll INF=(1ll&lt;&lt;60);int hou[MAXN];bool v[MAXN];struct Edge&#123; int y,g,oth; ll w,c;&#125;e[MAXM];int ln=0;void ins(int x,int y,ll w,ll c)&#123; e[++ln]=(Edge)&#123;y,hou[x],ln+1,w,c&#125;;hou[x]=ln; e[++ln]=(Edge)&#123;x,hou[y],ln-1,-w,0&#125;;hou[y]=ln;&#125;ll mymax(ll x,ll y) &#123;return x&gt;y?x:y;&#125;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;//*******************实现*******************int st,ed;int lrd[MAXN];ll dis[MAXN],mic[MAXN];queue&lt;int&gt; lst;ll now=0,ans=0;bool bfs()&#123; memset(dis,-63,sizeof(dis)); memset(v,0,sizeof(v)); lst.push(st);dis[st]=0;v[st]=1;mic[st]=INF; while(!lst.empty()) &#123; int x=lst.front();lst.pop(); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(dis[y]&lt;dis[x]+e[k].w and e[k].c&gt;0) &#123; dis[y]=dis[x]+e[k].w; mic[y]=mymin(mic[x],e[k].c); lrd[y]=e[k].oth; if(!v[y]) v[y]=1,lst.push(y); &#125; &#125; v[x]=0; &#125; if(mic[ed]==0) return 0; ll cost=dis[ed],flow=mic[ed]; if(cost&lt;-now) return 0;//game over if(cost&lt;0) flow=mymin(flow,-now/cost); now+=flow*cost; ans+=flow; for(int x=ed;x!=st;x=e[lrd[x]].y) &#123; e[e[lrd[x]].oth].c-=flow; e[lrd[x]].c+=flow; &#125; return 1;&#125;//*******************主函数*******************int get(int x)&#123; int s=0; for(int i=2;i*i&lt;=x;i++) &#123;while(x%i==0) x/=i,s++;&#125; if(x&gt;1) s++; return s;&#125;int a[MAXN],b[MAXN];ll c[MAXN];int cnt[MAXN];int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]),cnt[i]=get(a[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;b[i]); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;c[i]); st=0,ed=2*n+1; for(int i=1;i&lt;=n;i++) &#123; ins(st,i,0,b[i]);ins(n+i,ed,0,b[i]); for(int j=1;j&lt;i;j++) &#123; if( ((a[i]%a[j])==0 and cnt[i]==cnt[j]+1) or ((a[j]%a[i])==0 and cnt[j]==cnt[i]+1) ) &#123; ins(i,n+j,c[i]*c[j],INF); ins(j,n+i,c[i]*c[j],INF); &#125; &#125; &#125; while(bfs()) ; printf("%lld\n",ans/2);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDOI2018]]></title>
    <url>%2Fposts%2Fd688.html</url>
    <content type="text"><![CDATA[GDOI2018 这篇文章……或许并没有什么用处只是一个半退役选手的满口胡言乱语罢了 GDOI2017 思考录 day-12018.4.27借koi发的绿册子看去年的题目只会前面两道题 d1t1题意：字符串查找替换kmp裸题，O(N^2*L)忽然想起刚学的时候做字符串都是直接用stl的，特无耻 d1t2感觉自己就是个大沙茶，看错题目了，狂问师兄题意：给一棵树，求对于每个点，除了子树外其他点的mex（对于一个集合，在非负整数中没出现的最小值）对于每种颜色，求出其lca（两两求就好），然后对于lca到root间的点，它都是【没有在其他地方出现的值】，所以维护一下最小值就好了，O(N) GDKOI2014 模拟赛（三个半小时） day0早上用以前的原题做模拟赛，就我们竞赛室的几个人小测一下，据hz说又是很简单然后第一题manacher水题第二题网络流，但是数据有误第三题暴力50分 GDOI2018 游记初中oi生涯要结束了哎前面说的看起来很简单，但gdkoi2018是真的懵逼啊……话说今年可是我们主场呀然后顺带一提,我们几个竞赛室的约定：有谁进了day3就请另外两个人吃饭 day1T1二分水题，nlogn T2打了个bfs拿暴力分，然后搞了搞m=2的暴力中午听ozy大爷讲题： 先差分一波，然后现在目标就是把所有的数变成【m的倍数】 计算出当前数与上下两个【m的倍数】的距离a、b 然后就听不懂了讲课： 通过差分,让区间操作变成一个数+1,一个数-1,而且因为可加可减 那么这个时候，每个数字的顺序已经无关紧要了，可以先排个序 然后有一个显然的性质：一个数没有必要既增加又减少，所以必然是有固定决策的 记录决策的和，线性扫描一遍，枚举两个数中间作为中介点，当左右两侧的和相同（总有这样的位置，因为题目必然有解），则这个和就是最优解「这一步刚开始有点问题，原来是忘记最后一位的差分了，请教了rose」时间复杂度：nlognUP：在知乎上找到了原题：51nod1357-密码锁T3暴力10分和链10分akc大爷：二维线段树rose大爷：四维KD-tree讲课：乱七八糟，但rose被卡了，跑了70分.在打球之前听akc大爷讲： 询问：「dfn1,dfn2」和「t+deprt-1,INF」 修改：「dfnx」和「t+depx-1」 维护双区间，但是如果直接两个树状数组需要n^2的空间，其实完全可以动态开点，改成线段树，然后这样的话，修改是一条链，空间复杂度nlogn，时间复杂度nlognlogn T4完全不会讲课：还是不会UP：在知乎上找到了原题：Uoj#12-B 总结期望总分：100+30+20+0=150实际得分：100+20+10+0=130两道题都是case打wa了，不知原因，毕竟是暴力也不好复评 描述一下心路历程吧开始半个小时看完题目，把t1切了，感觉难度不对劲，此时九点半然后看第二题，没思路，但是部分分还是可以的，然后就写了bfs和m=2和3的情况十点半点了，第三题感觉很难处理掉落的情况啊，没什么思路，感觉考虑深度，也推不上去啊把小数据和链的分拿了，此时已经十一点半了回头搞第二题，发现有m=3的大数据错了，然后打对拍，调策略，直到最后检查一下其他题目后继续搞……比赛结束前忽然又拍出错误，发现我解决不了……（然后原来出题人也没有什么想法woc） 那么如今回顾一下，感觉前面三题真的不难，大概是一场noip+模拟赛难度，也似乎确实有人ak了第二题其实就是个经典套路——差分，然后再贪贪心，但是因为没怎么用差分，所以没想过，而且这个贪心策略也不是那么好想的，似乎有灰常多巨佬也被卡炸了……第三题，其实打链的情况的时候也想过这个深度的关系，但是没想到「把dfs序静态化」，所以灰常不可做，如今看来，其实只要把条件转化一下，然后推推关系式，发现是双区间而且互不影响，树状数组维护一波即可 那么完美的策略：看题目：30minT1：思考10min，实现10minT2：思考40min，实现20minT3：思考1h，实现40minT4：挂机……因为我不会期望剩余检查时间：30min 然鹅这场考试，重在求稳，任何一道题，如果翻车就会灰常麻烦（虽然我并没有高分经验）那么这场考试前面三题的最高预备知识是很简单的：树状数组但是其灵活的命题，灰常考验对套路的熟练使用 这场比赛，我考得相当差，一部分原因是缺乏经验和自信，感觉难度会和koi一样，是那种ac一题就很好的那种第二点是做题太少，整天做脑残noip题目，所以我决定接下来的一年，我的刷题量要增加500题！ 总之，保持自信，相信自己，争取明天翻盘吧！目标：进day3 day2T1杠了三个小时……打了个60分的O(nm)，虽然加了个素数优化10的常数，但本机跑了7秒……而且我居然忘记了大样例输出文件的存在？？？也就是说我只知道时间，却忘记看正确答案输出了打了个对拍，但是很sb地测1000，直接wa，然后只是去检查公式？居然没有自己出个小的数据，或者拍小的数据然后推了一个小时分块，没退出来，因为太久没用了，其实就是n/(n/t)，正确性其实很显然，因为整除是向下的，分母小，必然得到的最大t总之不知道多少分，可能0，也可能60、70 总而言之，这道题不算特别难，算是莫反的一个裸题吧，或许对于别人来说的签到题，我却耗费了大量时间，原因？可能还是要怪中途去做noip这种玩意吧，不知道教练口中那个进了省队刷noip的师兄是怎么想的，或许是时代在变化吧 讲课：莫比乌斯反演我是真的不自量力，看着题目限制没有下限，然后因为最近没用过莫比乌斯反演所以想着yy一种替代做法，就是用总量-不互质的数对的贡献然鹅当时过了灰常小的样例就以为没问题了其实稍微用个6这样的多个素因子的数字，就会发现算重复了 如今看来，其实不会也可以跳过的 T2暴力5分听说其实k=1不在乎顺序的时候可以组合数学乱搞，有点亏讲课：不会 T3暴力10分讲课：好像是有单调性什么的，居然最高只用了链表？？不是很懂 T4题意：找出一个点所在的最小环完全不会，然后因为感觉后面会比前面难，所以也没怎么看题目讲课：好像floyd可以搞？ 总结感觉初中oi就这么结束了吧凉凉的感觉期望分数：0+5+10+0实际分数：0+5+0+0暴力分又炸了怎么老是这样，不知不觉，加起来丢了30分，但是又不知道原因 现在感觉，这两天，还是第一天比较友好，但是错失良机了然后在省选前，专题没有完整搞定，去做noip之类的，真的是自寻死路第一天被简单题目拉了差距，第二天又拿不到分 结束了后面，也没我什么事了准备了这么久，并没有明显的收获吧 day3上午听了网络流的讲座，还好吧然后把d1t2切了开始回到noip状态，打算快速做完以后开始搞数论好像说我们可以延迟退役，等丰山的课程，又可以苟延残喘一会了 day4上午颁奖仪式，最精彩的部分就是省队选手的颁奖了那一刻，虽然说名单早就公布，依然全场安静，所有的教练都站了起来，或许心中都带着某种骄傲之情？有一天，我会站在那上面吗？ 总结我能感受到自己在变强，然鹅大家也在变强，可能唯一的优势就是我不怎么颓废？还记得有天早上老妈跟我说：你的实力，其实很可能进不了省队我：但除此之外我也不知道我能干什么了。不进省队也可以搞搞降分的吧（然鹅其实心中依然对进省队抱有期望……） 附录hz大佬的blog:here]]></content>
      <categories>
        <category>竞赛历程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【模板】动态树]]></title>
    <url>%2Fposts%2Fbebe.html</url>
    <content type="text"><![CDATA[Source and JudgeLuogu3690 Problem【Description】给定n个点以及每个点的权值，要你处理接下来的m个操作。操作有4种。操作从0到3编号。点从1到n编号。0：后接两个整数(x，y)，代表询问从x到y的路径上的点的权值的xor和。保证x到y是联通的。1：后接两个整数(x，y)，代表连接x到y，若x到y已经联通则无需连接。2：后接两个整数(x，y)，代表删除边(x，y)，不保证边(x，y)存在。3：后接两个整数(x，y)，代表将点x上的权值变成y。【Input】第1行两个整数，分别为n和m，代表点数和操作数。第2行到第n+1行，每行一个整数，整数在［1，10^9］内，代表每个点的权值。第n+2行到第n+m+1行，每行三个整数，分别代表操作类型和操作所需的量。【Output】对于每一个0号操作，你须输出x到y的路径上点权的xor和。【Limited conditions】单词数n&lt;=60所有字符串长度、m&lt;=100【Sample input】3 31231 1 20 1 20 1 1【Sample output】31【Sample explanation】无 Record1h Analysis请先思考后再展开 省选前模板练手 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;ll mymax(ll x,ll y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(ll &amp;x,ll y) &#123;if(x&lt;y) x=y;&#125;void chmin(ll &amp;x,ll y) &#123;if(x&gt;y) x=y;&#125;ll mysqr(ll x) &#123;return x*x;&#125;//*******************全局常量*******************const int MAXN=510000;//*******************全局定义*******************struct Lct&#123; int son[2],f; int d,c;//值、xor和 bool fz;&#125;p[MAXN];//*******************实现*******************void pushup(int x)&#123; int lc=p[x].son[0],rc=p[x].son[1]; p[x].c=p[x].d; if(lc&gt;0) p[x].c^=p[lc].c; if(rc&gt;0) p[x].c^=p[rc].c;&#125;void pushdown(int x)&#123; if(!p[x].fz) return; p[x].fz=0;//debug swap(p[x].son[0],p[x].son[1]); int lc=p[x].son[0],rc=p[x].son[1]; p[lc].fz^=1;p[rc].fz^=1;&#125;void rotate(int x,int w)&#123; int f=p[x].f,ff=p[f].f; if(ff&gt;0) &#123; if(p[ff].son[0]==f) p[ff].son[0]=x; else if(p[ff].son[1]==f) p[ff].son[1]=x; &#125; p[x].f=ff; int xson=p[x].son[w]; p[f].son[1-w]=xson; if(xson&gt;0) p[xson].f=f; p[x].son[w]=f; p[f].f=x; pushup(f); pushup(x);&#125;bool isrt(int x,int rt)&#123; return (p[x].f==rt)or(p[p[x].f].son[0]!=x and p[p[x].f].son[1]!=x);&#125;int lst[MAXN];void splay(int x,int rt)&#123; int t=x,s=0; while(!isrt(t,rt)) lst[++s]=t,t=p[t].f; lst[++s]=t;while(s&gt;0) pushdown(lst[s--]); while(!isrt(x,rt)) &#123; int f=p[x].f,ff=p[f].f; if(isrt(f,rt)) &#123; if(p[f].son[0]==x) rotate(x,1); else if(p[f].son[1]==x) rotate(x,0); return; &#125; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125;&#125;void access(int x)&#123; int y=0; while(x&gt;0) &#123; splay(x,0); p[x].son[1]=y; pushup(x); y=x;x=p[x].f; &#125;&#125;void makeroot(int x)&#123; access(x); splay(x,0); p[x].fz^=1;&#125;void splity(int x,int y)&#123; makeroot(x); access(y); splay(y,0);&#125;int findrt(int x)&#123; access(x); splay(x,0); while(1) &#123; pushdown(x);//debug if(!p[x].son[0]) break; x=p[x].son[0]; &#125; splay(x,0);//速度 return x;&#125;void link(int x,int y)&#123; makeroot(y); p[y].f=x;&#125;void cut(int x,int y)&#123; splity(x,y); if(p[y].son[0]!=x or (p[y].son[0]==x and p[x].son[1]&gt;0)) return; p[p[y].son[0]].f=0;//debug p[y].son[0]=0; pushup(y);//debug&#125;//*******************主函数*******************int d[MAXN];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;p[i].d); p[i].c=p[i].d; p[i].son[0]=p[i].son[1]=p[i].f=0; p[i].fz=0; &#125; while(m--) &#123; int op,x,y;scanf("%d%d%d",&amp;op,&amp;x,&amp;y); if(op==0) &#123; splity(x,y); printf("%d\n",p[y].c); &#125; if(op==1) &#123; if(findrt(x)!=findrt(y)) link(x,y); &#125; if(op==2) &#123; if(findrt(x)==findrt(y)) cut(x,y); &#125; if(op==3) &#123; splay(x,0); p[x].d=y; pushup(x); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LCT</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JSOI2007】文本生成器]]></title>
    <url>%2Fposts%2Feec3.html</url>
    <content type="text"><![CDATA[Source and JudgeJSOI2007 文本生成器Bzoj1030Luogu4052 Problem【Description】给出一些单词和文本固定长度，求所有满足此长度的，包含至少一个单词的文本的数量，对10007取模。【Input】第一行两个数表示单词数量n和文本长度m。接下来每行一个字符串表示单词。【Output】答案。【Limited conditions】单词数n&lt;=60所有字符串长度、m&lt;=100【Sample input】2 2AB【Sample output】100【Sample explanation】无 Record3h Analysis请先思考后再展开 最先，也是最重要的一点：把答案容斥，转化为更容易计算的，不包含任何单词的文本数量，然后用总量26^m-数量即是答案。而这种包含与否的关系，很容易联想到多串匹配，那当然少不了AC自动机。接下来呢？ 我们所要求的，就是跳m次，没有跳到任何一个【单词结尾节点】的方案数。但是考虑这样一种情况：只有单词a和bbabbb，m=3，然后我们跳到第三层的a，然后以为没有经过任何单词，就累计了答案。然鹅，不难发现其实我们还是包含了单词a。所以必须确保其任何后缀都不是单词的结尾。网上大部分人都是暴力跳fail去验证，然鹅其实可以在计算fail的时候，顺便递推过来，能节省时间（注意要用与运算），因为此时的bfs，fail的深度一定比x小。 一种直观的想法就是直接dfs跳，然后套一个记忆化。。。那既然如此不如直接dp？反正是等效的吧 那我们就可以愉快地dp啦你可以想象一个长度为m的任意字符串在ac机上面跳来跳去所以我们可以在任何时刻任意追加字符然鹅这样空间消耗灰常大但是不难发现，对于一个不在ac机上面的点，其接下来的拓展性与自己无关（fail=0），所以是等价于根节点0的，所以为了方便和节省空间，可以把空节点也设为0.一开始连模板都打错了qwq Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=110;const int MOD=10007;//*******************全局定义*******************char s[MAXN];int Mod(int x) &#123;return (x%MOD+MOD)%MOD;&#125;//*******************实现*******************struct Trie&#123; int ch[26]; bool ed; int fail; void clear() &#123; memset(ch,0,sizeof(ch)); fail=ed=0; &#125;&#125;a[MAXN*60];int cnt=0;void add()&#123; scanf("%s",s+1); int ln=strlen(s+1); int now=0; for(int i=1;i&lt;=ln;i++) &#123; int t=s[i]-'A'; if(!a[now].ch[t]) a[now].ch[t]=++cnt,a[cnt].clear(); now=a[now].ch[t]; &#125; a[now].ed=1;&#125;queue&lt;int&gt; q;void getfail()&#123; q.push(0); while(!q.empty()) &#123; int x=q.front();q.pop(); for(int i=0;i&lt;26;i++) &#123; int son=a[x].ch[i]; if(!son) continue; if(x==0) a[son].fail=0;//debug 模板都打错了 else &#123; int p=a[x].fail; while(p&gt;0 and !a[p].ch[i]) p=a[p].fail; a[son].fail=a[p].ch[i]; a[son].ed|=a[a[son].fail].ed;//debug 与运算 &#125; q.push(son); &#125; &#125;&#125;int ans=0,m;int f[MAXN][MAXN*60];bool v[MAXN][MAXN*60];typedef pair&lt;int,int&gt; pp;queue&lt;pp&gt; q2;void solve()&#123; f[0][0]=v[0][0]=1; q2.push(pp(0,0)); while(!q2.empty()) &#123; int now=q2.front().first,sp=q2.front().second;q2.pop(); if(sp==m) &#123;ans=Mod(ans+f[sp][now]);continue;&#125; for(int i=0;i&lt;26;i++) &#123; int tmp=now; while(tmp&gt;0 and !a[tmp].ch[i]) tmp=a[tmp].fail; int son=a[tmp].ch[i]; if(!a[son].ed) &#123; f[sp+1][son]=Mod(f[sp+1][son]+f[sp][now]); if(!v[sp+1][son]) &#123; v[sp+1][son]=1; q2.push(pp(son,sp+1)); &#125; &#125; &#125; &#125;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d%d",&amp;n,&amp;m); a[0].clear(); while(n--) add(); getfail(); solve(); int fm=1;for(int i=1;i&lt;=m;i++) fm=Mod(fm*26); printf("%d",Mod(fm-ans));&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>AC自动机</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SCOI2013】【Bzoj3325】【Luogu3279】密码]]></title>
    <url>%2Fposts%2F4b95.html</url>
    <content type="text"><![CDATA[Source and JudgeSCOI2013Bzoj3325Luogu3279 Problem【Description】已知一个字符串的：1. 长度为N。2. 仅含小写字母。3. 以每一个字符为中心的最长回文串长度。4. 以每两个相邻字符的间隙为中心的最长回文串长度。输出满足条件的字符串中字典序最小的。【Input】输入由三行组成。第一行仅含一个整数N，表示长度。第二行包含N 个整数，表示以每个字符为中心的最长回文串长度。第三行包含N - 1 个整数，表示每两个相邻字符的间隙为中心的最长回文串长度。【Output】输出答案，保证有解【Limited conditions】对于20% 的数据，1 &lt;= n &lt;= 100。另有30% 的数据，1 &lt;= n &lt;= 1000。最后50% 的数据，1 &lt;= n &lt;= 10^5。【Sample input 1】31 1 10 0【Sample output 1】abc【Sample input 2】31 3 10 0【Sample output 2】aba【Sample input 3】31 3 12 2【Sample output 3】aaa【Sample explanation】无 Record2h Analysis请先思考后再展开 一开始想贪心乱搞，然后显然是不可靠の玄学的怎样稳一点呢？相等性和互斥性，而且不是二分图，那不就是并查集了嘛！但是我们并不能单单处理相同的，然后去合并，也不能像某些二分图的时候那样拆成两个对立点，把所有对立的合并起来，因为字母不只2个。有种灰常妙的办法：建边！把与该点所在集合存在互斥关系的集合连上边，然后分配的时候，因为要求字典序最小，则必须选择一个【没有被在前面的，与当前互斥】的字母。注意一定要从整个集合来看，网上有人直接从当前点出发，显然是不正确的，虽然说数据比较水这样，我们就有50分辣！激动吗？（雾 首先，通常来说，如果一个正规比赛题面有灰常类似某个算法的裸题的描述的话，通常来说其实不是用这种算法。。。然鹅今天连做两道题都是要用到那个算法。。（另一个是动物园。。kmp）所以我们还是要借鉴一下manacher的神奇线性做法滴 例如这种情况，就造成了重复，虽然并不是那么直观。manacher的跳过，是不需要验证相同。这道题的跳过，是不需要使它们相同。操作的类似使复杂度也是O(n)的。 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=210000;//*******************全局定义*******************int n;int ma[MAXN],g[MAXN];int v[30];//时间戳int c[MAXN];//分配//*******************实现*******************int fa[MAXN];int findfa(int x) &#123;return (x==fa[x])?x:fa[x]=findfa(fa[x]);&#125;void merg(int x,int y)&#123; int fx=findfa(x),fy=findfa(y); if(fx!=fy) fa[fx]=fy;&#125;int hou[MAXN];struct Edge&#123; int y,g;&#125;e[MAXN*2];//互斥关系int ln=0;void ins(int x,int y)&#123; if(!(1&lt;=x and x&lt;=n)) return; if(!(1&lt;=y and y&lt;=n)) return; e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln; e[++ln]=(Edge)&#123;x,hou[y]&#125;;hou[y]=ln;&#125;//*******************主函数*******************int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;g[2*i]),++g[2*i]; for(int i=1;i&lt;=n-1;i++) scanf("%d",&amp;g[2*i+1]),++g[2*i+1]; n=n*2;ma[1]=1; for(int i=1;i&lt;=n;i++) fa[i]=i;//debug 在后面 int md=1,rx=md+ma[md]-1; for(int i=2;i&lt;=n;i++) &#123; ma[i]=(i&gt;rx)?1:mymin(ma[2*md-i],rx-i+1); for(;ma[i]&lt;g[i];ma[i]++) merg(i-ma[i],i+ma[i]); //ins(i-g[i],i+g[i]);//必须不同 if(i+ma[i]-1&gt;rx) md=i,rx=md+ma[md]-1; &#125; for(int i=2;i&lt;=n;i++) ins(findfa(i-g[i]),findfa(i+g[i]));//必须不同 //奇数位已经无意义 for(int i=2;i&lt;=n;i+=2) &#123; int fx=findfa(i); if(!c[fx])//不能占用0…… &#123; for(int k=hou[fx];k&gt;0;k=e[k].g) v[ c[findfa(e[k].y)] ]=i; for(int j=1;j&lt;=26;j++) if(v[j]&lt;i) &#123;c[fx]=j;break;&#125; &#125; putchar('a'+c[fx]-1); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>难度2</tag>
        <tag>manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AHOI2005】【CQOI2014】病毒检测/通配符匹配]]></title>
    <url>%2Fposts%2F4a8c.html</url>
    <content type="text"><![CDATA[Source and JudgeAHOI2005 病毒检测Bzoj1966Luogu2536CQOI2014 通配符匹配Bzoj3507Luogu3167 Problem【Description】给出通配符字符串，其中 * 的意思是可以匹配上0个或任意多个字符，而 ? 的意思是匹配上任意一个字母，询问给出字符串是否能匹配。【Input】如题目描述【Output】如题目描述【Limited conditions】0&lt;N&lt;100通配符字符串的长度不超过100000询问字符串的长度不超过500通配符个数不超过10【Sample input 1】123**ASD*ASDASD*A?SD?*AS?D*SAD?A?D*?1ASDASDASDADSDASSDASDDDSADAASDAAAAS【Sample output 1】0【Sample input 2】1234567*a*5asdasdddasssdd【Sample output 2】2【Sample explanation】无 Record10h话说我的心路历程可真有意思：ac机=》Here=》贪心比它还长……虽然都没有打代码233 Analysis请先思考后再展开 这道题……栋老师跟Claris学，我跟栋老师学…… 前置知识：Hash 通配符就是本题最关键的部分对于星号，连长度都是任意的，是有很高自由度的，也是最高优先级的，所以要以其为分割点分成一个个段。对于问号，虽然说没有星号这么bt，好歹限制了长度，但其作用并非万能字符那么简单。 咱们先从一些显然的事实开始入手： 如果没有星号，直接匹配 对于第一个星号左边的，必须匹配；最后一个星号后面的部分同理 剩下的段，如果每一个都尽量地偏前面匹配，显然是最优的（或者说，否则不会更优）如果不计算匹配的话，以上过程最坏是O(q*星号数量*n)=1kw 然鹅要怎么匹配呢？如果可以常数级别那当然是极好的那验证相同性……当然要祭出hash不过可别忽略问号哦，所以按照问号拆分开来就好了因为通配符数量的保证，复杂度是常数级别的。 然后就没有然后了。。。。 Code1CQOI2014请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=110000;const int MXCNT=15;const ull base=13331;//*******************全局定义*******************ull bs[MAXN];char s[MAXN];int ln;int cnt,pos[MXCNT];int num[MXCNT],sum[MXCNT][MXCNT];//数量，每个小段数量ull ha[MXCNT][MXCNT];//每个小段hash值//*******************实现*******************bool cmp(char a,char b) &#123;return (a=='?' or b=='?')?1:(a==b);&#125;ull hb[MAXN];//Hashull gethash(int l,int r) &#123; return hb[r]-hb[l-1]*bs[r-l+1]; &#125;bool check(int k,int l)&#123; for(int i=0;i&lt;=num[k-1];i++) &#123; if(sum[k-1][i]==0) &#123;l++;continue;&#125; if(ha[k-1][i]!=gethash(l,l+sum[k-1][i]-1)) return false; l+=sum[k-1][i]+1;//注意+1，因为问号 &#125; return true;&#125;char s2[MAXN];bool solve()&#123; scanf("%s",s2+1);int ln2=strlen(s2+1); if(!cnt)//无星号 &#123; if(ln!=ln2) return false; for(int i=1;i&lt;=ln;i++) if(!cmp(s[i],s2[i])) return false; &#125; else &#123; for(int i=1;i&lt;pos[1];i++) if(!cmp(s[i],s2[i])) return false; for(int i=1;i&lt;=ln-pos[cnt];i++) if(!cmp(s[ln-i+1],s2[ln2-i+1])) return false; int l=pos[1],r=ln2-(ln-pos[cnt])+1;//对于s2 for(int i=l;i&lt;=r;i++) hb[i]=hb[i-1]*base+s2[i]; for(int k=2;k&lt;=cnt;k++) &#123; for(;l&lt;=r;l++) if(check(k,l)) break; l+=pos[k]-pos[k-1]-1; if(l&gt;r) return false; &#125; &#125; return true;&#125;//*******************主函数*******************int main()&#123; bs[0]=1;for(int i=1;i&lt;MAXN;i++) bs[i]=bs[i-1]*base; scanf("%s",s+1);ln=strlen(s+1); cnt=0; for(int i=1;i&lt;=ln;i++) if(s[i]=='*') pos[++cnt]=i; else if(s[i]=='?') ++num[cnt]; else sum[cnt][num[cnt]]++,ha[cnt][num[cnt]]=ha[cnt][num[cnt]]*base+s[i]; int q;scanf("%d",&amp;q); while(q--) solve()?puts("YES"):puts("NO");&#125; Code2AHOI2005请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=1100;const int MXCNT=2100;const ull base=13331;//*******************全局定义*******************ull bs[MAXN];char s[MAXN];int ln;int cnt,pos[MXCNT];int num[MXCNT],sum[MXCNT][MXCNT];//数量，每个小段数量ull ha[MXCNT][MXCNT];//每个小段hash值//*******************实现*******************bool cmp(char a,char b) &#123;return (a=='?' or b=='?')?1:(a==b);&#125;ull hb[MAXN];//前缀Hashull gethash(int l,int r) &#123; return hb[r]-hb[l-1]*bs[r-l+1]; &#125;bool check(int k,int l)&#123; for(int i=0;i&lt;=num[k-1];i++) &#123; if(sum[k-1][i]==0) &#123;l++;continue;&#125; if(ha[k-1][i]!=gethash(l,l+sum[k-1][i]-1)) return false; l+=sum[k-1][i]+1;//注意+1，因为问号 &#125; return true;&#125;char s2[MAXN];bool solve()&#123; scanf("%s",s2+1);int ln2=strlen(s2+1); if(!cnt)//无星号 &#123; if(ln!=ln2) return false; for(int i=1;i&lt;=ln;i++) if(!cmp(s[i],s2[i])) return false; &#125; else &#123; for(int i=1;i&lt;pos[1];i++) if(!cmp(s[i],s2[i])) return false; for(int i=1;i&lt;=ln-pos[cnt];i++) if(!cmp(s[ln-i+1],s2[ln2-i+1])) return false; int l=pos[1],r=ln2-(ln-pos[cnt])+1;//对于s2 for(int i=l;i&lt;=r;i++) hb[i]=hb[i-1]*base+s2[i]; for(int k=2;k&lt;=cnt;k++) &#123; for(;l&lt;=r;l++) if(check(k,l)) break; l+=pos[k]-pos[k-1]-1; if(l&gt;r) return false; &#125; &#125; return true;&#125;//*******************主函数*******************int main()&#123; bs[0]=1;for(int i=1;i&lt;MAXN;i++) bs[i]=bs[i-1]*base; scanf("%s",s+1);ln=strlen(s+1); cnt=0; for(int i=1;i&lt;=ln;i++) if(s[i]=='*') pos[++cnt]=i; else if(s[i]=='?') ++num[cnt]; else sum[cnt][num[cnt]]++,ha[cnt][num[cnt]]=ha[cnt][num[cnt]]*base+s[i]; int q;scanf("%d",&amp;q); int ans=0; while(q--) ans+=!solve(); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【USACO12DEC】【Bzoj3012】【Luogu3065】First!]]></title>
    <url>%2Fposts%2F710f.html</url>
    <content type="text"><![CDATA[Source and JudgeUsaco2012 DecBzoj3012Luogu3065 Problem【Description】给n个字符串，问如果重定义字典序，有哪些单词可能排在字典的第一名。字典序计算：1. 优先找不同的字母2. 其次长度小则前【Input】字符串总量n每行一个字符串【Output】满足条件的数量每行一个，输出原串（按输入顺序）【Limited conditions】1 &lt;= N &lt;= 30,000字符总数不会超过300,000只有小写字母【Sample input】4ommmoomomommnom【Sample output】2ommmom【Sample explanation】如果定义 o 在 m 之前，则omm 可排第一，如果定义 m 在 o 之前，则mom 可排第一，但余下两个单词是无论如何不可能排在第一的。 Record2h Analysis请先思考后再展开 首先： 从面向数据编程的角度，看到字符串总长度，而且只有小写字母，可以考虑字典树 从字符串比较的角度，是从前往后的，也就是前缀，那也是字典树 然后可以考虑枚举每一个字符串，然后什么条件下它能够成为字典序最小的呢？ 不能存在某个字符串是它的前缀 对于某个位置，如果前面都一样，则这个不一样的部分，我的将是最小的显然两个都跟前缀有关，可以用字典树搞一搞然后对于2，产生了一些不等关系 那么有三种思路（大致时间复杂度都是O(N^2)）： 用拓扑排序，如果某一时刻没有入度为0的点，则无解 用差分约束，有负环无解 用强连通找环，有环无解那么网上的大部分都是用第一种的，事实上这也是性价比最高的，所以另外两种就不写了，但是理解还是一定要的。 至于空间的话……网上都说每个串不超过20，但为了不被卡，用了string，慢也是正常的。 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=31000;//*******************全局定义*******************string s[MAXN];//*******************验证*******************const int C=26;int ru[C];bool mp[C][C];bool check()&#123; for(int cnt=1;cnt&lt;=C;cnt++) &#123; int i; for(i=0;i&lt;C;i++) if(ru[i]==0) break; if(i==C) return 0;//环 ru[i]=-1; for(int j=0;j&lt;C;j++) if(mp[i][j]) ru[j]--; &#125; return 1;&#125;//*******************Trie*******************struct Trie&#123; int s; int ch[26]; bool ed;&#125;;vector&lt;Trie&gt; a;void add(int x)&#123; int ln=s[x].length(); int now=0; for(int i=0;i&lt;ln;i++) &#123; int t=s[x][i]-'a'; if(a[now].ch[t]==0) &#123; a.push_back((Trie)&#123;&#125;); a[now].ch[t]=a.size()-1; &#125; now=a[now].ch[t]; a[now].s++; &#125; a[now].ed=1;&#125;bool solve(int x)&#123; memset(mp,0,sizeof(mp)); memset(ru,0,sizeof(ru)); int ln=s[x].length(); int now=0; for(int i=0;i&lt;ln;i++) &#123; if(a[now].ed) return 0; int t=s[x][i]-'a'; for(int j=0;j&lt;C;j++) if(j!=t and !mp[t][j] and a[ a[now].ch[j] ].s&gt;0) mp[t][j]=1,ru[j]++; now=a[now].ch[t]; &#125; return check();&#125;//*******************主函数*******************char sss[310000];bool fine[MAXN];int main()&#123; a.push_back((Trie)&#123;&#125;); int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",sss); s[i]=sss; add(i); &#125; int cnt=0; for(int i=1;i&lt;=n;i++) if(solve(i)) fine[i]=1,cnt++; printf("%d\n",cnt); for(int i=1;i&lt;=n;i++) if(fine[i]) printf("%s\n",s[i].c_str());&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>拓扑</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3670】【Luogu2375】动物园]]></title>
    <url>%2Fposts%2F53a7.html</url>
    <content type="text"><![CDATA[Source and JudgeBzoj3670Luogu2375 Problem【Description】对于字符串S的前i个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作num[i]。输出所有(num[i]+1)的乘积，对1,000,000,007取模的结果即可。【Input】第1行仅包含一个正整数n ，表示测试数据的组数。随后n行，每行描述一组测试数据。每组测试数据仅含有一个字符串S，S的定义详见题目描述。【Output】包含 n 行，每行描述一组测试数据的答案，答案的顺序应与输入数据的顺序保持一致。对于每组测试数据，仅需要输出一个整数，表示这组测试数据的答案对 1,000,000,007 取模的结果。【Limited conditions】S中仅含小写字母。1 N ≤ 5, L ≤ 502 N ≤ 5, L ≤ 2003 N ≤ 5, L ≤ 2004 N ≤ 5, L ≤ 10,0005 N ≤ 5, L ≤ 10,0006 N ≤ 5, L ≤ 100,0007 N ≤ 5, L ≤ 200,0008 N ≤ 5, L ≤ 500,0009 N ≤ 5, L ≤ 1,000,00010 N ≤ 5, L ≤ 1,000,000【Sample input】3aaaaaababcababc【Sample output】36132【Sample explanation】S为aaaaa，则num[4] = 2。这是因为S的前4个字符为aaaa，其中a和aa都满足性质‘既是后缀又是前缀’，同时保证这个后缀与这个前缀不重叠。而aaa虽然满足性质‘既是后缀又是前缀’，但遗憾的是这个后缀与这个前缀重叠了，所以不能计算在内。同理，num[1] = 0,num[2] =1， num[3] = 1,num[5] = 2 Record1h Analysis请先思考后再展开 一开始看错题以为是对于当前前缀的长度，以为就kmp特判一下……然后手玩数据才发现错 用kmp搞出nxt数组（注意不重叠的条件暂时不理，否则会影响后面） 用一个x表示上一次的合法值，然后转移为当前i的nxt值（不一定最大）（这一步不能偷懒直接用nxt[i]，否则前功尽弃，50分） 跳nxt直到满足条件 记录一个【无视条件的个数】的sum，然后直接继承 有没有感觉这个sum和num的关系，很像是莫比乌斯反演中F和f的关系都是从题目要求的，但是很困难的，先计算类似但范围更大而且容易计算的的，然后推导出题目要求的，这种思想灰常值得学习。 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=1100000;const int MOD=1e9+7;//*******************全局定义*******************char s[MAXN];int nxt[MAXN];ll sum[MAXN];//*******************实现*******************//*******************主函数*******************int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; scanf("%s",s+1); int ln=strlen(s+1); ll ans=1;nxt[1]=0;sum[1]=1;//debug int x=0; for(int i=2;i&lt;=ln;i++) &#123; int j=nxt[i-1]; while(j&gt;0 and s[j+1]!=s[i]) j=nxt[j]; nxt[i]=j+(s[j+1]==s[i]); sum[i]=sum[nxt[i]]+1; while(x&gt;0 and s[x+1]!=s[i]) x=nxt[x]; if(s[x+1]==s[i]) x++; while(x&gt;0 and !(x*2&lt;=i)) x=nxt[x]; ans=(ans*(sum[x]+1))%MOD; &#125; printf("%lld\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Vijos1677】陶陶的名字]]></title>
    <url>%2Fposts%2F9bc9.html</url>
    <content type="text"><![CDATA[Source and JudgeVijos1677 Problem【Description】某一天，陶陶想把自己的名字涂在墙上。由于他的名字太长，为了省事，他从自己名字的开头截取了一段作为模板。我们不妨设这个模板的长度为l，陶陶的名字的长度为L，那么有1≤l≤L。然后陶陶会用这个模板进行若干次喷涂，喷出自己的名字（后一次喷涂会覆盖前一次喷涂的结果，例如当前墙上已经有abc三个字符，那么如果在c处进行喷涂，就会得到ababc）。陶陶喷涂名字总是从前向后喷的，假设陶陶喷涂了k次，这k次喷涂按时间顺序第i次喷涂的位置是s[i]，那么s[i]&lt;s[i+1]。【Input】陶陶的名字【Output】最短的模版长度【Limited conditions】对于10%的数据， n≤200对于30%的数据， n≤1000对于100%的数据，n≤1000000【Sample input】abcabababc【Sample output】3【Sample explanation】陶陶的名字是abcabababc，最短的模版是abc。注意，印刷只能从前向后印 Record1h Analysis请先思考后再展开 akc的突破口：最后面一定是一样的一起yy出来但最后没用的：满足二分性( UP 2018.7.8 其实应该是不满足的 )正解：先跑一次kmp，得到nxt数组p对于一个i，尝试验证其$p[i]$是否可行回顾一下：$S(1,p[i])=S(i-p[i]+1,i)$定义lst是最后一个$p[i]=0$，那么在kmp中，这意味着一切重新开始，此后的最长公共前缀后缀都不会越过这里 ①$p[i]&gt;=i-p[i]+1$相等的段重叠了，所以显然是可行的，直接叠过去就好②$p[i]&lt;i-p[i]+1$如果$lst&lt;=p[i]$，那么在它们之间每个p都不是0（发挥作用啦）而这个p[p[i]]，其实可以理解为，能够用1~p[p[i]]之间的元素覆盖这个地方又根据定义，最后的一段是能够完美覆盖的，所以不会多出来 那么接下来就是从最后不停向前跳去验证p[i]，直到出现$lst&gt;p[i]$，则结束。 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;typedef long long ll;typedef unsigned long long ull;//*******************全局常量*******************const int MAXN=1100000;//*******************全局定义*******************char s[MAXN];int nxt[MAXN];//*******************主函数*******************int main()&#123; scanf("%s",s+1); int ln=strlen(s+1); int lst=0; nxt[1]=0; for(int i=2;i&lt;=ln;i++) &#123; int j=nxt[i-1]; while(j&gt;0 and s[j+1]!=s[i]) j=nxt[j]; nxt[i]=j+(s[j+1]==s[i]); if(nxt[i]==0) lst=i; &#125; int x=ln; while(nxt[x]&gt;=lst) x=nxt[x]; printf("%d",x);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51Nod1304】字符串的相似度]]></title>
    <url>%2Fposts%2F23a.html</url>
    <content type="text"><![CDATA[Source and Judge51Nod1304 Problem【Description】我们定义2个字符串的相似度等于两个串的相同前缀的长度。例如 “abc” 同 “abd” 的相似度为2，”aaa” 同 “aaab” 的相似度为3。给出一个字符串S，计算S同他所有后缀的相似度之和。例如：S = “ababaa”，所有后缀为：ababaa 6babaa 0abaa 3baa 0aa 1a 1S同所有后缀的相似度的和 = 6 + 0 + 3 + 0 + 1 + 1 = 11【Input】输入一个字符串S，L为字符串S的长度，且S由a-z的小写字母组成。【Output】输出S同所有后缀的相似度的和。【Limited conditions】1 &lt;= L &lt;= 1000000【Sample input】ababaa【Sample output】11【Sample explanation】无 Record20min Analysis请先思考后再展开 exkmp裸题ex数组之和一开始忘开long long了，wa了一个 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=1100000;//*******************全局定义*******************char sa[MAXN],sb[MAXN];int la,lb;int ext[MAXN],ex[MAXN];//*******************实现*******************void pre_exkmp()&#123; ext[1]=lb; ext[2]=0;while(2+ext[2]&lt;=lb and sb[1+ext[2]]==sb[2+ext[2]]) ext[2]++; int k=2,rx=k+ext[k]-1; for(int i=3;i&lt;=lb;i++) &#123; int j=i-k+1,L=ext[j];//对应点 if(L&lt;rx-i+1) ext[i]=L; else &#123;ext[i]=mymax(rx-i+1,0);while(i+ext[i]&lt;=lb and sb[1+ext[i]]==sb[i+ext[i]]) ext[i]++;&#125; if(i+ext[i]-1&gt;rx) k=i,rx=k+ext[k]-1; &#125;&#125;void exkmp()&#123; pre_exkmp(); ex[1]=0;while(1+ex[1]&lt;=lb and sb[1+ex[1]]==sa[1+ex[1]]) ex[1]++; int k=1,rx=k+ex[k]-1; for(int i=2;i&lt;=la;i++) &#123; int j=i-k+1,L=ext[j];//对应点 if(L&lt;rx-i+1) ex[i]=L; else &#123;ex[i]=mymax(rx-i+1,0);while(1+ex[i]&lt;=lb and i+ex[i]&lt;=la and sb[1+ex[i]]==sa[i+ex[i]]) ex[i]++;&#125; if(i+ex[i]-1&gt;rx) k=i,rx=k+ex[k]-1; &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%s",sa+1); memcpy(sb,sa,sizeof(sa)); la=lb=strlen(sa+1); exkmp(); ll ans=0; for(int i=1;i&lt;=la;i++) ans+=ex[i]; printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>exkmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1462】回文串]]></title>
    <url>%2Fposts%2Ff89e.html</url>
    <content type="text"><![CDATA[Source and JudgeCaioj1462 Problem【Description】给出26个字母所代表的权值和一个字符串，要求把字符串分成两段（每一段长度至少为1，也就是必须要有字符），假如这一段子串是一个回文串，那么加上该串所有字符权值之和，求最大的权值和。【Input】输入一个整数T，表示数据组数.每组数据第一行输入26个数，表示26个字母的权值，第二行输入一个字符串【Output】输出每组数据的最大权值和【Limited conditions】保证字符串内全是小写字母,2&lt;=字符串长度&lt;=500000【Sample input】21 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1aba1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1acacac【Sample output】16【Sample explanation】无 Record30min Analysis请先思考后再展开 对于回文字符串，常用的特性：对称性然鹅有个更通俗易懂大众化的但是很容易被忽略的特性：反转后与原串一样而exkmp正好可以后缀匹配另一个的最长前缀 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=510000;//*******************全局定义*******************char sa[MAXN],sb[MAXN];int la,lb;int ext[MAXN],ex[MAXN];//*******************实现*******************void pre_exkmp()&#123; ext[1]=lb; ext[2]=0;while(2+ext[2]&lt;=lb and sb[1+ext[2]]==sb[2+ext[2]]) ext[2]++; int k=2,rx=k+ext[k]-1; for(int i=3;i&lt;=lb;i++) &#123; int j=i-k+1,L=ext[j];//对应点 if(L&lt;rx-i+1) ext[i]=L; else &#123;ext[i]=mymax(rx-i+1,0);while(i+ext[i]&lt;=lb and sb[1+ext[i]]==sb[i+ext[i]]) ext[i]++;&#125; if(i+ext[i]-1&gt;rx) k=i,rx=k+ext[k]-1; &#125;&#125;void exkmp()&#123; pre_exkmp(); ex[1]=0;while(1+ex[1]&lt;=lb and sb[1+ex[1]]==sa[1+ex[1]]) ex[1]++; int k=1,rx=k+ex[k]-1; for(int i=2;i&lt;=la;i++) &#123; int j=i-k+1,L=ext[j];//对应点 if(L&lt;rx-i+1) ex[i]=L; else &#123;ex[i]=mymax(rx-i+1,0);while(1+ex[i]&lt;=lb and i+ex[i]&lt;=la and sb[1+ex[i]]==sa[i+ex[i]]) ex[i]++;&#125; if(i+ex[i]-1&gt;rx) k=i,rx=k+ex[k]-1; &#125;&#125;int cc[300];int sum[MAXN];bool f[MAXN];int solve()&#123; for(char i='a';i&lt;='z';i++) scanf("%d",&amp;cc[i]); scanf("%s",sa+1);la=lb=strlen(sa+1); memcpy(sb,sa,sizeof(sa)); std::reverse(sb+1,sb+lb+1); exkmp(); for(int i=2;i&lt;=lb;i++) f[i]=(ex[i]==lb-i+1); std::swap(sa,sb); exkmp(); for(int i=1;i&lt;=lb;i++) sum[i]=sum[i-1]+cc[sa[i]]; int ans=0; for(int i=1;i&lt;=lb-1;i++) &#123; int tmp=0; if(f[lb-i+1]) tmp+=sum[i]; if(ex[i+1]==lb-i) tmp+=sum[lb]-sum[i]; ans=mymax(ans,tmp); &#125; return ans;&#125;//*******************主函数*******************int main()&#123; //freopen("tmp.in","r",stdin); int T;scanf("%d",&amp;T); while(T--) printf("%d\n",solve());&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>exkmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj5290】【Luogu4438】Hnoi2018道路]]></title>
    <url>%2Fposts%2Fd692.html</url>
    <content type="text"><![CDATA[Source and JudgeHnoi2018Bzoj5290Luogu4438 Problem【Description】W 国的交通呈一棵树的形状。W 国一共有 n - 1 个城市和 n 个乡村，其中城市从 1 到 n−1 编号，乡村从 1 到 n 编号，且 1 号城市是首都。道路都是单向的，本题中我们只考虑从乡村通往首都的道路网络。对于每一个城市，恰有一条公路和一条铁路通向这座城市。对于城市i， 通向该城市的道路（公路或铁路）的起点，要么是一个乡村，要么是一个编号比 i 大的城市。 没有道路通向任何乡村。除了首都以外，从任何城市或乡村出发只有一条道路；首都没有往 外的道路。从任何乡村出发，沿着唯一往外的道路走，总可以到达首都。W 国的国王小 W 获得了一笔资金，他决定用这笔资金来改善交通。由于资金有限，小 W 只能翻修 n−1 条道路。小 W 决定对每个城市翻修恰好一条通向它的道路，即从公路和铁 路中选择一条并进行翻修。小 W 希望从乡村通向城市可以尽可能地便利，于是根据人口调 查的数据，小 W 对每个乡村制定了三个参数，编号为 i 的乡村的三个参数是a,b,c 。假设 从编号为 i 的乡村走到首都一共需要经过 x 条未翻修的公路与 y 条未翻修的铁路，那么该乡村 的不便利值为(a+x)×(b+y)×c。在给定的翻修方案下，每个乡村的不便利值相加的和为该翻修方案的不便利值。 翻修 n−1 条道路有很多方案，其中不便利值最小的方案称为最优翻修方案，小 W 自然希望找到最优翻修方案，请你帮助他求出这个最优翻修方案的不便利值。【Input】第一行为正整数 n 。接下来 n−1 行，每行描述一个城市。其中第 i 行包含两个数 si,ti 。si 表示通向第 i 座城市 的公路的起点，ti 表示通向第i座城市的铁路的起点。如果si&gt;0 ，那么存在一条从第si 座城 市通往第 i 座城市的公路，否则存在一条从第 −si个乡村通往第i座城市的公路； ti 类似地，如 果 ti&gt;0 ，那么存在一条从第 ti 座城市通往第i座城市的铁路，否则存在一条从第 −ti 个乡村通 往第 i 座城市的铁路。接下来 n 行，每行描述一个乡村。其中第i行包含三个数 a,b,c，其意义如题面所示。【Output】输出一行一个整数，表示最优翻修方案的不便利值。【Limited conditions】n≤20000,1≤ai,bi≤60,1≤ci≤10^9，任意乡村可以通过不超过40条道路到达首都。【Sample input 1】62 34 5-1 -2-3 -4-5 -61 2 31 3 22 1 32 3 13 1 23 2 1【Sample output 1】54【Sample input 2】92 -23 -34 -45 -56 -67 -78 -8-1 -91 60 11 60 11 60 11 60 11 60 11 60 11 60 11 60 11 60 1【Sample output 2】548【Sample input 3】122 45 3-7 1011 9-1 68 7-6 -10-9 -4-12 -5-2 -3-8 -1153 26 49124 58 19017 37 35615 51 99730 19 3983 45 2752 55 83816 18 93158 24 21243 25 19854 15 17234 5 524【Sample output 3】5744902【Sample explanation】如图所示，我们分别用蓝色、黄色节点表示城市、乡村；用绿色、红色箭头分别表示 公路、铁路；用加粗箭头表示翻修的道路。一种不便利值等于54的方法是：翻修通往城市2和城市5的铁路，以及通往其他城市的 公路。用→和⇒表示公路和铁路，用∗→和∗⇒表示翻修的公路和铁路，那么：编号为1的乡村到达首都的路线为：-1 ∗→ 3 ⇒ 1，经过0条未翻修公路和1条未翻修铁 路，代价为3 × (1 + 0) × (2 + 1) = 9；编号为2的乡村到达首都的路线为：-2 ⇒ 3 ⇒ 1，经过0条未翻修公路和2条未翻修铁 路，代价为2 × (1 + 0) × (3 + 2) = 10；编号为3的乡村到达首都的路线为：-3 ∗→ 4 → 2 ∗→ 1，经过1条未翻修公路和0条未 翻修铁路，代价为3 × (2 + 1) × (1 + 0) = 9；编号为4的乡村到达首都的路线为：-4 ⇒ 4 → 2 ∗→ 1，经过1条未翻修公路和1条未翻 修铁路，代价为1 × (2 + 1) × (3 + 1) = 12；编号为5的乡村到达首都的路线为：-5 → 5 ∗⇒ 2 ∗→ 1，经过1条未翻修公路和0条未 翻修铁路，代价为2 × (3 + 1) × (1 + 0) = 8；编号为6的乡村到达首都的路线为：-6 ∗⇒ 5 ∗⇒ 2 ∗→ 1，经过0条未翻修公路和0条未翻修铁路，代价为1 × (3 + 0) × (2 + 0) = 6；总的不便利值为9 + 10 + 9 + 12 + 8 + 6 = 54。可以证明这是本数据的最优解。 Record30min Analysis请先思考后再展开 好菜啊，没想到记忆化，考试的时候打了个暴力主要是自己傻傻地把边拉出来决策……这样就根本不会联想到记忆化好吧 听说这个题当初省选现场没有省队大爷AC……这道题的精髓就在于，把2^n的大暴力通过记忆化变成了精悍的树形dp Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=21000;//*******************全局定义*******************struct Nod&#123; int lc,rc;&#125;a[MAXN];struct Xj&#123; ll a,b,c;&#125;b[MAXN];ll f[MAXN][41][41];//*******************实现*******************ll solve(int now,ll x,ll y)&#123; if(now&lt;0) return (b[-now].a+x)*(b[-now].b+y)*b[-now].c; if(f[now][x][y]&lt;f[0][0][0]) return f[now][x][y]; return f[now][x][y]=mymin( solve(a[now].lc,x,y)+solve(a[now].rc,x,y+1), solve(a[now].lc,x+1,y)+solve(a[now].rc,x,y) );&#125;//*******************主函数*******************int main()&#123; //freopen("tmp.in","r",stdin); int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n-1;i++) scanf("%d%d",&amp;a[i].lc,&amp;a[i].rc); for(int i=1;i&lt;=n;i++) scanf("%lld%lld%lld",&amp;b[i].a,&amp;b[i].b,&amp;b[i].c); memset(f,63,sizeof(f)); printf("%lld",solve(1,0,0));&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF838-B】Diverging Directions]]></title>
    <url>%2Fposts%2Fb187.html</url>
    <content type="text"><![CDATA[Source and JudgeCF838-B Problem【Description】西瓜们生活在编号 1⋯n 的 n个平行时空中，2n−2 台时光机将这些平行时空联系在一起。一台时光机有 3个整数参数 u,v,t 表示从时空 u 可以花费 t 的时间穿梭到时空 v。为了确保时空之间可以相互穿梭，同时方便作为现世的 1号时空的通行，西瓜们将这些时光机进行分工：前 n−1 台时光机确保从 1号时空可以直接 / 间接抵达任意时空，后 n−1台时光机负责从 2⋯n号时空直接返回 1号时空。【Input】第一行 3 个整数 n,q 分别表示 平行时空，操作 的个数。接下来 2n−2 行，每行 3 个整数 u,v,t 表示一台时光机。接下来 q 行，每行 3 个整数 id,x,y：若 $id=1$，表示第 $x$ 台时光机的运行时间变成了 $y$。若 $id=2$，表示当前有一个西瓜想要从时空 $x$ 穿梭到 时空 $y$；【Output】每次询问输出最短时间。【Limited conditions】n,q&lt;=2*10^6【Sample input】5 91 3 13 2 21 4 33 5 45 1 53 1 62 1 74 1 82 1 12 1 32 3 52 5 21 1 1002 1 31 8 302 4 22 2 4【Sample output】014810013210【Sample explanation】无 Record1h Analysis请先思考后再展开 显然是一个树类似树链剖分的思想，准确地说是dfs序如果对dfs序不是很懂的话，可以去看看这道经典题软件包管理器很水呀但是机房居然只有三个人过…… Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;const int INF=0x3f3f3f3f;typedef long long ll;void qread(int &amp;x)&#123; x=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') x=x*10+c-'0',c=getchar();&#125;void qreadll(ll &amp;x)&#123; x=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') x=x*10ll+c-'0',c=getchar();&#125;ll mymin(ll x,ll y) &#123;return (x&lt;y)?x:y;&#125;const int MAXN=210000;struct Seg&#123; int l,r,mid; int lc,rc; ll mi,lz;&#125;s[MAXN*2];int cnt=0;int build(int l,int r)&#123; int t=++cnt; if(l==r) s[t]=(Seg)&#123;l,r,l,0,0,0,0&#125;; else &#123; s[t]=(Seg)&#123;l,r,(l+r)&gt;&gt;1,0,0,0,0&#125;; s[t].lc=build(l,s[t].mid); s[t].rc=build(s[t].mid+1,r); s[t].mi=mymin(s[s[t].lc].mi,s[s[t].rc].mi); &#125; return t;&#125;void pushdown(int x)&#123; int lc=s[x].lc,rc=s[x].rc; if(lc&gt;0) &#123;s[lc].mi+=s[x].lz;s[lc].lz+=s[x].lz;&#125; if(rc&gt;0) &#123;s[rc].mi+=s[x].lz;s[rc].lz+=s[x].lz;&#125; s[x].lz=0;&#125;void change(int x,int l,int r,ll o)&#123; if(s[x].l==l and s[x].r==r) &#123; s[x].mi+=o; s[x].lz+=o; return; &#125; if(s[x].lz!=0) pushdown(x); int lc=s[x].lc,rc=s[x].rc; if(r&lt;=s[x].mid) change(lc,l,r,o); else if(l&gt;s[x].mid) change(rc,l,r,o); else change(lc,l,s[x].mid,o),change(rc,s[x].mid+1,r,o); s[x].mi=mymin(s[lc].mi,s[rc].mi);&#125;ll ask(int x,int l,int r)&#123; if(s[x].l==l and s[x].r==r) return s[x].mi; if(s[x].lz!=0) pushdown(x); int lc=s[x].lc,rc=s[x].rc; if(r&lt;=s[x].mid) return ask(lc,l,r); if(l&gt;s[x].mid) return ask(rc,l,r); return mymin( ask(lc,l,s[x].mid),ask(rc,s[x].mid+1,r) );&#125;struct Nod&#123; int hou; int siz; ll dis,tt; Nod() &#123; hou=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,g;ll c;&#125;e[MAXN*2];int ln=0;void ins(int x,int y,ll c)&#123; e[++ln]=(Edge)&#123;y,p[x].hou,c&#125;;p[x].hou=ln;&#125;int yz[MAXN],id=0;void dfs(int x,int fa)&#123; yz[x]=++id;p[x].siz=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; p[y].dis=p[x].dis+e[k].c; dfs(y,x); p[x].siz+=p[y].siz; &#125;&#125;struct SG&#123; int x,y; ll z;&#125;ss[2*MAXN];ll solve(int x,int y)&#123; if(yz[x]&lt;=yz[y] and yz[y]&lt;=yz[x]+p[x].siz-1) return ( ask(1,yz[y],yz[y])-p[y].tt )-( ask(1,yz[x],yz[x])-p[x].tt ); return ask(1,yz[x],yz[x]+p[x].siz-1)-(ask(1,yz[x],yz[x])-p[x].tt)+(ask(1,yz[y],yz[y])-p[y].tt);&#125;int main()&#123; int n,q;qread(n);qread(q); for(int i=1;i&lt;=2*n-2;i++) &#123; int x,y;ll z; qread(x);qread(y);qreadll(z); ss[i]=(SG)&#123;x,y,z&#125;; if(y==1) p[x].tt=z; else ins(x,y,z); &#125; dfs(1,0); build(1,n); for(int i=2;i&lt;=n;i++) change(1,yz[i],yz[i],p[i].dis+p[i].tt); while(q--) &#123; int id,x,y;qread(id);qread(x);qread(y); if(id==2) printf("%I64d\n",solve(x,y)); else &#123; int nx=ss[x].x,ny=ss[x].y; if(ny==1) change(1,yz[nx],yz[nx],-p[nx].tt+y),p[nx].tt=y; else change(1,yz[ny],yz[ny]+p[ny].siz-1,-ss[x].z+y),ss[x].z=y; &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>树链剖分</tag>
        <tag>dfs序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1178】最长共同前缀长度]]></title>
    <url>%2Fposts%2Ff934.html</url>
    <content type="text"><![CDATA[Source and JudgeCaioj1178 Problem【Description】给出模板串A和子串B，长度分别为lenA和lenB，要求对于每个A[i],(1&lt;=i&lt;=lenA)，求出A[i..lenA]与B的最长公共前缀长度【Input】输入A，B两个串【Output】输出lenA个数，表示A[i…lenA]与B的最长公共前缀长度，每个数之前有空格【Limited conditions】lenB&lt;=lenA&lt;=1000000【Sample input】aabbabaaabaabb【Sample output】4 1 0 0 1 0 2 3 1 0【Sample explanation】无 Record2h Analysis请先思考后再展开 exkmp入门题，求ex数组详见：【OI之路】10字符串-3ExKMP Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=1100000;//*******************全局定义*******************char sa[MAXN],sb[MAXN];int la,lb;int ext[MAXN],ex[MAXN];//*******************实现*******************void pre_exkmp()&#123; lb=strlen(sb+1); ext[1]=lb; ext[2]=0;while(2+ext[2]&lt;=lb and sb[1+ext[2]]==sb[2+ext[2]]) ext[2]++; int k=2,rx=k+ext[k]-1; for(int i=3;i&lt;=lb;i++) &#123; int j=i-k+1,L=ext[j];//对应点 if(L&lt;rx-i+1) ext[i]=L; else &#123;ext[i]=mymax(rx-i+1,0);while(i+ext[i]&lt;=lb and sb[1+ext[i]]==sb[i+ext[i]]) ext[i]++;&#125; if(i+ext[i]-1&gt;rx) k=i,rx=k+ext[k]-1; &#125;&#125;void exkmp()&#123; la=strlen(sa+1); ex[1]=0;while(1+ex[1]&lt;=lb and sb[1+ex[1]]==sa[1+ex[1]]) ex[1]++; int k=1,rx=k+ex[k]-1; for(int i=2;i&lt;=la;i++) &#123; int j=i-k+1,L=ext[j];//对应点 if(L&lt;rx-i+1) ex[i]=L; else &#123;ex[i]=mymax(rx-i+1,0);while(1+ex[i]&lt;=lb and i+ex[i]&lt;=la and sb[1+ex[i]]==sa[i+ex[i]]) ex[i]++;&#125; if(i+ex[i]-1&gt;rx) k=i,rx=k+ex[k]-1; &#125;&#125;//*******************主函数*******************int main()&#123; //freopen("tmp.in","r",stdin); scanf("%s%s",sa+1,sb+1); pre_exkmp(); exkmp(); for(int i=1;i&lt;=la;i++) printf("%d ",ex[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>exkmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC096-b】Static Sushi]]></title>
    <url>%2Fposts%2Feb3b.html</url>
    <content type="text"><![CDATA[Source and JudgeARC096-b Problem【Description】给出包含n个寿司的圆环的圆周c，并按顺时针给出其与源点的顺时针距离从源点出发，从任何一个位置离开，总收获=寿司卡路里和-路上花费和【Input】N Cx1 v1x2 v2:xN vN【Output】最大收获【Limited conditions】1≤N≤10^52≤C≤10^141≤x1&lt;x2&lt;…&lt;xN&lt;C1≤vi≤10^9【Sample input】3 202 809 116 120【Sample output】192【Sample explanation】无 Record2h Analysis请先思考后再展开 考试的时候傻了，居然还想单调队列……然后到目前为止还是wa两个点代码太丑，何况还是错的，就不贴了 其实把前面的信息记录一下，然后后面就简单地取mx就好了 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;typedef long long ll;typedef unsigned long long ull;ll mymax(ll x,ll y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=110000;//*******************全局定义*******************ll f[MAXN],g[MAXN];//顺时针，逆时针ll x[MAXN],v[MAXN];//*******************实现*******************//*******************主函数*******************int main()&#123; //freopen("tmp.in","r",stdin); int n;ll c;scanf("%d%lld",&amp;n,&amp;c); for(int i=1;i&lt;=n;i++) scanf("%lld%lld",&amp;x[i],&amp;v[i]); ll ans=0,sum; sum=0;for(int i=1;i&lt;=n;i++) sum+=v[i],f[i]=sum-x[i],ans=mymax(ans,f[i]); sum=0;for(int i=n;i&gt;=1;i--) sum+=v[i],g[i]=sum-(c-x[i]),ans=mymax(ans,g[i]); ll mx; mx=0;for(int i=n-1;i&gt;=1;i--) mx=mymax(mx,g[i+1]),ans=mymax(ans,f[i]+mx-x[i]); mx=0;for(int i=2;i&lt;=n;i++) mx=mymax(mx,f[i-1]),ans=mymax(ans,g[i]+mx-(c-x[i])); printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3461】Oulipo]]></title>
    <url>%2Fposts%2Feaf4.html</url>
    <content type="text"><![CDATA[Source and JudgeBAPC 2006 QualificationPoj3461Caioj1460 Problem【Description】给出串A、B，判断A在B中出现次数，可重叠。【Input】第一行的正整数表示数据组数。每组数据两个不包含空格的字符串表示串A、B。【Output】每组数据输出一个数，表示匹配个数。【Limited conditions】字符串仅由大写字母组成。1 ≤ |A| ≤ 10,000|A| ≤ |B| ≤ 1,000,000.【Sample input】3BAPCBAPCAZAAZAZAZAVERDIAVERDXIVYERDIAN【Sample output】130【Sample explanation】无 Record30min Analysis1请先思考后再展开 这道题是kmp的经典入门问题 Code1请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=1100000;//*******************全局定义*******************char a[MAXN],b[MAXN];int la,lb;//*******************实现*******************int nxt[MAXN];void prekmp()&#123; lb=strlen(b+1); for(int i=2;i&lt;=lb;i++) &#123; int j=nxt[i-1]; while(j&gt;0 and b[j+1]!=b[i]) j=nxt[j]; if(b[j+1]==b[i]) nxt[i]=j+1; else nxt[i]=0; &#125;&#125;int kmp()&#123; la=strlen(a+1); int ans=0; int j=0; for(int i=1;i&lt;=la;i++) &#123; while(j&gt;0 and b[j+1]!=a[i]) j=nxt[j]; if(b[j+1]==a[i]) j++; if(j==lb) ans++; &#125; return ans;&#125;//*******************主函数*******************int main()&#123; //freopen("tmp.in","r",stdin); int T;scanf("%d",&amp;T); while(T--) &#123; scanf("%s%s",b+1,a+1); prekmp(); printf("%d\n",kmp()); &#125;&#125; Analysis2请先思考后再展开 然后这道题练习hash也是极好的$S(l,r)=f[r]-b^{r-l+1}\times f[l-1]$ Code2请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=1100000;const ull base=13331;//*******************全局定义*******************char a[MAXN],b[MAXN];ull f[MAXN];//*******************实现*******************ull bs[MAXN];ull getf(int l,int r)&#123; return f[r]-f[l-1]*bs[r-l+1];&#125;int solve()&#123; int la=strlen(a+1),lb=strlen(b+1); ull hb=0;for(int i=1;i&lt;=lb;i++) hb=hb*base+b[i]; int ans=0; for(int r=1;r&lt;=la;r++) &#123; f[r]=f[r-1]*base+a[r]; if(r&gt;=lb and getf(r-lb+1,r)==hb) ans++; &#125; return ans;&#125;//*******************主函数*******************int main()&#123; //freopen("tmp.in","r",stdin); bs[0]=1;for(int i=1;i&lt;MAXN;i++) bs[i]=bs[i-1]*base;//base^i int T;scanf("%d",&amp;T); while(T--) &#123; scanf("%s%s",b+1,a+1); printf("%d\n",solve()); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>难度1</tag>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3124】【Luogu3304】直径]]></title>
    <url>%2Fposts%2F15f6.html</url>
    <content type="text"><![CDATA[Source and JudgeSdoi2013Bzoj3124Luogu3304 Problem【Description】给定一棵树，求直径的长度，以及有多少条边满足【所有的直径都经过】。【Input】第一行包含一个整数N，表示节点数。接下来N-1行，每行三个整数a, b, c ，表示点 a和点b之间有一条长度为c的无向边。【Output】共两行。第一行一个整数，表示直径的长度。第二行一个整数，表示被所有直径经过的边的数量。【Limited conditions】2&lt;=N&lt;=200000，所有点的编号都在1..N的范围内，边的权值&lt;=10^9【Sample input】63 1 10001 4 104 2 1004 5 504 6 100【Sample output】11102【Sample explanation】直径共有两条，3 到2的路径和3到6的路径。这两条直径都经过边(3, 1)和边(1, 4)。 Record30min Analysis请先思考后再展开 很有趣的一道题思路来自akc大爷： 找出一条直径 把直径扯直，其它子树挂在上面，此时答案一定从其中产生 预处理出直径上前缀和、后缀和，以及每个子树的最大深度mxi 从右往左找到第一个满足【mx+sum=L（直径长度）】，则意味着排除左边所有边，记录此l 从左往右同理，记录r 于是我们就可以枚举左右端点去枚举这种情况：【mx1+sum+mx2=L】复杂度O(n) Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=210000;//*******************全局定义*******************struct Nod&#123; int hou; int fa; ll dis; bool v; Nod() &#123; hou=v=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,g;ll c;&#125;e[MAXN*2];int ln=0;void ins()&#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); e[++ln]=(Edge)&#123;y,p[x].hou,c&#125;;p[x].hou=ln; e[++ln]=(Edge)&#123;x,p[y].hou,c&#125;;p[y].hou=ln;&#125;//*******************实现*******************int tmp;void dfs(int x,int fa)&#123; p[x].fa=fa; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa or p[y].v) continue; p[y].dis=p[x].dis+e[k].c; if(p[y].dis&gt;p[tmp].dis) tmp=y; dfs(y,x); &#125;&#125;//*******************主函数*******************int f[MAXN];int sum[MAXN],mx[MAXN];int cnt=0;//记录直径int main()&#123; //freopen("tmp.in","r",stdin); int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n-1;i++) ins(); tmp=1;p[tmp].dis=0;dfs(tmp,0);int aa=tmp; tmp=aa;p[tmp].dis=0;dfs(tmp,0);int bb=tmp; printf("%lld\n",p[bb].dis); int x=bb; while(1) &#123; f[++cnt]=x; p[x].v=1; if(x==aa) break; x=p[x].fa; &#125; for(int i=1;i&lt;=cnt;i++) &#123; tmp=f[i]; sum[i]=p[tmp].dis; p[tmp].dis=0; dfs(tmp,0); mx[i]=p[tmp].dis; &#125; int l=1;for(int i=cnt;i&gt;=1;i--) if(mx[i]==sum[1]-sum[i]) &#123;l=i;break;&#125; int r=cnt;for(int i=1;i&lt;=cnt;i++) if(mx[i]==sum[i]) &#123;r=i;break;&#125; printf("%d",r-l);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP14 D1T3】飞扬的小鸟]]></title>
    <url>%2Fposts%2Fad3d.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2014 提高组 D1T3Luogu1941Caioj1565 Problem【Description】Flappy Bird 是一款风靡一时的休闲手机游戏。玩家需要不断控制点击手机屏幕的频率来调节小鸟的飞行高度，让小鸟顺利通过画面右方的管道缝隙。如果小鸟一不小心撞到了水管或者掉在地上的话，便宣告失败。为了简化问题，我们对游戏规则进行了简化和改编：1. 游戏界面是一个长为 n ，高为 m 的二维平面，其中有 k 个管道（忽略管道的宽度）。2. 小鸟始终在游戏界面内移动。小鸟从游戏界面最左边任意整数高度位置出发，到达游戏界面最右边时，游戏完成。3. 小鸟每个单位时间沿横坐标方向右移的距离为1 ，竖直移动的距离由玩家控制。如果点击屏幕，小鸟就会上升一定高度X ，每个单位时间可以点击多次，效果叠加；如果不点击屏幕，小鸟就会下降一定高度Y 。小鸟位于横坐标方向不同位置时，上升的高度X 和下降的高度Y 可能互不相同。4. 小鸟高度等于0 或者小鸟碰到管道时，游戏失败。小鸟高度为 m 时，无法再上升。现在，请你判断是否可以完成游戏。如果可以 ，输出最少点击屏幕数；否则，输出小鸟最多可以通过多少个管道缝隙。【Input】第1 行有3 个整数n ，m ，k ，分别表示游戏界面的长度，高度和水管的数量，每两个整数之间用一个空格隔开；接下来的n 行，每行2 个用一个空格隔开的整数X 和Y ，依次表示在横坐标位置0 ~n- 1上玩家点击屏幕后，小鸟在下一位置上升的高度X ，以及在这个位置上玩家不点击屏幕时，小鸟在下一位置下降的高度Y 。接下来k 行，每行3 个整数P ，L ，H ，每两个整数之间用一个空格隔开。每行表示一个管道，其中P 表示管道的横坐标，L 表示此管道缝隙的下边沿高度为L ，H 表示管道缝隙上边沿的高度（输入数据保证P 各不相同，但不保证按照大小顺序给出）。【Output】共两行。第一行，包含一个整数，如果可以成功完成游戏，则输出1 ，否则输出0 。第二行，包含一个整数，如果第一行为1 ，则输出成功完成游戏需要最少点击屏幕数，否则，输出小鸟最多可以通过多少个管道缝隙。【Limited conditions】对于 30%的数据：5≤n≤10，5≤m≤10，k=0，保证存在一组最优解使得同一单位时间最多点击屏幕 3 次；对于 50%的数据：5≤n≤20，5≤m≤10，保证存在一组最优解使得同一单位时间最多点击屏幕 3 次；对于 70%的数据：5≤n≤1000，5≤m≤100；对于 100%的数据：5≤n≤10000，5≤m≤1000，0≤k&lt;n，0&lt;X&lt;m，0&lt;Y&lt;m，0&lt;P&lt;n，0≤L&lt;H ≤m，L+1&lt;H。【Sample input 1】10 10 63 99 91 21 31 21 12 12 11 62 21 2 75 1 56 3 57 5 88 7 99 1 3【Sample output 1】16【Sample input 2】10 10 41 23 12 21 81 83 22 12 12 21 21 0 26 7 99 1 43 8 10【Sample output 2】03【Sample explanation】如下图所示，蓝色直线表示小鸟的飞行轨迹，红色直线表示管道。 Record3h Analysis1请先思考后再展开 首先，题意不是很明确，有个细节：当高度达到m以上，并不是非法，而是视作m！解法1：bfs爆搜预计得分：75时间复杂度：$O(nm^2log_2(nm))$ Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=10001;//*******************全局定义*******************int n,m;int ll[MAXN],rr[MAXN];int xx[MAXN],yy[MAXN];struct Pt&#123; int x,y,g; Pt(int tx=0,int ty=0,int tg=0) &#123;x=tx,y=ty,g=tg;&#125;&#125;;bool operator &lt; (Pt a,Pt b) &#123;return a.g&gt;b.g;&#125;//*******************实现*******************priority_queue&lt;Pt&gt; q;//小根堆int ans2=0;int vis[MAXN][1001];//min( g() )void ins(Pt now)&#123; if(now.y&gt;ll[now.x] and now.y&lt;rr[now.x] and vis[now.x][now.y]&gt;now.g) &#123; vis[now.x][now.y]=now.g; ans2=mymax(ans2,now.x); q.push(now); &#125;&#125;int solve()&#123; memset(vis,127,sizeof(vis)); for(int i=1;i&lt;=m;i++) ins( Pt(0,i,0) ); while(!q.empty()) &#123; Pt now=q.top();q.pop(); if(now.g&gt;vis[now.x][now.y]) continue;//old imformation if(now.x==n) return now.g; //1. down ins(Pt(now.x+1,now.y-yy[now.x],now.g)); //2. up int y=now.y,g=now.g; while(y&lt;rr[now.x+1])//剪枝 &#123; y+=xx[now.x]; if(y&gt;m) y=m; ins( Pt(now.x+1,y,++g) ); if(y==m) break; &#125; &#125; return -1;&#125;//*******************主函数*******************int pp[MAXN];int main()&#123; //freopen("tmp.in","r",stdin); int k;scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=0;i&lt;=n-1;i++) scanf("%d%d",&amp;xx[i],&amp;yy[i]); memset(ll,0,sizeof(ll)); memset(rr,127,sizeof(rr)); for(int i=1;i&lt;=k;i++) &#123; scanf("%d",&amp;pp[i]); scanf("%d%d",&amp;ll[ pp[i] ],&amp;rr[ pp[i] ]); &#125; int ans=solve(); if(ans&gt;=0) printf("1\n%d",ans); else &#123; sort(pp+1,pp+k+1); printf("0\n%d",lower_bound(pp+1,pp+k+1,ans2)-pp-1); &#125;&#125; Analysis2请先思考后再展开 在上一个做法中，我们忽略了这道题一个重要的特性：方向固定（向右）所以是可以DP的把上升看作【多次背包】，下降看作【单次背包】 朴素的$O(nm^2)$：$$f[i][j] =\left{\begin{matrix}\underset{k}{min}(f[i-1][j-k\times x[i-1]])+k&amp; (j-k\times x[i-1]&gt;0) \f[i-1][j+y[i-1]]&amp; (j+y[i-1]\leq m)\end{matrix}\right.$$ 然鹅，对于这之中耗时最多的枚举k，其实我们完全可以【放后影响】，从上一遍搞过来（显而易见，打bfs的时候想过但是不适用……然鹅DP是可以的）于是就下降到了$O(nm)$辣：$$f[i][j] =\left{\begin{matrix}min(f[i-1][j-x[i-1]],f[i][j-x[i-1])+1&amp; (j-x[i-1]&gt;0) \f[i-1][j+y[i-1]]&amp; (j+y[i-1]\leq m)\end{matrix}\right.$$ 注意：对于撞到管子的$f[i][j]$，还是要计算的，因为有这种情况：我们从$f[i][j-x[i-1]]$转移过来，它撞墙了，但$f[i][j]$没有撞墙，它去没得继承了。所以要顺便说一句：感觉这个dp很像维护一个二维前缀 所以，综上所述，对于每一列： 无视水管，dp（特判m的情况），只考虑上升做多重背包 水管上，还原为inf 水管空档的下降，01背包 总结：如果有单向性，先考虑一下DP，再去想爆搜 Code2请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=10001;const int INF=0x3f3f3f3f;//*******************全局定义*******************int n,m,k;int xx[MAXN],yy[MAXN];int l[MAXN],r[MAXN];//*******************实现*******************int f[MAXN][1001];void solve()&#123; memset(f,63,sizeof(f)); for(int i=1;i&lt;=m;i++) f[0][i]=0; for(int x=1;x&lt;=n;x++) &#123; //1. up for(int y=xx[x-1]+1;y&lt;=m;y++) f[x][y]=mymin(f[x-1][y-xx[x-1]],f[x][y-xx[x-1]])+1; //2. up-特判m for(int k=m-xx[x-1];k&lt;=m;k++) f[x][m]=mymin( f[x][m],mymin(f[x-1][k],f[x][k])+1 ); //3. lock for(int y=1;y&lt;=l[x];y++) f[x][y]=INF; for(int y=r[x];y&lt;=m;y++) f[x][y]=INF; //4. down for(int y=l[x]+1;y&lt;=r[x]-1;y++) if(y+yy[x-1]&lt;=m) f[x][y]=mymin(f[x][y],f[x-1][y+yy[x-1]]); &#125;&#125;//*******************主函数*******************int pp[MAXN];int main()&#123; //freopen("tmp.in","r",stdin); scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=0;i&lt;=n-1;i++) scanf("%d%d",&amp;xx[i],&amp;yy[i]); for(int i=0;i&lt;=n;i++) l[i]=0,r[i]=m+1; for(int i=1;i&lt;=k;i++) &#123; scanf("%d",&amp;pp[i]); scanf("%d%d",&amp;l[ pp[i] ],&amp;r[ pp[i] ]); &#125; solve(); int ans=INF,cnt=k; for(int x=n;x&gt;=1;x--) &#123; for(int y=l[x]+1;y&lt;=r[x]-1;y++) ans=mymin(ans,f[x][y]); if(ans!=INF) break;//成功 if(r[x]&lt;=m) cnt--;//失败 &#125; if(cnt==k) printf("1\n%d",ans); else printf("0\n%d",cnt);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>bfs</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP14 D2T1】无线网络发射器选址]]></title>
    <url>%2Fposts%2F3a8c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2014 提高组 D2T1Luogu1941Caioj1566 Problem【Description】假设某城市的布局为由严格平行的129 条东西向街道和129 条南北向街道所形成的网格状，并且相邻的平行街道之间的距离都是恒定值 1。东西向街道从北到南依次编号为0,1,2…128 , 南北向街道从西到东依次编号为0,1,2…128。东西向街道和南北向街道相交形成路口，规定编号为 x 的南北向街道和编号为 y 的东西向街道形成的路口的坐标是（x, y）。在某些路口存在一定数量的公共场所。由于政府财政问题，只能安装一个大型无线网络发射器。该无线网络发射器的传播范围是一个以该点为中心，边长为 2*d 的正方形。传播范围包括正方形边界。例如下图是一个d = 1 的无线网络发射器的覆盖范围示意图。现在政府有关部门准备安装一个传播参数为 d 的无线网络发射器，希望你帮助他们在城市内找出合适的安装地点，使得覆盖的公共场所最多。【Input】第一行包含一个整数 d，表示无线网络发射器的传播距离。第二行包含一个整数 n，表示有公共场所的路口数目。接下来 n 行，每行给出三个整数 x, y, k, 中间用一个空格隔开，分别代表路口的坐标(x, y)以及该路口公共场所的数量。同一坐标只会给出一次。【Output】输出一行，包含两个整数，用一个空格隔开，分别表示能覆盖最多公共场所的安装地点方案数，以及能覆盖的最多公共场所的数量。【Limited conditions】1 ≤ d ≤ 20，1 ≤ n ≤ 20， 0 ≤ x ≤ 128, 0 ≤ y ≤ 128, 0 &lt; k ≤ 1,000,000【Sample input】124 4 106 6 20【Sample output】1 30【Sample explanation】无 Record10min Analysis请先思考后再展开 sb题 Code请先思考后再展开 12345678910111213141516171819202122232425int mp[150][150];int main()&#123; int d,n;scanf("%d%d",&amp;d,&amp;n); for(int i=1;i&lt;=n;i++) &#123; int x,y,k; scanf("%d%d%d",&amp;x,&amp;y,&amp;k); mp[x][y]=k; &#125; int ans=0,cnt=0; for(int x=0;x&lt;=128;x++) &#123; for(int y=0;y&lt;=128;y++) &#123; int tmp=0; for(int i=x-d;i&lt;=x+d;i++) for(int j=y-d;j&lt;=y+d;j++) if(i&gt;=0 and i&lt;=128 and j&gt;=0 and j&lt;=128) tmp+=mp[i][j]; if(tmp==ans) cnt++; if(tmp&gt;ans) ans=tmp,cnt=1; &#125; &#125; printf("%d %d",cnt,ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP14 D1T2】联合权值]]></title>
    <url>%2Fposts%2Fb8ea.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2014 提高组 D1T2Luogu1351Caioj1564 Problem【Description】给出一棵树，点从 1 到 n 依次编号，编号为 i 的点的权值为Wi ，每条边的长度均为1 。对于点对(u, v) ，若它们的距离为2 ，则它们之间会产生Wu×Wv 的联合权值。请问所有可产生联合权值的有序点对中，联合权值最大的是多少？所有联合权值之和是多少？【Input】第一行包含1 个整数n 。接下来n - 1 行，每行包含 2 个用空格隔开的正整数u 、v ，表示编号为 u 和编号为v 的点之间有边相连。最后1 行，包含 n 个正整数，每两个正整数之间用一个空格隔开，其中第 i 个整数表示图G 上编号为i 的点的权值为W i 。【Output】输出共1 行，包含2 个整数，之间用一个空格隔开，依次为图G 上联合权值的最大值和所有联合权值之和。由于所有联合权值之和可能很大，输出它时要对10007 取余。【Limited conditions】对于30% 的数据，1 &lt; n≤ 100 ；对于60% 的数据，1 &lt; n≤ 2000；对于100%的数据，1 &lt; n≤ 200 , 000 ，0 &lt; wi≤ 10, 000 。【Sample input】51 22 33 44 51 5 2 3 10【Sample output】20 74【Sample explanation】本例输入的图如上所示，距离为2 的有序点对有( 1,3) 、( 2,4) 、( 3,1) 、( 3,5) 、( 4,2) 、( 5,3) 。其联合权值分别为2 、15、2 、20、15、20。其中最大的是20，总和为74。 Record20min Analysis请先思考后再展开 先把有序变无序，sum乘2即可那么只有两种情况： 与祖父搞 和同父亲的哥哥搞 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=210000;const int MOD=10007;//*******************全局定义*******************struct Nod&#123; int hou; int w;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXN*2];int ln=0;void ins(int x,int y)&#123; e[++ln]=(Edge)&#123;y,p[x].hou&#125;;p[x].hou=ln;&#125;int mx=0,sum=0;//*******************实现*******************void dfs(int x,int f,int ff)&#123; mx=mymax(mx,p[x].w*p[ff].w); sum=(sum+p[x].w*p[ff].w%MOD)%MOD; int wmx=0,wsum=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==f) continue; mx=mymax(mx,wmx*p[y].w); sum=(sum+wsum*p[y].w%MOD)%MOD; dfs(y,x,f); wmx=mymax(wmx,p[y].w); wsum=(wsum+p[y].w)%MOD; &#125;&#125;//*******************主函数*******************int main()&#123; //freopen("tmp.in","r",stdin); int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i].w),p[i].w%=MOD; dfs(1,0,0); printf("%d %d",mx,sum*2%MOD);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP14 D1T1】生活大爆炸版石头剪刀布]]></title>
    <url>%2Fposts%2Fe3ff.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2014 提高组 D1T1Luogu1328Caioj1563 Problem【Description】石头剪刀布是常见的猜拳游戏：石头胜剪刀，剪刀胜布，布胜石头。如果两个人出拳一样，则不分胜负。在《生活大爆炸》第二季第8 集中出现了一种石头剪刀布的升级版游戏。升级版游戏在传统的石头剪刀布游戏的基础上，增加了两个新手势：斯波克：《星际迷航》主角之一。蜥蜴人：《星际迷航》中的反面角色。这五种手势的胜负关系如表一所示，表中列出的是甲对乙的游戏结果。现在，小A 和小B 尝试玩这种升级版的猜拳游戏。已知他们的出拳都是有周期性规律的，但周期长度不一定相等。已知小A 和小B 一共进行N 次猜拳。每一次赢的人得1 分，输的得0 分；平局两人都得0 分。现请你统计N 次猜拳结束之后两人的得分。【Input】第一行包含三个整数：N ，NA，NB，分别表示共进行 N 次猜拳、小 A 出拳的周期长度，小B 出拳的周期长度。数与数之间以一个空格分隔。第二行包含NA个整数，表示小 A 出拳的规律，第三行包含NB个整数，表示小 B 出拳的规律。其中，0 表示“剪刀”，1 表示“石头”，2 表示“布”，3 表示“蜥蜴人”， 4 表示“斯波克”。数与数之间以一个空格分隔。【Output】输出一行， 包含两个整数，以一个空格分隔，分别表示小A 、小B 的得分。【Limited conditions】0 &lt; N ≤ 200 ，0 &lt; NA ≤ 200 ， 0 &lt; NB ≤ 200 。【Sample input】9 5 50 1 2 3 41 0 3 2 4【Sample output】4 4【Sample explanation】无 Record10min Analysis请先思考后再展开 sb题 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=210;const int k[5][5]=&#123; &#123; 0,-1, 1, 1,-1&#125;, &#123; 1, 0,-1 ,1,-1&#125;, &#123;-1, 1, 0,-1, 1&#125;, &#123;-1,-1, 1, 0, 1&#125;, &#123; 1, 1,-1,-1, 0&#125;&#125;;//*******************全局定义*******************int a[MAXN],b[MAXN];//*******************实现*******************//*******************主函数*******************int main()&#123; //freopen("tmp.in","r",stdin); int n,na,nb;scanf("%d%d%d",&amp;n,&amp;na,&amp;nb); for(int i=1;i&lt;=na;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=nb;i++) scanf("%d",&amp;b[i]); int ax=1,bx=1; int ans1=0,ans2=0; while(n--) &#123; int t1=a[ax],t2=b[bx]; if(k[t1][t2]&gt;0) ans1++; if(k[t1][t2]&lt;0) ans2++; ax++;if(ax&gt;na) ax=1; bx++;if(bx&gt;nb) bx=1; &#125; printf("%d %d",ans1,ans2);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP13 D2T3】华容道]]></title>
    <url>%2Fposts%2F23c4.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2013 提高组 D2T3Luogu1979Caioj1562 Problem【Description】给定一种局面，华容道是否根本就无法完成，如果能完成，最少需要多少时间。游戏规则：1. 在一个 n*m 棋盘上有 n*m 个格子，其中有且只有一个格子是空白的，其余 n*m-1个格子上每个格子上有一个棋子，每个棋子的大小都是 1*1 的；2. 有些棋子是固定的，有些棋子则是可以移动的；3. 任何与空白的格子相邻（有公共的边）的格子上的棋子都可以移动到空白格子上。 游戏的目的是把某个指定位置可以活动的棋子移动到目标位置。给定一个棋盘，游戏可以玩 q 次，当然，每次棋盘上固定的格子是不会变的，但是棋盘上空白的格子的初始位置、指定的可移动的棋子的初始位置和目标位置却可能不同。第 i 次玩的时候，空白的格子在第 EX 行第 EY 列，指定的可移动棋子的初始位置为第 SX 行第 SY 列，目标位置为第 TX 行第 TY 列。假设小 B 每秒钟能进行一次移动棋子的操作，而其他操作的时间都可以忽略不计。请你告诉小 B 每一次游戏所需要的最少时间，或者告诉他不可能完成游戏。【Input】第一行有 3 个整数，每两个整数之间用一个空格隔开，依次表示 n、m 和 q；接下来的 n 行描述一个 n*m 的棋盘，每行有 m 个整数，每两个整数之间用一个空格隔开，每个整数描述棋盘上一个格子的状态，0 表示该格子上的棋子是固定的，1 表示该格子上的棋子可以移动或者该格子是空白的。接下来的 q 行，每行包含 6 个整数依次是Ex、Ey、SX、SY、TX、TY，每两个整数之间用一个空格隔开，表示每次游戏空白格子的位置，指定棋子的初始位置和目标位置。【Output】输出有 q 行，每行包含 1 个整数，表示每次游戏所需要的最少时间.如果某次游戏无法完成目标则输出−1。【Limited conditions】对于 30%的数据，1 ≤ n, m ≤ 10，q = 1；对于 60%的数据，1 ≤ n, m ≤ 30，q ≤ 10；对于 100%的数据，1 ≤ n, m ≤ 30，q ≤ 500。【Sample input】3 4 20 1 1 10 1 1 00 1 0 03 2 1 2 2 21 2 2 2 3 2【Sample output】3【Sample explanation】棋盘上划叉的格子是固定的，红色格子是目标位置，圆圈表示棋子，其中绿色圆圈表示目标棋子。第一次游戏，空白格子的初始位置是 (3, 2)（图中空白所示），游戏的目标是将初始位置在(1, 2)上的棋子（图中绿色圆圈所代表的棋子）移动到目标位置(2, 2)（图中红色的格子）上。移动过程如下：第二次游戏，空白格子的初始位置是（1, 2）（图中空白所示），游戏的目标是将初始位置在（2, 2）上的棋子（图中绿色圆圈所示）移动到目标位置 (3, 2)上。要将指定块移入目标位置，必须先将空白块移入目标位置，空白块要移动到目标位置，必然是从位置（2， 2）上与当前图中目标位置上的棋子交换位置，之后能与空白块交换位置的只有当前图中目标位置上的那个棋子，因此目标棋子永远无法走到它的目标位置， 游戏无法完成。 Record5h Analysis请先思考后再展开 这是一道有脑子的搜索题 本质上就是空白的棋子到处和别人交换来达成目标，固定即不可交换那么只要记录当前空白的位置和目标棋子的位置，就可以bfs了，据说有70分时间复杂度：O(q(nm)^2)，虽然稳tle，但考场上还是灰常值得的，也可以拿来拍 那我们梳理一下，可以这样想象：目标棋子和前面的空白交换，然后空白到后面之后，又屁颠屁颠地跑到目标棋子前面……周边的普通棋子就像群众，一旦墙壁明确，存在性等同于空气。怎么样，题意是不是明确了很多显然仅当【空白在棋子旁边】的状态是有用的，仅有3600种！但是我们虽然减少了状态，但并不代表忽略bfs还是要有的，但不能每一次都搞呀，不然还是炸（特别是无解的时候）因为如果指定棋子要移动，首先空格要到它旁边，而这段信息基本是公共的，尽管空格位置每次不同。也就是说，需要计算出dis(ax,ay,bx,by,d)，分别表示空格和指定棋子位置以及最后空格在棋子的方位（0表示下方，1表示上方，2表示左方，3表示右方）注意！没有必要枚举两点，用到的时候再处理而且，不能忽略终点来bfs（我一开始是这样想的），因为bfs的要求是不能穿越终点（否则空格就会影响到当前棋子的值，而这个我们应单独处理） 那么搜索中有个强大的东西：A*！教程的话，因为也在很多领域有应用，所以网上有灰常多的资料。然后据说这东西的神奇之处在于，对于搜索题，帮你搞定很多想不到的剪枝。但我对这东西不是太熟练，特别是其使用条件（适用范围） 首先，预处理出相邻可移动棋子的距离（用于求解中） 估价函数h(n)：指定棋子到终点位置的曼哈顿距离 实际代价函数g(n)：当前步数 open表：搞一个小根堆即可（ f*(n)=h*(n)+g*(n) ） hash表：hash(state.x,state.y,state.d)=min{ g(state) } 那么，对于每一次求解，先预处理这一次bfs距离值然后每一次取出小根堆中第一个来拓展然后两种情况： 空格与棋子交换，注意方向调换 空格走到棋子其他侧 最后说一句，这道题既考验脑力，也考验码力，挺不错的 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=31;const int tx[4]=&#123;1,-1,0,0&#125;;const int ty[4]=&#123;0,0,1,-1&#125;;//*******************全局定义*******************int n,m;int mp[MAXN][MAXN];int dis[MAXN][MAXN][MAXN][MAXN][4];//不能碰到终点//*******************预处理*******************struct Pt&#123; int x,y; Pt(int tx=0,int ty=0) &#123;x=tx;y=ty;&#125;&#125;;queue&lt;Pt&gt; q1;int tmp[MAXN][MAXN];void bfs(Pt st,Pt ed)&#123; memset(tmp,-1,sizeof(tmp)); for(int i=0;i&lt;4;i++) dis[st.x][st.y][ed.x][ed.y][i]=-1; q1.push(st);tmp[st.x][st.y]=0; while(!q1.empty()) &#123; Pt now=q1.front();q1.pop(); for(int i=0;i&lt;4;i++) &#123; if(ed.x+tx[i]==now.x and ed.y+ty[i]==now.y) dis[st.x][st.y][ed.x][ed.y][i]=tmp[now.x][now.y]; int nx=now.x+tx[i],ny=now.y+ty[i]; if(nx&lt;1 or nx&gt;n or ny&lt;1 or ny&gt;m or !mp[nx][ny]) continue; if(tmp[nx][ny]!=-1 or (nx==ed.x and ny==ed.y)) continue;//debug tmp[nx][ny]=tmp[now.x][now.y]+1; q1.push( Pt(nx,ny) ); &#125; &#125;&#125;//*******************实现*******************struct Data&#123; Pt now;//目标棋子 int d;//空白所在方向 int g,h;//实际步数、预估剩余步数&#125;;bool operator &lt; (Data a,Data b) &#123;return a.g+a.h&gt;b.g+b.h;&#125;priority_queue&lt;Data&gt; q2;//小根堆int hs[MAXN][MAXN][4];//Hash表，存储g()void ins(Data x)&#123; if(hs[x.now.x][x.now.y][x.d]&gt;x.g) &#123; hs[x.now.x][x.now.y][x.d]=x.g; q2.push(x); &#125;&#125;Pt e,st,ed;int H(Pt now) &#123;return myabs(now.x-ed.x)+myabs(now.y-ed.y);&#125;int solve()&#123; scanf("%d%d%d%d%d%d",&amp;e.x,&amp;e.y,&amp;st.x,&amp;st.y,&amp;ed.x,&amp;ed.y); if(st.x==ed.x and st.y==ed.y) return 0;//debug memset(hs,127,sizeof(hs)); while(!q2.empty()) q2.pop();//debug bfs(e,st); for(int i=0;i&lt;4;i++) if(dis[e.x][e.y][st.x][st.y][i]!=-1) ins( (Data)&#123;st,i,dis[e.x][e.y][st.x][st.y][i],H(st)&#125; ); while(!q2.empty()) &#123; Data x=q2.top();q2.pop(); if(x.now.x==ed.x and x.now.y==ed.y) return x.g; Pt kg=Pt(x.now.x+tx[x.d],x.now.y+ty[x.d]);//空格位置 //1. 空格与棋子交换，注意方向调换 ins( (Data)&#123;kg,x.d^1,x.g+1,H(kg)&#125; ); //2. 空格走到棋子其他侧 for(int i=0;i&lt;4;i++) if(dis[kg.x][kg.y][x.now.x][x.now.y][i]!=-1) ins( (Data)&#123;x.now,i,x.g+dis[kg.x][kg.y][x.now.x][x.now.y][i],x.h&#125; ); &#125; return -1;&#125;//*******************主函数*******************int main()&#123; //freopen("tmp.in","r",stdin); int q;scanf("%d%d%d",&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;mp[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(mp[i][j]) for(int t=0;t&lt;4;t++) if(mp[i+tx[t]][j+ty[t]]) bfs( Pt(i,j),Pt(i+tx[t],j+ty[t]) ); while(q--) printf("%d\n",solve());&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>bfs</tag>
        <tag>spfa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1379】八数码]]></title>
    <url>%2Fposts%2F6628.html</url>
    <content type="text"><![CDATA[Source and Judge经典问题Luogu1379Caioj1046 Problem【Description】在3×3的棋盘上，摆有八个棋子，每个棋子上标有1至8的某一数字。棋盘中留有一个空格，空格用0来表示。空格周围的棋子可以移到空格中。要求解的问题是：给出一种初始布局（初始状态）和目标布局（为了使题目简单,设目标状态为123804765），找到一种最少步骤的移动方法，实现从初始布局到目标布局的转变。【Input】输入初始状态，一行九个数字，空格用0表示。【Output】只有一行，该行只有一个数字，表示从初始状态到目标状态需要的最少移动次数(测试数据中无特殊无法到达目标状态数据)【Limited conditions】无【Sample input】283104765【Sample output】4【Sample explanation】无 Record30min Analysis请先思考后再展开 这道题可谓搜索算法的超级经典入门题然后方法也灰常多，康托展开（如今看来没有什么卵用，而且想想就知道了）、bool数组乱搞那么今天因为要用到A*算法，打算用这道题试一试然后网上看到一个大概是acmer的，炒鸡变态地用八种做法做了：强烈推介 那关于A*的做法教程，这篇文章还是挺好的：this Code请先思考后再展开 然鹅我并不想打搜索题了……]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP13 D2T2】花匠]]></title>
    <url>%2Fposts%2F56ba.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2013 提高组 D2T2Luogu1970Caioj1561 Problem【Description】花匠栋栋种了一排花，每株花都有自己的高度。花儿越长越大，也越来越挤。栋栋决定把这排中的一部分花移走，将剩下的留在原地，使得剩下的花能有空间长大，同时，栋栋希望剩下的花排列得比较别致。具体而言，栋栋的花的高度可以看成一列整数h1, h2, … , hn。设当一部分花被移走后，剩下的花的高度依次为g1, g2, … , gm，则栋栋希望下面两个条件中至少有一个满足（i为正整数）：注意上面两个条件在m = 1时同时满足，当m &gt; 1时最多有一个能满足。请问，栋栋最多能将多少株花留在原地。【Input】输入的第一行包含一个整数n，表示开始时花的株数。第二行包含n个整数，依次为h1,h2..hn,表示每株花的高度。【Output】输出一行，包含一个整数m，表示最多能留在原地的花的株数。【Limited conditions】对于 20%的数据，n ≤ 10；对于 30%的数据，n ≤ 25；对于 70%的数据，n ≤ 1000，0 ≤ ℎi≤ 1000；对于 100%的数据，1 ≤ n ≤ 100,000，0 ≤ hi≤ 1,000,000，所有的 hi 随机生成，所有随机数服从某区间内的均匀分布。【Sample input】55 3 2 1 2【Sample output】3【Sample explanation】有多种方法可以正好保留 3 株花，例如，留下第 1、4、5 株，高度分别为 5、1、2，满足条件 B。 Record30min Analysis请先思考后再展开 贪心即可 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=210000;//*******************全局定义*******************//*******************实现*******************//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); int ans=1;int bk=-1;//-1未定0下降1上升 int ed;scanf("%d",&amp;ed); for(int i=2;i&lt;=n;i++) &#123; int now;scanf("%d",&amp;now); if(bk&lt;0) &#123; if(ed!=now) bk=!(now&gt;ed),ed=now,ans++; &#125; else if(bk) &#123; if(ed&lt;now) bk=!bk,ed=now,ans++; else ed=now; &#125; else &#123; if(ed&gt;now) bk=!bk,ed=now,ans++; else ed=now; &#125; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP13 D2T1】积木大赛]]></title>
    <url>%2Fposts%2Fd499.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2013 提高组 D2T1Luogu1969Caioj1560 Problem【Description】一座宽度为n的大厦可以看成由n块宽度为1的积木组成，第i块积木的最终高度需要是hi。在搭建开始之前，没有任何积木（可以看成n块高度为 0 的积木）。接下来每次操作，小朋友们可以选择一段连续区间[l, r]，然后将第第 L 块到第 R 块之间（含第 L 块和第 R 块）所有积木的高度分别增加1。小 M 是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。【Input】输入包含两行，第一行包含一个整数n，表示大厦的宽度。第二行包含n个整数，第i个整数为hi 。【Output】仅一行，即建造所需的最少操作数。【Limited conditions】对于 30%的数据，有1 ≤ n ≤ 10；对于 70%的数据，有1 ≤ n ≤ 1000；对于 100%的数据，有1 ≤ n ≤ 100000，0 ≤ hi≤ 10000。【Sample input】52 3 4 1 2【Sample output】5【Sample explanation】其中一种可行的最佳方案，依次选择1[1,5][1,3][2,3][3,3][5,5] Record30min Analysis请先思考后再展开 这道题很容易被数据结构和数据范围误导啊然后我又是没有什么好思路不要脸地去膜“普及-”的题解……然后坚定了我noip前必刷usaco的想法 原来方案看起来是灰常复杂的，但是只要求次数，那么问题的难度会暴跌为什么呢？因为答案的单一性意味着可以边搞边调整方案，甚至不理会具体方案 对于这道题，把积木看作山峰，不难发现费用都和上坡有关，因为下坡必然能由上坡搞定所以只要记录上一个，每次比较判断是否为山峰，然后更新答案即可。 Code请先思考后再展开 123456789101112int main()&#123; int n;scanf("%d",&amp;n); int ans,lst;scanf("%d",&amp;lst);ans=lst; for(int i=2;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); if(t&gt;lst) ans+=(t-lst); lst=t; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>精品题</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP13 D1T3】货车运输]]></title>
    <url>%2Fposts%2F622b.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2013 提高组 D1T3Luogu1967 Problem【Description】A 国有 n 座城市，编号从 1 到 n，城市之间有 m 条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有 q 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。【Input】第一行有两个用一个空格隔开的整数 n，m，表示 A 国有 n 座城市和 m 条道路。接下来 m 行每行 3 个整数 x、 y、 z，每两个整数之间用一个空格隔开，表示从 x 号城市到 y 号城市有一条限重为 z 的道路。注意： x 不等于 y，两座城市之间可能有多条道路 。接下来一行有一个整数 q，表示有 q 辆货车需要运货。接下来 q 行，每行两个整数 x、y，之间用一个空格隔开，表示一辆货车需要从 x 城市运输货物到 y 城市，注意： x 不等于 y 。【Output】输出共有 q 行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出-1。【Limited conditions】对于 30%的数据，0 &lt; n &lt; 1,000，0 &lt; m &lt; 10,000，0 &lt; q&lt; 1,000；对于 60%的数据，0 &lt; n &lt; 1,000，0 &lt; m &lt; 50,000，0 &lt; q&lt; 1,000；对于 100%的数据，0 &lt; n &lt; 10,000，0 &lt; m &lt; 50,000，0 &lt; q&lt; 30,000，0 ≤ z ≤ 100,000。【Sample input】4 31 2 42 3 33 1 131 31 41 3【Sample output】3-13【Sample explanation】无 Record30min Analysis请先思考后再展开 首先，对于两个点间的多条路径，肯定是选择最短的一条。那么反正是双向道路，直接搞一波最大生成树，显然不会让结果更差。然后？既然是树了，那两点间路径就一条，相当于查询最小值罢了。然后因为是稀疏图，就用kruskal，实在是森林就-1至于查询，因为没有修改，不用出动树链剖分，直接倍增即可。 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=11000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int hou; int dep; Nod() &#123; hou=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,c,g;&#125;e[MAXN*2];int ln=0;void ins(int x,int y,int c)&#123; e[++ln]=(Edge)&#123;y,c,p[x].hou&#125;;p[x].hou=ln; e[++ln]=(Edge)&#123;x,c,p[y].hou&#125;;p[y].hou=ln;&#125;int n,m;int f[MAXN][20],ds[MAXN][20];//*******************实现*******************void pre(int x,int fa)&#123; p[x].dep=p[fa].dep+1; f[x][0]=fa; for(int i=1;i&lt;=15;i++) &#123; f[x][i]=f[ f[x][i-1] ][i-1]; ds[x][i]=mymin(ds[x][i-1],ds[ f[x][i-1] ][i-1]); if(f[x][i]==0) break; &#125; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; ds[y][0]=e[k].c; pre(y,x); &#125;&#125;int bin[20];int query(int x,int y)&#123; int mi=INF; if(p[x].dep&lt;p[y].dep) swap(x,y); for(int i=15;i&gt;=0;i--) if(p[x].dep-p[y].dep&gt;=bin[i]) mi=mymin(mi,ds[x][i]),x=f[x][i]; if(x==y) return mi; for(int i=15;i&gt;=0;i--) if(f[x][i]!=f[y][i]) mi=mymin(mi,mymin(ds[x][i],ds[y][i])),x=f[x][i],y=f[y][i]; return mymin(mi,mymin(ds[x][0],ds[y][0]));//debug&#125;int fa[MAXN];int findfa(int x) &#123;return (x==fa[x])?x:fa[x]=findfa(fa[x]);&#125;struct Road&#123; int x,y,c;&#125;rd[51000];bool cmp(Road a,Road b) &#123;return a.c&gt;b.c;&#125;void kruskal()&#123; sort(rd+1,rd+m+1,cmp); for(int i=1;i&lt;=n;i++) fa[i]=i; int cnt=0; for(int i=1;i&lt;=m and cnt&lt;n-1;i++) &#123; int fx=findfa(rd[i].x),fy=findfa(rd[i].y); if(fx!=fy) &#123; cnt++; fa[fx]=fy; ins(rd[i].x,rd[i].y,rd[i].c); &#125; &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf("%d%d%d",&amp;rd[i].x,&amp;rd[i].y,&amp;rd[i].c); kruskal(); for(int i=1;i&lt;=n;i++) if(p[i].dep==0) pre(i,0);//debug 忘记是森林，被hack啦 bin[0]=1;for(int i=1;i&lt;=15;i++) bin[i]=bin[i-1]&lt;&lt;1; int q;scanf("%d",&amp;q); while(q--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); if(findfa(x)!=findfa(y)) printf("-1\n"); else printf("%d\n",query(x,y)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP11 D1T2】选择客栈]]></title>
    <url>%2Fposts%2Fec55.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2011 提高组 D1T2Luogu1311 Problem【Description】丽江河边有n家很有特色的客栈，客栈按照其位置顺序从1到n编号。每家客栈都按照某一种色调进行装饰（总共k种，用整数0~ k-1表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过p。他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过p元的咖啡店小聚。【Input】第一行三个整数n，k，p，每两个整数之间用一个空格隔开，分别表示客栈的个数，色调的数目和能接受的最低消费的最高值；接下来的n行，第i+1行两个整数，之间用一个空格隔开，分别表示i号客栈的装饰色调和i号客栈的咖啡店的最低消费。【Output】输出只有一行，一个整数，表示可选的住宿方案的总数。【Limited conditions】对于30% 的数据，有 n ≤100；对于50% 的数据，有 n ≤1,000；对于100%的数据，有 2 ≤n ≤200,000，0&lt;k ≤50，0≤p ≤100 ， 0 ≤最低消费≤100。【Sample input】5 2 30 51 30 21 41 5【Sample output】3【Sample explanation】2 人要住同样色调的客栈，所有可选的住宿方案包括：住客栈①③，②④，②⑤，④⑤，但是若选择住4 、5 号客栈的话，4 、5 号客栈之间的咖啡店的最低消费是4 ，而两人能承受的最低消费是3 元，所以不满足要求。因此只有前 3 种方案可选。 Record30min Analysis请先思考后再展开 对于区间问题，可以考虑枚举其中一个端点然后以当前颜色最后一个可行点代表前面的可行点去累计答案 Code请先思考后再展开 123456789101112131415161718192021int lst[60];//颜色最后位置int sum[60];//okay前数量int cnt[60];//总数量int main()&#123; int n,k,p;scanf("%d%d%d",&amp;n,&amp;k,&amp;p); int ans=0; int okay=0; for(int r=1;r&lt;=n;r++) &#123; int col,cst;scanf("%d%d",&amp;col,&amp;cst); if(cst&lt;=p) okay=r;//自己也行 if(lst[col]&lt;=okay) sum[col]=cnt[col];//okay最近出现 ans+=sum[col]; lst[col]=r; cnt[col]++; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP13 D1T2】火柴排队]]></title>
    <url>%2Fposts%2F421b.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2013 提高组 D1T2Luogu1966Caioj1558 Problem【Description】两个长为 n 的序列 a,b ，定义两个序列的距离为：sigma (ai-bi)^2每个序列中相邻两个位置的数可以交换，问最少需要交换多少次，可以最小化这个柿子？最小交换次数对 99,999,997 取模。【Input】共三行，第一行包含一个整数 n。第二行有 n 个整数，每两个整数之间用一个空格隔开，表示第一列数。第三行有 n 个整数，每两个整数之间用一个空格隔开，表示第二列数。【Output】输出共一行，包含一个整数，表示最少交换次数对 99,999,997 取模的结果。【Limited conditions】对于 10%的数据， 1 ≤ n ≤ 10；对于 30%的数据，1 ≤ n ≤ 100；对于 60%的数据，1 ≤ n ≤ 1,000；对于 100%的数据，1 ≤ n ≤ 100,000，0 ≤火柴高度≤ maxint【Sample input】41 3 4 21 7 2 4【Sample output】2【Sample explanation】最小距离是 10，最少需要交换 2 次，比如：交换第 1 列的中间 2 根火柴的位置，再交换第 2 列中后 2 根火柴的位置。 Record30min Analysis请先思考后再展开 显然为了让两列差值最小，让【两边同一排名的在一行】显然是最优的（可以自己推推柿子，其他调整不会更优）那么既然只关心排名，先离散化一波 然后就是这道题的精华啦：构造一个数组q，表示一种对应关系，即q[i]表示a中位置为i的，与其排名相同的在b的第j个那么显然目标就是q[i]=i，也就是排序后的状态既然现在求交换次数，那么也就是q的逆序对数量了 为什么呢？明确题目条件是只能交换相邻的那么猜一波结论：只需要移动一个序列，另一个不动。那么对于q中一个数q[i]=x（此时已经离散化），把它移动到正确位置x的代价就是【以x为较小值的逆序对数】。 如果还是像我一样没有完全懂的话，可以考虑联想一下冒泡排序其交换次数就是逆序对个数，而每一个逆序对其实意义就是变成有序（也就是目标）迟早要交换的次数。 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=110000;const int MOD=99999997;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int x,p;&#125;a[MAXN],b[MAXN];bool cmp (Nod a,Nod b) &#123;return a.x&lt;b.x;&#125;int n;int q[MAXN];//*******************实现*******************int tmp[MAXN];int ans=0;void gbsort(int l,int r)&#123; if(l&gt;=r) return;//debug int mid=(l+r)&gt;&gt;1; gbsort(l,mid);gbsort(mid+1,r); int x=l,y=mid+1,p=l; while(x&lt;=mid and y&lt;=r) &#123; if(q[x]&lt;q[y]) tmp[p++]=q[x++]; else ans=(ans+mid-x+1)%MOD,tmp[p++]=q[y++]; &#125; while(x&lt;=mid) tmp[p++]=q[x++]; while(y&lt;=r) tmp[p++]=q[y++]; for(int i=l;i&lt;=r;i++) q[i]=tmp[i];&#125;//*******************主函数*******************int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i].x),a[i].p=i; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;b[i].x),b[i].p=i; sort(a+1,a+n+1,cmp);sort(b+1,b+n+1,cmp); for(int i=1;i&lt;=n;i++) q[a[i].p]=b[i].p; gbsort(1,n); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>难度2</tag>
        <tag>模拟</tag>
        <tag>归并排序</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP13 D1T1】转圈游戏]]></title>
    <url>%2Fposts%2Fd86a.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2013 提高组 D1T1Luogu1965Caioj1557 Problem【Description】n 个小伙伴（编号从 0 到 n-1）围坐一圈玩游戏。按照顺时针方向从0 到 n-1，给 n 个位置编号。最初，第 0 号小伙伴在第 0 号位置，第 1 号小伙伴在第 1 号位置，……，依此类推。游戏规则如下：每一轮第 0 号位置上的小伙伴顺时针走到第 m 号位置，第 1 号位置小伙伴走到第 m+1 号位置，……，依此类推，第n−m号位置上的小伙伴走到第 0 号位置，第n-m+1 号位置上的小伙伴走到第 1 号位置，……，第 n-1 号位置上的小伙伴顺时针走到第m-1 号位置。现在，一共进行了 10^k轮，请问 x 号小伙伴最后走到了第几号位置。【Input】输入共 1 行，包含 4 个整数 n、m、k、x，每两个整数之间用一个空格隔开。【Output】输出共 1 行，包含 1 个整数，表示 10^k 轮后 x 号小伙伴所在的位置编号。【Limited conditions】对于 30%的数据，0 &lt; k &lt; 7；对于 80%的数据，0 &lt; k &lt; 10^7；对于 100%的数据，1 &lt;n &lt; 1,000,000，0 &lt; m &lt; n，1 ≤ x ≤ n，0 &lt; k &lt; 10^9【Sample input】10 3 4 5【Sample output】5【Sample explanation】无 Record10min Analysis请先思考后再展开 sb题ans=x+10^k*m (mod n) Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=51000;const int INF=0x3f3f3f3f;//*******************全局定义*******************int n,m,k,x;//*******************实现*******************ll power(int x,int e)&#123; int ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=(ans*x)%n; x=(x*x)%n;e&gt;&gt;=1; &#125; return ans;&#125;//*******************主函数*******************int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;x); m=power(10,k)*m%n; printf("%d",(x+m)%n);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hdu4902】Nice boat]]></title>
    <url>%2Fposts%2Fddc6.html</url>
    <content type="text"><![CDATA[Source and Judge2014 Multi-University Training Contest 4作者：陈立杰%%%Hdu4902 Problem【Description】多组数据给你n个数，Q次操作操作分两类对于第一类操作(type1)，将区间[l,r]内的数改成x对于第二类操作(type2)，将区间[l,r]内&gt;x的a[i]$改成gcd(x,a[i])你需要输出Q次操作后的序列【Input】第一行正整数T，表示数据组数第一行两个数n,Q接着一行n个数a[i]接下来Q行，每行四个数type,l,r,x，分别代表操作类型，操作区间[l,r]和x【Output】每行n个数，代表Q次操作后的序列，用空格隔开【Limited conditions】n,Q&lt;=100000,0&lt;=x,a[i]&lt;=2^31-1【Sample input】11016807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709101 3 6 742430422 4 8 165317291 3 4 14748331692 1 8 11315709332 7 9 15057953352 3 7 1019292671 4 10 16243791492 2 8 21100106722 6 7 1560917451 2 5 937186357【Sample output】16807 937186357 937186357 937186357 937186357 1 1 1624379149 1624379149 1624379149【Sample explanation】无 Record1h Analysis请先思考后再展开 第一眼就觉得是线段树然后gcd有点烦证明了单纯地gcd是可以叠加的但这道题对于操作对象有讲究所以就不叠加了 比赛的时候码了半小时吧，然后对拍了两小时，还是比较稳的对了，那时候看错时限了，以为是1s（其实是1.5s），然后自己造极限数据，跑了0.95s，于是还搞了点卡常 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110000;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int gcd(int x,int y)&#123; return (y==0)?x:gcd(y,x%y);&#125;int a[MAXN];int qread()&#123; char c=getchar(); int t=0; while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') t=t*10+c-'0',c=getchar(); return t;&#125;void qwrite(int x)&#123; if(x&gt;9) qwrite(x/10); putchar('0'+x%10);&#125;struct Seg&#123; int l,r,mid; int lc,rc; int c; int lz1,lz2;&#125;p[MAXN&lt;&lt;1];int ln;int build(int l,int r)&#123; if(l&gt;r) return 0;//debug int t=++ln; p[t]=(Seg)&#123;l,r,(l+r)&gt;&gt;1,0,0,-1,-1,0&#125;; if(l==r) p[t].c=a[l]; else &#123; p[t].lc=build(l,p[t].mid); p[t].rc=build(p[t].mid+1,r); &#125; return t;&#125;void pushdown(int x)&#123; if(x&lt;=0) return; int lc=p[x].lc,rc=p[x].rc; if(p[x].lz1&gt;=0) &#123; p[lc].c=p[lc].lz1=p[x].lz1; p[rc].c=p[rc].lz1=p[x].lz1; p[x].lz1=-1;p[x].lz2=0; &#125; else if(p[x].lz2&gt;0) &#123; pushdown(lc);pushdown(rc); p[lc].lz2=gcd(p[lc].lz2,p[x].lz2); p[rc].lz2=gcd(p[rc].lz2,p[x].lz2); if(p[lc].c&gt;p[x].lz2) p[lc].c=gcd(p[lc].c,p[x].lz2); if(p[rc].c&gt;p[x].lz2) p[rc].c=gcd(p[rc].c,p[x].lz2); p[x].lz2=0; &#125;&#125;void change1(int x,int l,int r,int xx)&#123; if(l&gt;r) return; if(p[x].l==l and p[x].r==r) &#123; p[x].lz1=p[x].c=xx; p[x].lz2=0; return; &#125; pushdown(x); if(r&lt;=p[x].mid) change1(p[x].lc,l,r,xx); else if(l&gt;p[x].mid) change1(p[x].rc,l,r,xx); else change1(p[x].lc,l,p[x].mid,xx),change1(p[x].rc,p[x].mid+1,r,xx);&#125;void change2(int x,int l,int r,int xx)&#123; if(l&gt;r) return; if(p[x].l==l and p[x].r==r) &#123; pushdown(x); p[x].lz2=gcd(p[x].lz2,xx); if(p[x].c&gt;xx) p[x].c=gcd(p[x].c,xx); return; &#125; pushdown(x); if(r&lt;=p[x].mid) change2(p[x].lc,l,r,xx); else if(l&gt;p[x].mid) change2(p[x].rc,l,r,xx); else change2(p[x].lc,l,p[x].mid,xx),change2(p[x].rc,p[x].mid+1,r,xx);&#125;void ask(int x,int ps)&#123; if(p[x].l==p[x].r) &#123;qwrite(p[x].c);putchar(' ');return;&#125; pushdown(x); ask((ps&lt;=p[x].mid)?p[x].lc:p[x].rc,ps);&#125;int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) a[i]=qread(); ln=0;build(1,n); int q;scanf("%d",&amp;q); while(q--) &#123; int op=qread(),l=qread(),r=qread(),x=qread(); if(op==1) change1(1,l,r,x); else change2(1,l,r,x); &#125; for(int i=1;i&lt;=n;i++) ask(1,i); putchar('\n'); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1529】【Luogu3420】ska Piggy banks]]></title>
    <url>%2Fposts%2Ff249.html</url>
    <content type="text"><![CDATA[Source and JudgePOI2005Bzoj1529Luogu3420 Problem【Description】Byteazar the Dragon拥有N个小猪存钱罐。每一个存钱罐能够用相应的钥匙打开或者被砸开。Byteazar已经将钥匙放入到一些存钱罐中。现在已知每个钥匙所在的存钱罐，Byteazar想要买一辆小汽车，而且需要打开所有的存钱罐。然鹅，他想要破坏尽量少的存钱罐，帮助Byteazar去决策最少要破坏多少存钱罐。【Input】第一行一个整数 N 表示存钱罐的总数.接下来每行一个整数,第 i+1行的整数代表第i个存钱罐的钥匙放置的存钱罐编号.【Output】一个整数表示最少打破多少个存钱罐.【Limited conditions】1&lt;=N&lt;=1000000【Sample input】42124【Sample output】2【Sample explanation】无 Record30min Analysis1请先思考后再展开 考试的时候打的是强连通，然后被卡空间了 首先，可以通过存储关系建边构图然后最无敌的做法：强连通缩点，统计入度为0的点然后比赛的时候这样是能AC的当然 Code1请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1000001;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;struct Nod&#123; int hou; int dfn,low; bool v; Nod() &#123; hou=dfn=low=0; v=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXN];int ln=0;void ins(int x,int y)&#123; e[++ln]=(Edge)&#123;y,p[x].hou&#125;;p[x].hou=ln;&#125;int id=0;int sta[MAXN],top=0;int cnt=0;int belg[MAXN];void tarjan(int x)&#123; p[x].dfn=p[x].low=++id; sta[++top]=x;p[x].v=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;//debug 不需要判fa if(p[y].dfn==0) tarjan(y),p[x].low=mymin(p[x].low,p[y].low); else if(p[y].v==1) p[x].low=mymin(p[x].low,p[y].low);//debug 写错了p[y].v==0 &#125; if(p[x].dfn==p[x].low) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].v=0; belg[t]=cnt; if(t==x) break; &#125; &#125;&#125;int ru[MAXN];int a[MAXN];int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); if(i!=a[i]) ins(a[i],i); &#125; for(int i=1;i&lt;=n;i++) if(p[i].dfn==0) tarjan(i); for(int i=1;i&lt;=n;i++) if(belg[i]!=belg[a[i]]) ru[belg[i]]++; int ans=0; for(int i=1;i&lt;=cnt;i++) if(ru[i]==0) ans++; printf("%d",ans);&#125; Analysis2请先思考后再展开 那么上面的做法在bzoj中是会被卡空间的（好像是爆栈）那么有没有更优美的做法呢？来看看题目中的特殊条件你看，边只有n条，那么对于一个强联通块，显然只会有一个入口既然如此，答案就是多少个联通块那在这道题中，强连通块和双向边块是等效的，因为每个点只会有一个入边（不排除是自己）所以用并查集就好啦 Code2请先思考后再展开 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1000001;int fa[MAXN];int findfa(int x)&#123; if(fa[x]!=x) fa[x]=findfa(fa[x]); return fa[x];&#125;void join(int x,int y)&#123; int fx=findfa(x),fy=findfa(y); if(fx!=fy) fa[fx]=fy;&#125;int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); if(i!=t) join(t,i); &#125; int ans=0; for(int i=1;i&lt;=n;i++) ans+=(fa[i]==i); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>难度2</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3784】树上的路径]]></title>
    <url>%2Fposts%2F1486.html</url>
    <content type="text"><![CDATA[Source and JudgeBzoj3784 Problem【Description】给定一个n个结点的树，结点用正整数1..n编号，每条边有一个正整数权值。用d(a,b)表示从结点a到结点b路边上经过边的权值，输出前大M的距离（去同两个点）。【Input】第一行两个正整数N,M下面N-1行，每行三个正整数a,b,c。表示结点a到结点b有一条权值为c的边。【Output】共M行，如题所述。【Limited conditions】a,b&lt;=n，c&lt;=10000N&lt;=50000M&lt;=Min(300000,n*(n-1)/2)【Sample input】5 101 2 11 3 22 4 32 5 4【Sample output】7 7 6 5 4 4 3 3 2 1【Sample explanation】无 Record2h Analysis请先思考后再展开 首先，有个弱化版：超级钢琴那么现在假设你已经理解了上面这道题 然后我们从暴力开始思考，显然枚举每个起点dfs去搞，复杂度是n^2的 然后既然是前m大，当然是用堆维护尝试枚举起点后，搞出一个dfs序，那么以【数量与深度有关的每个父亲】作为中介，搞出一条条链，而且显然【终点】是连续的。那么因为不能重复，考虑对于点y，只找dfs序比y小的点x。为了方便，不先枚举起点，而是先枚举中介父亲，然后才是起点。于是现在每个点被访问的次数是深度，复杂度是深度*n 那么现在大概就能拿到不错的分数了但是很容易被链啊，扫把啊什么的卡主要是这个“深度”所以点分治一波就好啦然后就是nlogn了 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=51000,MAXID=MAXN*40;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int hou; int siz; bool v;&#125;p[MAXN];struct Edge&#123; int y,c,g;&#125;e[MAXN*2];int ln=0;void ins(int x,int y,int c)&#123; e[++ln]=(Edge)&#123;y,c,p[x].hou&#125;;p[x].hou=ln; e[++ln]=(Edge)&#123;x,c,p[y].hou&#125;;p[y].hou=ln;&#125;int n,k;//*******************实现*******************int h[MAXID];//当前dfs序节点与当前中介父亲int id=0;void pre(int x,int fa,int dis)&#123; h[++id]=dis; p[x].siz=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa or p[y].v) continue; pre(y,x,dis+e[k].c); p[x].siz+=p[y].siz; &#125;&#125;int st[MAXID][20];int bin[20],lg[MAXID];int _mx(int x,int y)&#123; return (h[x]&gt;h[y])?x:y;&#125;void preST()&#123; bin[0]=1;for(int i=1;bin[i]&lt;=id;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;=id;i++) lg[i]=lg[i&gt;&gt;1]+1; for(int i=1;i&lt;=id;i++) st[i][0]=i; for(int j=1;bin[j]&lt;=id;j++) for(int i=1;i+bin[j]-1&lt;=id;i++) st[i][j]=_mx(st[i][j-1],st[i+bin[j-1]][j-1]);&#125;int rmq(int l,int r)&#123; int t=lg[r-l+1]; return _mx( st[l][t],st[r-bin[t]+1][t] );&#125;int f[MAXN];int G,sum;void getrt(int x,int fa)&#123; f[x]=0;p[x].siz=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa or p[y].v) continue; getrt(y,x); f[x]=mymax(f[x],p[y].siz); p[x].siz+=p[y].siz; &#125; f[x]=mymax(f[x],sum-p[x].siz); if(f[x]&lt;f[G]) G=x;&#125;struct Data&#123; int now,l,r; int mx;&#125;;vector&lt;Data&gt; tmp;void divi(int x)&#123; p[x].v=1; int begin=id; h[++id]=0;//自己 int ss=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(p[y].v) continue; pre(y,x,e[k].c); for(int i=1;i&lt;=p[y].siz;i++) tmp.push_back( (Data)&#123;begin+ss+i,begin+1,begin+ss,0&#125; ); ss+=p[y].siz; &#125; //注意不能合并循环，因为dfs序要求【同深度同层】，等完成后再分治 for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(p[y].v) continue; sum=p[y].siz;G=0;getrt(y,x);divi(G); &#125;&#125;bool operator &lt; (Data a,Data b)&#123; return h[a.now]+h[a.mx]&lt;h[b.now]+h[b.mx];&#125;priority_queue&lt;Data&gt; q;void solve()&#123; f[0]=INF;G=0;sum=n;getrt(1,0);divi(G); preST(); int tz=tmp.size(); for(int i=0;i&lt;tz;i++) &#123; tmp[i].mx=rmq(tmp[i].l,tmp[i].r);//debug 忘记st表还没做好 q.push(tmp[i]); &#125; while(k--) &#123; Data x=q.top();q.pop(); printf("%d\n",h[x.now]+h[x.mx]); if(x.l&lt;=x.mx-1) q.push( (Data)&#123;x.now,x.l,x.mx-1,rmq(x.l,x.mx-1)&#125; ); if(x.mx+1&lt;=x.r) q.push( (Data)&#123;x.now,x.mx+1,x.r,rmq(x.mx+1,x.r)&#125; ); &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n-1;i++) &#123; int x,y,c; scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c); &#125; solve();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>点分治</tag>
        <tag>st表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOI2010】超级钢琴]]></title>
    <url>%2Fposts%2Fe5b3.html</url>
    <content type="text"><![CDATA[Source and JudgeBzoj2006Luogu2048 Problem【Description】求给定序列中长度为L~R之间的前k大子串（连续）的和【Input】输入第一行包含四个正整数n, k, L, R。其中n为音符的个数，k为乐曲所包含的超级和弦个数，L和R分别是超级和弦所包含音符个数的下限和上限。接下来n行，每行包含一个整数Ai，表示按编号从小到大每个音符的美妙度。【Output】输出只有一个整数，表示乐曲美妙度的最大值。【Limited conditions】-1000≤Ai≤1000，1≤L≤R≤n且保证一定存在满足要求的乐曲。【Sample input】4 3 2 332-68【Sample output】11【Sample explanation】共有5种不同的超级和弦：1. 音符1~2，美妙度为3 + 2 = 52. 音符2~3，美妙度为2 + (-6) = -43. 音符3~4，美妙度为(-6) + 8 = 24. 音符1~3，美妙度为3 + 2 + (-6) = -15. 音符2~4，美妙度为2 + (-6) + 8 = 4最优方案为：乐曲由和弦1，和弦3，和弦5组成，美妙度为5+2+4=11。 Record2h Analysis请先思考后再展开 哇发现所谓st表就是Sparse Table然后最大子串，也就是区间，如果用前缀和表示，那么当确定一个右端点r，就是要找一个区间内最小的前缀和值来确定l，那么可以用一个st表来搞 有个要注意的点就是，因为不能重复，拿出一个点，需要把两个左右边填回去 然后就算比较水了，提高+吧 Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=510000;const int INF=0x3f3f3f3f;//*******************全局定义*******************int n,k,L,R;ll s[MAXN];struct Data&#123; int now,l,r; int mi;&#125;;bool operator &lt; (Data a,Data b)&#123; return (s[a.now]-s[a.mi])&lt;(s[b.now]-s[b.mi]);&#125;priority_queue&lt;Data&gt; q;int mn(int a,int b) &#123;return (s[a]&lt;s[b])?a:b;&#125;//*******************实现*******************int bin[20];int lg[MAXN];int st[MAXN][20];int rmq(int l,int r)&#123; int t=lg[r-l+1]; return mn(st[l][t],st[r-bin[t]+1][t]);&#125;ll solve()&#123; for(int i=L;i&lt;=n;i++) &#123; int l=mymax(i-R,0),r=i-L;//debug if(l&lt;=r) q.push( (Data)&#123;i,l,r,rmq(l,r)&#125; ); &#125; ll ans=0; for(int i=1;i&lt;=k;i++) &#123; Data x=q.top();q.pop(); ans+=s[x.now]-s[x.mi]; if(x.l&lt;=x.mi-1) q.push( (Data)&#123;x.now,x.l,x.mi-1,rmq(x.l,x.mi-1)&#125; ); if(x.mi+1&lt;=x.r) q.push( (Data)&#123;x.now,x.mi+1,x.r,rmq(x.mi+1,x.r)&#125; ); &#125; return ans;&#125;//*******************主函数*******************int main()&#123; bin[0]=1;for(int i=1;i&lt;=19;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;MAXN;i++) lg[i]=lg[i&gt;&gt;1]+1; scanf("%d%d%d%d",&amp;n,&amp;k,&amp;L,&amp;R); for(int i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;s[i]); s[i]+=s[i-1]; st[i][0]=i; &#125; for(int j=1;bin[j]&lt;=n;j++) for(int i=0;i+bin[j]-1&lt;=n;i++)//从0开始 st[i][j]=mn(st[i][j-1],st[i+bin[j-1]][j-1]); printf("%lld",solve());&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>st表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1112】砖块]]></title>
    <url>%2Fposts%2F2ed3.html</url>
    <content type="text"><![CDATA[Source and JudgePOI2008Bzoj1112 Problem【Description】给出n个数，希望有连续k个是一样的。可以由两种操作：1. 一个数-12. 一个数+1求完成任务的最少操作数【Input】第一行给出N,K。下面N行,每行代表这柱砖的高度.【Output】最小的动作次数【Limited conditions】1≤k≤n≤1000000≤hi≤1000000【Sample input】5 339231【Sample output】2【Sample explanation】无 Record2h Analysis请先思考后再展开 等价于，对于一个长度为k的区间，把所有数变成数轴上的点，找到一个位置使所有点到此距离之和最小。之前在糖果中讲过，这个位置必然是中位数，否则存在使答案更小的办法。 然后搞一个数据结构，维护一下第k大来找中位数，统计答案即可。然后类似在数轴上滑动的一个窗，从而利用之前的信息而不必重构（显然考试的时候还是忘记啦）时间复杂度：$O(nlogn)$ 考试的时候打了个很挫的主席树，而且没想到可以搞中位数，只想到是抛物线至于二次函数上三分……不会，好像也蛮慢的 Code1先来一发无脑splay好处是值可以灰常大而不受限制，空间也少一个log请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=110000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int son[2],f; int c,n; ll d,sum;&#125;p[MAXN];//*******************Splay*******************void update(int x)&#123; p[x].c=p[x].n;p[x].sum=p[x].d*p[x].n;//debug!! int lc=p[x].son[0],rc=p[x].son[1]; if(lc&gt;0) p[x].c+=p[lc].c,p[x].sum+=p[lc].sum; if(rc&gt;0) p[x].c+=p[rc].c,p[x].sum+=p[rc].sum;&#125;void rotate(int x,int w)&#123; int f=p[x].f,ff=p[f].f; if(p[ff].son[0]==f) p[ff].son[0]=x; else p[ff].son[1]=x; p[x].f=ff; int pson=p[x].son[w]; p[f].son[1-w]=pson; if(pson&gt;0) p[pson].f=f; p[x].son[w]=f; p[f].f=x; update(f); update(x);&#125;int root;void splay(int x,int rt)&#123; while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(ff==rt) &#123; if(p[f].son[0]==x) rotate(x,1); else rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==0) root=x;&#125;int findip(ll d)&#123; int x=root; while(p[x].d!=d) &#123; if(d&lt;p[x].d) &#123; if(p[x].son[0]&gt;0) x=p[x].son[0]; else break; &#125; else &#123; if(p[x].son[1]&gt;0) x=p[x].son[1]; else break; &#125; &#125; return x;&#125;int cnt=0;void add(ll d,int f)&#123; cnt++; p[cnt].son[0]=p[cnt].son[1]=-1; p[cnt].c=p[cnt].n=1; p[cnt].sum=p[cnt].d=d; p[cnt].f=f; if(d&lt;p[f].d) p[f].son[0]=cnt; else p[f].son[1]=cnt;&#125;void insert(ll d)&#123; if(!root) &#123; add(d,0); root=cnt; return; &#125; int x=findip(d); if(p[x].d==d) &#123; p[x].n++; splay(x,0); &#125; else &#123; add(d,x); splay(cnt,0); &#125;&#125;void del(ll d)&#123; int x=findip(d); splay(x,0); if(p[x].n&gt;1) &#123; p[x].n--; update(x); return; &#125; int lc=p[x].son[0],rc=p[x].son[1]; if(lc==-1 and rc&gt;0) &#123; root=rc; p[root].f=0; &#125; else if(lc&gt;0 and rc==-1) &#123; root=lc; p[root].f=0; &#125; else &#123; int t=rc; while(p[t].son[0]&gt;0) t=p[t].son[0]; splay(t,root);p[t].f=0;root=t; p[t].son[0]=lc;p[lc].f=t; update(root);//debug &#125;&#125;ll findk(int k)&#123; int x=root; while(1) &#123; int lc=p[x].son[0],lcc=(lc&gt;0)?p[lc].c:0; if(k&lt;=lcc) x=lc; else if(k&gt;lcc+p[x].n) k-=lcc+p[x].n,x=p[x].son[1]; else break; &#125; splay(x,0); return p[x].d;&#125;//*******************实现*******************ll solve(int k)&#123; ll mid=findk(k/2+1); int lc=p[root].son[0],rc=p[root].son[1]; ll sm1=mid*p[lc].c,sm2=p[lc].sum; ll bg1=mid*p[rc].c,bg2=p[rc].sum; ll ans=0; if(lc&gt;0) ans+=sm1-sm2; if(rc&gt;0) ans+=bg2-bg1; return ans;//debug 没有其中儿子&#125;//*******************主函数*******************int h[MAXN];int main()&#123; int n,k;scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;h[i]); for(int i=1;i&lt;=k;i++) insert(h[i]); ll ans=solve(k); for(int r=k+1;r&lt;=n;r++) &#123; insert(h[r]); del(h[r-k]); ans=mymin(ans,solve(k)); &#125; printf(BIGN,ans);&#125; Code2是不是觉得巨长？其实有代码又短，常数又小的树状数组小心空间复杂度请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=110000;const int MAXNUM=1000001;//1000000+1const int INF=0x3f3f3f3f;//*******************全局定义*******************int bin[21];ll cnt[MAXNUM],sum[MAXNUM];//次数、和//*******************树状数组*******************int lowbit(int x) &#123;return x&amp;(-x);&#125;void add(int p,int c,ll *s)&#123; while(p&lt;=MAXNUM) s[p]+=c,p+=lowbit(p);&#125;ll getsum(int p,ll *s)&#123; ll ans=0; while(p&gt;=1) ans+=s[p],p-=lowbit(p); return ans;&#125;ll findk(int k)&#123; int now=0,tk=0; for(int i=20;i&gt;=0;i--)//逆向求和 &#123; now+=bin[i]; if(now&lt;=MAXNUM and tk+cnt[now]&lt;k) tk+=cnt[now]; else now-=bin[i]; &#125; return now+1;//【小于k数量】+1&#125;//*******************实现*******************void insert(ll d)&#123; add(d,1,cnt); add(d,d,sum);&#125;void del(ll d)&#123; add(d,-1,cnt); add(d,-d,sum);&#125;ll solve(int k)&#123; ll mid=findk(k/2+1); ll sm1=mid*getsum(mid-1,cnt),sm2=getsum(mid-1,sum); ll bg1=mid*(getsum(MAXNUM,cnt)-getsum(mid,cnt)),bg2=getsum(MAXNUM,sum)-getsum(mid,sum); return (sm1-sm2)+(bg2-bg1);&#125;//*******************主函数*******************int h[MAXN];int main()&#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; int n,k;scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;h[i]),h[i]++;//debug 有0 for(int i=1;i&lt;=k;i++) insert(h[i]); ll ans=solve(k); for(int r=k+1;r&lt;=n;r++) &#123; insert(h[r]); del(h[r-k]); ans=mymin(ans,solve(k)); &#125; printf(BIGN,ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
        <tag>树状数组</tag>
        <tag>难度2</tag>
        <tag>中位数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1084】【Bzoj1465】【Bzoj1045】糖果传递]]></title>
    <url>%2Fposts%2Ffa4.html</url>
    <content type="text"><![CDATA[Source and JudgeHAOI2008Luogu2512Bzoj1045Bzoj1465 Problem【Description】有n个小朋友坐成一圈，每人有ai个糖果。每人只能给左右两人传递糖果。每人每次传递一个糖果代价为1。【Input】小朋友个数n下面n个ai【Output】使所有人获得均等糖果的最小代价。【Limited conditions】n&lt;=1000000【Sample input】41 2 5 4【Sample output】4【Sample explanation】无 Record1h Analysis请先思考后再展开 首先，为了方便，把传递的双向改为单向（例如左边），这样传递量可能是负数。 $a[i]$=原本干草数$ed$=期望干草数$x[i]$=给左边干草数(可能是负数) $a[i]-x[i]+x[i+1]=ed$$\Rightarrow x[i+1]=x[i]-(a[i]-ed)$对于第1堆：$x[1]=x[n]-(a[n]-ed)=x[1]$ （还是使用x[1]本身较适合）对于第2堆：$x[2]=x[1]-(a[2]-ed)$对于第3堆：$x[3]=x[2]-(a[3]-ed)=x[1]-(a[2]-ed)-(a[3]-ed)$为了简化模型，变成单变量极值问题定义$c[i]=c[i-1]+(a[i]-ed)（i&gt;1,可能是负数）$于是$x[i]=x[1]-c[i]$ 我们希望 $答案=|x[2]|….+|x[n]|$ 最小也就是 $|x[1]-c[2]|….+|x[1]-c[n]|$ 最小 注意c[1]=0 所以现在x1是变量，而c是常量 绝对值几何意义：数轴上两点距离所以问题变成了：数轴上的n个点，找出一个【到他们的距离】之和最小的点问题解答：中位数 所以原题解答：$最好的x[1]=c的中位数$$ans=\sum_{i=2}^n abs(x1-c[i])$ 中位数证明：想象数轴上任意一点，首先假设，它左边有4个点，右边有2个点，把该点往左移动d单位距离（并且不碰到别的点），距离之和减少了2d当右边点较多时同理，【左右点数量差】越小越好，即最好的是中位数如果输入点有奇数个，则最优解应该是中间那个点即中位数如果有偶数个，则可以位于最中间两个点的任意位置（还是可用中位数解决） 另外，以后只要转化为这个数轴模型，就能使用中位数解决 然后这道题是很久以前做的，今天打比赛碰到类似题没想出来……同学提醒我做过这样一道题 所以有兴趣的也可以看看这道类似题：砖块 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;ll myabs(ll x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=1100000;const int INF=0x3f3f3f3f;//*******************全局定义*******************ll a[MAXN],c[MAXN];//*******************实现*******************//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); ll sum=0;for(int i=1;i&lt;=n;i++) scanf(BIGN,&amp;a[i]),sum+=a[i]; ll ed=sum/n;for(int i=2;i&lt;=n;i++) c[i]=c[i-1]+(a[i]-ed); sort(c+1,c+n+1);ll x1=(n&amp;1)?c[n/2+1]:(c[n/2]+c[n/2+1])/2; ll ans=0; for(int i=1;i&lt;=n;i++) ans+=myabs(x1-c[i]); printf(BIGN,ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>中位数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj5194】Snow Boots]]></title>
    <url>%2Fposts%2F1f6f.html</url>
    <content type="text"><![CDATA[Source and JudgeUSACO 2018 February Gold 原题 Bzoj5194 Luogu4269 Problem【Brief description】N个点，从1开始编号，第i个位置有个ai有b双鞋，每双有两个属性s和d，使你能走过所有ai&lt;=s的地方，并且跳跃时一次最多能跳d步求每一双鞋子能否只用它从1到达n（确保这两个位置ai=0）【Input】第一行包含两个空格分隔的整数N和B。第二行包含N个空格分隔的整数，表示a。下面b行，每行两个数，表示s和d。【Output】n行，用0和1表示可行性【Limited conditions】1≤N,B≤10^50≤ai≤10^90≤s≤10^91≤d≤N-1【Sample input】8 70 3 8 5 6 9 0 00 50 66 28 110 15 3150 7【Sample output】0110111【Sample explanation】无 Record1h Analysis请先思考后再展开 首先要明确，从1到n的时候，是既可以走（+1）也可以跳（+d以内）的 那么显然，对于一只鞋，我们需要的，就是判断它所不能走的地方最大连续长度，只要这个最大长度是比d小的，就是能走过去的。 【因为做题量少+被“过河”误导+被没说清楚的题目误导（原来是可以跳短一点的），担心了各种细节，把题意复杂化了，所以考试的时候战略性放弃了】 开始讲做法： 把鞋子按照s从大到小排序，然后把点也按照从大到小排序个序 现在按排序还处理鞋子，这样能走的点只会减少，把能走的点用链表维护 维护一个【最大的能走的点间距离】，那么也就是最长的不能走的长度 每次删除链表中的点时，距离只会变大，更新一下答案即可 时间复杂度：O(nlogn+blogb)，那么题目的数据范围是灰常宽松的，加读优的暴力也能跑70 所以出题还是要卡一卡 当然，方法还有很多 用线段树而非链表维护，最长区间长度，但这样会慢一点，实现也麻烦 鞋子也可以从小到大排序，即能走的点增多，则可以考虑写一个可删堆或线段树 也就是说，如果从大到小，是完全没必要写线段树的 如果非要从小到大，可能写个可删堆会比较快？虽然常数大一点 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int INF=0x3f3f3f3f;const int MAXN=110000;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int n,b;struct Lb&#123; int a; int id; int q,h;//链表&#125;p[MAXN],lb[MAXN];struct Qes&#123; int s,d; int id; bool ans;&#125;q[MAXN];bool cmp1(Lb a,Lb b) &#123;return a.a&gt;b.a;&#125;bool cmp2(Qes a,Qes b) &#123;return a.s&gt;b.s;&#125;bool cmp3(Qes a,Qes b) &#123;return a.id&lt;b.id;&#125;int first=1;int mx=0;bool solve(int x)&#123; for(;p[first].a&gt;q[x].s;first++) &#123; int t=p[first].id; int q=lb[t].q,h=lb[t].h; lb[q].h=h;lb[h].q=q; mx=mymax(mx,h-q-1);//长度 &#125; return q[x].d&gt;mx;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;b); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i].a),p[i].id=i; for(int i=1;i&lt;=b;i++) scanf("%d%d",&amp;q[i].s,&amp;q[i].d),q[i].id=i; memcpy(lb,p,sizeof(p));for(int i=1;i&lt;=n;i++) lb[i].q=i-1,lb[i].h=i+1; sort(p+1,p+n+1,cmp1); sort(q+1,q+b+1,cmp2); for(int i=1;i&lt;=b;i++) q[i].ans=solve(i); sort(q+1,q+b+1,cmp3); for(int i=1;i&lt;=b;i++) printf("%d\n",q[i].ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2500】幸福的道路]]></title>
    <url>%2Fposts%2F73a.html</url>
    <content type="text"><![CDATA[Source and JudgeBzoj2500 Problem【Brief description】给一棵n个点的树，边长为$w_i$。现在假设有n天，每一天都可以从点i出发，然后走一条最长路径（每条边只经过一次）现在要求选择最长的连续几天，这些天的极差不超过$M$，求最大长度。【Input】第一行包含两个整数$N, M$，表示节点数和波动上限。第二至第$N$行,每行两个数字$F_i , w_i$, 第i行表示第i个节点的父亲是$F_i$,且路径长度是$w_i$.【Output】一行表示答案。【Limited conditions】50%的数据N&lt;=100080%的数据N&lt;=100 000100%的数据N&lt;=1000 000【Sample input】3 21 11 3【Sample output】3【Sample explanation】无 Record5h Analysis请先思考后再展开 首先，求每个点的最长链$g[i]$有几个方法： ① 两次dfs求出树的直径，每个点求与直径端点距离，复杂度$O(2n+2nlogn)$ ② 两次dfs求出树的直径，从直径两个端点再dfs更新每个点的答案，复杂度$O(4n)$ ③ dfs1把每个点子树内最长链和次长链计算出，然后dfs2用父亲的答案更新儿子的，复杂度$O(2n)$ 然后因为是连续的一段，所以可以用单调队列搞一搞 但怎么“搞”呢？考试的时候想半天没想到 首先我们单调的限制条件，就是极差是m以内 那所谓极差就是最大和最小值的差 我们可以同时维护两个单调队列【据说这是常规操作】 一个上升，一个下降，先维护其单调性 然后现在加入了一个点$r$，也就是当前连续的几天的右端点 把不符合条件的，从头开始踢出，同时把$l$用$max$维护一下就好了 注意，此时我们不一定把所有$l$前面的踢出了，但他们既不影响更新，也迟早会出去 同理，$l$之后的也不一定都在里面，只是因为不满足单调性而被去除了而已 哎刚开始打的时候没想通，还以为是用单调队列的长度这玩意真的挺有意思的 搞了这么久，主要是犯了很多sb错误 Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;ll mymaxll(ll x,ll y) &#123;return x&gt;y?x:y;&#125;int qread()&#123; int x=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') x=x*10+c-'0',c=getchar(); return x;&#125;const int MAXN=1000001;struct Nod&#123; int hou; ll dis; Nod() &#123; hou=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,g; ll c;&#125;e[MAXN*2];int ln=0;void ins(int x,int y,ll c)&#123; e[++ln]=(Edge)&#123;y,p[x].hou,c&#125;;p[x].hou=ln; e[++ln]=(Edge)&#123;x,p[y].hou,c&#125;;p[y].hou=ln;&#125;void dfs(int x,int fa)&#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; p[y].dis=p[x].dis+e[k].c; dfs(y,x); &#125;&#125;ll g[MAXN];//最长链void dfs2(int x,int fa,ll dis)&#123; g[x]=mymaxll(g[x],dis); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dfs2(y,x,dis+e[k].c); &#125;&#125;int q1[MAXN];int q2[MAXN];int main()&#123; int n=qread(),m=qread(); for(int i=2;i&lt;=n;i++)//debug 被坑了一天!!!! &#123; int a=qread(),b=qread(); ins(a,i,ll(b)); &#125; int aa=1;p[1].dis=0;dfs(1,0);for(int i=1;i&lt;=n;i++) if(p[i].dis&gt;p[aa].dis) aa=i; int bb=aa;p[aa].dis=0;dfs(aa,0);for(int i=1;i&lt;=n;i++) if(p[i].dis&gt;p[bb].dis) bb=i; dfs2(aa,0,0);dfs2(bb,0,0); int ans=1; int tou1=1,wei1=1;q1[1]=1;//递增 int tou2=1,wei2=1;q2[1]=1;//递减 int l=1;//左端点 for(int r=1;r&lt;=n;r++)//右端点 &#123; while(tou1&lt;=wei1 and g[q1[wei1]]&gt;=g[r]) wei1--;q1[++wei1]=r;//维护单调性 while(tou1&lt;=wei1 and g[r]-g[q1[tou1]]&gt;m) l=mymax(l,q1[tou1]+1),tou1++;//维护合法性 while(tou2&lt;=wei2 and g[q2[wei2]]&lt;=g[r]) wei2--;q2[++wei2]=r;//维护单调性 while(tou2&lt;=wei2 and g[q2[tou2]]-g[r]&gt;m) l=mymax(l,q2[tou2]+1),tou2++;//维护合法性 ans=mymax(ans,r-l+1); &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
        <tag>难度2</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF566A】【51Nod1615】Matching Names]]></title>
    <url>%2Fposts%2Ff13e.html</url>
    <content type="text"><![CDATA[Source and JudgeVK Cup 2015 - Finals分配笔名51Nod1626CF566A 但是CF的麻烦，懒得打了…… Problem【Brief description】班里有n个同学。老师为他们选了n个笔名。现在要把这些笔名分配给每一个同学，每一个同学分配到一个笔名，每一个笔名必须分配给某个同学。现在定义笔名和真名之间的相关度是他们之间的最长公共前缀。那么我们就可以得到匹配的质量是每一个同学笔名和真名之间相关度的和。现在要求分配笔名，使得匹配质量最大。【Input】第一行有一个整数n ，表示班级中同学的数目。接下来n行，表示每一个同学的真名，每一个名字是非空串，且由小写字母组成。名字可能重复。最后n行是老师已经安排好的笔名。每一个笔名是一个非空串，且由小写字母组成。笔名可能重复。【Output】输出最大的匹配质量【Limited conditions】1≤n≤100000输入的字符总数目不超过 800000。【Sample input】5gennadygalyaborisbilltoshikbilbotoringendalfsmauggaladriel【Sample output】11以下为CF额外：4 12 51 35 23 4【Sample explanation】无 Record1h Analysis请先思考后再展开 字典树 然后考试的时候写错了，漏了情况 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int INF=0x3f3f3f3f;struct Trie&#123; int s,ch[26];&#125;p[1000000];void clear(int x)&#123; p[x].s=0; memset(p[x].ch,-1,sizeof(p[x].ch));&#125;int cnt;char s[810000];void add()&#123; int ln=strlen(s+1); int x=0; for(int i=1;i&lt;=ln;i++) &#123; int t=s[i]-'a'; if(p[x].ch[t]&lt;=0) &#123; p[x].ch[t]=++cnt; clear(cnt); &#125; x=p[x].ch[t]; p[x].s++; &#125;&#125;int solve()&#123; int ans=0; int ln=strlen(s+1); int x=0; for(int i=1;i&lt;=ln;i++) &#123; int t=s[i]-'a'; if(p[x].ch[t]&lt;=0) break; x=p[x].ch[t]; if(p[x].s&gt;0) p[x].s--,ans++; //下面的是错误的代码 //if(p[x].s&lt;=0) break; //p[x].s--;ans++; //反例 名字aab 笔名aa aab &#125; return ans;&#125;int main()&#123; int n;scanf("%d",&amp;n);getchar(); clear(0);cnt=0; for(int i=1;i&lt;=n;i++) &#123; gets(s+1); add(); &#125; int ans=0; for(int i=1;i&lt;=n;i++) &#123; gets(s+1); ans+=solve(); &#125; printf("%d\n",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF11B】【51Nod1615】Jumping Jack]]></title>
    <url>%2Fposts%2Fff50.html</url>
    <content type="text"><![CDATA[Source and Judge跳跃的杰克51Nod1615CF11BCF的原题好像已经被删了 Problem【Brief description】杰克正站在X坐标轴原点上。他想跳到坐标(x,0)上，为了达到训练效果，他决定首次跳跃的距离是1，之后每一次跳跃的距离将会比上一次跳跃的距离大1个单位。每一次跳跃，他可以选择往左或者往右跳。他很好奇至少要经过多少次跳跃才能到达终点。【Input】整数x【Output】输出杰克到达终点所需要的最少的跳跃次数【Limited conditions】-10^9&lt;=x&lt;=10^9【Sample input】2【Sample output】3【Sample explanation】无 Record30min 考试签到题 Analysis请先思考后再展开 思维题 首先，既然我们在0，那x可以直接转正 然后考虑贪心，在没到x前一直往右 然后到了以后有两种情况： now-x是奇数，则试图调整前面的，但无论前面是什么数，调换方向后都是偶数，所以无法到x now-x是偶数，则把(now-x)/2的数，方向反转即可 Code请先思考后再展开 123456789101112131415#include&lt;cstdio&gt;using namespace std;int main()&#123; int x;scanf("%d",&amp;x); if(x&lt;0) x=-x; int now=0,f=0; while(now&lt;x or (now-x)&amp;1) &#123; f++; now+=f; &#125; printf("%d\n",f);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>精品题</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1084】疫情控制]]></title>
    <url>%2Fposts%2F32f8.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2012 提高组 D2T3Luogu1084Caioj1556 Problem【Brief description】H 国有 n 个城市，这 n 个城市用 n-1 条双向道路相互连通构成一棵树，1 号城市是首都，也是树中的根节点。H 国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。 【Input】第一行一个整数 n，表示城市个数。接下来的 n-1 行，每行 3 个整数，u、v、w，每两个整数之间用一个空格隔开，表示从城市 u 到城市 v 有一条长为 w 的道路。数据保证输入的是一棵树，且根节点编号为 1。接下来一行一个整数 m，表示军队个数。接下来一行 m 个整数，每两个整数之间用一个空格隔开，分别表示这 m 个军队所驻扎的城市的编号。 【Output】共一行，包含一个整数，表示控制疫情所需要的最少时间。如果无法控制疫情则输出-1。 【Limited conditions】保证军队不会驻扎在首都。对于 20%的数据，2≤ n≤ 10；对于 40%的数据，2 ≤n≤50，0&lt;w &lt;10^5；对于 60%的数据，2 ≤ n≤1000，0&lt;w &lt;10^6；对于 80%的数据，2 ≤ n≤10,000；对于 100%的数据，2≤m≤n≤50,000，0&lt;w &lt;10^9。 【Sample input】41 2 11 3 23 4 322 2 【Sample output】3 【Sample explanation】**第一支军队在 2 号点设立检查点，第二支军队从 2 号点移动到 3 号点设立检查点，所需时间为 3 个小时。 Record5h Analysis请先思考后再展开 显然就是让时间最长的最小，然后可以考虑二分然后，显然除了到根节点，其他时候深度越小越好，而且还是一棵树，那么就可以倍增搞一搞而且，对于那些在时限内无法到达根节点的点，直接跑到最高处即可于是，现在问题转化为：确定时限，判断【能到根节点而又余力的军队】和【没有接触瘟疫的根的子树】如何分配（显然过了根节点，就没有必要往深处走了） 然后又是一波贪心2333，首先把军队和子树从小到大排序一下情况①：同子树未覆盖，则优先覆盖（无条件），这样最节省资源情况②：只能找其他子树下的空缺，有可能无任何贡献这个方法的正确性是显而易见的，然鹅看到有人用奇奇怪怪的贪心也过去了……可能有人看到这个“显而易见”又不爽？补充一下对于一个a，如果本来是由b负责的，因为已经排好序，如果b不是搞a，而是搞a后面的c，把a交给了b后面的d，则可行性不变，不会更优 最后提醒一下：有一种错误的贪心（自己想错了……然后被自己卡了）就是把有余力的军队，留最短的那支去管理自己的但可能有一种情况：三个点，然后一个很长，没人有空余，一个中间，有一个空余，一个很短，有两个空余然后短的那部分，只能去中间长度的按照现在的做法，会强行把中间那个留下，但其实放到长那地方，短的派一个过来会更优 正确的做法是，先把自己不能到根再回来的留下一个（这种情况，到别的更短地方不会更优）那么剩下的就很好处理了，只要贪心的大管大即可其中第一步很重要，避免原本能管理自己的，因为【空余减去到根距离】太小，导致浪费 这个贪心，万一在考场上太激动，没想到这个反例，然后分数被卡炸就惨了…… Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=51000;const int INF=0x3f3f3f3f;//*******************全局定义*******************int hou[MAXN];struct Edge&#123; int y,g; ll c;&#125;e[MAXN*2];int ln=0;void ins(int x,int y,ll c)&#123; e[++ln]=(Edge)&#123;y,hou[x],c&#125;;hou[x]=ln; e[++ln]=(Edge)&#123;x,hou[y],c&#125;;hou[y]=ln;&#125;//*******************预处理*******************int f[MAXN][20];ll ds[MAXN][20];void dfs(int x,int fa)&#123; f[x][0]=fa; for(int i=1;i&lt;=16;i++) &#123; f[x][i]=f[f[x][i-1]][i-1]; ds[x][i]=ds[x][i-1]+ds[f[x][i-1]][i-1]; if(f[x][i]==0) break; &#125; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; ds[y][0]=e[k].c; dfs(y,x); &#125;&#125;//*******************寻找*******************bool fg[MAXN];void dfs2(int x)&#123; if(fg[x]) return; bool son=0; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==f[x][0]) continue; son=1; dfs2(y); if(!fg[y]) return;//空缺 &#125; if(son) fg[x]=1;&#125;//*******************统计和分配*******************int na,nb;struct Nod//有余力的军队、空缺的【根节点下子树】&#123; int id;//【根节点下子树】编号 ll rst;//长度&#125;sa[MAXN],sb[MAXN];bool cmp(Nod a,Nod b) &#123;return a.rst&lt;b.rst;&#125;void presb()&#123; for(int k=hou[1];k&gt;0;k=e[k].g) &#123; int y=e[k].y; dfs2(y); if(!fg[y]) sb[++nb]=(Nod)&#123;y,e[k].c&#125;; &#125;&#125;//*******************验证*******************int n,m;int army[MAXN];bool check(ll mid)&#123; na=nb=0; memset(fg,0,sizeof(fg)); for(int i=1;i&lt;=m;i++) &#123; int x=army[i];ll now=0;//已走长度 for(int j=16;j&gt;=0;j--) if(f[x][j]&gt;1 and now+ds[x][j]&lt;=mid)//非0且非根节点 now+=ds[x][j],x=f[x][j]; if(f[x][0]==1) sa[++na]=(Nod)&#123;x,mid-now-ds[x][0]&#125;; else fg[x]=1;//debug &#125; presb(); if(na&lt;nb) return 0; sort(sa+1,sa+na+1,cmp); sort(sb+1,sb+nb+1,cmp); int x=1; for(int i=1;i&lt;=na;i++) &#123; if(!fg[sa[i].id]) fg[sa[i].id]=1;//优先同子树 else &#123; if(sa[i].rst&gt;=sb[x].rst) fg[sb[x++].id]=1; else ;//无用 &#125; while(x&lt;=nb and fg[sb[x].id]) x++;//准备 &#125; return x&gt;nb;&#125;//*******************主函数*******************int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n-1;i++) &#123; int x,y,c; scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,ll(c)); &#125; scanf("%d",&amp;m); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;army[i]); dfs(1,0); ll l=0,r=ll(INF)*n,ans=-1; while(l&lt;=r) &#123; ll mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf(BIGN,ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>二分</tag>
        <tag>精品题</tag>
        <tag>贪心</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1083】借教室]]></title>
    <url>%2Fposts%2Fb9a5.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2012 提高组 D2T2Luogu1083Caioj1555 Problem【Brief description】在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。面对海量租借教室的信息，我们自然希望编程解决这个问题。我们需要处理接下来n天的借教室信息，其中第i天学校有$ri​$个教室可供租借。共有m份订单，每份订单用三个正整数描述，分别为$dj,sj,tj​$，表示某租借者需要从第$sj​$天到第$tj​$天租借教室（包括第$sj​$天和第$tj​$天），每天需要租借$dj​$个教室。我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供$dj$个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第$sj$天到第$tj$天中有至少一天剩余的教室数量不足$dj$个。现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。【Input】第一行包含两个正整数n,m，表示天数和订单的数量。第二行包含n个正整数，其中第i个数为$ri$，表示第i天可用于租借的教室数量。接下来有m行，每行包含三个正整数$dj,sj,tj$，表示租借的数量，租借开始、结束分别在第几天。每行相邻的两个数之间均用一个空格隔开。天数与订单均用从1开始的整数编号。【Output】如果所有订单均可满足，则输出只有一行，包含一个整数 0。否则（订单无法完全满足）输出两行，第一行输出一个负整数-1，第二行输出需要修改订单的申请人编号。【Limited conditions】对于10%的数据，有1≤ n,m≤ 10；对于30%的数据，有1≤ n,m≤1000；对于 70%的数据，有1 ≤ n,m ≤ 10^5；对于 100%的数据，有1 ≤ n,m ≤ 10^6,0 ≤ ri,dj≤ 10^9,1 ≤ sj≤ tj≤ n。【Sample input】4 32 5 4 32 1 33 2 44 2 4【Sample output】-12【Sample explanation】第 1 份订单满足后，4 天剩余的教室数分别为 0，3，2，3。第 2 份订单要求第 2 天到第 4 天每天提供 3 个教室，而第 3 天剩余的教室数为 2，因此无法满足。分配停止，通知第 2 个申请人修改订单。 Record2h Analysis1请先思考后再展开 先来个线段树 区间最小值和区间减小，打个lazy标记 然后网上说的70分，却拿到了95 终究是因为自己笨 Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=1100000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int l,r,mid; int lc,rc; int mi,lz;&#125;p[MAXN*2];int a[MAXN];//*******************实现*******************int ln=0;int build(int l,int r)&#123; int t=++ln; int mid=(l+r)&gt;&gt;1; if(l&lt;r) &#123; p[t]=(Nod)&#123;l,r,mid,build(l,mid),build(mid+1,r),0,0&#125;; p[t].mi=mymin(p[p[t].lc].mi,p[p[t].rc].mi); &#125; else p[t]=(Nod)&#123;l,r,mid,-1,-1,a[l],0&#125;; return t;&#125;void update(int x)&#123; int lc=p[x].lc,rc=p[x].rc; if(lc&gt;0) p[lc].mi+=p[x].lz,p[lc].lz+=p[x].lz; if(rc&gt;0) p[rc].mi+=p[x].lz,p[rc].lz+=p[x].lz; p[x].lz=0;&#125;void change(int x,int l,int r,int c)&#123; if(p[x].l==l and p[x].r==r) &#123; p[x].mi+=c; p[x].lz+=c; return; &#125; if(p[x].lz!=0) update(x); int lc=p[x].lc,rc=p[x].rc; if(r&lt;=p[x].mid) change(lc,l,r,c); else if(l&gt;p[x].mid) change(rc,l,r,c); else change(lc,l,p[x].mid,c),change(rc,p[x].mid+1,r,c); p[x].mi=mymin(p[p[x].lc].mi,p[p[x].rc].mi);&#125;int ask(int x,int l,int r)&#123; if(p[x].l==l and p[x].r==r) return p[x].mi; if(p[x].lz!=0) update(x); int lc=p[x].lc,rc=p[x].rc; if(r&lt;=p[x].mid) return ask(lc,l,r); if(l&gt;p[x].mid) return ask(rc,l,r); return mymin(ask(lc,l,p[x].mid),ask(rc,p[x].mid+1,r));&#125;//*******************主函数*******************int qread()&#123; int s=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') s=s*10+c-'0',c=getchar(); return s;&#125;int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) a[i]=qread(); build(1,n); for(int i=1;i&lt;=m;i++) &#123; int d=qread(),l=qread(),r=qread(); if(ask(1,l,r)&gt;=d) change(1,l,r,-d); else &#123; printf("-1\n%d",i); return 0; &#125; &#125; printf("0");&#125; Analysis2请先思考后再展开 网上看到了针对区间修改的”永久标记“，于是试一发 然鹅并没有任何卵用 Code2请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=1100000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int l,r,mid; int lc,rc; int mi,lz;&#125;p[MAXN*2];int a[MAXN];//*******************实现*******************int ln=0;int build(int l,int r)&#123; int t=++ln; int mid=(l+r)&gt;&gt;1; if(l&lt;r) &#123; p[t]=(Nod)&#123;l,r,mid,build(l,mid),build(mid+1,r),0,0&#125;; p[t].mi=mymin(p[p[t].lc].mi,p[p[t].rc].mi); &#125; else p[t]=(Nod)&#123;l,r,mid,-1,-1,a[l],0&#125;; return t;&#125;void change(int x,int l,int r,int c)&#123; if(p[x].l==l and p[x].r==r) &#123; p[x].mi+=c; p[x].lz+=c; return; &#125; if(r&lt;=p[x].mid) change(p[x].lc,l,r,c); else if(l&gt;p[x].mid) change(p[x].rc,l,r,c); else change(p[x].lc,l,p[x].mid,c),change(p[x].rc,p[x].mid+1,r,c); p[x].mi=mymin(p[p[x].lc].mi,p[p[x].rc].mi)+p[x].lz;&#125;int ask(int x,int l,int r,int lz)//注意标记叠加&#123; if(p[x].l==l and p[x].r==r) return p[x].mi+lz;//debug if(r&lt;=p[x].mid) return ask(p[x].lc,l,r,lz+p[x].lz); if(l&gt;p[x].mid) return ask(p[x].rc,l,r,lz+p[x].lz); return mymin(ask(p[x].lc,l,p[x].mid,lz+p[x].lz),ask(p[x].rc,p[x].mid+1,r,lz+p[x].lz));&#125;//*******************主函数*******************int qread()&#123; int s=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') s=s*10+c-'0',c=getchar(); return s;&#125;int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) a[i]=qread(); build(1,n); for(int i=1;i&lt;=m;i++) &#123; int d=qread(),l=qread(),r=qread();//scanf("%d%d%d",&amp;d,&amp;l,&amp;r); if(ask(1,l,r,0)&gt;=d) change(1,l,r,-d); else &#123; printf("-1\n%d",i); return 0; &#125; &#125; printf("0");&#125; Analysis3请先思考后再展开 现在的目的就是加速辣 区间修改$O(Klogn)$ （减法） 区间验证$O(Klogn)$ （找最小值） 总时间$O(m\times 2Klogn)$ 其中K是由于区间修改而导致的复杂度上升，当然打标记已经尽量优化了，多大我也不知道 那如果引入差分呢？ 区间修改$O(1)$ 区间验证$O(n)$ （暴力验证） 那么这个差分乍一看是没有这么优秀的，看起来像个暴力，但是具体实现也有两种： ①一个个搞过去，总时间$O(m\times n)$ ②二分验证，验证的时候要花一点时间在把前面订单搞定，总时间$O(logm\times (m+n))$ 于是，采用②，时间才会真正达到$O(nlogn)$的复杂度 而区间修改的线段树则有点危险 这tm怎么想得到？？？ Code3请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=1100000;const int INF=0x3f3f3f3f;//*******************全局定义*******************int n;int a[MAXN],s[MAXN];int d[MAXN],st[MAXN],ed[MAXN];//*******************实现*******************bool check(int mid)&#123; memset(s,0,sizeof(s));//需求量 for(int i=1;i&lt;=mid;i++) s[st[i]]+=d[i],s[ed[i]+1]-=d[i]; int sum=0; for(int i=1;i&lt;=n;i++) &#123; sum+=s[i]; if(sum&gt;a[i]) return 0; &#125; return 1;&#125;//*******************主函数*******************int main()&#123; int m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=m;i++) scanf("%d%d%d",&amp;d[i],&amp;st[i],&amp;ed[i]); int l=1,r=m,ans=-1;//最左的 while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(!check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; if(ans&lt;0) printf("0"); else printf("-1\n%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>二分</tag>
        <tag>精品题</tag>
        <tag>标记永久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1082】同余方程]]></title>
    <url>%2Fposts%2Fad35.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2012 提高组 D2T1Luogu1082Caioj1554 Problem【Brief description】求关于 x 的同余方程 $ax ≡ 1 (\mod b)$的最小正整数解。 【Input】输入只有一行，包含两个正整数 a, b，用一个空格隔开。 【Output】输出只有一行，包含一个正整数 x0，即最小正整数解。输入数据保证一定有解。 【Limited conditions】对于 40%的数据，2 ≤b≤ 1,000；对于 60%的数据，2 ≤b≤ 50,000,000；对于 100%的数据，2 ≤a, b≤ 2,000,000,000。 【Sample input】3 10 【Sample output】7 【Sample explanation】**无 Record10min Analysis请先思考后再展开 经典题 详见【OI之路】02数论算法-1公约数公倍数与欧几里得 Code请先思考后再展开 12345678910111213141516171819202122232425int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(b==0) &#123; x=1;y=0; return a; &#125; int tx,ty; int t=exgcd(b,a%b,tx,ty); x=ty; y=tx-(a/b)*ty; return t;&#125;int main()&#123; int a,b;scanf("%d%d",&amp;a,&amp;b); int A=a,B=b,K=1; int x,y; int gcd=exgcd(A,B,x,y); x=x*(K/gcd); int t=B/K; int XX=(x%t+t)%t; printf("%d",XX);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>拓展欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1081】开车旅行]]></title>
    <url>%2Fposts%2Ff1fd.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2012 提高组 D1T3Luogu1081Caioj1553 Problem【Brief description】现在有n个城市，每个城市有它的高度Hi，保证每个Hi互不相同。我们定义两个城市之间的距离$disi,j=|Hi−Hj|$，并且只能从编号小的城市去到编号大的城市。现在有两个人，小A和小B要开车去旅行。小A先开一天，小B再开一天。每一天都可以从一个开到另一个城市。小A会选择去离当前城市第二近的城市，小B会选择去离当前城市最近的那个城市（如果两个城市与现在距离相同，则认为高度低的更近）。如果他们行驶的总路程将会超过给定的X就会不继续开车，结束旅行。求：1：给定一个X，求从哪一个城市出发，【小A行驶的路程/小B行驶的路程】最小（认为一个非0数/0=∞）。若有多个城市相等，选择高度最高的那个。2：给出m个询问，每次询问从S出发，限制为X，小A走的路程和小B走的路程。【Input】第一行包含一个整数 N，表示城市的数目。第二行有 N 个整数，每两个整数之间用一个空格隔开，依次表示城市 1 到城市 N 的海拔高度，即 H1，H2，……，Hn，且每个 Hi都是不同的。第三行包含一个整数 X0。第四行为一个整数 M，表示给定 M 组 Si 和 Xi。接下来的 M 行，每行包含 2 个整数 Si 和 Xi，表示从城市 Si出发，最多行驶 Xi公里。【Output】第一行包含一个整数 S0，表示对于给定的 X0，从编号为 S0的城市出发，小 A 开车行驶的路程总数与小 B 行驶的路程总数的比值最小。接下来的 M 行，每行包含 2 个整数，之间用一个空格隔开，依次表示在给定的 Si 和 Xi 下小 A 行驶的里程总数和小 B 行驶的里程总数。【Limited conditions】对于30%的数据，有1≤N≤20，1≤M≤20；对于40%的数据，有1≤N≤100，1≤M≤100；对于50%的数据，有1≤N≤100，1≤M≤1,000；对于70%的数据，有1≤N≤1,000，1≤M≤10,000；对于100%的数据，有1≤N≤100,000，1≤M≤100,000，-1,000,000,000≤Hi≤1,000,000,000，0≤X0≤1,000,000,000，1≤Si≤N，0≤Xi≤1,000,000,000，数据保证Hi 互不相同。【Sample input 1】42 3 1 4341 32 33 34 3【Sample output 1】11 12 00 00 0【Sample input 2】104 5 6 1 2 3 7 8 9 107101 72 73 74 75 76 77 78 79 710 7【Sample output 2】23 22 42 12 45 15 12 12 00 00 0【Sample explanation】【输入输出样例 1 说明】各个城市的海拔高度以及两个城市间的距离如上图所示。如果从城市 1 出发，可以到达的城市为 2,3,4，这几个城市与城市 1 的距离分别为 1,1,2，但是由于城市 3 的海拔高度低于城市 2，所以我们认为城市 3 离城市 1 最近，城市 2 离城市1 第二近，所以小 A 会走到城市 2。到达城市 2 后，前面可以到达的城市为 3,4，这两个城市与城市 2 的距离分别为 2,1，所以城市 4 离城市 2 最近，因此小 B 会走到城市 4。到达城市 4 后，前面已没有可到达的城市，所以旅行结束。如果从城市 2 出发，可以到达的城市为 3,4，这两个城市与城市 2 的距离分别为 2,1，由于城市 3 离城市 2 第二近，所以小 A 会走到城市 3。到达城市 3 后，前面尚未旅行的城市为4，所以城市 4 离城市 3 最近，但是如果要到达城市 4，则总路程为 2+3=5&gt;3，所以小 B 会直接在城市 3 结束旅行。如果从城市 3 出发，可以到达的城市为 4，由于没有离城市 3 第二近的城市，因此旅行还未开始就结束了。如果从城市 4 出发，没有可以到达的城市，因此旅行还未开始就结束了。【输入输出样例 2 说明】当 X=7 时， 如果从城市 1 出发，则路线为 1 -&gt; 2 -&gt; 3 -&gt; 8 -&gt; 9，小 A 走的距离为 1+2=3，小 B 走的距离为 1+1=2。（在城市 1 时，距离小 A 最近的城市是 2 和 6，但是城市 2 的海拔更高，视为与城市 1 第二近的城市，所以小 A 最终选择城市 2；走到 9 后，小 A 只有城市 10 可以走，没有第 2 选择可以选，所以没法做出选择，结束旅行）如果从城市 2 出发，则路线为 2 -&gt; 6 -&gt; 7 ，小 A 和小 B 走的距离分别为 2，4。如果从城市 3 出发，则路线为 3 -&gt; 8 -&gt; 9，小 A 和小 B 走的距离分别为 2，1。如果从城市 4 出发，则路线为 4 -&gt; 6 -&gt; 7，小 A 和小 B 走的距离分别为 2，4。如果从城市 5 出发，则路线为 5 -&gt; 7 -&gt; 8 ，小 A 和小 B 走的距离分别为 5，1。如果从城市 6 出发，则路线为 6 -&gt; 8 -&gt; 9，小 A 和小 B 走的距离分别为 5，1。如果从城市 7 出发，则路线为 7 -&gt; 9 -&gt; 10，小 A 和小 B 走的距离分别为 2，1。如果从城市 8 出发，则路线为 8 -&gt; 10，小 A 和小 B 走的距离分别为 2，0。如果从城市 9 出发，则路线为 9，小 A 和小 B 走的距离分别为 0，0（旅行一开始就结束了）。如果从城市10出发，则路线为 10，小A 和小B 走的距离分别为0，0。从城市 2 或者城市 4 出发小 A 行驶的路程总数与小 B 行驶的路程总数的比值都最小，但是城市 2 的海拔更高，所以输出第一行为 2。 Record3h Analysis请先思考后再展开 其实这东西有点类似弹飞绵羊，但是因为那个有修改，所以分块更优，而这个不修改，所以搞个倍增。 那么有一个很关键的东西，就是确定，每个点，A和B开一次车会到哪里（即最近和次近） 那么如果模拟需要$O(n^2)$，不过70分的暴力分也算挺多的了 那么有一种显然的思想，就是排序，这样就到了$O(nlogn)$，不过怎么处理只能向右这个条件？ 网上有很多种方法啊，其中双向链表和set还是比较好理解的，当然线段树也可以但麻烦，至于并查集？？懵逼 那么一开始尝试set，发现接口不是很友好啊，那还是自己实现算了，虽然有点麻烦但不算难 20行，半个小时过去了…… 然后正如上面所说的，可以愉快地倍增了 注意到A和B是交替开车的，所以定义交替一次为一轮。 $A[x][i]$=在x点开始，走$2^i$轮，A走过的距离 B数组同理 $m[x][i]$=在x点开始，走$2^i$轮，到达的点 然后预处理倍增一下 然后回答询问： 第一个，枚举每一个点倍增回答，$O(nlogx)$ 后面的，倍增回答，共$O(mlogx)$ Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=110000; const ll INF=(1ll&lt;&lt;62); int myabs(int x) &#123;return x&gt;0?x:-x;&#125; int bin[40]; int n; struct Lb &#123; int d; int l,r; int pos; Lb() &#123; pos=-1; &#125; &#125;lb[MAX_N]; int fd[MAX_N];//原数列对应链表编号 bool cmp(Lb a,Lb b) &#123;return a.d&lt;b.d;&#125; ll dis(int x,int y) &#123;return (x==0 or y==0 or x&gt;n or y&gt;n)?INF:myabs(lb[x].d-lb[y].d);&#125; int h[MAX_N]; int nx1[MAX_N],nx2[MAX_N];//没有则-1 void pre()//预处理最大和次大 &#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]*2; for(int i=1;i&lt;=n;i++) lb[i].d=h[i],lb[i].pos=i; sort(lb+1,lb+n+1,cmp); for(int i=1;i&lt;=n;i++) lb[i].l=i-1,lb[i].r=i+1,fd[lb[i].pos]=i; memset(nx1,-1,sizeof nx1); memset(nx2,-1,sizeof nx2); for(int i=1;i&lt;=n;i++)//左到右 &#123; int x=fd[i]; int fl=lb[x].l,fr=lb[x].r; int fll=lb[fl].l,frr=lb[fr].r; ll a=dis(fll,x),b=dis(fl,x),c=dis(fr,x),d=dis(frr,x); if(b==c) nx1[i]=lb[fl].pos,nx2[i]=lb[fr].pos; else if(b&lt;c) &#123; nx1[i]=lb[fl].pos; if(a&lt;=c) nx2[i]=lb[fll].pos; else nx2[i]=lb[fr].pos; &#125; else &#123; nx1[i]=lb[fr].pos; if(b&lt;=d) nx2[i]=lb[fl].pos; else nx2[i]=lb[frr].pos; &#125; //printf("%d=%d,%d\n",i,nx1[i],nx2[i]); lb[fl].r=fr;lb[fr].l=fl; &#125; &#125; ll fa[MAX_N][30],fb[MAX_N][30]; int ed[MAX_N][30];//没有则-1 void pre2()//预处理倍增 &#123; memset(ed,-1,sizeof ed); for(int i=1;i&lt;=n;i++) &#123; if(nx2[i]&gt;0) fa[i][0]=myabs(h[i]-h[nx2[i]]); if(nx2[i]&gt;0 and nx1[i]&gt;0) fb[i][0]=myabs(h[nx2[i]]-h[nx1[nx2[i]]]); ed[i][0]=nx1[nx2[i]]; &#125; for(int t=1;t&lt;=20;t++) for(int x=1;x&lt;=n;x++) &#123; if(ed[x][t-1]&lt;=0) continue; fa[x][t]=fa[x][t-1]+fa[ed[x][t-1]][t-1]; fb[x][t]=fb[x][t-1]+fb[ed[x][t-1]][t-1]; ed[x][t]=ed[ed[x][t-1]][t-1]; &#125; &#125; ll Ta,Tb; void solve(int st,ll mx) &#123; Ta=Tb=0; for(int i=20;i&gt;=0;i--) &#123; if(ed[st][i]&gt;0 and Ta+fa[st][i]+Tb+fb[st][i]&lt;=mx) &#123; Ta+=fa[st][i]; Tb+=fb[st][i]; st=ed[st][i]; &#125; &#125; if(nx2[st]&gt;0 and Ta+fa[st][0]+Tb&lt;=mx) Ta+=fa[st][0]; &#125; void solve1() &#123; int x0;scanf("%d",&amp;x0); double ans=-1;int id=-1; for(int st=1;st&lt;=n;st++) &#123; solve(st,x0); double t=(Tb==0)?INF:(double)Ta/Tb; if(ans&lt;0 or t&lt;ans or (t==ans and h[st]&gt;h[id])) ans=t,id=st; &#125; printf("%d\n",id); &#125; void solve2() &#123; int st,mx;scanf("%d%d",&amp;st,&amp;mx); solve(st,mx); printf("%lld %lld\n",Ta,Tb); &#125; void main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;h[i]); pre(); pre2(); solve1(); int q;scanf("%d",&amp;q); while(q--) solve2(); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1080】国王游戏]]></title>
    <url>%2Fposts%2F1b05.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2012 提高组 D1T2Luogu1080Caioj1552 Problem【Brief description】恰逢 H 国国庆，国王邀请 n 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 n 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。【Input】第一行包含一个整数 n，表示大臣的人数。第二行包含两个整数 a和 b，之间用一个空格隔开，分别表示国王左手和右手上的整数。接下来 n 行，每行包含两个整数 a 和 b，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。【Output】输出只有一行，包含一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。【Limited conditions】对于 20%的数据，有 1≤ n≤ 10，0 &lt; a、b &lt; 8；对于 40%的数据，有 1≤ n≤20，0 &lt; a、b &lt; 8；对于 60%的数据，有 1≤ n≤100；对于 60%的数据，保证答案不超过 10^9；对于 100%的数据，有 1 ≤ n ≤1,000，0 &lt; a、b &lt; 10000。【Sample input】31 12 37 44 6【Sample output】2【Sample explanation】按 1、2、3 号大臣这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；按 1、3、2 这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；按 2、1、3 这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；按 2、3、1 这样排列队伍，获得奖赏最多的大臣所获得金币数为 9；按 3、1、2 这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；按 3、2、1 这样排列队伍，获得奖赏最多的大臣所获得金币数为 9。因此，奖赏最多的大臣最少获得 2 个金币，答案输出 2。 Record1h Analysis请先思考后再展开 根据贪心，我们可以证明用每个人左右手乘积从小到大排序，是最优解。 证明：贪心有种证明方式叫做微扰就是说证明，对于任意两个相邻的元素，最优解中，把他们交换可能得到更坏的结果。 那么在本题中就是，设大臣1和大臣2，他们是相邻的 身份 左手 右手 国王 a0 …… …… （乘积省略到a0中） …… 大臣1 a1 b1 …… XXX …… 大臣2 a2 b2 …… …… …… 则有两种方案：方案① 大臣1在前：$A=\frac{a0}{b1}$$B=XXX\times a0\times \frac{a1}{b2}$$ANS1=max(A,B)$ 方案② 大臣2在前：$C=\frac{a0}{b2}$$D=XXX\times a0 \times \frac{a2}{b1}$$ANS2=max(C,D)$ 选择小的那个方案就是最优解 由于都是正整数，已知$A\leq D$$C\leq B$关于A和B的大小关系，又有两种情况情况① $A&lt;B$，则$A,C \leq B,D$，根据B,D大小决策【等价于左右手乘积小的在前面】情况② $A\geq B$，则$C \leq B \leq A \leq D$，可以直接选择方案② 但现在有两种决策方案，显然不利于实现我们可以把情况②看作情况①的一部分因为如果按照乘积比较的话，能得到同样的结果 综上所述，对于相邻的两个元素，乘积小的应该在前面那么根据冒泡排序，我们可以通过交换相邻元素去消除逆序对当逆序对数=0时是最优的，也就是可以通过排序得到最优解。 然后极限是$10000^{1000}$，即4000个位……所以要写高精度的乘和除（还好是与单精度的，不然真的不会） 最后，感谢这位大佬League丶翎在我解题过程中的耐心解释 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=1100;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Boy&#123; int a,b; ll ab;&#125;p[MAXN];bool cmp(Boy a,Boy b) &#123;return a.ab&lt;b.ab;&#125;//*******************实现*******************struct Bnum&#123; int a[4100],ln; Bnum() &#123; memset(a,0,sizeof(a)); &#125;&#125;;Bnum cheng(Bnum a,int b)&#123; Bnum c;c.ln=a.ln; for(int i=1;i&lt;=c.ln;i++) &#123; c.a[i]+=a.a[i]*b; if(c.a[i]&gt;9) &#123; c.a[i+1]+=c.a[i]/10; c.a[i]%=10; if(i==c.ln) c.ln++; &#125; &#125; return c;&#125;Bnum chu(Bnum a,int b)&#123; Bnum c;c.ln=a.ln; int ys=0; for(int i=c.ln;i&gt;=1;i--) &#123; ys=ys*10+a.a[i]; c.a[i]=ys/b; ys%=b; &#125; for(int i=1;i&lt;=c.ln;i++) if(c.a[i]&gt;9) &#123; c.a[i+1]+=c.a[i]/10; c.a[i]%=10; if(i==c.ln) c.ln++; &#125; while(c.ln&gt;1 and c.a[c.ln]==0) c.ln--; return c;&#125;bool comp(Bnum a,Bnum b)&#123; if(a.ln!=b.ln) return a.ln&lt;b.ln; for(int i=a.ln;i&gt;=1;i--) if(a.a[i]!=b.a[i]) return a.a[i]&lt;b.a[i]; return a.a[0]&lt;b.a[0];&#125;//*******************主函数*******************Bnum now,tmp,ans;int main()&#123; int n;scanf("%d",&amp;n); for(int i=0;i&lt;=n;i++) &#123; scanf("%d%d",&amp;p[i].a,&amp;p[i].b); p[i].ab=ll(p[i].a)*p[i].b; &#125; sort(p+1,p+n+1,cmp); now.a[1]=1;now.ln=1;now=cheng(now,p[0].a); for(int i=1;i&lt;=n;i++) &#123; tmp=chu(now,p[i].b); if(comp(ans,tmp)) ans=tmp; now=cheng(now,p[i].a); &#125; for(int i=ans.ln;i&gt;=1;i--) printf("%d",ans.a[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高精度</tag>
        <tag>难度2</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1079】Vigenère密码]]></title>
    <url>%2Fposts%2F745a.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2012 提高组 D1T1Luogu1079Caioj1551 Problem【Brief description】16 世纪法国外交家 Blaise de Vigenère 设计了一种多表密码加密算法――Vigenère 密码。Vigenère 密码的加密解密算法简单易用，且破译难度比较高，曾在美国南北战争中为南军所广泛使用。在密码学中，我们称需要加密的信息为明文，用 M 表示；称加密后的信息为密文，用C 表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为 k。在 Vigenère 密码中，密钥 k 是一个字母串，k=k1k2…kn。当明文 M=m1m2…mn时，得到的密文 C=c1c2…cn，其中 ci=mi®ki，运算®的规则如下表所示：Vigenère 加密在操作时需要注意：1. ®运算忽略参与运算的字母的大小写，并保持字母在明文 M 中的大小写形式；2. 当明文 M 的长度大于密钥 k 的长度时，将密钥 k 重复使用。例如，明文 M=Helloworld，密钥 k=abc 时，密文 C=Hfnlpyosnd。【Input】第一行为一个字符串，表示密钥 k，长度不超过 100，其中仅包含大小写字母。第二行为一个字符串，表示经加密后的密文，长度不超过 1000，其中仅包含大小写字母。【Output】一个字符串，表示输入密钥和密文所对应的明文。【Limited conditions】对于10% 的数据，k=0 ；对于20% 的数据，k=1 ；对于40% 的数据，2 ≤ n ≤ 50，1 ≤ m ≤ 1,000，0 ≤ k ≤ 20，0 ≤ Di ≤ 10，0 ≤ T i ≤ 500；对于60% 的数据，1 ≤ n ≤ 100，1 ≤ m ≤ 1,000，0 ≤ k ≤ 100 ，0 ≤ Di ≤ 100，0 ≤ T i ≤ 10,000 ；对于100%的数据，1 ≤ n ≤ 1,000，1 ≤ m ≤ 10,000 ，0 ≤ k ≤ 100,000，0 ≤ Di ≤ 100 ，0 ≤ T i ≤ 100,000。【Sample input】CompleteVictoryYvqgpxaimmklongnzfwpvxmniytm【Sample output】Wherethereisawillthereisaway【Sample explanation】输入的密钥的长度不超过 100，输入的密文的长度不超过 1000，且都仅包含英文字母。 Record10min Analysis请先思考后再展开 设‘a’为0 ci=(mi+ki)%26 mi=(ci-ki+26)%26 Code请先思考后再展开 123456789101112131415161718192021char k[110],c[1100];char m[1100];char getm(char cc,char kk)&#123; if(cc&gt;='A' and cc&lt;='Z') cc-='A'; else cc-='a'; if(kk&gt;='A' and kk&lt;='Z') kk-='A'; else kk-='a'; return 'a'+(26+cc-kk)%26;&#125;int main()&#123; scanf("%s%s",k+1,c+1); int ln1=strlen(c+1),ln2=strlen(k+1); int t=1; for(int i=1;i&lt;=ln1;i++) &#123; m[i]=getm(c[i],k[t]); if(c[i]&gt;='A' and c[i]&lt;='Z') m[i]+='A'-'a'; t++;if(t&gt;ln2) t=1; &#125; puts(m+1);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1315】观光公交]]></title>
    <url>%2Fposts%2Fb81a.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2011 提高组 D2T3Luogu1315Caioj1550 Problem【Brief description】风景迷人的小城Y 市，拥有n 个美丽的景点。由于慕名而来的游客越来越多，Y 市特意安排了一辆观光公交车，为游客提供更便捷的交通服务。观光公交车在第 0 分钟出现在 1号景点，随后依次前往 2、3 、4 ……n 号景点。从第 i 号景点开到第 i+1 号景点需要 Di 分钟。任意时刻，公交车只能往前开，或在景点处等待。设共有m 个游客，每位游客需要乘车1 次从一个景点到达另一个景点，第i 位游客在Ti 分钟来到景点 Ai ，希望乘车前往景点Bi （Ai&lt;Bi ）。为了使所有乘客都能顺利到达目的地，公交车在每站都必须等待需要从该景点出发的所有乘客都上车后才能出发开往下一景点。假设乘客上下车不需要时间。一个乘客的旅行时间，等于他到达目的地的时刻减去他来到出发地的时刻。因为只有一辆观光车，有时候还要停下来等其他乘客，乘客们纷纷抱怨旅行时间太长了。于是聪明的司机ZZ给公交车安装了 k 个氮气加速器，每使用一个加速器，可以使其中一个 Di 减1 。对于同一个Di 可以重复使用加速器，但是必须保证使用后Di 大于等于0 。那么ZZ该如何安排使用加速器，才能使所有乘客的旅行时间总和最小？【Input】第 1 行是3 个整数n, m, k ，每两个整数之间用一个空格隔开。分别表示景点数、乘客数和氮气加速器个数。第 2 行是n-1 个整数，每两个整数之间用一个空格隔开，第i 个数表示从第i 个景点开往第i+1 个景点所需要的时间，即 Di 。第 3 行至m+2 行每行 3 个整数 Ti, Ai, Bi，每两个整数之间用一个空格隔开。第 i+2 行表示第i 位乘客来到出发景点的时刻，出发的景点编号和到达的景点编号。【Output】共一行，包含一个整数，表示最小的总旅行时间。【Limited conditions】对于10% 的数据，k=0 ；对于20% 的数据，k=1 ；对于40% 的数据，2 ≤ n ≤ 50，1 ≤ m ≤ 1,000，0 ≤ k ≤ 20，0 ≤ Di ≤ 10，0 ≤ T i ≤ 500；对于60% 的数据，1 ≤ n ≤ 100，1 ≤ m ≤ 1,000，0 ≤ k ≤ 100 ，0 ≤ Di ≤ 100，0 ≤ T i ≤ 10,000 ；对于100%的数据，1 ≤ n ≤ 1,000，1 ≤ m ≤ 10,000 ，0 ≤ k ≤ 100,000，0 ≤ Di ≤ 100 ，0 ≤ T i ≤ 100,000。【Sample input】3 3 21 40 1 31 1 25 2 3【Sample output】10【Sample explanation】对D2 使用2 个加速器，从2 号景点到 3 号景点时间变为 2 分钟。公交车在第1 分钟从1 号景点出发，第2 分钟到达2 号景点，第5 分钟从2 号景点出发，第7 分钟到达 3 号景点。第1 个旅客旅行时间 7-0 = 7 分钟。第2 个旅客旅行时间 2-1 = 1 分钟。第3 个旅客旅行时间 7-5 = 2 分钟。总时间 7+1+2 = 10分钟。 Record6h Analysis1请先思考后再展开 首先，对于同一个点上车的乘客，除了最后那一个，其他人什么时候到达时没有关系的，只影响答案统计但不影响决策，因为他在这个点的等待时间无法改变，所以用lst[i]表示第i个点最后到的人的时间。 先定义几个数组 $tot[t]$=在t点下车的乘客数量 $arr[ t]$=当前方案，开车到t点的时间=$max(arr[t-1],lst[t-1])+d[t]$ 那么思考在什么地方用加速器呢？可以考虑贪心一下 假如要对$(t-1,t)$这条边加速， ①$lst[t]\geq arr[t]$，则对于【不在i点下车的乘客】，旅行时间不变，贡献$tot[t]$ ②$lst[t]&lt;arr[t]​$，贡献$\sum_{i=t}^{g[t]} tot[i]​$，g[t]是当前连续情况②的最后一个，因为一旦碰到①又要等了 然后tot不变，可以搞个前缀和 总结：把没有加速的答案先搞定，然后一个个贪心 复杂度：$O(kn)$ 至于数据……别管了很伪的，反正不会T 但是为什么能贪心呢？这个我没相通，因为感觉决策是变化很大的 Code1请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=1100;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int t,st,ed;&#125;p[11000];int d[MAXN];int tot[MAXN];int arr[MAXN],lst[MAXN];int g[MAXN];//最后影响点//*******************实现*******************//*******************主函数*******************int main()&#123; int n,m,k;scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n-1;i++) scanf("%d",&amp;d[i]); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;p[i].t,&amp;p[i].st,&amp;p[i].ed); lst[p[i].st]=mymax(lst[p[i].st],p[i].t); tot[p[i].ed]++; &#125; for(int i=2;i&lt;=n;i++) tot[i]+=tot[i-1]; arr[1]=lst[1];//debug for(int i=2;i&lt;=n;i++) arr[i]=mymax(arr[i-1],lst[i-1])+d[i-1]; int ans=0;for(int i=1;i&lt;=m;i++) ans+=arr[ p[i].ed ]-p[i].t; while(k--) &#123; g[n-1]=n;for(int i=n-2;i&gt;=1;i--) g[i]=(arr[i+1]&lt;=lst[i+1])?i+1:g[i+1]; int mx=0,t=-1; for(int i=1;i&lt;=n-1;i++)//i~i+1 if(d[i]&gt;0 and mx&lt;tot[g[i]]-tot[i]) &#123; mx=tot[g[i]]-tot[i]; t=i; &#125; if(t&lt;0) break; ans-=mx;d[t]--; for(int i=2;i&lt;=n;i++) arr[i]=mymax(arr[i-1],lst[i-1])+d[i-1]; &#125; printf("%d",ans);&#125; Analysis2请先思考后再展开 费用流~ 感觉思路真的很妙，不好想 但还是很好理解的，而且比贪心慢不了太多，但感觉特别稳 核心： 一次加速器，碰到$lst[t]\geq arr[t]$也就是上面的情况①就会停止 那么也就是说加速器个数超过$max(arr[i]-lst[i],0)$就停止影响 那么考虑把每一个点拆成【到达】和【离开】 然后用变化的【加速器分配方案】作为流量 则构图如下（i作为边i~i+1遍历）： 边 单位流量费用 流量 作用 $S\rightarrow S’$ 0 k 限制总个数 $S’\rightarrow i’$ 0 $d[i]$ $边权\geq 0$ $i’\rightarrow i+1$ $-tot[i+1]$ $INF$ 追求最小 $i\rightarrow i’$ 0 $max(arr[i]-lst[i],0)$ 确保影响范围 $i’\rightarrow T$ 0 $INF$ 统计答案 大功告成！ Code2请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=1100;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Boy&#123; int t,st,ed;&#125;b[11000];int d[MAXN];int tot[MAXN];int arr[MAXN],lst[MAXN];//*******************实现*******************struct Nod&#123; int hou; int dis; int fm,mic; bool v; Nod() &#123; hou=v=0; &#125;&#125;p[MAXN*2];struct Edge&#123; int y,w,c,g; int oth;&#125;e[MAXN*8];int ln=0;void ins(int x,int y,int c,int w)&#123; e[++ln]=(Edge)&#123;y,w,c,p[x].hou,ln+1&#125;;p[x].hou=ln; e[++ln]=(Edge)&#123;x,-w,0,p[y].hou,ln-1&#125;;p[y].hou=ln;&#125;int cost;int q[MAXN*3];bool spfa(int st,int ed)&#123; for(int i=1;i&lt;=ed;i++) p[i].dis=p[i].mic=INF; int tou=1,wei=2;q[1]=st; p[st].v=1;p[st].dis=0;p[st].mic=INF;//debug while(tou!=wei) &#123; int x=q[tou++];if(tou==MAXN) tou=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dis&gt;p[x].dis+e[k].w and e[k].c&gt;0) &#123; p[y].dis=p[x].dis+e[k].w; p[y].mic=mymin(p[x].mic,e[k].c); p[y].fm=k; if(!p[y].v) &#123; p[y].v=1; q[wei++]=y;if(wei==MAXN) wei=1; &#125; &#125; &#125; p[x].v=0; &#125; if(p[ed].dis==INF) return 0; cost+=p[ed].mic*p[ed].dis; int x=ed; while(x!=st) &#123; e[p[x].fm].c-=p[ed].mic; e[e[p[x].fm].oth].c+=p[ed].mic; x=e[e[p[x].fm].oth].y; &#125; return 1;&#125;//*******************主函数*******************int main()&#123; int n,m,k;scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n-1;i++) scanf("%d",&amp;d[i]); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;b[i].t,&amp;b[i].st,&amp;b[i].ed); lst[b[i].st]=mymax(lst[b[i].st],b[i].t); tot[b[i].ed]++; &#125; arr[1]=lst[1];//debug for(int i=2;i&lt;=n;i++) arr[i]=mymax(arr[i-1],lst[i-1])+d[i-1]; int st=2*n+1,st2=st+1,ed=st+2; ins(st,st2,k,0); for(int i=1;i&lt;=n-1;i++) &#123; ins(st2,n+i,d[i],0); ins(i,n+i,mymax(arr[i]-lst[i],0),0); ins(n+i,i+1,INF,-tot[i+1]); ins(i+1,ed,INF,0); &#125; int ans=0;for(int i=1;i&lt;=m;i++) ans+=arr[ b[i].ed ]-b[i].t; cost=0;while(spfa(st,ed)) ; printf("%d",ans+cost);&#125; Analysis3请先思考后再展开 然后猛地发现，虽然上面两种看起来都灰常快，事实上跑官方数据也确实算快 然鹅，理论复杂度都是灰常大的 有没有更快的呢？我才不会告诉你这几个解法我一个都没想到 其实优化一下贪心就好了 把arr的更新，从全部减少为更新范围（根据上面的限制公式） 每次用多几个加速器（根据上面的限制公式） 然后速度就从700ms到了12ms…… Code3请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=1100;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int t,st,ed;&#125;p[11000];int d[MAXN];int tot[MAXN];int arr[MAXN],lst[MAXN];int g[MAXN];//最后影响点//*******************实现*******************int n,m,k;int ans=0;bool solve()&#123; int best_tot=0,best_i,best_wei; int now_k=INF,best_k=INF; int wei=n;//之前的g[] for(int i=n-1;i&gt;=1;i--)//i~i+1 &#123; if(arr[i+1]&lt;=lst[i+1]) &#123; now_k=arr[i+1]; wei=i+1; &#125; else now_k=mymin(now_k,arr[i+1]-lst[i+1]); if(d[i]&gt;0 and best_tot&lt;tot[wei]-tot[i]) &#123; best_tot=tot[wei]-tot[i]; best_i=i; best_wei=wei; best_k=mymin(now_k,mymin(d[i],k)); &#125; &#125; if(best_k==0) return 0; k-=best_k; d[best_i]-=best_k; ans-=best_k*best_tot; for(int i=best_i+1;i&lt;=best_wei;i++) arr[i]-=best_k; return 1;&#125;//*******************主函数*******************int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n-1;i++) scanf("%d",&amp;d[i]); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;p[i].t,&amp;p[i].st,&amp;p[i].ed); lst[p[i].st]=mymax(lst[p[i].st],p[i].t); tot[p[i].ed]++; &#125; arr[1]=lst[1]; for(int i=2;i&lt;=n;i++) &#123; tot[i]+=tot[i-1]; arr[i]=mymax(arr[i-1],lst[i-1])+d[i-1]; &#125; for(int i=1;i&lt;=m;i++) ans+=arr[ p[i].ed ]-p[i].t; while(solve()) ; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>费用流</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1314】聪明的质监员]]></title>
    <url>%2Fposts%2Fe6e5.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2011 提高组 D2T2Luogu1314Caioj1549 Problem【Brief description】小 T 是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有n个矿石，从1到n逐一编号，每个矿石都有自己的重量wi以及价值vi。检验矿产的流程是：1、给定m个区间[Li，Ri]；2、选出一个参数W；3、对于一个区间[Li，Ri]，计算矿石在这个区间上的 检验值Yi：$Y_i = (\sum\limits_j 1) * (\sum\limits_j v_j) , j \in [L_i,R_i] 且 w_j \ge W$即数量×价值和这批矿产的检验结果Y为各个区间的检验值之和。即：Y1+Y2…+Ym通过调整参数W 的值，使得S-Y 的绝对值最小。请你帮忙求出这个最小值。【Input】第一行包含三个整数n，m，S，分别表示矿石的个数、区间的个数和标准值。接下来的n 行，每行2个整数，中间用空格隔开，第i+1 行表示 i 号矿石的重量 wi 和价值vi。接下来的m 行，表示区间，每行2 个整数，中间用空格隔开，第i+n+1 行表示区间[Li,Ri]的两个端点Li 和Ri。【Output】输出只有一行，包含一个整数，表示所求的最小值。【Limited conditions】不同区间可能重合或相互重叠。对于10% 的数据，有 1 ≤n ，m≤10；对于30% 的数据，有 1 ≤n ，m≤500 ；对于50% 的数据，有 1 ≤n ，m≤5,000；对于70% 的数据，有 1 ≤n ，m≤10,000 ；对于100%的数据，有 1 ≤n ，m≤200,000，0 &lt; wi, vi≤10^6，0 &lt; S≤10^12，1 ≤ Li ≤ Ri ≤n 。【Sample input】5 3 151 52 53 54 55 51 52 43 3【Sample output】10【Sample explanation】当 W 选 4 的时候，三个区间上检验值分别为 20、5 、0 ，这批矿产的检验结果为 25，此时与标准值S 相差最小为10。 Record30min Analysis请先思考后再展开 首先这个W是满足二分答案的性质的，log2后大概是40 那我的想法是二份答案验证 但是如果一个一个区间搞，很容易被卡 考虑每次验证，构造两个前缀和 然后一个个区间统计即可 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=200010,MAXM=800010;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int w; ll v;&#125;p[MAXN];struct Qes&#123; int l,r;&#125;q[MAXN];int n,m;ll S;ll cnt[MAXN];ll sum[MAXN];//*******************实现*******************ll check(int w)&#123; cnt[0]=sum[0]=0; for(int i=1;i&lt;=n;i++) &#123; cnt[i]=cnt[i-1]+(p[i].w&gt;=w); sum[i]=sum[i-1]+p[i].v*(p[i].w&gt;=w); &#125; ll ans=0; for(int i=1;i&lt;=m;i++) ans+=(cnt[q[i].r]-cnt[q[i].l-1])*(sum[q[i].r]-sum[q[i].l-1]); return ans;&#125;ll solve()&#123; int l=0,r=1000000; ll ans=ll(INF)*INF; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; ll t=check(mid); if(t&gt;S) ans=mymin(ans,t-S),l=mid+1; else ans=mymin(ans,S-t),r=mid-1; &#125; return ans;&#125;//*******************主函数*******************int main()&#123; scanf("%d%d%lld",&amp;n,&amp;m,&amp;S); for(int i=1;i&lt;=n;i++) scanf("%d%lld",&amp;p[i].w,&amp;p[i].v); for(int i=1;i&lt;=m;i++) scanf("%d%d",&amp;q[i].l,&amp;q[i].r); printf("%lld",solve());&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1313】计算系数]]></title>
    <url>%2Fposts%2F8493.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2011 提高组 D2T1Luogu1313Caioj1548 Problem【Brief description】给定一个多项式(by+ax)^k，请求出多项式展开后x^n*y^m 项的系数。【Input】共一行，包含 5 个整数，分别为 a，b，k，n ，m，每两个整数之间用一个空格隔开。【Output】输出共1 行，包含一个整数，表示所求的系数，这个系数可能很大，输出对10007 取模后的结果。【Limited conditions】对于30% 的数据，有 0 ≤k ≤10 ；对于50% 的数据，有 a = 1，b = 1；对于100%的数据，有 0 ≤k ≤1,000，0≤n, m≤k ，且n+m = k ，0 ≤a ，b ≤1,000,000。【Sample input】1 1 3 1 2【Sample output】3【Sample explanation】无 Record30minwa了一次忘记模底数了以后小心点，20分啊 Analysis请先思考后再展开 二项式定理题目转化：$$C_{n+m}^n \timesa^n \timesb^m$$ Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MOD=10007;const int INF=0x3f3f3f3f;//*******************全局定义*******************int c[1100][1100];//*******************实现*******************int power(int x,int e)&#123; int ans=1;x%=MOD;//debug while(e&gt;0) &#123; if(e&amp;1) ans=(ans*x)%MOD; x=(x*x)%MOD;e&gt;&gt;=1; &#125; return ans;&#125;//*******************主函数*******************int main()&#123; int a,b,k,n,m;scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;k,&amp;n,&amp;m); c[0][0]=1; for(int i=1;i&lt;=n+m;i++) &#123; c[i][0]=1; for(int j=1;j&lt;=i;j++) c[i][j]=(c[i-1][j-1]+c[i-1][j])%MOD; &#125; int ans=((c[n+m][n]*power(a,n)%MOD)*power(b,m))%MOD; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>二项式定理</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1312】Mayan游戏]]></title>
    <url>%2Fposts%2F62b4.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2011 提高组 D1T3Luogu1312Caioj1547 Problem【Brief description】Mayan puzzle是最近流行起来的一个游戏。游戏界面是一个 7 行 5 列的棋盘，上面堆放着一些方块，方块不能悬空堆放，即方块必须放在最下面一行，或者放在其他方块之上。游戏通关是指在规定的步数内消除所有的方块，消除方块的规则如下：1 、每步移动可以且仅可以沿横向（即向左或向右）拖动某一方块一格：当拖动这一方块时，如果拖动后到达的位置（以下称目标位置）也有方块，那么这两个方块将交换位置（参见输入输出样例说明中的图6到图7）；如果目标位置上没有方块，那么被拖动的方块将从原来的竖列中抽出，并从目标位置上掉落（直到不悬空，参见下面图1 和图2）；2 、任一时刻，如果在一横行或者竖列上有连续三个或者三个以上相同颜色的方块，则它们将立即被消除（参见图1 到图3）。上面图1 到图 3 给出了在棋盘上移动一块方块之后棋盘的变化。棋盘的左下角方块的坐标为（0, 0），将位于（3, 3）的方块向左移动之后，游戏界面从图 1 变成图 2 所示的状态，此时在一竖列上有连续三块颜色为4 的方块，满足消除条件，消除连续3 块颜色为4 的方块后，上方的颜色为3 的方块掉落，形成图 3 所示的局面。注意：a) 如果同时有多组方块满足消除条件，几组方块会同时被消除（例如下面图4 ，三个颜色为1 的方块和三个颜色为 2 的方块会同时被消除，最后剩下一个颜色为 2 的方块）。b) 当出现行和列都满足消除条件且行列共享某个方块时，行和列上满足消除条件的所有方块会被同时消除（例如下面图5 所示的情形，5 个方块会同时被消除）。3 、方块消除之后，消除位置之上的方块将掉落，掉落后可能会引起新的方块消除。注意：掉落的过程中将不会有方块的消除。【Input】第一行为一个正整数n ，表示要求游戏通关的步数。接下来的5 行，描述 7*5 的游戏界面。每行若干个整数，每两个整数之间用一个空格隔开，每行以一个0 结束，自下向上表示每竖列方块的颜色编号（颜色不多于10种，从1 开始顺序编号，相同数字表示相同颜色）。【Output】如果有解决方案，输出 n 行，每行包含 3 个整数x，y，g ，表示一次移动，每两个整数之间用一个空格隔开，其中（x，y）表示要移动的方块的坐标，g 表示移动的方向，1 表示向右移动，-1表示向左移动。注意：多组解时，按照 x 为第一关健字，y 为第二关健字，1优先于-1 ，给出一组字典序最小的解。游戏界面左下角的坐标为（0 ，0 ）。如果没有解决方案，输出一行，包含一个整数-1。【Limited conditions】输入数据保证初始棋盘中没有可以消除的方块。对于30% 的数据，初始棋盘上的方块都在棋盘的最下面一行；对于100%的数据，0&lt;n≤5。【Sample input】31 02 1 02 3 4 03 1 02 4 3 4 0【Sample output】2 1 13 1 13 0 1【Sample explanation】按箭头方向的顺序分别为图6 到图11样例输入的游戏局面如上面第一个图片所示，依次移动的三步是：（2，1）处的方格向右移动，（3，1）处的方格向右移动，（3，0）处的方格向右移动，最后可以将棋盘上所有方块消除。 Record3h Analysis请先思考后再展开 首先，把操作看作是相邻交换，所以bfs剪枝：因为有多解的时候优先x、y、右所以如果左边是非空，则交给左边的来搞 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXS=310000;const int tx[4]=&#123;0,0,1,-1&#125;;const int ty[4]=&#123;1,-1,0,0&#125;;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Ans&#123; int x,y,g;&#125;;struct State&#123; int mp[6][8]; int step; Ans ans[11]; State() &#123; memset(mp,0,sizeof(mp)); &#125;&#125;st;set&lt;ll&gt; has;int maxstep;//*******************实现*******************bool okay(int x,int y) &#123;return x&gt;=1 and x&lt;=5 and y&gt;=1 and y&lt;=7;&#125;ll key(State a)//hash&#123; ll ans=0,t=1; for(int i=1;i&lt;=5;i++) for(int j=1;j&lt;=7;j++) &#123; ans+=t*ll(a.mp[i][j]); t*=11; &#125; return ans;&#125;void push(State &amp;a,int i)//自由落体&#123; for(int j=1;j&lt;=7;j++) &#123; while(a.mp[i][j]==0)//debug &#123; int sum=0; for(int k=j+1;k&lt;=7;k++) sum+=a.mp[i][k],swap(a.mp[i][k-1],a.mp[i][k]); if(!sum) break; &#125; &#125;&#125;bool cl[10][10];bool clear(State &amp;a)//消除&#123; memset(cl,0,sizeof(cl)); for(int i=1;i&lt;=5;i++) for(int j=1;j&lt;=7;j++) if(a.mp[i][j]&gt;0) &#123; int ln1=1,l1=i,r1=i,nx; nx=i-1;while(okay(nx,j) and a.mp[nx][j]==a.mp[i][j]) nx--,ln1++,l1--; nx=i+1;while(okay(nx,j) and a.mp[nx][j]==a.mp[i][j]) nx++,ln1++,r1++; int ln2=1,l2=j,r2=j,ny; ny=j-1;while(okay(i,ny) and a.mp[i][ny]==a.mp[i][j]) ny--,ln2++,l2--; ny=j+1;while(okay(i,ny) and a.mp[i][ny]==a.mp[i][j]) ny++,ln2++,r2++; if(ln1&gt;=3) for(int k=l1;k&lt;=r1;k++) cl[k][j]=1; if(ln2&gt;=3) for(int k=l2;k&lt;=r2;k++) cl[i][k]=1; &#125; bool bk=0; for(int i=1;i&lt;=5;i++) for(int j=1;j&lt;=7;j++) if(cl[i][j]) bk=1,a.mp[i][j]=0; if(bk) for(int t=1;t&lt;=5;t++) push(a,t); return bk;&#125;State lst[MAXS];void solve()&#123; st.step=0;has.insert(key(st)); int tou=1,wei=2;lst[1]=st; while(tou!=wei) &#123; State now=lst[tou++];if(tou==MAXS) tou=1; if(now.step==maxstep) break; for(int x=1;x&lt;=5;x++) &#123; for(int y=1;now.mp[x][y]&gt;0;y++)//仅移动有色块 &#123; for(int t=1;t&gt;=-1;t--) &#123; if(t==0) continue; int nx=x+t; if(!okay(nx,y) or now.mp[x][y]==now.mp[nx][y]) continue; if(t&lt;0 and now.mp[nx][y]&gt;0) continue;//剪枝2，从左边过来 State nxt=now; swap(nxt.mp[x][y],nxt.mp[nx][y]); for(int i=1;i&lt;=5;i++) push(nxt,i);//debug while(clear(nxt)) ;//干干净净 nxt.step=now.step+1;nxt.ans[nxt.step]=(Ans)&#123;x,y,t&#125;; ll hs=key(nxt); if(hs==0) &#123; for(int i=1;i&lt;=nxt.step;i++) printf("%d %d %d\n",nxt.ans[i].x-1,nxt.ans[i].y-1,nxt.ans[i].g); return; &#125; if(has.count(hs)) continue;//去重 has.insert(hs); lst[wei++]=nxt;if(wei==MAXS) wei=1; &#125; &#125; &#125; &#125; printf("-1");&#125;//*******************主函数*******************int main()&#123; scanf("%d",&amp;maxstep); for(int i=1;i&lt;=5;i++) for(int t=1;t==1 or st.mp[i][t-1]!=0;t++) scanf("%d",&amp;st.mp[i][t]); solve();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>bfs</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1514】铺地毯]]></title>
    <url>%2Fposts%2F1666.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2011 提高组 D1T1Luogu1514Caioj1544 Problem【Brief description】为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 n 张地毯，编号从 1 到n 。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。【Input】输入共n+2 行。第一行，一个整数n ，表示总共有 n 张地毯。接下来的n 行中，第 i+1 行表示编号i 的地毯的信息，包含四个正整数 a ，b ，g ，k ，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标（a ，b）以及地毯在x轴和y 轴方向的长度。第n+2 行包含两个正整数 x 和y，表示所求的地面的点的坐标（x ，y）。【Output】输出共1 行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出-1 。【Limited conditions】对于30% 的数据，有 n ≤2 ；对于50% 的数据，0 ≤a, b, g, k≤100；对于100%的数据，有 0 ≤n ≤10,000 ，0≤a, b, g, k ≤100,000。【Sample input】31 0 2 30 2 3 32 1 3 32 2【Sample output】3【Sample explanation】如下图，1 号地毯用实线表示，2 号地毯用虚线表示，3 号用双实线表示，覆盖点（2,2）的最上面一张地毯是 3 号地毯。 Record10min Analysis请先思考后再展开 sb题 Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=11000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int a,b,w,h;&#125;p[MAXN];//*******************实现*******************//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d%d%d",&amp;p[i].a,&amp;p[i].b,&amp;p[i].w,&amp;p[i].h); int x,y;scanf("%d%d",&amp;x,&amp;y); for(int i=n;i&gt;=1;i--) &#123; if(x&gt;=p[i].a and y&gt;=p[i].b and x&lt;=p[i].a+p[i].w and y&lt;=p[i].b+p[i].h) &#123; printf("%d",i); return 0; &#125; &#125; printf("-1");&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1514】引水入城]]></title>
    <url>%2Fposts%2Fd2e5.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2010 提高组 T4Luogu1514Caioj1544 Problem【Brief description】在一个遥远的国度，一侧是风景秀美的湖泊，另一侧则是漫无边际的沙漠。该国的行政区划十分特殊，刚好构成一个N 行M 列的矩形，如图所示。其中每个格子都代表一座城市，每座城市都有一个海拔高度。为了使居民们都尽可能饮用到清澈的湖水，现在要在某些城市建造水利设施。水利设施有两种，分别为蓄水厂和输水站。蓄水厂的功能是利用水泵将湖泊中的水抽取到所在城市的蓄水池中。因此，只有与湖泊毗邻的第1 行的城市可以建造蓄水厂。而输水站的功能则是通过输水管线利用高度落差，将湖水从高处向低处输送。故一座城市能建造输水站的前提，是存在比它海拔更高且拥有公共边的相邻城市，已经建有水利设施。由于第N 行的城市靠近沙漠，是该国的干旱区，所以要求其中的每座城市都建有水利设施。那么，这个要求能否满足呢？如果能，请计算最少建造几个蓄水厂；如果不能，求干旱区中不可能建有水利设施的城市数目。【Input】每行中两个数之间用一个空格隔开。输入的第一行是两个正整数 N 和 M，表示矩形的规模。接下来 N 行，每行 M 个正整数，依次代表每座城市的海拔高度。【Output】如果能满足要求，输出的第一行是整数1，第二行是一个整数，代表最少建造几个蓄水厂；如果不能满足要求，输出的第一行是整数0，第二行是一个整数，代表有几座干旱区中的城市不可能建有水利设施。【Limited conditions】【Sample input】3 68 4 5 6 4 47 3 4 3 3 33 2 2 1 1 2【Sample output】13【Sample explanation】上图中，在 3 个粗线框出的城市中建造蓄水厂，可以满足要求。以这 3 个蓄水厂为源头在干旱区中建造的输水站分别用 3 种颜色标出。当然，建造方法可能不唯一。 Record3h Analysis请先思考后再展开 本来看着这个图，硬是yy了一个本来不会的费用流【因为自己灵光一闪发现好久没用啦】然后中午做了两道裸题学会了费用流然后打、调了两个小时这题，建图：把开通一个地方看作费用为1这是因为之前做过一道费用不是单位而是边的题目但其实那道题是每条边只能用一次的，所以没有关系但这道题的话，用费用的时候，spfa完全没有任何比较能力，所以是错误的！心疼我的两小时，特别是今天已经不得不去考统测五而浪费一天时间 然后正解又是爆搜……noip不搞这个会死 首先，如果有解，显然每一个蓄水站，所覆盖的地方一定是一段连续的区间，否则断开的地方别的蓄水站也无法进入于是就变成了区间覆盖问题 那区间，就是l和r，灰常好维护，考虑DP但是不能直接从下往上来DP，从样例就能看出，可能水会往上所以用更加灵活的记忆化搜索代替DP即可 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=510;const int INF=0x3f3f3f3f;const int tx[4]=&#123;0,0,1,-1&#125;;const int ty[4]=&#123;1,-1,0,0&#125;;//*******************全局定义*******************int n,m;int mp[MAXN][MAXN];int l[MAXN][MAXN],r[MAXN][MAXN];bool v[MAXN][MAXN];//*******************实现*******************void dfs(int x,int y)&#123; v[x][y]=1; for(int i=0;i&lt;=3;i++) &#123; int nx=x+tx[i],ny=y+ty[i]; if(nx&gt;=1 and nx&lt;=n and ny&gt;=1 and ny&lt;=m and mp[nx][ny]&lt;mp[x][y]) &#123; if(!v[nx][ny]) dfs(nx,ny); l[x][y]=mymin(l[x][y],l[nx][ny]); r[x][y]=mymax(r[x][y],r[nx][ny]); &#125; &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;mp[i][j]); memset(l,0x3f,sizeof(l)); memset(r,0,sizeof(r)); for(int i=1;i&lt;=m;i++) l[n][i]=r[n][i]=i; for(int i=1;i&lt;=m;i++) if(!v[1][i]) dfs(1,i); int ans=0; for(int i=1;i&lt;=m;i++) if(!v[n][i]) ans++; if(ans&gt;0) printf("0\n%d",ans); else &#123; int lf=1; while(lf&lt;=m) &#123; int rt=0;//最右的覆盖 for(int i=1;i&lt;=m;i++) if(l[1][i]&lt;=lf) rt=mymax(rt,r[1][i]); ans++;lf=rt+1; &#125; printf("1\n%d",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>贪心</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj2135】Farm Tour]]></title>
    <url>%2Fposts%2F2acf.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2010 提高组 T4Poj2135Caioj1544 Problem【Brief description】一个无向图有 N 个点和 M 无向边，出发点是 1，终点为 N求从点1出发到点N再从点N回到点1的最短路程，并且要求每条边只能走一次。【Input】第一行： 两个整数N和M。下来M行，每行三个整数: X Y L 分别表示一条无向边两个点的编号和边的长度。【Output】输出一个整数，最短路程。【Limited conditions】1&lt;=N&lt;=10001&lt;=M&lt;=10000每条边的长度小于等于35000。【Sample input】4 51 2 12 3 13 4 11 3 22 4 2【Sample output】6【Sample explanation】无 Record30min Analysis请先思考后再展开 最小费用最大流把边权作为边的费用，1作为边的容量即可 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int INF=0x3f3f3f3f;const int MAXN=1100,MAXM=41000;//*******************全局定义*******************struct Nod&#123; int hou; int dis; bool v; int fm; Nod() &#123; hou=v=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,w,c,g;&#125;e[MAXM];int ln=0;void ins(int x,int y,int w,int c)&#123; e[++ln].y=y;e[ln].w=w;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; e[++ln].y=x;e[ln].w=-w;e[ln].c=0; e[ln].g=p[y].hou;p[y].hou=ln;&#125;int getoth(int t) &#123;return (t&amp;1)?t+1:t-1;&#125;//*******************实现*******************int n;int st,ed;int lst[MAXN];bool spfa()&#123; for(int i=st;i&lt;=ed;i++) p[i].dis=INF; int tou=1,wei=2;lst[1]=st; p[st].v=1;p[st].dis=0; while(tou!=wei) &#123; int x=lst[tou++]; if(tou==MAXN) tou=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dis&gt;p[x].dis+e[k].w and e[k].c&gt;0)//debug &#123; p[y].dis=p[x].dis+e[k].w; p[y].fm=k; if(p[y].v==0) &#123; p[y].v=1; lst[wei++]=y; if(wei==MAXN) wei=1; &#125; &#125; &#125; p[x].v=0; &#125; return p[ed].dis&lt;INF;&#125;int mincost()&#123; int ans=0; while(spfa()) &#123; ans+=p[ed].dis; int x=ed; while(x!=st) &#123; int k=p[x].fm,ok=getoth(k); e[k].c-=1; e[ok].c+=1; x=e[ok].y; &#125; &#125; return ans;&#125;//*******************主函数*******************int main()&#123; int m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; int x,y,w;scanf("%d%d%d",&amp;x,&amp;y,&amp;w); ins(x,y,w,1);ins(y,x,w,1); &#125; st=0,ed=n+1; ins(st,1,0,2);ins(n,ed,0,2); printf("%d",mincost());&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1525】关押罪犯]]></title>
    <url>%2Fposts%2F8b22.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2010 提高组 T3Luogu1525Caioj1543 Problem【Brief description】S 城现有两座监狱，一共关押着N 名罪犯，编号分别为1~N。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为c 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 c 的冲突事件。每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到S 城Z 市长那里。公务繁忙的Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。在详细考察了N 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。那么，应如何分配罪犯，才能使Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？【Input】每行中两个数之间用一个空格隔开。第一行为两个正整数 N 和 M，分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的 M 行每行为三个正整数aj，bj，cj，表示 aj 号和 bj 号罪犯之间存在仇恨，其怨气值为cj。【Output】共1 行，为Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出0。【Limited conditions】数据保证1&lt;=aj&lt;=bj&lt;=N，0&lt;cj≤1,000,000,000，且每对罪犯组合只出现一次。对于30%的数据有N≤ 15。对于70%的数据有N≤ 2000，M≤ 50000。对于100%的数据有N≤ 20000，M≤ 100000。【Sample input】4 61 4 25342 3 35121 2 283511 3 66182 4 18053 4 12884【Sample output】3512【Sample explanation】罪犯之间的怨气值如下面左图所示，右图所示为罪犯的分配方法，市长看到的冲突事件影响力是3512（由 2 号和 3 号罪犯引发）。其他任何分法都不会比这个分法更优。 Record30min Analysis请先思考后再展开 考虑一个贪心：优先处理权值大的关系证明：因为本题求的是最大值，如果放弃当前，那么无论你后面多么优秀，答案都是确定的然后因为要维护互斥的关系，可以很巧妙地用拆点解决，然后就可以并查集了 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; int fa[41000]; int findfa(int x) &#123;return fa[x]=(fa[x]==x?x:findfa(fa[x]));&#125; struct Edge &#123; int x,y,c; &#125;e[110000]; bool cmp(Edge a,Edge b) &#123;return a.c&gt;b.c;&#125; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n*2;i++) fa[i]=i; for(int i=1;i&lt;=m;i++) scanf("%d%d%d",&amp;e[i].x,&amp;e[i].y,&amp;e[i].c); sort(e+1,e+m+1,cmp); for(int i=1;i&lt;=m;i++) &#123; int x=e[i].x,y=e[i].y; int fx=findfa(x),fy=findfa(y); if(fx==fy) &#123;printf("%d",e[i].c);return;&#125; fa[fx]=findfa(y+n); fa[fy]=findfa(x+n); &#125; puts("0"); &#125;&#125;;int main()&#123; mine::main();&#125; Analysis2请先思考后再展开 也可以二分答案，然后对于大于mid的边，判断是否是二分图]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1541】乌龟棋]]></title>
    <url>%2Fposts%2Fe616.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2010 提高组 T2Luogu1541Caioj1542 Problem【Brief description】乌龟棋的棋盘是一行N个格子，每个格子上一个分数（非负整数）。棋盘第1格是唯一的起点，第N格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。乌龟棋中M张爬行卡片，分成4种不同的类型（M张卡片中不一定包含所有4种类型的卡片，见样例），每种类型的卡片上分别标有1、2、3、4四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？【Input】第1行2个正整数N和M，分别表示棋盘格子数和爬行卡片数。第2行N个非负整数，a1 a2……aN，其中ai表示棋盘第i个格子上的分数。第3行M个整数，b1 b2……bM，表示M张爬行卡片上的数字。输入数据保证到达终点时刚好用光M张爬行卡片。【Output】1个整数，表示小明最多能得到的分数。【Limited conditions】对于30%的数据有1≤N≤30，1≤M≤12。对于50%的数据有1≤N≤120，1≤M≤50，且4种爬行卡片，每种卡片的张数不会超过20。对于100%的数据有1≤N≤350，1≤M≤120，且4种爬行卡片，每种卡片的张数不会超过40；0≤ai≤100，1≤i≤N；1≤bi≤4，1≤i≤M。【Sample input】9 56 10 14 2 8 8 18 5 171 3 1 2 1【Sample output】73【Sample explanation】小明使用爬行卡片顺序为1，1，3，1，2，得到的分数为6+10+14+8+18+17=73。注意，由于起点是1，所以自动获得第1格的分数6。 Record30min Analysis请先思考后再展开 一眼DP,12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970空间：2560000时间：21760000枚举的时候按照n、d、c、b的顺序&#123;% endfold %&#125;## Code&#123;% fold 请先思考后再展开 %&#125;```cpp//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN &quot;%I64d&quot;#else#define BIGN &quot;%lld&quot;#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int INF=0x3f3f3f3f;const int MAXN=10;//*******************全局定义*******************int ct[5];int s[400];int f[50][50][50][50];//*******************实现*******************//*******************主函数*******************int main()&#123; int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;=n-1;i++) scanf(&quot;%d&quot;,&amp;s[i]); for(int i=1;i&lt;=m;i++) &#123; int t; scanf(&quot;%d&quot;,&amp;t); ct[t]++; &#125; f[0][0][0][0]=s[0]; for(int i=0;i&lt;=n-2;i++) &#123; for(int d=0;d&lt;=ct[4];d++) &#123; for(int c=0;c&lt;=ct[3];c++) &#123; for(int b=0;b&lt;=ct[2];b++) &#123; int a=i-4*d-3*c-2*b; if(a&lt;0) break; if(a&gt;ct[1]) continue;//debug f[a+1][b][c][d]=mymax(f[a+1][b][c][d],f[a][b][c][d]+s[i+1]); f[a][b+1][c][d]=mymax(f[a][b+1][c][d],f[a][b][c][d]+s[i+2]); f[a][b][c+1][d]=mymax(f[a][b][c+1][d],f[a][b][c][d]+s[i+3]); f[a][b][c][d+1]=mymax(f[a][b][c][d+1],f[a][b][c][d]+s[i+4]); &#125; &#125; &#125; &#125; printf(&quot;%d&quot;,f[ct[1]][ct[2]][ct[3]][ct[4]]);//n-1&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1075】机器翻译]]></title>
    <url>%2Fposts%2F3759.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2010 提高组 T1Luogu1540Caioj1541 Problem【Brief description】小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。题目描述这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。假设内存中有M个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过M-1，软件会将新单词存入一个未使用的内存单元；若内存中已存入M个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。假设一篇英语文章的长度为N个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。【Input】第一行为两个正整数M和N，代表内存容量和文章的长度。第二行为N个非负整数，按照文章的顺序，每个数（大小不超过1000）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。【Output】软件需要查词典的次数。【Limited conditions】对于10%的数据有M=1，N≤5。对于100%的数据有0&lt;=M&lt;=100，0&lt;=N&lt;=1000。【Sample input】3 71 2 1 5 4 4 1【Sample output】5【Sample explanation】整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：空：内存初始状态为空。1． 1：查找单词1并调入内存。2． 1 2：查找单词2并调入内存。3． 1 2：在内存中找到单词1。4． 1 2 5：查找单词5并调入内存。5． 2 5 4：查找单词4并调入内存替代单词1。6． 2 5 4：在内存中找到单词4。7． 5 4 1：查找单词1并调入内存替代单词2。共计查了5次词典。 Record10min Analysis请先思考后再展开 sb题 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int INF=0x3f3f3f3f;const int MAXN=10;//*******************全局定义*******************deque&lt;int&gt; q;bool v[1100];//*******************实现*******************//*******************主函数*******************int main()&#123; int m,n;scanf("%d%d",&amp;m,&amp;n); int ans=0; for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); if(!v[t]) &#123; v[t]=1; if(q.size()==m) v[q.front()]=0,q.pop_front(); q.push_back(t); ans++; &#125; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1075】靶形数独]]></title>
    <url>%2Fposts%2Fead0.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2009 提高组 T4Luogu1074Caioj1540 Problem【Brief description】小城和小华都是热爱数学的好学生，最近，他们不约而同地迷上了数独游戏，好胜的他们想用数独来一比高低。但普通的数独对他们来说都过于简单了，于是他们向 Z博士请教，Z 博士拿出了他最近发明的“靶形数独” ，作为这两个孩子比试的题目。靶形数独的方格同普通数独一样，在9×9的大九宫格中有9个3×3的小九宫格（用粗黑色线隔开的）。在这个大九宫格中，有一些数字是已知的，根据这些数字，利用逻辑推理，在其他的空格上填入1到9的数字。每个数字在每个小九宫格内不能重复出现，每个数字在每行、每列也不能重复出现。但靶形数独有一点和普通数独不同，即每一个方格都有一个分值，而且如同一个靶子一样，离中心越近则分值越高。比赛的要求是：每个人必须完成一个给定的数独（每个给定数独可能有不同的填法） ，而且要争取更高的总分数。而这个总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和。如图，在以下的这个已经填完数字的靶形数独游戏中，总分数为 2829。游戏规定，将以总分数的高低决出胜负。求出对于给定的靶形数独，能够得到的最高分数。【Input】一共 9 行。每行 9 个整数（每个数都在0—9的范围内），表示一个尚未填满的数独方格，未填的空格用“0”表示。每两个数字之间用一个空格隔开。【Output】输出可以得到的靶形数独的最高分数。如果这个数独无解，则输出整数-1。【Limited conditions】40%的数据，数独中非0数的个数不少于30。80%的数据，数独中非0数的个数不少于26。100%的数据，数独中非0数的个数不少于24。【Sample input】7 0 0 9 0 0 0 0 11 0 0 0 0 5 9 0 00 0 0 2 0 0 0 8 00 0 5 0 2 0 0 0 30 0 0 0 0 0 6 4 84 1 3 0 0 0 0 0 00 0 7 0 0 2 0 9 02 0 1 0 6 0 8 0 40 8 0 5 0 4 0 1 2【Sample output】2829【Sample explanation】无 Record3h Analysis1请先思考后再展开 通过估价函数（实时变化），也就是通过行、列、宫确定数来找最优决策顺序然后暴力即可 本代码可100，但有点危险而且还牺牲了最优化方案【某种平衡？】有点莫队中【分块与哈密顿距离最小生成树】的感觉 UP:洗了个澡回来就想了种新想法：其实直接预处理出顺序就好了瞬间比所谓”跳舞链“差不了多少 应该比大部分题解快而简单了吧于是就是很稳的正解啦！ Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int INF=0x3f3f3f3f;const int MAXN=10;const int score[MAXN][MAXN]=&#123; &#123;0,0,0,0,0,0,0,0,0,0&#125;, &#123;0,6,6,6,6,6,6,6,6,6&#125;, &#123;0,6,7,7,7,7,7,7,7,6&#125;, &#123;0,6,7,8,8,8,8,8,7,6&#125;, &#123;0,6,7,8,9,9,9,8,7,6&#125;, &#123;0,6,7,8,9,10,9,8,7,6&#125;, &#123;0,6,7,8,9,9,9,8,7,6&#125;, &#123;0,6,7,8,8,8,8,8,7,6&#125;, &#123;0,6,7,7,7,7,7,7,7,6&#125;, &#123;0,6,6,6,6,6,6,6,6,6&#125;&#125;;//*******************全局定义*******************int mp[MAXN][MAXN];bool hang[MAXN][MAXN],lie[MAXN][MAXN],block[MAXN][MAXN];int hangs[MAXN],lies[MAXN],blocks[MAXN];int n;//*******************实现*******************int getid(int x,int y) &#123; return ((x-1)/3)*3+(y-1)/3+1; &#125;void getmx(int &amp;nx,int &amp;ny)&#123; int mx=-1;//debug for(int i=1;i&lt;=9;i++) for(int j=1;j&lt;=9;j++) if(mp[i][j]==0) &#123; int t=hangs[i]+lies[j]+blocks[ getid(i,j) ]; if(t&gt;mx) mx=t,nx=i,ny=j; &#125; //9的常数 /*int mx; mx=-1;for(int i=1;i&lt;=9;i++) if(hangs[i]&gt;mx and hangs[i]&lt;9) mx=hangs[i],nx=i; mx=-1;for(int j=1;j&lt;=9;j++) if(lies[j]&gt;mx and !mp[nx][j]) mx=lies[j],ny=j;*/ //玄学，但有用的估价？ //有点莫队中【分块与哈密顿距离最小生成树】的感觉&#125;pair&lt;int,int&gt; ss[MAXN*MAXN];void pre()&#123; for(int i=1;i&lt;=n;i++) &#123; int x,y;getmx(x,y); ss[i].first=x;ss[i].second=y; mp[x][y]=1;//仅标记 hangs[x]++;lies[y]++;blocks[getid(x,y)]++; &#125; for(int i=1;i&lt;=n;i++) &#123; int x=ss[i].first,y=ss[i].second; mp[x][y]=0;//仅标记 hangs[x]--;lies[y]--;blocks[getid(x,y)]--; &#125;&#125;int maxscore=-1;void dfs(int x,int y,int dep,int nowsc)&#123; if(dep&gt;n) &#123; maxscore=mymax(maxscore,nowsc); return; &#125; int id=getid(x,y); mp[x][y]=1;//仅标记 hangs[x]++;lies[y]++;blocks[id]++; int nx=ss[dep+1].first,ny=ss[dep+1].second; for(int i=1;i&lt;=9;i++) &#123; if(hang[x][i] or lie[y][i] or block[id][i]) continue; hang[x][i]=lie[y][i]=block[id][i]=1; dfs(nx,ny,dep+1,nowsc+i*score[x][y]); hang[x][i]=lie[y][i]=block[id][i]=0; &#125; mp[x][y]=0;//仅标记 hangs[x]--;lies[y]--;blocks[id]--;&#125;//*******************主函数*******************int main()&#123; int nowsc=0; for(int i=1;i&lt;=9;i++) for(int j=1;j&lt;=9;j++) &#123; scanf("%d",&amp;mp[i][j]); int d=mp[i][j]; if(d&gt;0) &#123; hang[i][d]=1;hangs[i]++; lie[j][d]=1;lies[j]++; int id=getid(i,j);block[id][d]=1;blocks[id]++; nowsc+=mp[i][j]*score[i][j]; &#125; else n++; &#125; pre(); dfs(ss[1].first,ss[1].second,1,nowsc); printf("%d",maxscore);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>模拟</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1073】最优贸易]]></title>
    <url>%2Fposts%2Fb656.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2009 提高组 T3Luogu1073Caioj1539 Problem【Brief description】C 国有 n 个大城市和 m 条道路，每条道路连接这 n 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 m 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 1 条。C 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。商人阿龙来到 C 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 C 国 n 个城市的标号从 1~n，阿龙决定从 1 号城市出发，并最终在 n 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 n 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品——水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 C 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。现在给出 n 个城市的水晶球价格，m 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。【Input】第一行包含 2 个正整数 n 和 m，中间用一个空格隔开，分别表示城市的数目和道路的数目。第二行 n 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 n 个城市的商品价格。接下来 m 行，每行有 3 个正整数，x，y，z，每两个整数之间用一个空格隔开。如果 z=1，表示这条道路是城市 x 到城市 y 之间的单向道路；如果 z=2，表示这条道路为城市 x 和城市y 之间的双向道路。【Output】共 1 行，包含 1 个整数，表示最多能赚取的旅费。如果没有进行贸易，则输出 0。【Limited conditions】输入数据保证 1 号城市可以到达 n 号城市。对于 10%的数据，1≤n≤6。对于 30%的数据，1≤n≤100。对于 50%的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。对于 100%的数据，1≤n≤100000，1≤m≤500000，1≤x，y≤n，1≤z≤2，1≤各城市水晶球价格≤100。【Sample input】5 54 3 5 6 11 2 11 4 12 3 23 5 14 5 2【Sample output】5【Sample explanation】C 国有 5 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。假设 1~n 号城市的水晶球价格分别为 4，3，5，6，1。阿龙可以选择如下一条线路：1-&gt;2-&gt;3-&gt;5，并在 2 号城市以 3 的价格买入水晶球，在 3号城市以 5 的价格卖出水晶球，赚取的旅费数为 2。阿龙也可以选择如下一条线路 1-&gt;4-&gt;5-&gt;4-&gt;5，并在第 1 次到达 5 号城市时以 1 的价格买入水晶球，在第 2 次到达 4 号城市时以 6 的价格卖出水晶球，赚取的旅费数为 5。 Record1h Analysis1请先思考后再展开 图上灰常规DP注意两个很重要的剪枝【如果不喜欢剪枝，可以用强连通搞一搞，总之就是避免环】 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int INF=0x3f3f3f3f;const int MAXN=110000,MAXM=1100000;//*******************全局定义*******************struct Nod&#123; int hou,c; Nod() &#123; hou=c=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXM];int ln=0;void ins(int x,int y)&#123; e[++ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;int mix[MAXN];int f[MAXN];//走到i的最大收益//*******************实现*******************void dfs(int x,int fa,int mi)//路上最便宜&#123; bool bk=0; mi=mymin(mi,p[x].c);//剪枝1 if(mi&lt;mix[x]) mix[x]=mi,bk=1; int mx=mymax(f[fa],p[x].c-mi);//剪枝2 if(mx&gt;f[x]) f[x]=mx,bk=1; if(!bk) return; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; dfs(y,x,mi); &#125;&#125;//*******************主函数*******************int main()&#123; memset(mix,63,sizeof(mix)); int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i].c); while(m--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y);if(c&gt;1) ins(y,x); &#125; dfs(1,0,INF); printf("%d",f[n]);&#125; Analysis2请先思考后再展开 主要到这道题的方法灰常多，算是不错的题目，比较创新而且大家都是尽力简化各种方法各种奇奇怪怪题解嗯以我的尿性，肯定是选了最简单最快的了…… UP 2018.8.29看了看正规的做法，其实一点都不难对于这种，和路径上先后顺序有关的题目，可以按照节点，把路径拆分一下具体而言就是计算出每个节点，在原图上过来的所有路径中最小，反图上过来最大，这两个信息具体实现大概用spfa会比较方便]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>并查集</tag>
        <tag>DP</tag>
        <tag>难度1</tag>
        <tag>精品题</tag>
        <tag>模拟</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1071】潜伏者]]></title>
    <url>%2Fposts%2F9e5c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2009 提高组 T1Luogu1071Caioj1537 Problem【Brief description】R 国和 S 国正陷入战火之中，双方都互派间谍，潜入对方内部，伺机行动。历尽艰险后，潜伏于 S 国的 R 国间谍小 C 终于摸清了 S 国军用密码的编码规则：1. S 国军方内部欲发送的原信息经过加密后在网络上发送，原信息的内容与加密后所得的内容均由大写字母‘A’-‘Z’构成（无空格等其他字符）。2. S 国对于每个字母规定了对应的“密字”。加密的过程就是将原信息中的所有字母替换为其对应的“密字”。3. 每个字母只对应一个唯一的“密字”，不同的字母对应不同的“密字”。“密字”可以和原字母相同。例如，若规定‘A’的密字为‘A’，‘B’的密字为‘C’（其他字母及密字略），则原信息“ABA”被加密为“ACA”。现在，小C通过内线掌握了 S 国网络上发送的一条加密信息及其对应的原信息。小C希望能通过这条信息，破译S国的军用密码。小C的破译过程是这样的：扫描原信息，对于原信息中的字母 x（代表任一大写字母），找到其在加密信息中的对应大写字母 y，并认为在密码里 y 是 x 的密字。如此进行下去直到停止于如下的某个状态：1. 所有信息扫描完毕，‘A’-‘Z’ 所有 26 个字母在原信息中均出现过并获得了相应的“密字”。2. 所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现。3. 扫描中发现掌握的信息里有明显的自相矛盾或错误（违反 S 国密码的编码规则）。例如某条信息“XYZ”被翻译为“ABA”就违反了“不同字母对应不同密字”的规则。在小C忙得头昏脑涨之际，R国司令部又发来电报，要求他翻译另外一条从S国刚刚截取到的加密信息。现在请你帮助小 C：通过内线掌握的信息，尝试破译密码。然后利用破译的密码，翻译电报中的加密信息。【Input】第 1 行为小 C 掌握的一条加密信息。第 2 行为第 1 行的加密信息所对应的原信息。第 3 行为 R 国司令部要求小 C 翻译的加密信息。输入数据保证所有字符串仅由大写字母‘A’-‘Z’构成，且第 1 行长度与第 2 行相等。【Output】共 1 行。若破译密码停止时出现 2，3 两种情况，请你输出“Failed”（不含引号，注意首字母大写，其它小写）。否则请输出利用密码翻译电报中加密信息后得到的原信息。【Limited conditions】字符串长度在 1 到 100 之间。【Sample input 1】AAABEOWIE【Sample output 1】Failed【Sample input 2】QWERTYUIOPLKJHGFDSAZXCVBNABCDEFGHIJKLMNOPQRSTUVWXYDSLIEWO【Sample output 2】Failed【Sample input 3】MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPPYIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLLFLSO【Sample output 3】NOIP【Sample explanation】【输入输出样例 1 说明】原信息中的字母‘A’和‘B’对应相同的密字，输出“Failed”。【输入输出样例 2 说明】字母‘Z’在原信息中没有出现，输出“Failed”。 Record30min Analysis请先思考后再展开 模拟即可 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int INF=0x3f3f3f3f;//*******************全局定义*******************char s1[110],s2[110],s3[110];int to[30];//*******************实现*******************//*******************主函数*******************int main()&#123; scanf("%s%s%s",s1+1,s2+1,s3+1); int ln1=strlen(s1+1),ln3=strlen(s3+1); bool bk=0; for(int i=1;i&lt;=ln1;i++) &#123; if(to[s1[i]-'A'+1]&gt;0 and to[s1[i]-'A'+1]!=s2[i]) bk=1; to[s1[i]-'A'+1]=s2[i]; &#125; for(int i=1;i&lt;=26;i++) if(to[i]==0) bk=1; for(int i=1;i&lt;=25;i++) for(int j=i+1;j&lt;=26;j++) if(to[i]&gt;0 and to[i]==to[j]) bk=1; if(bk) printf("Failed"); else for(int i=1;i&lt;=ln3;i++) putchar( to[s3[i]-'A'+1] );&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1072】Hankson的趣味题]]></title>
    <url>%2Fposts%2F7398.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2009 提高组 T2Luogu1072Caioj1538 Problem【Brief description】已知正整数 a0,a1,b0,b1，正整数 x 满足：1. gcd(x,a0)=a12. lcm(x,b0)=b1求x的个数【Input】第一行为一个正整数 n，表示有 n 组输入数据。接下来的 n 行每行一组输入数据，为四个正整数 a0，a1，b0，b1，每两个整数之间用一个空格隔开。【Output】共 n 行。每组输入数据的输出结果占一行，为一个整数。对于每组数据：若不存在这样的 x，请输出 0；若存在这样的 x，请输出满足条件的 x 的个数；【Limited conditions】输入数据保证 a0 能被 a1 整除，b1 能被 b0 整除。对于 50%的数据，保证有 1≤a0，a1，b0，b1≤10000 且 n≤100。对于 100%的数据，保证有 1≤a0，a1，b0，b1≤2,000,000,000 且 n≤2000。【Sample input】241 1 96 28895 1 37 1776【Sample output】62【Sample explanation】第一组输入数据，x 可以是 9、18、36、72、144、288，共有 6 个。第二组输入数据，x 可以是 48、1776，共有 2 个。 Record1h Analysis1请先思考后再展开 优雅的暴力：观察柿子，不难发现x是a1的倍数，b1的约数枚举b1约数即x，验证即可 时间复杂度：最坏$O(n*sqrt(b1)*log2(b1))$极限26亿，然鹅luogu上还是很快的 Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;//*******************全局常量*******************const int MAXN=150;//*******************全局定义*******************//*******************实现*******************int gcd(int x,int y) &#123;return (y==0)?x:gcd(y,x%y);&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); while(n--) &#123; int a0,a1,b0,b1;scanf("%d%d%d%d",&amp;a0,&amp;a1,&amp;b0,&amp;b1); int ans=0; for(int x=1;x*x&lt;=b1;x++) &#123; if(b1%x==0 and x%a1==0 and gcd(x,a0)==a1 and gcd(x,b0)*b1==x*b0) ++ans; int tx=b1/x; if(tx!=x and b1%tx==0 and tx%a1==0 and gcd(tx,a0)==a1 and gcd(tx,b0)*b1==tx*b0) ++ans; &#125; printf("%d\n",ans); &#125;&#125; Analysis2请先思考后再展开 虽然过去了，显然跑得很慢呀 UP 2018.8.6：讲讲正解吧为了方便，改改字母gcd(x,a)=clcm(x,b)=d 先从优化的角度反思上面的做法，我们可以把暴力判断gcd消耗的log省去具体做法是，从质因数p的层面上考虑gcd和lcm，那么就变成了次幂的min和max也就是说，枚举约数质因数p，设其在a,b,c,d,x中次幂数分别是ma,mb,mc,md,mx对于gcd：①$ma=mc,mx&gt;=mc$②$ma&gt;mc,mx=mc$③$ma&lt;mc,无解$对于lcm：①$mb=md,mx=md$②$mb&lt;md,mx=md$③$mb&gt;md,无解$ 合并情况如下：①$ma=mc,mb=md,mc&lt;=md,则mc&lt;=mx&lt;=md$，共md-mc+1种②$ma=mc,mb&lt;md,mc&lt;=md,则mx=md$，共1种③$ma&gt;mc,mb=md,mc&lt;=md,则mx=mc$，共1种④$ma&gt;mc,mb&lt;md,mc=md,则mx=mc=md$，共1种⑤其他，无解 最后把每种p下，mx可行的选择数乘法原理即可把质数预处理一下，然后根据分布数量这样的复杂度是$O(n \times \sqrt d / log_2( \sqrt d) )$ Code2请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;const int MAXNUM=50000;int prime[MAXNUM],pr=0;bool v[MAXNUM];void pre()&#123; for(int i=2;i&lt;MAXNUM;i++) &#123; if(!v[i]) prime[++pr]=i; for(int j=1;j&lt;=pr and ll(i)*prime[j]&lt;MAXNUM;j++) &#123; v[i*prime[j]]=1; if(i%prime[j]==0) break; &#125; &#125;&#125;int a,b,c,d;int ans;void solve(int prm)&#123; int ma=0;while(a%prm==0) ma++,a/=prm; int mb=0;while(b%prm==0) mb++,b/=prm; int mc=0;while(c%prm==0) mc++,c/=prm; int md=0;while(d%prm==0) md++,d/=prm; if(ma==mc and mb==md and mc&lt;=md) ans*=md-mc+1; else if(ma==mc and mb&lt;md and mc&lt;=md) ; else if(ma&gt;mc and mb==md and mc&lt;=md) ; else if(ma&gt;mc and mb&lt;md and mc==md) ; else ans=0;&#125;int main()&#123; pre(); int T;scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d%d%d",&amp;a,&amp;c,&amp;b,&amp;d); ans=1; for(int i=1;i&lt;=pr;i++) if(d%prime[i]==0) solve(prime[i]); if(d&gt;1) solve(d);//剩下的唯一质因数 printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1155】双栈排序]]></title>
    <url>%2Fposts%2F958b.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2008 提高组 T4Luogu1155Caioj1536 Problem【Brief description】Tom最近在研究一个有趣的排序问题。如图所示，通过2个栈S1和S2，Tom希望借助以下4种操作实现将输入序列升序排序。操作a如果输入序列不为空，将第一个元素压入栈S1操作b如果栈S1不为空，将S1栈顶元素弹出至输出序列操作c如果输入序列不为空，将第一个元素压入栈S2操作d如果栈S2不为空，将S2栈顶元素弹出至输出序列如果一个1~n的排列P可以通过一系列操作使得输出序列为1，2，…，(n-1)，n，Tom就称P是一个“可双栈排序排列”。例如(1,3,2,4)就是一个“可双栈排序序列”，而(2,3,4,1)不是。下图描述了一个将(1,3,2,4)排序的操作序列：&lt;a,c,c,b,a,d,d,b&gt;当然，这样的操作序列有可能有几个，对于上例(1,3,2,4)，&lt;a,c,c,b,a,d,d,b&gt;是另外一个可行的操作序列。Tom希望知道其中字典序最小的操作序列是什么。【Input】第一行是一个整数n。第二行有n个用空格隔开的正整数，构成一个1~n的排列。【Output】共一行，如果输入的排列不是“可双栈排序排列”，输出数字0；否则输出字典序最小的操作序列，每两个操作之间用空格隔开，行尾没有空格。【Limited conditions】30%的数据满足：n&lt;=1050%的数据满足：n&lt;=50100%的数据满足：n&lt;=1000【Sample input】41 3 2 4【Sample output】a b a a b b a b【Sample explanation】无 Record2h这种题打不了暴力，建议手出数据检验 Analysis1请先思考后再展开 首先，因为放进去就不变了，两个栈都要保持单调递减考虑栈在排序中起了什么作用，其实就是辅助交换逆序对 那么很好想的方法一：贪心也就是说，尽量找操作编号小的来搞 先想简单的出栈，判断条件很简单：只要是当前需要输出的值在栈顶就弹出因为显然弹出一定最优 但是，入栈是有一定条件滴（以下数值都表示相对大小）既然是“双”，有一个经典的套路思想：由一及多先从单栈排序思考：如果出现2…3…1的情况，则无解而有了第二个栈（设为辅栈），就有了缓冲空间，但一旦出现如2…3…4…1的情况，就会炸分析一下为什么？ “1”的存在使2、3不能弹出 “3”和“4”的存在，都无法满足递减的要求 然鹅，双栈的特点在于多种可能所以即使没有直接像上面一样无解，也不能乱入栈，特别是到底入哪个栈考虑哪些情况会导致不能共存（这个方法二也会有）如3…2…5…1？那把5放辅栈就好了，这不是我们当前搞“2”要考虑的【当辅栈什么也没有，我们多了一条命】但，如果辅栈有东西呢？3…2…5…14哇肿么办【可以发现，这个其实无解，但这是等到5的时候再判断的】 “1”的存在又是让我们不能轻易弹出 “4”的存在让5不能过去所以这个时候，只能把“2”放过去 总结：对于主栈，即使有top1&gt;a[now]，如果有a[now]&lt;a[x1]且top2&lt;a[x1]同时有a[now]&gt;a[x2]限制弹出，则now只能尝试去辅栈上述条件对辅栈无效，因为辅栈没用就直接GG了 这样一来，判断无解就简单很多了：什么也干不了的时候 时间复杂度：O(n^2) Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************//*******************全局定义*******************int n,a[1100],now=1;int ned=1,ans[2100];stack&lt;int&gt; s1,s2;//*******************实现*******************bool check()&#123; if(s1.empty() or s2.empty()) return 1;//无敌 int x; for(x=now+1;x&lt;=n;x++) if(a[now]&lt;a[x] and s2.top()&lt;a[x]) break; for(x=x+1;x&lt;=n;x++) if(a[now]&gt;a[x]) return 0; return 1;&#125;bool solve()&#123; for(int i=1;i&lt;=2*n;i++) &#123; if(now&lt;=n and ( (s1.empty())or(s1.top()&gt;a[now]) ) and check()) &#123; ans[i]=1; s1.push(a[now++]); continue; &#125; if(!s1.empty() and s1.top()==ned) &#123; ans[i]=2; s1.pop(); ned++; continue; &#125; if(now&lt;=n and ( (s2.empty())or(s2.top()&gt;a[now]) )) &#123; ans[i]=3; s2.push(a[now++]); continue; &#125; if(!s2.empty() and s2.top()==ned) &#123; ans[i]=4; s2.pop(); ned++; continue; &#125; return 0;//无计可施 &#125; return 1;&#125;//*******************主函数*******************int main()&#123; scanf("%d",&amp;n);for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); if(!solve()) printf("0"); else for(int i=1;i&lt;=2*n;i++) printf("%c ",ans[i]+'a'-1);&#125; Analysis2请先思考后再展开 贪心这种东西，其实挺好的但考场上打还是要慎重所以考虑另一种显然的算法：二分图染色构图就是用不能共存的条件，从而划分为两个集合原因：只有两个栈 然后这种做法代码长一点，但比较无脑~时间复杂度：O(n^2) 【但事实上更快】 Code2请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=1100;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int hou,c; Nod() &#123; hou=c=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXN*2];int ln=0;void ins(int x,int y)&#123; e[++ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;bool bk=0;void dfs(int x,int c)&#123; p[x].c=c; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].c==c) bk=1; if(!p[y].c) dfs(y,3-c); &#125;&#125;int n,a[MAXN];int mi[MAXN];//*******************实现*******************int now=1,ned=1;stack&lt;int&gt; s1,s2;bool solve()&#123; for(int i=1;i&lt;=2*n;i++) &#123; if(now&lt;=n and p[now].c==1 and ( (s1.empty())or(s1.top()&gt;a[now]) )) &#123; printf("a "); s1.push(a[now++]); continue; &#125; if(!s1.empty() and s1.top()==ned) &#123; printf("b "); s1.pop(); ned++; continue; &#125; if(now&lt;=n and p[now].c==2 and ( (s2.empty())or(s2.top()&gt;a[now]) )) &#123; printf("c "); s2.push(a[now++]); continue; &#125; if(!s2.empty() and s2.top()==ned) &#123; printf("d "); s2.pop(); ned++; continue; &#125; &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%d",&amp;n);for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); mi[n+1]=INF;//debug mi[n]=a[n];for(int i=n-1;i&gt;=1;i--) mi[i]=mymin(a[i],mi[i+1]); for(int i=1;i&lt;=n-1;i++) for(int j=i+1;j&lt;=n;j++) if(a[i]&lt;a[j] and a[i]&gt;mi[j+1]) ins(i,j),ins(j,i); for(int i=1;i&lt;=n;i++) if(p[i].c==0) dfs(i,1);//优先1 if(bk) printf("0"); else solve();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>二分图染色</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1006】传纸条]]></title>
    <url>%2Fposts%2F7e9b.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2008 提高组 T3Luogu1006Caioj1535 Problem【Brief description】小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排做成一个m行n列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标(1,1)，小轩坐在矩阵的右下角，坐标(m,n)。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用0表示），可以用一个0-100的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的两条路径。【Input】第一行有2个用空格隔开的整数m和n，表示班里有m行n列。接下来的m行是一个m*n的矩阵，矩阵中第i行j列的整数表示坐在第i行j列的学生的好心程度。每行的n个整数之间用空格隔开。【Output】包含一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。【Limited conditions】1&lt;=m,n&lt;=50【Sample input】3 30 3 92 8 55 7 0【Sample output】34【Sample explanation】 Record30minWA:枚举行的时候忽略了步数的限制，导致错误下标访问【感谢网上一篇文章，讲了一个错误点，让我解决了问题，所以我也要传递一下】【所以说之前方格取数的代码也是错误的，但20个数据只有一个错误……】 Analysis请先思考后再展开 首先，所谓双向，其实就是单向其次，所谓只能帮忙一次，就是只有一次贡献，因为所有数大于等于0，所以经过这里相当于没有经过 综上说述，问题转化为方格取数真没想到NOIP居然会重复考同一道题目…… Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量**************** //*******************全局定义****************int mp[60][60];int f[110][60][60];//步数、下1、下2//*******************实现******************//*******************主函数******************int main()&#123; int m,n;scanf("%d%d",&amp;m,&amp;n); for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;mp[i][j]); for(int p=1;p&lt;=n+m;p++)//步数 &#123; for(int i=1;i&lt;=mymin(p,m);i++)//行1 &#123; for(int j=1;j&lt;=mymin(p,m);j++)//行2 &#123; int i2=p-i,j2=p-j;//列1、列2 f[p][i][j]= f[p-1][i][j]+mp[i][i2]+mp[j][j2]*(i!=j); //都右 f[p][i][j]=mymax(f[p][i][j], f[p-1][i-1][j-1]+mp[i][i2]+mp[j][j2]*(i!=j) );//都下 f[p][i][j]=mymax(f[p][i][j], f[p-1][i-1][j]+mp[i][i2]+mp[j][j2]*(i!=j) );//下右 f[p][i][j]=mymax(f[p][i][j], f[p-1][i][j-1]+mp[i][i2]+mp[j][j2]*(i!=j) );//右下 &#125; &#125; &#125; printf("%d",f[n+m][m][m]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1004】方格取数]]></title>
    <url>%2Fposts%2F3f83.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2000 提高组 T4Luogu1004Caioj1503 Problem【Brief description】设有N*N的方格图，我们将其中的某些方格中填入正整数，而其他的方格中则放数字0。某人从图的左上角的A点出发，可以向下行走，也可以向右走，直到到达右下角的B点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。此人从A点到B点共走两次，试找出2条这样的路径，使得取得的数之和为最大。【Input】输入的第一行为一个整数N（表示N*N的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的0表示输入结束。【Output】一个整数，表示2条路径上取得的最大的和。【Limited conditions】N&lt;=10【Sample input】82 3 132 6 63 5 74 4 145 2 215 6 46 3 157 2 140 0 0【Sample output】67【Sample explanation】12345678910A0 0 0 0 0 0 0 00 0 13 0 0 6 0 00 0 0 0 7 0 0 00 0 0 14 0 0 0 00 21 0 0 0 4 0 00 0 15 0 0 0 0 00 14 0 0 0 0 0 00 0 0 0 0 0 0 0 B Record30min Analysis请先思考后再展开 DP经典题两个人一起DP，避免过于贪心，便于处理只能拿一次的条件 UP:之前代码有误，现已更正详见：传纸条 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量**************** //*******************全局定义****************int mp[20][20];int f[30][20][20];//步数、下1、下2//*******************实现****************** //*******************主函数******************int main()&#123; int n;scanf("%d",&amp;n); while(1) &#123; int x,y,z;scanf("%d%d%d",&amp;x,&amp;y,&amp;z); if(x==0) break; mp[x][y]=z; &#125; for(int p=1;p&lt;=2*n;p++)//步数 &#123; for(int i=1;i&lt;=mymin(p,n);i++)//行1 &#123; for(int j=1;j&lt;=mymin(p,n);j++)//行2 &#123; int i2=p-i,j2=p-j;//列1、列2 f[p][i][j]= f[p-1][i][j]+mp[i][i2]+mp[j][j2]*(i!=j);//都右 f[p][i][j]=mymax(f[p][i][j], f[p-1][i-1][j-1]+mp[i][i2]+mp[j][j2]*(i!=j) );//都下 f[p][i][j]=mymax(f[p][i][j], f[p-1][i-1][j]+mp[i][i2]+mp[j][j2]*(i!=j) );//下右 f[p][i][j]=mymax(f[p][i][j], f[p-1][i][j-1]+mp[i][i2]+mp[j][j2]*(i!=j) );//右下 &#125; &#125; &#125; printf("%d",f[2*n][n][n]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1126】火柴棒等式]]></title>
    <url>%2Fposts%2Fce8e.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2008 提高组 T2Luogu1126Caioj1534 Problem【Brief description】给你n根火柴棍，你可以拼出多少个形如“A+B=C”的等式？等式中的A、B、C是用火柴棍拼出的整数（若该数非零，则最高位不能是0）。用火柴棍拼数字0-9的拼法如图所示：注意：1. 加号与等号各自需要两根火柴棍2. 如果A≠B，则A+B=C与B+A=C视为不同的等式（A、B、C&gt;=0）3. n根火柴棍必须全部用上【Input】共一行，又一个整数n。【Output】能拼成的不同等式的数目【Limited conditions】n&lt;=24【Sample input】14【Sample output】2【Sample explanation】2个等式为0+1=1和1+0=1。 Record1h Analysis请先思考后再展开 整理每个数字：2: 13: 74: 45: 2,3,56: 0,6,97: 8然后暴力走一走详细点说就是预处理费用下所有数然后枚举分配方案 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;const int MAXN=30;//****************全局定义****************int prenum[10][10]=&#123; &#123;0,0,0,0&#125;, &#123;0,0,0,0&#125;, &#123;0,1,0,0&#125;, &#123;0,7,0,0&#125;, &#123;0,4,0,0&#125;, &#123;0,2,3,5&#125;, &#123;0,0,6,9&#125;, &#123;0,8,0,0&#125;&#125;;int prect[10]=&#123;0,0,1,1,1,3,3,1&#125;;//数量int num[40][400000],ct[50];//****************实现****************void pre(int now,int c,int pst)&#123; if(c==0) &#123; num[pst][++ct[pst]]=now; return; &#125; for(int i=2;i&lt;=mymin(7,c);i++) for(int j=1;j&lt;=prect[i];j++) if(now&gt;0 or (now==0 and prenum[i][j]&gt;0))//前导零 pre(now*10+prenum[i][j],c-i,pst);&#125;int ans=0;int a[3];//分配方案void dfs(int x,int c)&#123; if(x==3) &#123; for(int i=1;i&lt;=ct[a[1]];i++) for(int j=1;j&lt;=ct[a[2]];j++) for(int k=1;k&lt;=ct[c];k++) if(num[a[1]][i]+num[a[2]][j]==num[c][k]) &#123; //printf("%d+%d=%d\n",num[a[1]][i],num[a[2]][j],num[c][k]); ans++; &#125; return; &#125; for(int i=2;i&lt;=mymin(c-2,MAXN-4);i++) &#123; a[x]=i; dfs(x+1,c-i); &#125;&#125;//****************主函数****************int main()&#123; ct[6]=1;num[6][1]=0;//debug for(int i=2;i&lt;=MAXN-4;i++) pre(0,i,i);//预处理 int n;scanf("%d",&amp;n); dfs(1,n-4); printf("%d",ans);&#125; 如何毒瘤地Hack？其实当看到题目难度标签是普及-的时候就感觉有点不对劲于是在噼里啪啦打完上面的不简单的爆搜后，一看题解woc都是直接枚举每一种数字但想半天也搞不懂他们是怎么取这个数字的（如1000、1111、2400） 那我当然就很不爽啊所以要把他们卡掉！那如果空间128MB的话，可能n可以出30，那25~30，恩怎么说卡30分是可以的~毕竟他们是N^2]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1125】笨小猴]]></title>
    <url>%2Fposts%2F8bcb.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2008 提高组 T1Luogu1125Caioj1533 Problem【Brief description】假设maxn是单词中出现次数最多的字母的出现次数，minn是单词中出现次数最少的字母的出现次数，如果maxn-minn是一个质数，那么笨小猴就认为这是个Lucky Word，这样的单词很可能就是正确的答案。【Input】一个单词【Output】第一行是一个字符串，假设输入的的单词是Lucky Word，那么输出“Lucky Word”，否则输出“No Answer”；第二行是一个整数，如果输入单词是Lucky Word，输出maxn-minn的值，否则输出0。【Limited conditions】单词中只可能出现小写字母，并且长度小于100。【Sample input】error【Sample output】Lucky Word2【Sample explanation】单词error中出现最多的字母r出现了3次，出现次数最少的字母出现了1次，3-1=2，2是质数。 Record10min Analysis请先思考后再展开 sb题 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;const int MAXN=510000,MAXM=1100000;//****************全局定义****************char s[110];int a[27];//****************实现****************bool isprime(int x)&#123; if(x&lt;=1) return 0; for(int i=2;i*i&lt;=x;i++) if(x%i==0) return 0; return 1;&#125;//****************主函数****************int main()&#123; scanf("%s",s+1);int ln=strlen(s+1); for(int i=1;i&lt;=ln;i++) a[ s[i]-'a'+1 ]++; int mx=1,mi=INF; for(int i=1;i&lt;=26;i++) if(a[i]&gt;0) &#123; mx=mymax(mx,a[i]); mi=mymin(mi,a[i]); &#125; int t=mx-mi; if(isprime(t)) printf("Lucky Word\n%d",t); else printf("No Answer\n0");&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1999】【Luogu1099】树网的核]]></title>
    <url>%2Fposts%2Fb262.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2007 提高组 T4Bzoj1999Luogu1099Caioj1532 Problem【Brief description】一句话：求直径上的路径F，长度不超过s，使树上最远点与其距离最小。精炼完整版：在无根树T上有n个结点，称d(a,b)为a,b两结点间的距离。一点v到一条路径P的距离为该点与P上的最近的结点的距离。无根树的直径：无根树中最长的路径称为无根树的直径。对于给定的无根树T，直径不一定是唯一的，但各直径的中点是唯一的。（不一定恰好是某个结点，可能在某条边的内部），我们称该点为无根树的中心。偏心距ECC(F)：无根树T中距路径F最远的结点到路径F的距离。任务：对于给定的无根树T和非负整数s，求一个路径F，它是某直径上的一段路径（该路径两端均为无根树中的结点），其长度不超过s，使偏心距ECC(F)最小。我们称这个路径为无根树T的核。必要时，F可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。下面的图给出了无根树的一个实例。图中，A-B与A-C是两条直径，长度均为20。点W是无根树的中心，EF边的长度为5。如果指定s=11，则无根树的核为路径DEFG（也可以取为路径DEF），偏心距为8。如果指定s=0（或s=1、s=2），则无根树的核为结点F，偏心距为12。【Input】第1行，两个正整数n和s。其中n为树网结点的个数，s为树网的核的长度的上界。设结点编号依次为1，2，……，n。从第2行到第n行，每行给出3个用空格隔开的正整数，依次表示每一条边的两个端点编号和长度。【Output】只有一个非负整数，为指定意义下的最小偏心距。【Limited conditions】5&lt;=n&lt;=500000, 0&lt;=s&lt;2^31边长度为不超过1000的正整数。【Sample input】8 61 3 22 3 23 4 64 5 34 6 44 7 27 8 3【Sample output】5【Sample explanation】无 Record5h Analysis请先思考后再展开 其实就是一道大水题关键：不同直径具有等效性经典思想（来自akc）：想象把直径挂起来成一条横线，然后其他东西挂在下面假设当前直径有ed个节点，等会当做已经有连续的编号，便于理解 解法1：n^3随便找一个直径，假设上面有t个节点乱搞枚举l和r，dfs找下面的东西 解法2：n^2首先，显然在合法（长度s内）的情况下，核的长度越大越好在解法1的基础上面用尺取法即可 解法3：nlogsum二分答案，然后把两个端点l和r缩短直到与直径左右端点的距离即将超过mid那么把l到r之间的，作为核最后检查中间部分是否超过s，同时看挂在核上面的子树，最深距离是否在mid以内即可 不用检查1~l-1和r+1~ed部分的地方，向下挂的部分，是因为由于直径的最长性对于那上面的任意位置x，下面挂的最大深度不会超过x与端点的最短距离（否则会有更长的直径） 解法4：n对于直径上的ed节点，考虑每个l和r的贡献$min { max (l到r间挂的最大深度,dis(直径左端点,l),dis(r,直径右端点)) }$此时如果用单调队列是可以直接搞定的了但还能更简单：根据解法3的最后一条，左右两边向下深度没有影响所以直接记从1到ed这每个节点向下最大深度的最大值为mx$min { max (mx,dis(直径左端点,l),dis(r,直径右端点)) }$ Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=510000; const int INF=0x3f3f3f3f; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; struct Nod &#123; int hou; int fa; int dis; bool v; Nod() &#123; hou=0; v=0; &#125; &#125;p[MAX_N]; struct Edge &#123; int y,c,g; &#125;e[MAX_N*2]; int ln=0; void ins(int x,int y,int c) &#123; e[++ln]=(Edge)&#123;y,c,p[x].hou&#125;; p[x].hou=ln; &#125; int mx; void dfs(int x,int fa) &#123; p[x].fa=fa; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(p[y].v or y==fa) continue; p[y].dis=p[x].dis+e[k].c; mx=mymax(mx,p[y].dis); dfs(y,x); &#125; &#125; void main() &#123; int n,s;scanf("%d%d",&amp;n,&amp;s); for(int i=1;i&lt;=n-1;i++) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);ins(y,x,c); &#125; int a=1;p[1].dis=0;dfs(1,0);for(int i=1;i&lt;=n;i++) if(p[i].dis&gt;p[a].dis) a=i; int b=1;p[a].dis=0;dfs(a,0);for(int i=1;i&lt;=n;i++) if(p[i].dis&gt;p[b].dis) b=i; //b=&gt;...=&gt;a 通过fa连接的链表 int ans=INF; for(int l=b,r=b;r!=p[a].fa;r=p[r].fa) &#123; while(p[l].dis-p[r].dis&gt;s) l=p[l].fa;//尺取法 ans=mymin(ans,mymax(p[b].dis-p[l].dis,p[r].dis)); &#125; mx=0; for(int x=b;x!=p[a].fa;x=p[x].fa) p[x].v=1,p[x].dis=0,dfs(x,p[x].fa); printf("%d",mymax(ans,mx)); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1005】矩阵取数游戏]]></title>
    <url>%2Fposts%2F836e.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2007 提高组 T3Luogu1005Caioj1531 Problem【Brief description】对于一个给定的n*m的矩阵，矩阵中的每个元素均为非负整数。游戏规则如下：1.每次取数时须从每行各取走一个元素，共n个，m次后取完矩阵所有元素2.每次取走的各个元素只能是该元素所在行的行首或行尾3.每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分=被取走的元素值*2^i，其中i表示第i次取数（从1开始编号）；4.游戏结束总得分为m次取数得分之和。帅帅想请你帮忙写一个程序，对于任意矩阵取数后的最大得分。【Input】第1行为两个用空格隔开的整数n和m。第2~n+1行为n*m矩阵，其中每行有m个用单个空格隔开的非负整数。【Output】一个整数，即输入矩阵取数后的最大得分【Limited conditions】1&lt;=n, m&lt;=80，0&lt;=aij&lt;=1000【Sample input】2 31 2 33 4 2【Sample output】82【Sample input】2 1096 56 54 46 86 12 23 88 80 4316 95 18 29 30 53 88 83 64 67【Sample output】316994【Sample explanation】无 Record1h Analysis请先思考后再展开 分析题目，先简化问题：答案是由行组成的，所以可以每一行算出答案再累加而没有影响 首先，我的第一想法是贪心但是让我们举个反例： 解释 1 2 3 4 矩阵 13 1 10 11 我的傻瓜贪心 16 8 4 2 显然更合理的分配 2 4 8 16 分析一下为什么？显然贪心这种东西通常都是鼠目寸光的而每一次我们的选择显然会对后面的状态有影响 那么怎么办？正着不行就反过来嘛，从什么也没有开始，一个个加入？【因为总次数已经确定，所以能实现】但怎么加呢？难道枚举起点？那然后呢？总不能又回到贪心的老路子上 其实反过来后，很容易发现虽然一次选择鼠目寸光，但我们可以比较方案啊！再仔细思考，没错，这玩意是满足最优子结构的，也就是说，可以区间DP搞一搞 总结：区间DP+高精度【这很显然】 Code1惯例，先没有高精度请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;ll mymax(ll x,ll y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************ll a[90];ll f[90][90];ll bin[90];//****************实现**************** //****************主函数****************int main()&#123; bin[0]=1;for(int i=1;i&lt;=80;i++) bin[i]=bin[i-1]*2; int n,m;scanf("%d%d",&amp;n,&amp;m); ll ans=0; for(int i=1;i&lt;=n;i++) &#123; for(int i=1;i&lt;=m;i++) &#123; scanf("%d",&amp;a[i]); f[i][i]=a[i]*bin[m]; &#125; for(int k=m-1;k&gt;=1;k--) &#123; int ln=m-k+1; for(int st=1;st&lt;=m-ln+1;st++) &#123; int ed=st+ln-1; f[st][ed]=mymax( f[st+1][ed]+a[st]*bin[k],f[st][ed-1]+a[ed]*bin[k] ); &#125; &#125; ans+=f[1][m]; &#125; printf("%lld",ans);&#125; Code2正确代码请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义**************** //****************实现****************struct Bnum&#123; int a[100],ln; Bnum() &#123; memset(a,0,sizeof(a)); &#125;&#125;;Bnum jia(Bnum a,Bnum b)&#123; Bnum c;c.ln=mymax(a.ln,b.ln); for(int i=1;i&lt;=c.ln;i++) &#123; c.a[i]+=a.a[i]+b.a[i];//debug if(c.a[i]&gt;9) &#123; c.a[i]-=10; c.a[i+1]++; if(i==c.ln) c.ln++; &#125; &#125; return c;&#125;Bnum cheng(Bnum a,int b)&#123; Bnum c;c.ln=a.ln; for(int i=1;i&lt;=c.ln;i++) &#123; c.a[i]+=a.a[i]*b; if(c.a[i]&gt;9) &#123; c.a[i+1]+=c.a[i]/10; c.a[i]%=10; if(i==c.ln) c.ln++; &#125; &#125; return c;&#125;bool cmp(Bnum a,Bnum b)&#123; if(a.ln!=b.ln) return a.ln&lt;b.ln; for(int i=a.ln;i&gt;=1;i--) if(a.a[i]!=b.a[i]) return a.a[i]&lt;b.a[i]; return 0;&#125;//****************主函数****************int a[90];Bnum f[90][90];Bnum bin[90];int main()&#123; bin[0].ln=1;bin[0].a[1]=1; for(int i=1;i&lt;=80;i++) bin[i]=cheng(bin[i-1],2); int n,m;scanf("%d%d",&amp;n,&amp;m); Bnum ans;ans.ln=1; for(int i=1;i&lt;=n;i++) &#123; for(int i=1;i&lt;=m;i++) &#123; scanf("%d",&amp;a[i]); f[i][i]=cheng(bin[m],a[i]); &#125; for(int k=m-1;k&gt;=1;k--) &#123; int ln=m-k+1; for(int st=1;st&lt;=m-ln+1;st++) &#123; int ed=st+ln-1; Bnum x=jia( f[st+1][ed],cheng(bin[k],a[st]) ); Bnum y=jia( f[st][ed-1],cheng(bin[k],a[ed]) ); f[st][ed]=cmp(x,y)?y:x; &#125; &#125; ans=jia(ans,f[1][m]); &#125; for(int i=ans.ln;i&gt;=1;i--) putchar('0'+ans.a[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1098】字符串的展开]]></title>
    <url>%2Fposts%2Fa5cf.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2007 提高组 T2Luogu1098Caioj1530 Problem【Brief description】约定如下：(1) 遇到下面的情况需要做字符串的展开：在输入的字符串中，出现了减号“-”，减号两侧同为小写字母或同为数字，且按照ASCII码的顺序，减号右边的字符严格大于左边的字符。(2) 参数p1：展开方式。p1=1时，对于字母子串，填充小写字母；p1=2时，对于字母子串，填充大写字母。这两种情况下数字子串的填充方式相同。p1=3时，不论是字母子串还是数字字串，都用与要填充的字母个数相同的星号“*”来填充。(3) 参数p2：填充字符的重复个数。p2=k表示同一个字符要连续填充k个。例如，当p2=3时，子串“d-h”应扩展为“deeefffgggh”。减号两边的字符不变。(4) 参数p3：是否改为逆序：p3=1表示维持原来顺序，p3=2表示采用逆序输出，注意这时候仍然不包括减号两端的字符。例如当p1=1、p2=2、p3=2时，子串“d-h”应扩展为“dggffeeh”。(5)如果减号右边的字符恰好是左边字符的后继，只删除中间的减号。例如：“d-e”应输出为“de”，“3-4”应输出为“34”。如果减号右边的字符按照ASCII码的顺序小于或等于左边字符，输出时，要保留中间的减号例如：“d-d”应输出为“d-d”，“3-1”应输出为“3-1”。【Input】第1行为用空格隔开的3个正整数，依次表示参数p1，p2，p3。第2行为一行字符串，仅由数字、小写字母和减号“-”组成。行首和行末均无空格。【Output】只有一行，为展开后的字符串。【Limited conditions】1&lt;=p1&lt;=3，1&lt;=p2&lt;=8，1&lt;=p3&lt;=2字符串长度不超过100【Sample input】1 2 1abcs-w1234-9s-4zz【Sample output】abcsttuuvvw1234556677889s-4zz【Sample explanation】无 Record20min Analysis请先思考后再展开 sb题 Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************int p1,p2,p3;char s[110];//****************实现****************bool isabc(char c)&#123; return c&gt;='a' and c&lt;='z';&#125;bool okay(char l,char r)&#123; return ( (isdigit(l) and isdigit(r) )or( isabc(l) and isabc(r)) ) and l&lt;=r;&#125;void printchar(char c,int times)&#123; for(int i=1;i&lt;=p2*times;i++) putchar(c);&#125;void print(char l,char r,int times)&#123; if(isabc(l) and p1==2) l+='A'-'a',r+='A'-'a'; if(p3==1) &#123; for(char t=l;t&lt;=r;t++) printchar(t,times); &#125; else &#123; for(char t=r;t&gt;=l;t--) printchar(t,times); &#125;&#125;//****************主函数****************int main()&#123; scanf("%d%d%d%s",&amp;p1,&amp;p2,&amp;p3,s+1); int ln=strlen(s+1); for(int i=1;i&lt;=ln;i++) &#123; char l=s[i-1],r=s[i+1]; if(s[i]!='-' or !okay(l,r)) putchar(s[i]); else if(l+1==r) ; else if(l==r) putchar('-'); else &#123; l++;r--; if(p1==3) print('*','*',r-l+1); else print(l,r,1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1097】统计数字]]></title>
    <url>%2Fposts%2Fc868.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2007 提高组 T1Luogu1097Caioj1529 Problem【Brief description】某次科研调查时得到了n个自然数，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。【Input】第一行是整数n，表示自然数的个数；第2~n+1每行一个自然数。【Output】包含m行（m为n个自然数中不相同数的个数），按照自然数从小到大的顺序输出。每行输出两个整数，分别是自然数和该数出现的次数，其间用一个空格隔开。【Limited conditions】1&lt;=n&lt;=200000每个数均不超过1500000000（1.5*10^9）【Sample input】8242451002100【Sample output】2 34 25 1100 2【Sample explanation】无 Record10min Analysis请先思考后再展开 sb题 Code请先思考后再展开 1234567891011121314int a[210000];int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); sort(a+1,a+n+1); int ans=1; for(int i=2;i&lt;=n;i++) &#123; if(a[i-1]==a[i]) ans++; else printf("%d %d\n",a[i-1],ans),ans=1; &#125; printf("%d %d",a[n],ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1066】2^k进制数]]></title>
    <url>%2Fposts%2Fa045.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2006 提高组 T4Luogu1065Caioj1528 Problem【Brief description】设r是个2^k进制数，并满足以下条件：（1）r至少是个2位的2^k进制数。（2）作为2^k进制数，除最后一位外，r的每一位严格小于它右边相邻的那一位。（3）将r转换为2进制数q后，则q的总位数不超过w。在这里，正整数k和w是事先给定的。我们再从另一角度作些解释：设S是长度为w的01字符串，S对应于上述条件（3）中的q。将S从右起划分为若干个长度为k的段，每段对应一位2^k进制的数，如果S至少可分成2段，则S所对应的二进制数又可以转换为上述的2^k进制数r。问：满足上述条件的不同的r共有多少个？【Input】输入只有1行，为两个正整数，用一个空格隔开：k W【Output】输出为1行，是一个正整数，为所求的计算结果，即满足条件的不同的r的个数（用十进制数表示），要求最高位不得为0，各数字之间不得插入数字以外的其他字符（例如空格、换行符、逗号等）。（提示：作为结果的正整数可能很大，但不会超过200位）【Limited conditions】1&lt;=k&lt;=9k&lt;W&lt;=30000【Sample input】3 7【Sample output】36【Sample explanation】例：设k=3，w=7。则r是个八进制数（2^3=8）。由于w=7，长度为7的01字符串按3位一段分，可分为3段（即1，3，3，左边第一段只有一个二进制位），则满足条件的八进制数有：2位数：高位为1：6个（即12，13，14，15，16，17），高位为2：5个，…，高位为6：1个（即67）。共6+5+…+1=21个。3位数：高位只能是1，第2位为2：5个（即123，124，125，126，127），第2位为3：4个，…，第2位为6：1个（即167）。共5+4+…+1=15个。所以，满足要求的r共有36个。 Record2h Analysis1请先思考后再展开 比较裸的数位DP，套个高精度说的很轻松，居然没有想出来，好菜啊 首先，分析条件由条件1知，r的长度最少为2由条件3知，r的长度最多为$s= \left \lceil \frac{w}{k} \right \rceil$并且当达到最大长度的时候，r的最高位最多为$q=2^{w\%k}-1$，否则转化为二进制后超过w 那么剩下的就是条件2了，这个限制条件可以看做一种递推关系考虑设$f(i,j)$表示长度为i的r，$最后一位\leq j$的方案数则有$f(i,j)=f(i,j-1)+f(i-1,j-1)$意思就是，$(最后一位\leq j-1)+(最后一位=j)$【注意：题目要求是严格小于】 那么答案就是$$\sum_{长度ln=2}^{s-1} f(ln,2^k-1)+\sum_{最高位m=1}^{q} f(s-1,q-m)$$解释右式：最高位m已经确定，剩下的s-1个数，范围是$m+1 \sim mx$，相当于$1 \sim mx-m$ 补充一个细节：向上取整的时候，可以直接+1，即使加多了，q=0，没有影响 先丢个简单易懂的非高精度吧，居然有70，但加上高精度也没多难 Code1请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************int f[31000][520];//****************实现****************//****************主函数****************int main()&#123; int k,w;scanf("%d%d",&amp;k,&amp;w); int s=w/k+1,q=(1&lt;&lt;(w%k))-1,mx=(1&lt;&lt;k)-1; int ans=0; for(int i=1;i&lt;=mx;i++) f[1][i]=i;//debug for(int ln=2;ln&lt;=s-1;ln++) &#123; for(int j=ln;j&lt;=mx;j++) &#123; f[ln][j]=f[ln][j-1]+f[ln-1][j-1]; &#125; ans+=f[ln][mx]; &#125; for(int m=1;m&lt;=q;m++) ans+=f[s-1][mx-m];//debug printf("%d",ans);&#125; Analysis2请先思考后再展开 基本功——高精度但是这样会炸空间呀……考场是只能瞎搞一个大小了【其实也有可能是其他解法，例如组合数学】恩通过计算，在不炸空间的情况下，只能开190然鹅事实证明太小啦！其实压位不就好了……手动抠鼻压9位就阔以1600了，这三十分能拿多少拿多少嘛~ 【以上模拟考场策略】 Code2请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;const int MOD=1000000000;//压9//****************全局定义****************struct Bnum&#123; int a[26],ln; Bnum() &#123; memset(a,0,sizeof(a)); &#125;&#125;;Bnum f[1601][513];//81MB//****************实现****************Bnum jia(Bnum a,Bnum b)&#123; Bnum c;c.ln=mymax(a.ln,b.ln); for(int i=1;i&lt;=c.ln;i++) &#123; c.a[i]+=a.a[i]+b.a[i]; if(c.a[i]&gt;=MOD) &#123; c.a[i]-=MOD; c.a[i+1]+=1; if(i==c.ln) c.ln++; &#125; &#125; return c;&#125;void putnum(int x)&#123; int t=MOD/10;while(x&lt;t) putchar('0'),t/=10; if(x&gt;0) printf("%d",x);&#125;//****************主函数****************int main()&#123; int k,w;scanf("%d%d",&amp;k,&amp;w); int s=w/k+1,q=(1&lt;&lt;(w%k))-1,mx=(1&lt;&lt;k)-1; Bnum ans;ans.ln=1; for(int i=1;i&lt;=mx;i++) &#123; f[1][i].ln=1; f[1][i].a[1]=i; &#125; for(int ln=2;ln&lt;=s-1;ln++) &#123; for(int j=ln;j&lt;=mx;j++) f[ln][j]=jia(f[ln][j-1],f[ln-1][j-1]); ans=jia(ans,f[ln][mx]); &#125; for(int m=1;m&lt;=q;m++) ans=jia(ans,f[s-1][mx-m]); printf("%d",ans.a[ans.ln]); for(int i=ans.ln-1;i&gt;=1;i--) putnum(ans.a[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数位DP</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1065】作业调度方案]]></title>
    <url>%2Fposts%2Fa978.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2006 提高组 T3Luogu1065Caioj1527长长的原题面，我已简化 Problem【Brief description】我们现在要利用m台机器加工n个工件，每个工件都有m道工序。每道工序都在不同的指定的机器上完成，每个工件的每道工序都有指定的加工时间。每个工件的每个工序称为一个操作，给出操作顺序，你的任务就是设计符合该顺序的实施方案。实施方案条件（后面不得违背前面）：1. 对同一个工件，每道工序必须在它前面的工序完成后才能开始；2. 同一时刻每一台机器至多只能加工一个工件。3. 在安排后面的操作时，不能改动前面已安排的操作的工作状态。4. 尽量靠前插入空档。5. 如果有多个空档可以插入，就插入到最前面的一个空档。操作顺序以以下格式描述：共n*m个正整数，表示对应的工件编号，同一工件编号共出现m次，分别表示m个工序的执行顺序【原理是方案条件1】注意，“安排顺序”只要求按照给定的顺序安排每个操作。不一定是各机器上的实际操作顺序。在具体实施时，有可能排在后面的某个操作比前面的某个操作先完成。显然，在这些约定下，对于给定的安排顺序，符合该安排顺序的实施方案是唯一的。请你计算出该方案完成全部任务所需的总时间。【Input】输入文件的第1行为两个正整数，用一个空格隔开：m n （其中m表示机器数，n表示工件数）第2行：m*n个用空格隔开的数，为给定的安排顺序。接下来的2n行，每行都是用空格隔开的m个正整数，每个数不超过20。其中前n行依次表示每个工件的每个工序所使用的机器号，第1个数为第1个工序的机器号，第2个数为第2个工序机器号，等等。后n行依次表示每个工件的每个工序的加工时间。【Output】一个正整数，为最少的加工时间【Limited conditions】m&lt;20n&lt;20物品的价格都是10元的整数倍【Sample input】2 31 1 2 3 3 21 21 22 13 22 52 4【Sample output】10【Sample explanation】 Record30min Analysis请先思考后再展开 时间上限：8000模拟即可 Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************int a[30][30],b[30][30];//机器、时间bool used[30][8100];//工作否int sx[410];//操作顺序int done[30];//完成工序数int last[30];//上一工序完成时间//****************实现****************bool check(int jq,int st,int ed)&#123; for(int i=st;i&lt;=ed;i++) if(used[jq][i]) return 0; for(int i=st;i&lt;=ed;i++) used[jq][i]=1;//占用 return 1;&#125;//****************主函数****************int main()&#123; int m,n;scanf("%d%d",&amp;m,&amp;n);//机器、工件 for(int i=1;i&lt;=m*n;i++) scanf("%d",&amp;sx[i]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;a[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;b[i][j]); int ans=0; for(int i=1;i&lt;=m*n;i++) &#123; int x=sx[i],t=++done[x]; int jq=a[x][t],time=b[x][t]; int st=last[x]+1,ed=st+time-1; while(!check(jq,st,ed)) st++,ed++; last[x]=ed;ans=mymax(ans,ed); &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1063】能量项链]]></title>
    <url>%2Fposts%2Fd69c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2006 提高组 T1Luogu1063Caioj1525 Problem【Brief description】在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为m*r*n（Mars单位），新产生的珠子的头标记为m，尾标记为n。需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。【Input】输入的第一行是一个正整数N，表示项链上珠子的个数。第二行是N个用空格隔开的正整数，所有的数均不超过1000。第i个数为第i颗珠子的头标记（1≤i≤N），当1≤i&lt;N时，第i颗珠子的尾标记应该等于第i+1颗珠子的头标记。第N颗珠子的尾标记应该等于第1颗珠子的头标记。至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。【Output】一个正整数E，为一个最优聚合顺序所释放的总能量。【Limited conditions】4≤N≤100E≤2.1*10^9【Sample input】42 3 5 10【Sample output】710【Sample explanation】4颗珠子的头标记与尾标记依次为(2，3) (3，5) (5，10) (10，2)。我们用记号⊕表示两颗珠子的聚合操作，(j⊕k)表示第j，k两颗珠子聚合后所释放的能量。则第4、1两颗珠子聚合后释放的能量为：(4⊕1)=10*2*3=60。这一串项链可以得到最优值的一个聚合顺序所释放的总能量为((4⊕1)⊕2)⊕3）=10*2*3+10*3*5+10*5*10=710。 Record30min Analysis请先思考后再展开 首先，这是一个环，经典的套路就是复制一次在后面然后就是一个单纯的DP了 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;ll mymax(ll x,ll y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************ll a[210];ll f[210][210];//****************实现****************//****************主函数****************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]),a[n+i]=a[i]; ll ans=0; for(int ln=2;ln&lt;=n;ln++) &#123; for(int st=1;st&lt;=n;st++) &#123; int ed=st+ln-1; for(int k=st;k&lt;=ed-1;k++) f[st][ed]=mymax(f[st][ed],f[st][k]+f[k+1][ed]+a[st]*a[k+1]*a[ed+1]); if(ln==n) ans=mymax(ans,f[st][ed]); &#125; &#125; printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1064】金明的预算方案]]></title>
    <url>%2Fposts%2F8231.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2006 提高组 T2Luogu1064Caioj1526 Problem【Brief description】如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。【Input】输入的第1行，为两个正整数，用一个空格隔开：N m （其中N表示总钱数，m为希望购买物品的个数。）从第2行到第m+1行，第j行给出了编号为j-1的物品的基本数据，每行有3个非负整数v p q（其中v表示该物品的价格，p表示该物品的重要度（1~5），q表示该物品是主件还是附件。如果q=0，表示该物品为主件，如果q&gt;0，表示该物品为附件，q是所属主件的编号）【Output】输出只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（&lt;200000）【Limited conditions】N&lt;32000m&lt;60v&lt;10000物品的价格都是10元的整数倍【Sample input】1000 5800 2 0400 5 1300 5 1400 3 0500 2 0【Sample output】2200【Sample explanation】无 Record30min Analysis请先思考后再展开 这题的关键在于附件的存在，但“附件的个数不超过2”大大降低了难度那么对于每个主件，只有以下情况 只买主件 买主件和附件1 买主件和附件2 买主件和两个附件将输入整理后，就转化成了背包问题中的经典问题：采药 Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;ll mymax(ll x,ll y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************int a[70][3],b[70][3];int f[33000];//****************实现****************//****************主函数****************int main()&#123; int N,m;scanf("%d%d",&amp;N,&amp;m); for(int i=1;i&lt;=m;i++) &#123; int x,y,z;scanf("%d%d%d",&amp;x,&amp;y,&amp;z); if(z==0) a[i][0]=x,b[i][0]=y; else if(b[z][1]==0) a[z][1]=x,b[z][1]=y; else a[z][2]=x,b[z][2]=y; &#125; for(int i=1;i&lt;=m;i++) &#123; for(int j=N;j&gt;=0;j--) &#123; int x,y; x=a[i][0]; y=a[i][0]*b[i][0]; if(j&gt;=x) f[j]=mymax(f[j],f[j-x]+y); x=a[i][0]+a[i][1]; y=a[i][0]*b[i][0]+a[i][1]*b[i][1]; if(j&gt;=x) f[j]=mymax(f[j],f[j-x]+y); x=a[i][0]+a[i][2]; y=a[i][0]*b[i][0]+a[i][2]*b[i][2]; if(j&gt;=x) f[j]=mymax(f[j],f[j-x]+y); x=a[i][0]+a[i][1]+a[i][2]; y=a[i][0]*b[i][0]+a[i][1]*b[i][1]+a[i][2]*b[i][2]; if(j&gt;=x) f[j]=mymax(f[j],f[j-x]+y); &#125; &#125; printf("%d",f[N]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1051】篝火晚会]]></title>
    <url>%2Fposts%2Fb7e3.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2005 提高组 T3Luogu1053Caioj1523 Problem【Brief description】佳佳刚进高中，在军训的时候，由于佳佳吃苦耐劳，很快得到了教官的赏识，成为了“小教官”。在军训结束的那天晚上，佳佳被命令组织同学们进行篝火晚会。一共有n个同学，编号从1到n。一开始，同学们按照1，2，……，n的顺序坐成一圈，而实际上每个人都有两个最希望相邻的同学。如何下命令调整同学的次序，形成新的一个圈，使之符合同学们的意愿，成为摆在佳佳面前的一大难题。佳佳可向同学们下达命令，每一个命令的形式如下：(b1, b2,… bm -1, bm)这里m的值是由佳佳决定的，每次命令m的值都可以不同。这个命令的作用是移动编号是b1，b2，…… bm的这m个同学的位置。要求b1换到b2的位置上，b2换到b3的位置上，……，要求bm换到b1的位置上。执行每个命令都需要一些代价。我们假定如果一个命令要移动m个人的位置，那么这个命令的代价就是m。我们需要佳佳用最少的总代价实现同学们的意愿，你能帮助佳佳吗？【Input】第一行是一个整数n，表示一共有n个同学。其后n行每行包括两个不同的正整数，以一个空格隔开，分别表示编号是1的同学最希望相邻的两个同学的编号，编号是2的同学最希望相邻的两个同学的编号，……，编号是n的同学最希望相邻的两个同学的编号。【Output】这一行只包含一个整数，为最小的总代价。如果无论怎么调整都不能符合每个同学的愿望，则输出-1。【Limited conditions】3&lt;=n&lt;=50000【Sample input】43 44 31 21 2【Sample output】2【Sample explanation】无 Record2h Analysis请先思考后再展开 首先，假设现在有k个人在错误的位置上，那么最小花费显然就是k【猜结论】那么问题就在于如何判断多少个人错误呢?因为这是一个环，当构造出当前环和目标环后，比较也是要O(n^2)，tle妥妥的 那么接下来就是求最少错误的，等价于求最多正确的当然这里的错误与正确只是相对的，分离出不同的链就有不同的结果，取得是最多的罢了那么怎么求呢？有个很妙的方法：所谓正确的，在环状态下，其实它们与原位置的偏移量是相同的那么计算出偏移量，选取其中最多的一种方案即可 不过猜结论还是有点危险啊，因为还要反着跑一遍栗子：当前：2 3 4 1目标：4 3 2 1其实目标就是4 1 2 3，也就是反过来那么答案不是2而是0 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************int n;int d[51000][2];int c[51000];int s[51000];//****************实现****************int ans=INF;bool solve(int t)//方向&#123; c[1]=1;c[2]=d[1][t]; for(int i=3;i&lt;=n;i++)//构造目标环 &#123; if(c[i-2]==d[c[i-1]][0]) c[i]=d[c[i-1]][1]; else c[i]=d[c[i-1]][0]; &#125; memset(s,0,sizeof(s)); for(int i=1;i&lt;=n;i++) &#123; int dis=( (c[i]-i)+n )%n;//c[i]当前 i目的 s[dis]++; ans=mymin(ans,n-s[dis]); &#125;&#125;//****************主函数****************int main()&#123; scanf("%d",&amp;n);for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;d[i][0],&amp;d[i][1]); for(int i=1;i&lt;=n;i++)//判无解 &#123; if(d[d[i][0]][0]!=i and d[d[i][0]][1]!=i or d[d[i][1]][0]!=i and d[d[i][1]][1]!=i) &#123; printf("-1"); return 0; &#125; &#125; solve(0);solve(1); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1052】过河]]></title>
    <url>%2Fposts%2F200e.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2005 提高组 T2Luogu1052Caioj1522 Problem【Brief description】在河上有一座独木桥，一只青蛙想沿着独木桥从河的一侧跳到另一侧。在桥上有一些石子，青蛙很讨厌踩在这些石子上。由于桥的长度和青蛙一次跳过的距离都是正整数，我们可以把独木桥上青蛙可能到达的点看成数轴上的一串整点：0，1，……，L（其中L是桥的长度）。坐标为0的点表示桥的起点，坐标为L的点表示桥的终点。青蛙从桥的起点开始，不停的向终点方向跳跃。一次跳跃的距离是S到T之间的任意正整数（包括S,T）。当青蛙跳到或跳过坐标为L的点时，就算青蛙已经跳出了独木桥。题目给出独木桥的长度L，青蛙跳跃的距离范围S,T，桥上石子的位置。你的任务是确定青蛙要想过河，最少需要踩到的石子数。【Input】第一行有一个正整数L，表示独木桥的长度。第二行有三个正整数S，T，M，分别表示青蛙一次跳跃的最小距离，最大距离，及桥上石子的个数。第三行有M个不同的正整数分别表示这M个石子在数轴上的位置（数据保证桥的起点和终点处没有石子）。所有相邻的整数之间用一个空格隔开。【Output】只包括一个整数，表示青蛙过河最少需要踩到的石子数。【Limited conditions】1&lt;=L&lt;=10^91&lt;=S&lt;=T&lt;=10，1&lt;=M&lt;=100【Sample input】102 3 52 3 5 6 7【Sample output】2【Sample explanation】无 Record30min Analysis请先思考后再展开 虽然说s和t都是不固定的，但它们的范围都灰常小，一种方案是状压，但代码复杂度较高，而且对新手不友好，按下不表。 其实，既然步数只有可能是1到10，那么由于题目根本不关心具体是怎么走过去的，甚至总步数都不关心，那么对于一段很长的距离，怎么走几乎是随便的。那么其实，无论s和t的取值是什么，对于1到10的最小公倍数2520（有的人会问怎么计算？把所有数字列出来，然后诸如4和8，就只取8，剩下7、8、9、10，那么因为10里面有2,8变成4，于是它们的乘积即2520了）然后根据位置差，排序后压缩路径，用bool数组对点记录即可 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334const int INF=0x3f3f3f3f;int a[110],b[110],c[110];int f[610000];bool v[610000];//****************主函数****************int main()&#123; int l,s,t,m;scanf("%d%d%d%d",&amp;l,&amp;s,&amp;t,&amp;m); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;a[i]); sort(a+1,a+1+m); for(int i=1;i&lt;=m;i++) &#123; b[i]=a[i]-a[i-1]; int tmp=b[i]%2520; if(b[i]&gt;=2520 and tmp&lt;=t) tmp+=2520;//确保正确性 c[i]=c[i-1]+tmp; v[ c[i] ]=1; &#125; memset(f,63,sizeof(f));f[0]=0; int tmp=(l-a[m])%2520; if((l-a[m])&gt;=2520 and tmp&lt;=t) tmp+=2520;//确保正确性 l=c[m]+tmp; int ans=INF; for(int i=1;i&lt;=l+t-1;i++) &#123; for(int p=s;p&lt;=t;p++) if(i-p&gt;=0) f[i]=min(f[i],f[i-p]+v[i]); if(i&gt;=l) ans=min(ans,f[i]); &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1092】虫食算]]></title>
    <url>%2Fposts%2F6a62.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2004 提高组 T4Luogu1092Caioj1519 Problem【Brief description】所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的字母。来看一个简单的栗子：123 43#9865#045+ 8468#6633=44445509678其中#号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是5和3，第二行的数字是5。现在，我们对问题做两个限制：首先，我们只考虑加法的虫食算。这里的加法是N进制加法，算式中三个数都有N位，允许有前导的0。其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是N进制的，我们就取英文字母表的前N个大写字母来表示这个算式中的0到N-1这N个不同的数字,但是这N个字母并不一定顺序地代表0到N-1。输入数据保证N个字母分别至少出现一次。123 BADC+CBDA DCCC上面的算式是一个4进制的算式。很显然，我们只要让ABCD分别代表0123，便可以让这个柿子成立了。你的任务是，对于给定的N进制加法算式，求出N个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解.【Input】包含四行。第一行有一个正整数N，后面的3行每行有一个由大写字母组成的字符串，分别代表两个加数以及和。这3个字符串左右两端都没有空格，从高位到低位，并且恰好有N位。【Output】包含一行。在这一行中，应当包含唯一的那组解。解是这样表示的：输出N个数字，分别表示A，B，C……所代表的数字，相邻的两个数字用一个空格隔开，不能有多余的空格。【Limited conditions】N&lt;=26【Sample input】5ABCEDBDACEEBBAA【Sample output】1 0 3 4 2【Sample explanation】无 Record1h Analysis1请先思考后再展开 先打了个暴力，想着数据可能水【其实的确没有极限数据】但依然TLE，但已经剪枝了然后跟着题解，发现可以不递推进位，减更多这时候还是差一点，然后就是一个神奇的玄学操作了：重新编号（从后往前），dfs决断的时候编号从大到小我一开始想着，这是为了搞掉首位进位（这个也是跟题解学的）那既然如此编号从前往后，dfs的时候从小到大也一样吧结果差距是几十倍？？ 考场上绝对不能这么玩，会死的很惨 Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************int n;int a[30];bool used[30];int jia1[30],jia2[30],he[30];//****************实现****************bool finaljudge()&#123; int jw=0; for(int i=1;i&lt;=n;i++) &#123; int x=a[jia1[i]],y=a[jia2[i]],z=a[he[i]]; if( (x+y+jw)%n!=z ) return 0; jw=(x+y+jw)/n; &#125; return 1;&#125;bool check()&#123; if(a[jia1[n]]+a[jia2[n]]&gt;=n) return 0; for(int i=1;i&lt;=n;i++)//从后往前 &#123; int x=a[jia1[i]],y=a[jia2[i]],z=a[he[i]]; if(x&lt;0 or y&lt;0 or z&lt;0) continue;//残缺 if( (x+y)%n!=z and (x+y+1)%n!=z ) return 0; &#125; return 1;&#125;int nxt[30];//新编号-Importantvoid Print()&#123; for(int i=1;i&lt;=n;i++) printf("%d ",a[i]); exit(0);&#125;void dfs(int x)&#123; if(x&gt;n) &#123; if(finaljudge()) Print(); return; &#125; //for(int i=0;i&lt;=n-1;i++) 玄学操作 for(int i=n-1;i&gt;=0;i--) if(used[i]==0) &#123; a[ nxt[x] ]=i; if(check()) &#123; used[i]=1; dfs(x+1); used[i]=0; &#125; a[ nxt[x] ]=-1; &#125;&#125;int cnt=0;//新编号-Importantvoid putnxt(int x)&#123; if(used[x]==0) &#123; used[x]=1;//借用 nxt[++cnt]=x; &#125;&#125;//****************主函数****************char ch[30];int main()&#123; scanf("%d",&amp;n); scanf("%s",ch+1);for(int i=n;i&gt;=1;i--) jia1[n-i+1]=ch[i]-'A'+1; scanf("%s",ch+1);for(int i=n;i&gt;=1;i--) jia2[n-i+1]=ch[i]-'A'+1; scanf("%s",ch+1);for(int i=n;i&gt;=1;i--) he[n-i+1]=ch[i]-'A'+1; for(int i=1;i&lt;=n;i++)//新编号-Important &#123; putnxt(jia1[i]); putnxt(jia2[i]); putnxt(he[i]); &#125; memset(used,0,sizeof(used)); memset(a,-1,sizeof(a)); dfs(1);&#125; Analysis2请先思考后再展开 并没有看懂的正解：https://blog.csdn.net/JeremyGJY/article/details/50611568https://blog.csdn.net/outer_form/article/details/50611820 Code2请先思考后再展开 12]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>模拟</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1051】谁拿了最多奖学金]]></title>
    <url>%2Fposts%2F5b4d.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2005 提高组 T1Luogu1051Caioj1521 Problem【Brief description】某校的惯例是在每学期的期末考试之后发放奖学金。发放的奖学金共有五种，获取的条件各自不同：1)院士奖学金，每人8000元，期末平均成绩高于80分，并且在本学期内发表1篇或1篇以上论文的学生均可获得；2)五四奖学金，每人4000元，期末平均成绩高于85分，并且班级评议成绩高于80分的学生均可获得；3)成绩优秀奖，每人2000元，期末平均成绩高于90分的学生均可获得；4)西部奖学金，每人1000元，期末平均成绩高于85分的西部省份学生均可获得；5)班级贡献奖，每人850元，班级评议成绩高于80分的学生干部均可获得；只要符合条件就可以得奖，每项奖学金的获奖人数没有限制，每名学生也可以同时获得多项奖学金。现在给出若干学生的相关数据，请计算哪些同学获得的奖金总数最高（假设总有同学能满足获得奖学金的条件）。【Input】第一行是一个整数N，表示学生的总数。接下来的N行每行是一位学生的数据，从左向右依次是姓名，期末平均成绩，班级评议成绩，是否是学生干部，是否是西部省份学生，以及发表的论文数。姓名是由大小写英文字母组成的长度不超过20的字符串（不含空格）；期末平均成绩和班级评议成绩都是0到100之间的整数（包括0和100）；是否是学生干部和是否是西部省份学生分别用一个字符表示，Y表示是，N表示不是；发表的论文数是0到10的整数（包括0和10）。每两个相邻数据项之间用一个空格分隔。【Output】第一行是获得最多奖金的学生的姓名，第二行是这名学生获得的奖金总数。如果有两位或两位以上的学生获得的奖金最多，输出他们之中在输入文件中出现最早的学生的姓名。第三行是这N个学生获得的奖学金的总数。【Limited conditions】1&lt;=N&lt;=100【Sample input】4YaoLin 87 82 Y N 0ChenRuiyi 88 78 N Y 1LiXin 92 88 N N 0ZhangQin 83 87 Y N 1【Sample output】ChenRuiyi900028700【Sample explanation】例如姚林的期末平均成绩是87分，班级评议成绩82分，同时他还是一位学生干部，那么他可以同时获得五四奖学金和班级贡献奖，奖金总数是4850元。 Record30min Analysis请先思考后再展开 模拟题 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************struct Boy&#123; char name[30];//姓名 int qm,bj;//期末平均成绩，班级评议成绩 bool gb,xb;//是否是学生干部，是否是西部省份学生 int lw;//发表的论文数 int jj;//奖金&#125;p[110];//****************实现****************void judge1(int x)&#123; if(p[x].qm&gt;80 and p[x].lw&gt;=1) p[x].jj+=8000;&#125;void judge2(int x)&#123; if(p[x].qm&gt;85 and p[x].bj&gt;80) p[x].jj+=4000;&#125;void judge3(int x)&#123; if(p[x].qm&gt;90) p[x].jj+=2000;&#125;void judge4(int x)&#123; if(p[x].qm&gt;85 and p[x].xb) p[x].jj+=1000;&#125;void judge5(int x)&#123; if(p[x].bj&gt;80 and p[x].gb) p[x].jj+=850;&#125;//****************主函数****************char s1[5],s2[5];int main()&#123; int n;scanf("%d",&amp;n); int mx=0,sum=0; for(int i=1;i&lt;=n;i++) &#123; scanf("%s%d%d%s%s%d",p[i].name+1,&amp;p[i].qm,&amp;p[i].bj,s1,s2,&amp;p[i].lw); p[i].gb=(s1[0]=='Y');p[i].xb=(s2[0]=='Y');p[i].jj=0; judge1(i);judge2(i);judge3(i);judge4(i);judge5(i); sum+=p[i].jj; if(p[i].jj&gt;p[mx].jj) mx=i;//没有歧义 &#125; printf("%s\n%d\n%d",p[mx].name+1,p[mx].jj,sum);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1054】等价表达式]]></title>
    <url>%2Fposts%2F146c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2005 提高组 T4Luogu1054Caioj1524 Problem【Brief description】明明进了中学之后，学到了代数表达式。有一天，他碰到一个很麻烦的选择题。这个题目的题干中首先给出了一个代数表达式，然后列出了若干选项，每个选项也是一个代数表达式，题目的要求是判断选项中哪些代数表达式是和题干中的表达式等价的。这个选择题中的每个表达式都满足下面的性质：1． 表达式只可能包含一个变量‘a’。2． 表达式中出现的数都是正整数，而且都小于10000。3． 表达式中可以包括四种运算‘+’，‘-’，‘*’，‘^’，以及小括号‘(’，‘)’。（注意：运算符‘+’，‘-’，‘*’，‘^’以及小括号‘(’，‘)’都是英文字符）小括号的优先级最高，其次是‘^’，然后是‘*’，最后是‘+’和‘-’。‘+’和‘-’的优先级是相同的。相同优先级的运算从左到右进行。4． 幂指数只可能是1到10之间的正整数（包括1和10）。5． 表达式内部，头部或者尾部都可能有一些多余的空格。下面是一些合理的表达式的栗子：123456((a ^1)^2)^3a* a+a-a((a+a) )9999+(a-a)*a1+(a -1)^31^ 10^9【Input】第一行给出的是题干中的表达式。第二行是一个整数n，表示选项的个数。后面n行，每行包括一个选项中的表达式。这n个选项的标号分别是A，B，C，D……输入中的表达式的长度都不超过50个字符，而且保证选项中总有表达式和题干中的表达式是等价的。【Output】一系列选项的标号，表示哪些选项是和题干中的表达式等价的。选项的标号按照字母顺序排列，而且之间没有空格。【Limited conditions】2&lt;=n&lt;=26【Sample input】12345( a + 1) ^23(a-1)^2+4*aa + 1+ aa^2 + 2 * a * 1 + 1^2 + 10 -10 +a -a【Sample output】AC【Sample explanation】无 Record30min Analysis请先思考后再展开 看到题面，突然就想到了NOIP2017D1T2的“时间复杂度”都是很有意思的题目呢虽然理论上“侦探推理”也很有意思，但纯属码农题 其实这道题感觉小学的时候想过，当时想设计四则运算的计算器，但半途而废了…… 好了讲正事用函数递归求解每次找优先级最低的地方，递归左右后计算即可 然后本来想自然溢出的，结果差一个点，改long long就行了 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************char s[2][60];int ln[2];ll ans[2][30];//****************实现****************bool isok(char c)&#123; return c&gt;='0' and c&lt;='9';&#125;ll power(ll x,int e) &#123;ll t=1;for(int i=1;i&lt;=e;i++) t=t*x;return t;&#125;ll make(int t,int l,int r,int a)&#123; int mi=INF,mp,now=0; bool op=0; for(int i=r;i&gt;=l;i--)//从后往前，保证自左向右结合性 &#123; int me=INF; if(s[t][i]==')') now+=100; if(s[t][i]=='(') now-=100; if(s[t][i]=='^') me=now+3,op=1; if(s[t][i]=='*') me=now+2,op=1; if(s[t][i]=='+') me=now+1,op=1; if(s[t][i]=='-') me=now+1,op=1; if(me&lt;mi) mi=me,mp=i; &#125; if(op==0) &#123; ll sum=0; for(int i=l;i&lt;=r;i++) &#123; if(s[t][i]=='a') return a; if(isok(s[t][i]))//去空格、换行、括号 sum=sum*10+s[t][i]-'0'; &#125; return sum; &#125; if(s[t][mp]=='^') return power( make(t,l,mp-1,a),make(t,mp+1,r,a) ); if(s[t][mp]=='*') return make(t,l,mp-1,a)*make(t,mp+1,r,a); if(s[t][mp]=='+') return make(t,l,mp-1,a)+make(t,mp+1,r,a); if(s[t][mp]=='-') return make(t,l,mp-1,a)-make(t,mp+1,r,a);&#125;//****************主函数****************int main()&#123; //gets(s[0]+1); scanf("%[^\r]",s[0]+1);getchar(); ln[0]=strlen(s[0]+1); for(int j=0;j&lt;=30;j++) ans[0][j]=make(0,1,ln[0],j-15); int n;scanf("%d",&amp;n);getchar(); for(int i=1;i&lt;=n;i++) &#123; //gets(s[1]+1); scanf("%[^\r]",s[1]+1);getchar(); ln[1]=strlen(s[1]+1); for(int j=0;j&lt;=30;j++) ans[1][j]=make(1,1,ln[1],j-15); if(memcmp(ans[0],ans[1],sizeof(ans[0]))==0) printf("%c",'A'+i-1); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1091】合唱队形]]></title>
    <url>%2Fposts%2F10e.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2004 提高组 T3Luogu1091Caioj1518 Problem【Brief description】N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学排成合唱队形。剩下的k个同学，要求顺序不变的情况下，身高从低到高再到低。已知所有N位同学的身高，计算最少需要几位同学出列。【Input】第一行是一个整数N，表示同学的总数。第一行有n个整数，用空格分隔，第i个整数Ti是第i位同学的身高(厘米)。【Output】一个整数，就是最少需要几位同学出列【Limited conditions】2&lt;=N&lt;=100130&lt;=Ti&lt;=230【Sample input】8186 186 150 200 160 130 197 220【Sample output】4【Sample explanation】无 Record20min Analysis请先思考后再展开 相当于求最长上升子序列和最长下降子序列 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int MAXN=310,MAXM=91000;const int INF=0x3f3f3f3f;//****************全局定义****************int a[110];int f1[110],f2[110];//****************实现****************//****************主函数****************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++) &#123; f1[i]=1; for(int j=1;j&lt;=i-1;j++) if(a[j]&lt;a[i]) f1[i]=mymax(f1[i],f1[j]+1); &#125; for(int i=n;i&gt;=1;i--) &#123; f2[i]=1; for(int j=n;j&gt;=i+1;j--) if(a[i]&gt;a[j]) f2[i]=mymax(f2[i],f2[j]+1); &#125; int ans=0; for(int i=1;i&lt;=n;i++) ans=mymax(ans,f1[i]+f2[i]-1); printf("%d",n-ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1090】合并果子]]></title>
    <url>%2Fposts%2F7e7e.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2004 提高组 T2Luogu1090Caioj1517 Problem【Brief description】在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n-1 次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。【Input】包括两行，第一行是一个整数n，表示果子的种类数。第二行包含n个整数，用空格分隔，第i个整数ai是第i种果子的数目。【Output】一个整数，也就是最小的体力耗费值。【Limited conditions】1&lt;=n&lt;=100001&lt;=ai&lt;=20000最小的体力耗费值小于2^31【Sample input】31 2 9【Sample output】15【Sample explanation】有3种果子，数目依次为1，2，9。可以先将1、2堆合并，新堆数目为 3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为12。所以多多总共耗费体力=3+12=15。可以证明15为最小的体力耗费值。 Record20min Analysis请先思考后再展开 唉没看清题目，以为是石子合并其实这道题是任意两堆合并，不在乎顺序的……所以只要每次取最小的两个，贪心即可 Code请先思考后再展开 1234567891011121314151617181920priority_queue&lt; int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int t; scanf("%d",&amp;t); q.push(t); &#125; int ans=0; for(int i=1;i&lt;=n-1;i++) &#123; int a=q.top();q.pop(); int b=q.top();q.pop(); ans+=a+b;q.push(a+b); &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1089】津津的储蓄计划]]></title>
    <url>%2Fposts%2Fe897.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2004 提高组 T1Luogu1089Caioj1516 Problem【Brief description】津津的零花钱一直都是自己管理。每个月的月初妈妈给津津300元钱，津津会预算这个月的花销，并且总能做到实际花销和预算的相同。为了让津津学习如何储蓄，妈妈提出，津津可以随时把整百的钱存在她那里，到了年末她会加上20％还给津津。因此津津制定了一个储蓄计划：每个月的月初，在得到妈妈给的零花钱后，如果她预计到这个月的月末手中还会有多于100元或恰好100元，她就会把整百的钱存在妈妈那里，剩余的钱留在自己手中。例如11月初津津手中还有83元，妈妈给了津津300元。津津预计11月的花销是180元，那么她就会在妈妈那里存200元，自己留下183元。到了11月月末，津津手中会剩下3元钱。津津发现这个储蓄计划的主要风险是，存在妈妈那里的钱在年末之前不能取出。有可能在某个月的月初，津津手中的钱加上这个月妈妈给的钱，不够这个月的原定预算。如果出现这种情况，津津将不得不在这个月省吃俭用，压缩预算。现在请你根据2004年1月到12月每个月津津的预算，判断会不会出现这种情况。如果不会，计算到2004年年末，妈妈将津津平常存的钱加上20％还给津津之后，津津手中会有多少钱。【Input】包括12行数据，每行分别表示1月到12月津津的预算。【Output】一行，这一行只包含一个整数。如果储蓄计划实施过程中出现某个月钱不够用的情况，输出-X，X表示出现这种情况的第一个月；否则输出到2004年年末津津手中会有多少钱。【Limited conditions】预算是一个小于350的非负整数【Sample input】29023028020030017034050908020060【Sample output】-7【Sample explanation】无 Record20min Analysis请先思考后再展开 模拟 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int MAXN=310,MAXM=91000;const int INF=0x3f3f3f3f;//****************全局定义****************int a[13];//****************实现****************//****************主函数****************int main()&#123; int s=0,now=0; for(int i=1;i&lt;=12;i++) &#123; scanf("%d",&amp;a[i]); now+=300; now-=a[i]; if(now&lt;0) &#123; printf("%d",-i); return 0; &#125; s+=(now/100)*100; now%=100; &#125; double t=now; t+=double(s)*1.2; printf("%.0lf",t);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1041】传染病控制]]></title>
    <url>%2Fposts%2F5005.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2003 提高组 T4Luogu1041Caioj1515 Problem【Brief description】研究表明，这种传染病的传播具有两种很特殊的性质；第一是它的传播途径是树型的，一个人 X 只可能被某个特定的人 Y 感染，只要 Y 不得病，或者是XY之间的传播途径被切断，则X就不会得病。第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。你的程序要针对给定的树，找出合适的切断顺序。【Input】输入格式的第一行是两个整数n和p。接下来p行，每一行有两个整数i和j，表示节点i和j间有边相连（意即，第i人和第j人之间有传播途径相连）。其中节点1是已经被感染的患者。【Output】输出总共被感染的人数【Limited conditions】1≤n≤300【Sample input】7 61 21 32 42 53 63 7【Sample output】3【Sample explanation】无 Record1h Analysis1请先思考后再展开 一开始打了个贪心，居然90？？？简易数据：10 91 21 32 42 52 63 77 88 99 10 Code1请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int MAXN=310,MAXM=91000;const int INF=0x3f3f3f3f;//****************全局定义****************struct Nod&#123; int hou; int fa; int dep,siz; bool v; Nod() &#123; hou=dep=siz=v=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXM];int ln=0;void ins(int x,int y)&#123; ln++;e[ln].y=y; e[ln].g=p[x].hou;p[x].hou=ln;&#125;int n;vector&lt;int&gt; dp[MAXN];//****************实现****************void dfs1(int x,int fa)//计算dep、siz&#123; p[x].fa=fa; p[x].dep=p[fa].dep+1; p[x].siz=1; dp[ p[x].dep ].push_back(x); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y==fa) continue; dfs1(y,x); p[x].siz+=p[y].siz; &#125;&#125;void dfs2(int x)//安全&#123; p[x].v=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) if(e[k].y!=p[x].fa) dfs2(e[k].y);&#125;int solve()&#123; dfs1(1,0); int ans=n; for(int i=2;!dp[i].empty();i++) &#123; int t=0,sz=0; for(int j=0;j&lt;=dp[i].size()-1;j++) &#123; int x=dp[i][j]; if(p[x].v==0 and p[x].siz&gt;sz) sz=p[x].siz,t=x; &#125; dfs2(t); ans-=sz; &#125; return ans;&#125;//****************主函数****************int main()&#123; int m;scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; printf("%d",solve());&#125; Analysis2请先思考后再展开 原来爆搜就好了QAQ Code2请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int MAXN=310,MAXM=91000;const int INF=0x3f3f3f3f;//****************全局定义****************struct Nod&#123; int hou; int fa; int dep,siz; bool v; Nod() &#123; hou=dep=siz=v=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXM];int ln=0;void ins(int x,int y)&#123; ln++;e[ln].y=y; e[ln].g=p[x].hou;p[x].hou=ln;&#125;int n;vector&lt;int&gt; dp[MAXN];//****************实现****************void dfs1(int x,int fa)//计算dep、siz&#123; p[x].fa=fa; p[x].dep=p[fa].dep+1; p[x].siz=1; dp[ p[x].dep ].push_back(x); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y==fa) continue; dfs1(y,x); p[x].siz+=p[y].siz; &#125;&#125;void hit(int x,bool c)&#123; p[x].v=c; for(int k=p[x].hou;k&gt;0;k=e[k].g) if(e[k].y!=p[x].fa) hit(e[k].y,c);&#125;int ans=INF;void solve(int dep,int sum)&#123; ans=mymin(ans,sum); for(int i=0;i&lt;dp[dep].size();i++) &#123; int j=dp[dep][i]; if(p[j].v) continue; hit(j,1); solve(dep+1,sum-p[j].siz); hit(j,0); &#125;&#125;//****************主函数****************int main()&#123; int m;scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; dfs1(1,0); solve(2,n); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1006】加分二叉树]]></title>
    <url>%2Fposts%2F1339.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2003 提高组 T3Luogu1006Caioj1535 Problem【Brief description】设一个n个节点的二叉树tree的中序遍历为（1,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下：subtree的左子树的加分×subtree的右子树的加分+subtree的根的分数若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出；（1）tree的最高加分（2）tree的前序遍历【Input】第1行：一个整数n，为节点个数。第2行：n个用空格隔开的整数，为每个节点的分数。【Output】第1行：一个整数，为最高加分。第2行：n个用空格隔开的整数，为该树的前序遍历。【Limited conditions】n＜30分数＜100结果不会超过4,000,000,000【Sample input】55 7 1 2 10【Sample output】1453 1 2 4 5【Sample explanation】无 Record30min Analysis请先思考后再展开 经典题 Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************int n;int d[40];int rt[40][40];//区间根//****************实现****************int f[40][40];void treedp(int l,int r)&#123; if(f[l][r]&gt;0) return; if(l&gt;r) &#123; f[l][r]=1; return; &#125; if(l==r) &#123; f[l][r]=d[l]; rt[l][r]=l; return; &#125; for(int i=l;i&lt;=r;i++) &#123; treedp(l,i-1);treedp(i+1,r); int t=f[l][i-1]*f[i+1][r]+d[i]; if(t&gt;f[l][r]) &#123; f[l][r]=t; rt[l][r]=i; &#125; &#125;&#125;void pf(int l,int r)&#123; int mid=rt[l][r]; printf("%d ",mid); if(l&lt;=mid-1) pf(l,mid-1); if(mid+1&lt;=r) pf(mid+1,r);&#125;//****************主函数****************int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;d[i]); treedp(1,n); printf("%d\n",f[1][n]); pf(1,n);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2326】数学作业]]></title>
    <url>%2Fposts%2F34da.html</url>
    <content type="text"><![CDATA[Source and JudgeHNOI2011 Day1 T1Bzoj2326Luogu3216 Problem【Brief description】给定正整数 N 和 M 要求计算 Concatenate (1 .. N) Mod M 的值，其中 Concatenate (1 ..N)是将所有正整数 1, 2, …, N 顺序连接起来得到的数。例如，N = 13, Concatenate (1 .. N)=12345678910111213.小C 想了大半天终于意识到这是一道不可能手算出来的题目，于是他只好向你求助，希望你能编写一个程序帮他解决这个问题。【Input】只有一行且为用空格隔开的两个正整数N和M，【Output】仅包含一个非负整数，表示 Concatenate (1 .. N) Mod M 的值。【Limited conditions】1≤N≤10^18且1≤M≤10^9.【Sample input】13 13【Sample output】4【Sample explanation】无 Analysis请先思考后再展开 矩阵乘法分层即可今天早上考试的签到题 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;ll MOD;struct martix&#123; int row,col; ll m[10][10]; martix() &#123; memset(m,0,sizeof(m)); &#125;&#125;;martix cheng(martix a,martix b)&#123; martix c; int n=a.row,m=a.col,p=b.col; c.row=n;c.col=p; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) c.m[i][j]=(c.m[i][j]+(a.m[i][k]%MOD)*(b.m[k][j]%MOD)%MOD)%MOD; return c;&#125;martix pre(int n)&#123; martix a;a.row=a.col=n; for(int i=1;i&lt;=n;i++) a.m[i][i]=1; return a;&#125;martix power(martix x,ll e)&#123; martix ans=pre(x.row); while(e&gt;0) &#123; if(e&amp;1) ans=cheng(ans,x); x=cheng(x,x);e&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; ll n;scanf("%lld%lld",&amp;n,&amp;MOD); martix a;a.row=a.col=3; a.m[1][1]=1;a.m[1][2]=a.m[2][2]=a.m[2][3]=a.m[3][3]=1; martix b;b.row=3;b.col=1; b.m[2][1]=b.m[3][1]=1; ll s=10; while(1) &#123; ll l=s/10ll,r=s-1; ll e=r-l+1; if(n&lt;r) e=n-l+1; martix tmp=a;tmp.m[1][1]=s%MOD;tmp=power(tmp,e); b=cheng(tmp,b); if(n&lt;s) break; s*=10; &#125; printf("%lld",b.m[1][1]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1039】侦探推理]]></title>
    <url>%2Fposts%2F9061.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2003 提高组 T2Luogu1039Caioj1513 Problem【Brief description】明明的同学们先商量好由其中的一个人充当罪犯（在明明不知情的情况下），明明的任务就是找出这个罪犯。接着，明明逐个询问每一个同学，被询问者可能会说：证词中出现的其他话，都不列入逻辑推理的内容。明明所知道的是，他的同学中有N个人始终说假话，其余的人始终说真。现在，明明需要你帮助他从他同学的话中推断出谁是真正的凶手，请记住，凶手只有一个！【Input】输入由若干行组成，第一行有三个整数，M、N和P；M是参加游戏的明明的同学数，N是其中始终说谎的人数，P是证言的总数。接下来M行，每行是明明的一个同学的名字（英文字母组成，没有空格，全部大写）。往后有P行，每行开始是某个同学的名宇，紧跟着一个冒号和一个空格，后面是一句证词，符合前表中所列格式。证词每行不会超过250个字符。输入中不会出现连续的两个空格，而且每行开头和结尾也没有空格。【Output】如果你的程序能确定谁是罪犯，则输出他的名字；如果程序判断出不止一个人可能是罪犯，则输出 Cannot Determine；如果程序判断出没有人可能成为罪犯，则输出 Impossible。【Limited conditions】1≤M≤201≤N≤M1≤P≤100【Sample input】3 1 5MIKECHARLESKATEMIKE: I am guilty.MIKE: Today is Sunday.CHARLES: MIKE is guilty.KATE: I am guilty.KATE: How are you??【Sample output】MIKE【Sample explanation】无 Record30min Analysis请先思考后再展开 真有意思的题面嘿嘿然后又去看了看数据没有极限数据是意料之中【取而代之的是恶心数据，不知道满分的都是什么人……】的了，但居然还有这个hhI love you!If there must be a deadline,I hope it is 10000 years!!!然后他的名字是拼音，翻译过来就是：曾经有一段真挚的感情。芳，在我面前，我没有珍惜。等到失去了以后，才追悔莫及。人世间最痛苦的事莫过于此。如果上天能给我一个再来一次的机会，我会对那个女孩子说三个字 好了讲正事，暴力枚举判断可行性即可就是这个输入麻烦……大小写敏感测试点#2：有一位同志，既承认自己有罪，又承认自己无罪。【然后答案居然是Impossible，辣鸡题面没说清】测试点#9：“I is not guilty.”，I是人名 woc，这道题大家别写了……虽然我已经把代码尽量精炼，依然是毒瘤题，特别是输入对了，理论上判断废话的时候，前面和后面可能会有废话，而中间重要，但没有这种数据就不打了，太恶心了这种题…… UP:弃坑了可能以后也不会填了贴一个别人的代码吧哎【灰常优质】 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;map&gt;using namespace std;map&lt;string,int&gt; name;string s,ss;string names[25];string testimony[25][105];int num[25];int n,m,p;bool crap(string tmp)&#123; if(tmp==" I am guilty.") return 0; if(tmp==" I am not guilty.") return 0; if(tmp==" Today is Monday.") return 0; if(tmp==" Today is Tuesday.") return 0; if(tmp==" Today is Wednesday.") return 0; if(tmp==" Today is Thursday.") return 0; if(tmp==" Today is Friday.") return 0; if(tmp==" Today is Saturday.") return 0; if(tmp==" Today is Sunday.") return 0; for(int i=1;i&lt;=m;i++) if(tmp==" "+names[i]+" is guilty."||tmp==" "+names[i]+" is not guilty.") return 0; return 1;&#125;bool judge(int guilty,int day)&#123; int ans; for(int i=1;i&lt;=m;i++) &#123; ans=0; for(int j=1;j&lt;=num[i];j++) &#123; if(testimony[i][j]==" I am guilty."&amp;&amp;guilty!=i) &#123;ans++;&#125; if(testimony[i][j]==" I am not guilty."&amp;&amp;guilty==i) &#123;ans++;&#125; if(testimony[i][j]==" Today is Monday."&amp;&amp;day!=1) &#123;ans++;&#125; if(testimony[i][j]==" Today is Tuesday."&amp;&amp;day!=2) &#123;ans++;&#125; if(testimony[i][j]==" Today is Wednesday."&amp;&amp;day!=3) &#123;ans++;&#125; if(testimony[i][j]==" Today is Thursday."&amp;&amp;day!=4) &#123;ans++;&#125; if(testimony[i][j]==" Today is Friday."&amp;&amp;day!=5) &#123;ans++;&#125; if(testimony[i][j]==" Today is Saturday."&amp;&amp;day!=6) &#123;ans++;&#125; if(testimony[i][j]==" Today is Sunday."&amp;&amp;day!=7) &#123;ans++;&#125; for(int k=1;k&lt;=m;k++) &#123; if(testimony[i][j]==" "+names[k]+" is guilty."&amp;&amp;guilty!=k) &#123;ans++;&#125; if(testimony[i][j]==" "+names[k]+" is not guilty."&amp;&amp;guilty==k) &#123;ans++;&#125; &#125; &#125; if(ans!=num[i]&amp;&amp;ans!=0) return 0; &#125; return 1;&#125;int check(int guilty,int day)&#123; int ans=0; bool twice; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=num[i];j++) &#123; twice=0; if(testimony[i][j]==" I am guilty."&amp;&amp;guilty!=i) &#123;ans++;break;&#125; if(testimony[i][j]==" I am not guilty."&amp;&amp;guilty==i) &#123;ans++;break;&#125; if(testimony[i][j]==" Today is Monday."&amp;&amp;day!=1) &#123;ans++;break;&#125; if(testimony[i][j]==" Today is Tuesday."&amp;&amp;day!=2) &#123;ans++;break;&#125; if(testimony[i][j]==" Today is Wednesday."&amp;&amp;day!=3) &#123;ans++;break;&#125; if(testimony[i][j]==" Today is Thursday."&amp;&amp;day!=4) &#123;ans++;break;&#125; if(testimony[i][j]==" Today is Friday."&amp;&amp;day!=5) &#123;ans++;break;&#125; if(testimony[i][j]==" Today is Saturday."&amp;&amp;day!=6) &#123;ans++;break;&#125; if(testimony[i][j]==" Today is Sunday."&amp;&amp;day!=7) &#123;ans++;break;&#125; for(int k=1;k&lt;=m;k++) &#123; if(testimony[i][j]==" "+names[k]+" is guilty."&amp;&amp;guilty!=k) &#123;ans++;twice=1;break;&#125; if(testimony[i][j]==" "+names[k]+" is not guilty."&amp;&amp;guilty==k) &#123;ans++;twice=1;break;&#125; &#125; if(twice==1) break; &#125; if(ans!=n) for(int i=1;i&lt;=m;i++) &#123; if(num[i]==0) ans++; if(ans==n) break; &#125; return ans;&#125;int read()&#123; char c=getchar(); int ans=0; while(c&lt;'0'||c&gt;'9') c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9') &#123; ans=ans*10+c-48; c=getchar(); &#125; return ans;&#125;string gl()&#123; string sss,c; do &#123; cin&gt;&gt;c; sss=sss+" "+c; &#125; while(c[c.size()-1]!='.'&amp;&amp;c[c.size()-1]!='?'&amp;&amp;c[c.size()-1]!='!'&amp;&amp;c[c.size()-1]!=','); return sss;&#125;int main()&#123; m=read();n=read();p=read(); for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;s; name[s]=i; names[i]=s; &#125; for(int i=1;i&lt;=p;i++) &#123; cin&gt;&gt;s; s=s.substr(0,s.size()-1); ss=gl(); if(crap(ss)) continue; num[name[s]]++; testimony[name[s]][num[name[s]]]=ss; &#125; int flag=0; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=7;j++) if(check(i,j)==n&amp;&amp;judge(i,j)) &#123; if(flag!=0) &#123; cout&lt;&lt;"Cannot Determine"&lt;&lt;endl; return 0; &#125; else &#123; flag=i; break; &#125; &#125; if(flag==0) cout&lt;&lt;"Impossible"&lt;&lt;endl; else cout&lt;&lt;names[flag]&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1038】神经网络]]></title>
    <url>%2Fposts%2F3ef1.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2003 提高组 T1Luogu1038Caioj1512 Problem【Brief description】在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的栗子：神经元〔编号为1）图中，X1―X3是信息输入渠道，Y1－Y2是信息输出渠道，C1表示神经元目前的状态，Ui是阈值，可视为神经元的一个内在参数。神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的栗子。兰兰规定，Ci服从公式：（其中n是网络中所有神经元的数目）公式中的Wji（可能为负值）表示连接j号神经元和i号神经元的边的权值。当 Ci 大于0时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为Ci。如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（Ci），要求你的程序运算出最后网络输出层的状态。【Input】第一行是两个整数n和p。接下来n行，每行两个整数，第i＋1行是神经元i最初状态和其阈值（Ui），非输入层的神经元开始时状态必然为0。再下面P行，每行由两个整数i，j及一个整数Wij，表示连接神经元i、j的边权值为Wij。【Output】输出文件包含若干行，每行有两个整数，分别对应一个神经元的编号，及其最后的状态，两个整数间以空格分隔。仅输出最后状态大于零的输出层神经元状态，并且按照编号由小到大顺序输出！若输出层的神经元最后状态均为 0，则输出 NULL。【Limited conditions】1≤n≤200【Sample input】5 61 01 00 10 10 11 3 11 4 11 5 12 3 12 4 12 5 1【Sample output】3 14 15 1【Sample explanation】无 Record30min Analysis请先思考后再展开 拓扑裸题坑点: 输入层c不用计算，u没用 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int MAXN=210,MAXM=51000;const int INF=0x3f3f3f3f;//****************全局定义****************struct Nod&#123; int hou; int c; int ru; bool v; Nod() &#123; hou=ru=v=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,c,g;&#125;e[MAXM];int ln=0;void ins(int x,int y,int c)&#123; e[++ln].y=y;e[ln].c=c;e[ln].g=p[x].hou; p[x].hou=ln;p[y].ru++;&#125;//****************实现****************int n;void solve()&#123; int tp=0; while(tp&lt;n) &#123; tp++; int x=-1;for(int i=1;i&lt;=n;i++) if(p[i].c&gt;0 and p[i].ru==0) &#123;x=i;break;&#125; if(x&lt;0) break; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; p[y].ru--; p[y].c+=e[k].c*p[x].c; &#125; if(p[x].hou&gt;0) p[x].c=0;//debug &#125;&#125;//****************主函数****************int main()&#123; int m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d%d",&amp;p[i].c,&amp;t); if(p[i].c==0) p[i].c-=t; &#125; while(m--) &#123; int x,y,c; scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c); &#125; solve(); bool bk=0; for(int i=1;i&lt;=n;i++) if(p[i].hou==0 and p[i].c&gt;0) bk=1,printf("%d %d\n",i,p[i].c); if(bk==0) printf("NULL");&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
        <tag>拓扑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1034】矩形覆盖]]></title>
    <url>%2Fposts%2F7.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2002 提高组 T4Luogu1034Caioj1511 Problem【Brief description】在平面上有 n 个点，每个点用一对整数坐标表示。例如：当 n=4 时，4个点的坐标分另为：p1(1,1),p2(2,2),p3(3，6),P4(0,7)，见图一。这些点可以用 k 个矩形（1&lt;=k&lt;=4）全部覆盖，矩形的边平行于坐标轴。当 k=2 时，可用如图二的两个矩形 s1，s2 覆盖，s1，s2 面积和为 4。问题是当 n 个点坐标和 k 给出后，怎样才能使得覆盖所有点的 k 个矩形的面积之和为最小。约定：覆盖一个点的矩形面积为 0；覆盖平行于坐标轴直线上点的矩形面积也为0。各个矩形必须完全分开（边线与顶点也都不能重合）。【Input】n k x1 y1 x2 y2 ……xn yn【Output】一个整数，即满足条件的最小的矩形面积之和。【Limited conditions】n&lt;=500&lt;=xi,yi&lt;=500【Sample input】4 21 12 23 60 7【Sample output】4【Sample explanation】无 Record1h Analysis1请先思考后再展开 首先手痒看了看数据，一如既往地水，连极限数据都没有一开始想着50^6枚举矩形对角点，发现很麻烦，计算量大于是又看了题解，正解太复杂，不管了……【其实正解(极角排序是计算几何的玩意)没有存在的必要，因为我测试了极限数据，灰常快】那么其实只要预设k个矩阵，枚举每个点，假设加入即可 Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************int n,k;struct Pt&#123; int x,y;&#125;p[510];struct Sqr&#123; Pt a,b;//左下、右上 bool v;//初始 Sqr() &#123; v=0; &#125;&#125;sq[5];//****************实现****************bool isfg(int x,int y)&#123; if(sq[x].v==0 or sq[y].v==0) return 0; if(sq[x].a.x&gt;sq[y].b.x or sq[x].a.y&gt;sq[y].b.y) return 0; if(sq[y].a.x&gt;sq[x].b.x or sq[y].a.y&gt;sq[x].b.y) return 0; return 1;&#125;bool okay()&#123; for(int i=1;i&lt;=k;i++) for(int j=1;j&lt;=k;j++) if(i!=j and isfg(i,j)) return 0; return 1;&#125;int sum()&#123; int ans=0; for(int i=1;i&lt;=k;i++) if(sq[i].v!=0) ans+=(sq[i].b.x-sq[i].a.x)*(sq[i].b.y-sq[i].a.y); return ans;&#125;int ans=INF;void dfs(int used)&#123; if(used==n) &#123; int t=0; for(int i=1;i&lt;=k;i++) if(sq[i].v==0) return; else t+=(sq[i].b.x-sq[i].a.x)*(sq[i].b.y-sq[i].a.y); ans=mymin(ans,t); return; &#125; int x=used+1; for(int i=1;i&lt;=k;i++) &#123; Sqr tmp=sq[i]; if(sq[i].v==0) &#123; sq[i].v=1; sq[i].a=sq[i].b=p[x]; &#125; else &#123; sq[i].a.x=mymin(sq[i].a.x,p[x].x); sq[i].a.y=mymin(sq[i].a.y,p[x].y); sq[i].b.x=mymax(sq[i].b.x,p[x].x); sq[i].b.y=mymax(sq[i].b.y,p[x].y); &#125; if(okay() and sum()&lt;ans) dfs(used+1); sq[i]=tmp;//还原 &#125;&#125;//****************主函数****************int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].x,&amp;p[i].y); dfs(0); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1033】自由落体]]></title>
    <url>%2Fposts%2F19c9.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2002 提高组 T3Luogu1033Caioj1510辣鸡题面一大堆错误 Problem【Brief description】在高为 H 的天花板上有 n 个小球，体积不计，位置分别为 0，1，2，… ，n-1。在地面上有一个小车（长为 L，高为 K，距原点距离为 S1）。已知小球下落距离计算公式为 $d=\frac{g\times t^2}{2}$ ，其中 g=10，t为下落时间。地面上的小车以速度 V 前进。小车与所有小球同时开始运动，当小球距小车的距离 &lt;= 0.0001时，即认为小球被小车接收（小球落到地面后不能被接收）。请你计算出小车能接收到多少个小球（当球落入车的尾部时，算作落入车内）。【Input】H，S1，V，L，K，n【Output】小车能接收到的小球个数【Limited conditions】1&lt;=H，S1，V，L，K，n&lt;=100000【Sample input】5.0 9.0 5.0 2.5 1.8 5【Sample output】1【Sample explanation】无 Record30min Analysis请先思考后再展开 一开始想错了……现在越来越觉得noip2017真的是太幸运了，题目比较正常这种精度题，公式很容易推错，特别是那个精度不是很懂怎么用然后比赛的时候也出不了什么强力数据 主要从最早和最晚情况考虑自由落体公式化简：$ t=\sqrt{\frac{d}{5}} $早：落到地面（底部）时间：$ a=\sqrt{\frac{H}{5}} $车头到达时间：$ b=\frac{S-(i+0.0001)}{v} $条件：$ a\geq b $晚：落到车尾（顶部）时间：$ c=\sqrt{\frac{H-K}{5}} $车尾到达时间：$ d=\frac{(S+L)-(i-0.0001)}{v} $条件：$ c\leq d $【注意很多网上代码的d都是错误的，0.0001应该是负】 Code请先思考后再展开 1234567891011121314int main()&#123; double h,s,v,l,k,n;scanf("%lf%lf%lf%lf%lf%lf",&amp;h,&amp;s,&amp;v,&amp;l,&amp;k,&amp;n); int ans=0; for(int i=0;i&lt;=n-1;i++) &#123; if( ( (s+l)-(i-0.0001) )/v &gt;= sqrt( (h-k)/5 ) and sqrt(h/5) &gt;= ( s-(i+0.0001) )/v ) ans++; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1032】字串变换]]></title>
    <url>%2Fposts%2F3d30.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2002 提高组 T2Luogu1032Caioj1509 Problem【Brief description】已知有两个字串 A, B 及一组字串变换的规则（至多6个规则）:A1 -&gt; B1A2 -&gt; B2规则的含义为：在 A中的子串 A1 可以变换为 B1、A2 可以变换为 B2 ……例如：A＝’abcd’ B＝’xyz’变换规则为：‘abc’-&gt;’xu’‘ud’-&gt;’y’‘y’-&gt;’yz’则此时，A 可以经过一系列的变换变为 B，其变换的过程为：‘abcd’-&gt;’xud’-&gt;’xy’-&gt;’xyz’共进行了三次变换，使得 A 变换为 B。【Input】A BA1 B1A2 B2… …【Output】若在 10 步（包含 10步）以内能将 A 变换为 B ，则输出最少的变换步数；否则输出”NO ANSWER!”【Limited conditions】所有字符串长度的上限为 20。【Sample input】abcd xyzabc xuud yy yz【Sample output】3【Sample explanation】无 Record2h剪枝是灰常重要滴！ Analysis1请先思考后再展开 边跑步边想……然后最好bfs，但去重好麻烦，先打个dfs试试感觉会超时，真的太危险啦然鹅事实上set的log可以剪掉灰常多的枝 or 数据乱出，很水果然是陈年老题s stl大法好 哦有个坑点：题目是可以变换，那就不一定要全部变 一直wa啊，有一个很玄学的地方，不知有没有dalao知道？UP:原来是因为，size返回的是一个无符号数，要转化为int Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//Zory-2018//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量****************const int INF=0x3f3f3f3f;//*******************全局定义****************string st,ed;string op1[10],op2[10];int f;map&lt;string,int&gt; has;//对应答案int mi,mx;//长度可行性优化//*******************实现******************void dfs(string now,int p)&#123; if(p&gt;=10) return; if( (int)now.length()+(10-p)*mi &gt; (int)ed.length() ) return; if( (int)now.length()+(10-p)*mx &lt; (int)ed.length() ) return; for(int i=1;i&lt;=f;i++) &#123; int pos=now.find(op1[i],0); while(pos&gt;=0) &#123; string tmp=now; tmp.replace(pos,op1[i].length(),op2[i]); if( !has.count(tmp) or has[tmp]&gt;p+1) has[tmp]=p+1,dfs(tmp,p+1); pos=now.find(op1[i],pos+1); &#125; &#125;&#125;//*******************主函数******************int main()&#123; cin&gt;&gt;st&gt;&gt;ed; f=1;mi=INF;mx=0; while(cin&gt;&gt;op1[f]&gt;&gt;op2[f]) &#123; mi=mymin(mi,op2[f].length()-op1[f].length()); mx=mymax(mx,op2[f].length()-op1[f].length()); f++; &#125; f--; has[st]=0; dfs(st,0); if(!has.count(ed)) printf("NO ANSWER!"); else printf("%d",has[ed]);&#125; Analysis2请先思考后再展开 然后akc教我hash，自然溢出什么的终于到最快的正解bfs了不过因为是手写的数组，空间不好控制【不明确的数据范围】 Code2请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//Zory-2018//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量****************const int MAXN=100000;const int INF=0x3f3f3f3f;//*******************全局定义****************set&lt;int&gt; has;struct Str&#123; char s[300]; int ln; int ps;&#125;;Str st,ed;int sth,edh;Str op1[10],op2[10];int n;int mi,mx;//长度可行性优化//*******************实现******************int hashstr(Str s)&#123; int ans=0,t=1; for(int i=1;i&lt;=s.ln;i++) &#123; ans+=t*s.s[i]; t*=271; &#125; return ans;&#125;Str lst[MAXN];int bfs()&#123; sth=hashstr(st);edh=hashstr(ed); has.insert(sth);st.ps=0; int tou=1,wei=2;lst[tou]=st; while(tou!=wei) &#123; Str now=lst[tou++]; if(tou==MAXN) tou=1; if(now.ps&gt;=10) return 0; for(int i=1;i&lt;=n;i++) &#123; int last=0; while(1) &#123; string str=now.s+1; int t=str.find(op1[i].s+1,last); if(t&lt;0) break; str.replace(t,op1[i].ln,op2[i].s+1); last=t+1; Str nxt;strcpy(nxt.s+1,str.c_str()); nxt.ln=str.length();nxt.ps=now.ps+1; if(nxt.ln+(10-nxt.ps)*mi&gt;ed.ln) continue; if(nxt.ln+(10-nxt.ps)*mx&lt;ed.ln) continue; int hs=hashstr(nxt); if(hs==edh) return nxt.ps; if(has.count(hs)==0) &#123; has.insert(hs); lst[wei++]=nxt; if(wei==MAXN) wei=1; &#125; &#125; &#125; &#125; return 0;&#125;//*******************主函数******************int main()&#123; scanf("%s%s",st.s+1,ed.s+1); st.ln=strlen(st.s+1);ed.ln=strlen(ed.s+1); n=1;mi=INF;mx=0; while(scanf("%s%s",op1[n].s+1,op2[n].s+1)!=EOF) &#123; op1[n].ln=strlen(op1[n].s+1); op2[n].ln=strlen(op2[n].s+1); mi=mymin(mi,op2[n].ln-op1[n].ln); mx=mymax(mx,op2[n].ln-op1[n].ln); n++; &#125; n--; int t=bfs(); if(!t) printf("NO ANSWER!"); else printf("%d",t);&#125; Analysis3请先思考后再展开 其实如果不满足也可以用折半搜索（不会刻意搜索我的其他题，应该会找到些解释）懒得打了……]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1031】均分纸牌]]></title>
    <url>%2Fposts%2F24a0.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2002 提高组 T1Luogu1031Caioj1508 Problem【Brief description】有N堆纸牌，编号分别为 1，2，…… , N。每堆上有若干张，但纸牌总数必为 N 的倍数。可以在任一堆上取若于张纸牌，然后移动。移牌规则为：在编号为1堆上取的纸牌，只能移到编号为2的堆上；在编号为N的堆上取的纸牌，只能移到编号为 N-1 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。【Input】N（N 堆纸牌）A1 A2 …… An （N 堆纸牌，每堆纸牌初始数）【Output】所有堆均达到相等时的最少移动次数。【Limited conditions】1 &lt;= N &lt;= 1001 &lt;= Ai &lt;= 10000【Sample input】49 8 17 6【Sample output】3【Sample explanation】123456N=4，4堆纸牌数分别为：(1) 9 (2) 8 (3) 17 (4) 6移动3次可达到目的：从 (3) 取 4 张牌放到 (4)（9 8 13 10） -&gt; 从 (3) 取 3 张牌放到 (2)（9 11 10 10） -&gt; 从 (2) 取 1 张牌放到 (1)（10 10 10 10） Record30min Analysis1请先思考后再展开 显然我的贪心很菜 首先，显然我们要与平均数比较，所以可以直接全部减去平均数那么把方向固定，以从左到右为例，对于i，前面i-1个已经解决【不一定是顺序上的】因为只能相邻操作，才保证了这种做法的正确性，总会有与i+1交互的过程那么自己不平衡的时候，步数+1，转移不平衡即可 Code1请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Zory-2018//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量**************** //*******************全局定义****************int a[110];//*******************实现****************** //*******************主函数******************int main()&#123; int n;scanf("%d",&amp;n); int sum=0; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); sum+=a[i]; &#125; sum/=n; int ans=0; for(int i=1;i&lt;=n;i++) &#123; a[i]-=sum; if(a[i]!=0) &#123; ans++; a[i+1]+=a[i]; &#125; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>精品题</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1027】Car的旅行路线]]></title>
    <url>%2Fposts%2Fe9ee.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2001 提高组 T4Luogu1027Caioj1507 Problem【Brief description】又到暑假了，住在城市A的Car想和朋友一起去城市B旅游。她知道每个城市都有四个飞机场，分别位于一个矩形的四个顶点上，同一个城市中两个机场之间有一条笔直的高速铁路，第I个城市中高速铁路了的单位里程价格为Ti，任意两个不同城市的机场之间均有航线，所有航线单位里程的价格均为t。那么Car应如何安排到城市B的路线才能尽可能的节省花费呢?她发现这并不是一个简单的问题，于是她来向你请教。找出一条从城市A到B的旅游路线，出发和到达城市中的机场可以任意选取，要求总的花费最少。【Input】第一行为一个正整数n，表示有n组测试数据。每组的第一行有四个正整数s，t，A，B。S表示城市的个数，t表示飞机单位里程的价格，A，B分别为城市A，B的序号。接下来有S行，其中第I行均有7个正整数xi1，yi1，xi2，yi2，xi3，yi3，Ti，这当中的(xi1，yi1)，(xi2，yi2)，(xi3，yi3)分别是第I个城市中任意三个机场的坐标，T I为第I个城市高速铁路单位里程的价格。【Output】共有n行，每行一个数据对应测试数据。保留一位小数【Limited conditions】0&lt;=n&lt;=100&lt;S&lt;=1001&lt;=A，B&lt;=S【Sample input】13 10 1 31 1 1 3 3 1 302 5 7 4 5 2 18 6 8 8 11 6 3【Sample output】47.5【Sample explanation】 Record1h Analysis1请先思考后再展开 这就是一个复杂构图的最短路裸题属于码农题 关于矩形的第四个点，我是自己yy出来的，写了较多注释 Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//Zory-2018//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;double mymin(double x,double y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量****************const int MAXN=410;const int INF=0x3f3f3f3f;//*******************全局定义****************struct Nod&#123; double x,y; double d; bool v; Nod() &#123; v=0; &#125;&#125;p[MAXN];double cs[MAXN];double mp[MAXN][MAXN];//*******************实现******************double dis(double ax,double ay,double bx,double by)&#123; return sqrt( (ax-bx)*(ax-bx)+(ay-by)*(ay-by) );&#125;void calc4(int x)&#123; int a=4*(x-1),b=4*(x-1)+1,c=4*(x-1)+2,d=4*(x-1)+3; double mx=(p[a].x+p[b].x)/2,my=(p[a].y+p[b].y)/2;//尝试ab double d1=dis(mx,my,p[a].x,p[a].y),d2=dis(mx,my,p[c].x,p[c].y); if( d1-d2&lt;-1e-6 or d1-d2&gt;1e-6 )//取错了，尝试ac &#123; swap(b,c); mx=(p[a].x+p[b].x)/2;my=(p[a].y+p[b].y)/2; d1=dis(mx,my,p[a].x,p[a].y),d2=dis(mx,my,p[c].x,p[c].y); if( d1-d2&lt;-1e-6 or d1-d2&gt;1e-6 )//取错了，尝试bc &#123; swap(a,c); mx=(p[a].x+p[b].x)/2;my=(p[a].y+p[b].y)/2; d1=dis(mx,my,p[a].x,p[a].y),d2=dis(mx,my,p[c].x,p[c].y); &#125; &#125; //a b c d //a c b d //b c a d //现确保a和b为对角 p[d].x=mx*2-p[c].x; p[d].y=my*2-p[c].y; //p[d].x+p[c].x=mx*2&#125;int lst[MAXN];int n;void spfa(int st)&#123; int tou=1,wei=2;lst[tou]=st; p[st].v=1;p[st].d=0; while(tou!=wei) &#123; int x=lst[tou++]; if(tou==MAXN) tou=1; for(int j=0;j&lt;=4*n-1;j++) &#123; if(p[j].d&gt;p[x].d+mp[x][j]) &#123; p[j].d=p[x].d+mp[x][j]; if(!p[j].v) &#123; p[j].v=1; lst[wei++]=j; if(wei==MAXN) wei=1; &#125; &#125; &#125; p[x].v=0; &#125;&#125;//*******************主函数******************int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; int st,ed;double s;scanf("%d%lf%d%d",&amp;n,&amp;s,&amp;st,&amp;ed); for(int i=1;i&lt;=n;i++) &#123; for(int t1=0;t1&lt;=2;t1++) scanf("%lf%lf",&amp;p[4*(i-1)+t1].x,&amp;p[4*(i-1)+t1].y); calc4(i);scanf("%lf",&amp;cs[i]); &#125; for(int i=0;i&lt;=4*n-1;i++) &#123; for(int j=0;j&lt;i;j++) &#123; double ts=( (i/4)==(j/4) )?cs[i/4+1]:s; mp[i][j]=mp[j][i]=dis(p[i].x,p[i].y,p[j].x,p[j].y)*ts; &#125; &#125; double ans=INF; for(int i=0;i&lt;=3;i++) &#123; for(int j=0;j&lt;=4*n-1;j++) p[j].d=INF; spfa(4*(st-1)+i); for(int j=0;j&lt;=3;j++) ans=mymin(ans,p[ 4*(ed-1)+j ].d); &#125; printf("%.2lf\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1026】统计单词个数]]></title>
    <url>%2Fposts%2Fd51a.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2001 提高组 T3Luogu1026Caioj1506 Problem【Brief description】给出一个长度不超过200的由小写英文字母组成的字母串。约定：该字串以每行20个字母的方式输入，且保证每行一定为20个。要求将此字母串分成k份，且每份中包含的单词个数加起来总数最大。每份中包含的单词可以部分重叠。当选用一个单词之后，其第一个字母不能再用。例如字符串this中可以包含this和is，选用this之后就不能包含th。单词在给出的一个不超过6个单词的字典中。要求输出最大的个数。【Input】第一行有2个正整数p，k。p表示字串的行数；k表示分为k个部分。接下来的p行，每行均有20个字符。再接下来有一个正整数s，表示字典中单词个数。接下来的s行，每行均有一个单词。【Output】一个整数，表示划分出来的最多单词个数【Limited conditions】1≤s≤6，1&lt;k≤40【Sample input】1 3thisisabookyouareaoh4isaoksab【Sample output】7【Sample explanation】按如下方式划分字符串：this/isabookyoua/reaoh Record1h Analysis1请先思考后再展开 错误解法：kmp乱搞会wa的……【居然也就20分】数据:1 4aaaaaaaaaaaaaaaaaaaa1aaaaa 主要思路：所谓寻找字符串，那划分一定不是重点【flag】那么就先kmp查找，统计一下断点的影响量即可 但这样会减重复然后不知道怎么更正……又去膜题解了 Code1请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//Zory-2018//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量****************//*******************全局定义****************char s[300];int ls;char s2[10][300];int ls2[10];//*******************实现******************int nxt[10][300];void calcnxt(int x)&#123; nxt[x][1]=0; for(int i=2;i&lt;=ls2[x];i++) &#123; int j=nxt[x][i-1]; while(j&gt;0 and s2[x][j+1]!=s2[x][i]) j=nxt[x][j]; if(s2[x][j+1]==s2[x][i]) nxt[x][i]=j+1; else nxt[x][i]=0; &#125;&#125;int a[300];bool v[300];int ans=0;void kmp(int x)&#123; int j=0; for(int i=1;i&lt;=ls;i++) &#123; while(j&gt;0 and s2[x][j+1]!=s[i]) j=nxt[x][j]; if(s2[x][j+1]==s[i]) j++; if(j==ls2[x]) &#123; int st=i-j+1; if(!v[st]) &#123; v[st]=1; for(int k=st;k&lt;=i-1;k++) a[k]++; ans++; &#125; &#125; &#125;&#125;//*******************主函数******************char ts[300];int main()&#123; int p,k;scanf("%d%d",&amp;p,&amp;k); while(p--) scanf("%s",ts),strcat(s+1,ts); ls=strlen(s+1); int t;scanf("%d",&amp;t); for(int i=1;i&lt;=t;i++) &#123; scanf("%s",s2[i]+1); ls2[i]=strlen(s2[i]+1); calcnxt(i); kmp(i); &#125; sort(a+1,a+(ls-1)+1); for(int i=1;i&lt;=k-1;i++) ans-=a[i]; printf("%d",ans);&#125; Analysis2请先思考后再展开 居然又是DP哎好菜主要是预处理出区间的答案本做法其实灰常慢……因为匹配的时候是暴力但数据太水，而且题目居然还不说单词长度 Code2请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//Zory-2018//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量****************//*******************全局定义****************int ss;char s[300],s2[10][300];int ls2[10];int q[300][300];int f[300][50];//*******************实现******************int ask(int l,int r)&#123; for(int i=1;i&lt;=ss;i++) &#123; if(r-l+1&lt;ls2[i]) continue; int j=0;while(s2[i][j+1]==s[l+j] and j+1&lt;=ls2[i]) j++;//debug if(j==ls2[i]) return 1; &#125; return 0;&#125;//*******************主函数******************int main()&#123; int p,k;scanf("%d%d",&amp;p,&amp;k); for(int i=1;i&lt;=p;i++) scanf("%s",s+(i-1)*20+1); p*=20; scanf("%d",&amp;ss); for(int i=1;i&lt;=ss;i++) scanf("%s",s2[i]+1),ls2[i]=strlen(s2[i]+1); /* for(int l=1;l&lt;=p;l++) for(int r=l;r&lt;=p;r++) for(int st=l;st&lt;=r;st++) q[l][r]+=ask(st,r); */ for(int l=p;l&gt;=1;l--) for(int r=l;r&lt;=p;r++) q[l][r]=q[l+1][r]+ask(l,r); //优化 for(int i=1;i&lt;=p;i++) f[i][1]=q[1][i]; for(int bl=2;bl&lt;=k;bl++) for(int i=bl;i&lt;=p;i++) for(int j=bl-1;j&lt;=i-1;j++) f[i][bl]=mymax(f[i][bl],f[j][bl-1]+q[j+1][i]); printf("%d",f[p][k]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1025】数的划分]]></title>
    <url>%2Fposts%2F2ac6.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2001 提高组 T2Luogu1025Caioj1505 Problem【Brief description】将整数n分成k份，且每份不能为空，任意两份不能相同(不考虑顺序)。例如:n=7,k=3,下面三种分法被认为是相同的。1，1，5；1，5，1；5，1，1；问有多少种不同的分法。【Input】n,k【Output】一个整数，即不同的分法。【Limited conditions】6&lt;n&lt;=200，2&lt;=k&lt;=6【Sample input】7 3【Sample output】4【Sample explanation】4种分法为：1,1,5；1,2,4；1,3,3；2,2,3 Record1h Analysis请先思考后再展开 较慢：dfs但加上记忆化就和DP一样了……没必要纠结 Code请先思考后再展开 123456789101112int ans=0;void dfs(int lst,int n,int k)&#123; if(k==1) &#123; ans++;return; &#125; for(int t=lst;t+(k-1)*t&lt;=n;t++) dfs(t,n-t,k-1);&#125;int main()&#123; int n,k;scanf("%d%d",&amp;n,&amp;k); dfs(1,n,k); printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1024】一元三次方程求解]]></title>
    <url>%2Fposts%2Ff28f.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2001 提高组 T1Luogu1024Caioj1504 Problem【Brief description】有形如：ax^3+bx^2+c^x+d=0 这样的一个一元三次方程。给出该方程中各项的系数，并约定该方程存在三个不同实根(根的范围在-100至100之间)，且根与根之差的绝对值&gt;=1。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后2位。提示：记方程f(x)=0，若存在2个数x1和x2，且x1&lt;x2，f(x1)*f(x2)&lt;0，则在(x1，x2)之间一定有一个根。【Input】4个实数A，B，C，D【Output】三个实根，并精确到小数点后2位【Limited conditions】a，b，c，d 均为实数【Sample input】1 -5 -4 20【Sample output】-2.00 2.00 5.00【Sample explanation】无 Record10min Analysis1请先思考后再展开 神题…… Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量****************//*******************全局定义****************double a,b,c,d;//*******************实现******************bool check(double x)&#123; double t=a*x*x*x+b*x*x+c*x+d; return (t&gt;=-1e-6) and (t&lt;=1e-6);&#125;//*******************主函数******************int main()&#123; scanf("%lf%lf%lf%lf",&amp;a,&amp;b,&amp;c,&amp;d); for(int i=-10000;i&lt;=10000;i++) &#123; double t=double(i)/100; if(check(t)) printf("%.2lf ",t); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1019】单词接龙]]></title>
    <url>%2Fposts%2Ff653.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2000 提高组 T3Luogu1019Caioj1502 Problem【Brief description】单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 beast和astonish，如果接成一条龙则变为beastonish，另外相邻的两部分不能存在包含关系，例如at 和 atide 间不能相连。【Input】第一行为一个单独的整数n表示单词数，以下n行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在.【Output】只需输出以此字母开头的最长的“龙”的长度【Limited conditions】n&lt;=20【Sample input】5attouchcheatchoosetacta【Sample output】23【Sample explanation】连成的“龙”为atoucheatactactouchoose Record1h Analysis请先思考后再展开 躺床上想了半天，没什么思路无奈看正解tm居然是爆搜？？？这是提高组？？？ 合并条件： 重叠长度&gt;=1,并!=min(长度) 使用次数&lt;2 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量**************** //*******************全局定义****************char s[30][10000];int mn[30][30];int ln[30];//*******************实现******************void calc(int x,int y)&#123; for(int i=ln[x];i&gt;=1;i--) &#123; int t=1;while(t&lt;=ln[y] and i+t-1&lt;=ln[x] and s[x][i+t-1]==s[y][t]) t++; if(t&gt;ln[y]) break; if(i+t-1&gt;ln[x]) &#123; mn[x][y]=t-1; break; &#125; &#125;&#125;int n;int ans=0;int use[30];void dfs(int x,int now)&#123; ans=mymax(now,ans); for(int i=1;i&lt;=n;i++) if(use[i]&lt;2 and mn[x][i]&gt;0) &#123; use[i]++; dfs(i,now+ln[i]-mn[x][i]); use[i]--; &#125;&#125;//*******************主函数******************int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%s",s[i]+1),ln[i]=strlen(s[i]+1); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) calc(i,j); char c[3];scanf("%s",c); for(int i=1;i&lt;=n;i++) if(s[i][1]==c[0]) &#123; use[i]++; dfs(i,ln[i]); use[i]--; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1017】进制转换]]></title>
    <url>%2Fposts%2F375d.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2000 提高组 T1Luogu1017Caioj1500 Problem【Brief description】我们可以用这样的方式来表示一个十进制数:将每个阿拉伯数字乘以一个以该数字所处位置的(值减1)为指数,以10为底数的幂之和的形式。例如:123可表示为 1*10^2+2*10^1+3*10^0 这样的形式。与之相似的,对二进制数来说,也可表示成每个二进制数码乘以一个以该数字所处位置的(值-1)为指数,以2为底数的幂之和的形式。一般说来,任何一个正整数R或一个负整数-R都可以被选来作为一个数制系统的基数。如果是以R或-R为基数,则需要用到的数码为 0,1,….R-1。例如,当R=7时,所需用到的数码是0,1,2,3,4,5和6,这与其是R或-R无关。如果作为基数的数绝对值超过10,则为了表示这些数码,通常使用英文字母来表示那些大于9的数码。例如对16进制数来说,用A表示10,用B表示11,用C表示12,用D表示13,用E表示14,用F表示15。在负进制数中是用-R 作为基数,例如-15(十进制)相当于110001(-2进制),并且它可以被表示为2的幂级数的和数:110001=1*(-2)^5+1*(-2)^4+0*(-2)^3+0*(-2)^2+0*(-2)^1+1*(-2)^0设计一个程序,读入一个十进制数和一个负进制数的基数,并将此十进制数转换为此负进制下的数【Input】输入文件有若干行，每行有两个输入数据。第一个是十进制数N第二个是负进制数的基数-R。【Output】输出此负进制数，若此基数超过10，则参照16进制的方式处理。【Limited conditions】-R∈{-2,-3,-4,…,-20}-32768&lt;=N&lt;=32767【Sample input】30000 -2【Sample output】11011010101110000【Sample explanation】无 Record30min Analysis请先思考后再展开 自己推把7和-7，转换成-3进制即可 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量****************//*******************全局定义****************//*******************实现******************char ans[110],ln=0;void putc(int t)&#123; ln++; if(t&lt;=9) ans[ln]='0'+t; else ans[ln]='A'+(t-10);&#125;//*******************主函数******************int main()&#123; int n,r;scanf("%d%d",&amp;n,&amp;r); printf("%d=",n); int now=1,nxt=r; while(n!=0) &#123; int t=n%nxt; if(t!=0) &#123; int k=t/now; k=(k+(-r))%(-r); putc( k ); n-=now*k; &#125; else putc(0); now=nxt; nxt=nxt*r; &#125; for(int i=ln;i&gt;=1;i--) putchar(ans[i]); printf("(base%d)",r);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1018】乘积最大]]></title>
    <url>%2Fposts%2F87af.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2000 提高组 T2Luogu1018Caioj1501 Problem【Brief description】设有一个长度为N的数字串，要求使用K个乘号将它分成K+1个部分，找出一种分法，使得这K+1个部分的乘积能够为最大。【Input】第一行共有2个自然数N，K第二行是一个长度为N的数字串。【Output】最大乘积【Limited conditions】6≤N≤40，1≤K≤6【Sample input】4 21231【Sample output】62【Sample explanation】无 Record30min Analysis请先思考后再展开 当年的梦魇f[i][k]=max( f[j][k-1]*(j+1~i) ) Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量****************//*******************全局定义****************char s[50];int f[50][8];//*******************实现******************int jh(int l,int r)&#123; int ans=0; for(int i=l;i&lt;=r;i++) ans=ans*10+s[i]-'0'; return ans;&#125;//*******************主函数******************int main()&#123; int n,K;scanf("%d%d%s",&amp;n,&amp;K,s+1); for(int i=1;i&lt;=n;i++) f[i][0]=jh(1,i); for(int k=1;k&lt;=K;k++) &#123; for(int i=k+1;i&lt;=n;i++) &#123; for(int j=k;j&lt;i;j++) &#123; f[i][k]=mymax(f[j][k-1]*jh(j+1,i),f[i][k]); &#125; &#125; &#125; printf("%d",f[n][K]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2186】【Luogu2155】沙拉公主的困惑]]></title>
    <url>%2Fposts%2F5557.html</url>
    <content type="text"><![CDATA[Source and JudgeSdoi2008Bzoj2186Luogu2155 Problem【Brief description】现有钞票编号范围为1到N的阶乘，但是，政府只发行编号与M!互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数灰常大，你只需计算出对R取模后的答案即可。R是一个质数。【Input】第一行为两个整数T，R。T表示该组中测试数据数目，R为模后面T行，每行一对整数N，M，见题目描述【Output】共T行，对于每一对N，M，输出1至N！中与M！互质的数的数量对R取模后的值【Limited conditions】R&lt;=10^9+10，T&lt;=10000，m&lt;=n1&lt;=N,M&lt;=10000000【Sample input】1 114 2【Sample output】1【Sample explanation】2^3=81+2+4+8=15 Record2h恶心数据卡常数……所以别开ll存 Analysis请先思考后再展开 首先，有这样一个我不会证明的定理：如果$gcd(x,a)=1$,则$gcd(x+k\times b,a)=1$那么如果对应这道题：如果$gcd(x,m!)=1$,则$gcd(x+k\times m!,m!)=1$而n!一定是m!的倍数，考虑把n!分成长度m!的一个个块，答案恰好变成这样的柿子(有关欧拉函数请找OI之路)：$$ANS=\frac{n!}{m!} \times \varphi(m!) (\mod R)$$那么套上欧拉函数的公式$\varphi(m!)=m! \times \frac{p1-1}{p1}\times \frac{p2-1}{p2}……\times \frac{pk-1}{pk}$：$$ANS=\frac{n!}{m!}\times m!\times \Pi_{t=1}^k \frac{pt-1}{pt} (\mod R) $$ $$ ANS=n!\times \Pi_{t=1}^k \frac{pt-1}{pt} (\mod R) $$ $$ ANS=n!\times\frac{\Pi_{t=1}^k(pt-1) }{\Pi_{t=1}^k pt} (\mod R) $$ $$ ANS=n!\times \Pi_{t=1}^k(pt-1) inv(pt) (\mod R) $$ 那就成功地消除了恶心的m!，瞬间简单很多预处理n!、小于等于m的质数p的【p-1】和【p的逆元】即可（因为m!的质因数显然是在m以内的，别被吓到） 嗯补充一句【经常要考虑】：$gcd(pt,R)\neq 1$而pt和R都是质数，那就只有一种情况了：pt=R那因为$n\geq m$，只要n不处理，逆元也不处理即可相当于除以R再乘以R网上经典数据：input1 34 3output2 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量****************const int MAXNUM=10000001;//*******************全局定义****************int MOD;//&lt;=1000000010int fac[MAXNUM],inv[MAXNUM];int p[1000000];int pos[MAXNUM];//debug//*******************实现******************int prime[1000000],pr=0;bool v[MAXNUM];void pre()&#123; inv[1]=1;fac[1]=1;p[0]=1;//debug for(int i=2;i&lt;MAXNUM;i++) &#123; inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i) %MOD; if(i!=MOD) fac[i]=1ll*fac[i-1]*i %MOD; else fac[i]=fac[i-1];//debug if(!v[i]) &#123; prime[++pr]=i; if(i!=MOD) p[pr]=1ll*p[pr-1]*(i-1)%MOD *inv[i] %MOD; else p[pr]=1ll*p[pr-1]*(i-1)%MOD;//debug &#125; pos[i]=pr; for(int j=1;j&lt;=pr;j++) &#123; if(i*prime[j]&gt;=MAXNUM) break; v[ i*prime[j] ]=1; if(i%prime[j]==0) break; &#125; &#125;&#125;//*******************主函数******************int main()&#123; int T;scanf("%d%lld",&amp;T,&amp;MOD);pre(); while(T--) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); if(n&gt;=MOD and m&lt;MOD) &#123; printf("0\n"); continue; &#125; printf("%d\n", int(1ll*fac[n]*p[ pos[m] ]%MOD) ); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>逆元</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj5192】【Luogu4271】New Barns]]></title>
    <url>%2Fposts%2Fdd1c.html</url>
    <content type="text"><![CDATA[Source and JudgeUsaco2018 Feb PlatinumBzoj5192Luogu4271 Problem【Brief description】每次添加一个点（形成森林）求距离这个点最远的点【Input】第一行包含一个整数Q以下Q行，每行包含一个请求。每个请求的格式都是“B p”或是“Q k”分别告诉你建造一个牛棚并与牛棚p连接，或是根据定义求从牛棚k出发最远的距离。如果p=-1，则新的牛棚不会与其他牛棚连接。否则，p是一个已经建造的牛棚的编号。牛棚编号从1开始，所以第一个被建造的谷仓是1号谷仓，第二个是2号谷仓，以此类推。【Output】对于每个距离请求输出一行。注意一个没有连接到其他牛棚的牛棚的最远距离为0【Limited conditions】1≤Q≤10^5【Sample input】7B -1Q 1B 1B 2Q 3B 2Q 2【Sample output】021【Sample explanation】(1) \ (2)–(4) /(3)对于请求1，我们建造牛棚1。对于请求2，我们询问从1出发到最远连接的牛棚的距离。由于牛棚1没有与其他牛棚连接，所以回答是0。对于请求3，我们建造牛棚2并将其与牛棚1连接。对于请求4，我们建造牛棚3并将其与牛棚2连接。对于请求5，我们询问从3出发到最远连接的牛棚的距离。在这时，最远的是牛棚1，距离为2单位。对于请求6，我们建造牛棚4并将其与牛棚2连接。对于请求7，我们询问从2出发到最远连接的牛棚的距离。所有其他三个牛棚1，3，4都与2相距相同的距离1，所以这就是我们的回答。 Record5h考试考的题目 Analysis1请先思考后再展开 好难哇splay是二叉树，不行，而且无法维护距离【结构会变】题目还是很有特性的，没必要lct吧？然后就以为是qtree4，乱搞一通，写挂了…… 然后暴力居然也写挂了是什么鬼方法1：2428ms做法1，也是比较显然的做法：每个点维护它的子树下，与他距离的最大和次大，并记录他们的来源，从而避免与x来自同一个子树而造成路径重复然后询问的时候直接向上面的祖先询问即可但是这样碰到一条链会被卡所以要点分治保证复杂度【离线后进行，注意打上现在是否可用的标记即可】 然后这个东西我考试的时候也是想过的，甚至也想过了点分治但打到一半发现不知道怎么维护因为做题太少，被qtree4毒害太深，只知道用堆……结果不知道怎么确保不会重复路径……难不成又要两个堆？麻烦死了而且没时间了……其实只要最大和次大，万一与最大重复子树就次大好了，很轻松嘛~ 哦还要注意，因为点分治的存在，树的结构改变，距离要在原树上面求 Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量****************const int MAXN=110000;const int INF=0x3f3f3f3f;//*******************全局定义****************struct Nod&#123; int hou; int dep; bool isrt; bool v; Nod() &#123; hou=dep=isrt=v=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXN*2];int ln=0;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;int dad[MAXN];//*******************点分治******************int G,sum,ty[MAXN],siz[MAXN];void getrt(int x,int fa)&#123; siz[x]=1;ty[x]=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa or p[y].v) continue; getrt(y,x); siz[x]+=siz[y]; ty[x]=mymax(ty[x],siz[y]); &#125; ty[x]=mymax(ty[x],sum-siz[x]); if(ty[x]&lt;ty[G]) G=x;&#125;void divi(int x)&#123; p[x].v=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(p[y].v) continue; sum=siz[y];G=0;getrt(y,x); dad[G]=x;divi(G); &#125;&#125;//*******************实现******************int bin[31],f[MAXN][31];void dfs(int x,int fa)&#123; p[x].dep=p[fa].dep+1; siz[x]=1;//因为是森林，块大小未知，用于sum f[x][0]=fa;for(int i=1;bin[i]&lt;=p[x].dep;i++) f[x][i]=f[ f[x][i-1] ][i-1]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y==fa) continue; dfs(y,x); siz[x]+=siz[y]; &#125;&#125;int LCA(int x,int y)&#123; if(p[x].dep&lt;p[y].dep) swap(x,y); for(int i=30;i&gt;=0;i--) if(p[x].dep-p[y].dep&gt;=bin[i]) x=f[x][i]; if(x==y) return x; for(int i=30;i&gt;=0;i--) if(bin[i]&lt;=p[x].dep and f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0];&#125;int getdis(int x,int y)//树的结构改变，距离要在原树上面求&#123; return p[x].dep+p[y].dep-2*p[LCA(x,y)].dep;&#125;bool bo[MAXN];pair&lt;int,int&gt; fri[MAXN],sec[MAXN];void turnblack(int x)&#123; bo[x]=1; int v=x,lst=x;//自己也更新下 while(x&gt;0) &#123; int d=getdis(x,v); if(lst==fri[x].second) fri[x].first=mymax(fri[x].first,d); else if(lst==sec[x].second) sec[x].first=mymax(sec[x].first,d); else if(d&gt;fri[x].first) sec[x]=fri[x],fri[x]=make_pair(d,lst); else if(d&gt;sec[x].first) sec[x]=make_pair(d,lst); if(fri[x].first&lt;sec[x].first) swap(fri[x],sec[x]); lst=x;x=dad[x]; &#125;&#125;int solve(int x)&#123; int v=x,lst=x; int ans=fri[x].first;x=dad[x]; while(x&gt;0) &#123; if(bo[x]) &#123; int d=getdis(x,v); if(lst==fri[x].second) ans=mymax(ans,d+sec[x].first); else ans=mymax(ans,d+fri[x].first); &#125; lst=x;x=dad[x]; &#125; return ans;&#125;//*******************主函数******************struct Qes&#123; int op,x;&#125;qes[MAXN];int main()&#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; int q;scanf("%d",&amp;q); char s[10]; int n=0; for(int i=1;i&lt;=q;i++) &#123; int t;scanf("%s%d",s,&amp;t); if(s[0]=='B') &#123; qes[i].op=1; n++;qes[i].x=n; if(t&lt;0) p[n].isrt=1; else ins(n,t),ins(t,n); &#125; else qes[i].op=2,qes[i].x=t; &#125; ty[0]=INF;p[0].v=1; for(int i=1;i&lt;=n;i++) if(p[i].isrt) &#123; dfs(i,0);//求dep、siz G=0;sum=siz[i];getrt(i,0); dad[G]=0;divi(G); &#125; for(int i=1;i&lt;=q;i++) if(qes[i].op==1) turnblack(qes[i].x); else printf("%d\n",solve(qes[i].x));&#125; Analysis2请先思考后再展开 哇两百行呀真烦人不是吗？有没有更便捷的方法呢？ 对于树上的，某一点固定的，最长路径，有这样一个性质： 定义 树的直径为，树上最长路径（长度相等的话任意一条即可，对答案没有影响） 某一点固定的最长路径，其另一个端点就是 树的直径 的两个端点之一 然后如果加入一个点，新的 树的直径 的端点必定是这三个点中的两个证明不会，但找不到反例，有兴趣的反证法试试？其实好像OI很多玄学的定理主要都是用反证法的…… UP【思路from rose，作了修正】:果然是用反证法设树上直径a、b，对于当前查询节点now，假设存在一个非a、b的节点p到now的距离最大那么对于now和a的一个公共祖先也就是now和a路径上的点k，则必定也是a和b路径上的点【这里其实依然不是太完美】既然如此，必定k-p大于k-a，则p应该成为直径的端点，与非b矛盾Q.E.D【其实这个没什么好纠结的，用akc的话说，感性地认知就好了】 UP 2018.4.6：这个好像来自一个这样的性质对于直径中的任意一点，其距离树中其他点的最远距离不超过该点到达直径端点的距离。【这个还是灰常显而易见的，否则就不是端点了，rose的证明更多是搞这个】然后再补充一个：所有直径交于一点，且必定是中点类似的证明但是他有图：果然有图就是一切吗 那明确这个性质之后就很舒服了师兄和beginend是用LCT维护的……但其实根本不用，直接用根当标记就好了就问你短不短！ ps：感觉以后如果要出题，这个可以有hh Code2请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量****************const int MAXN=110000;const int INF=0x3f3f3f3f;//*******************全局定义****************int d1[MAXN],d2[MAXN];//端点int rt[MAXN];//根int dep[MAXN];//深度int f[MAXN][21],bin[21];//*******************实现******************int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=20;i&gt;=0;i--) if(dep[x]-dep[y]&gt;=bin[i]) x=f[x][i]; if(x==y) return x; for(int i=20;i&gt;=0;i--) if(dep[x]&gt;=bin[i] and f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0];&#125;int DIS(int x,int y)&#123; return dep[x]+dep[y]-2*dep[LCA(x,y)];&#125;//*******************主函数******************int main()&#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; int q;scanf("%d",&amp;q);char s[10]; int x=0; while(q--) &#123; int t;scanf("%s%d",s,&amp;t); if(s[0]=='B') &#123; x++; if(t&lt;0) rt[x]=d1[x]=d2[x]=x,dep[x]=1; else &#123; rt[x]=rt[t];dep[x]=dep[t]+1; f[x][0]=t;for(int i=1;bin[i]&lt;=dep[x];i++) f[x][i]=f[ f[x][i-1] ][i-1]; int old=DIS(d1[rt[x]],d2[rt[x]]); if(DIS(d1[rt[x]],x)&gt;old) d2[rt[x]]=x; if(DIS(x,d2[rt[x]])&gt;old) d1[rt[x]]=x; &#125; &#125; else printf("%d\n",mymax( DIS(t,d1[rt[t]]),DIS(t,d2[rt[t]]) )); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>动态点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj1845】Sumdiv]]></title>
    <url>%2Fposts%2Fecf1.html</url>
    <content type="text"><![CDATA[Source and JudgeRomania OI 2002Poj1845 Problem【Brief description】给出自然数A、B，求S=A^B的所有自然数因子和【Input】A,B【Output】S模9901【Limited conditions】0&lt;=A,B&lt;=50000000【Sample input】2 3【Sample output】15【Sample explanation】2^3=81+2+4+8=15 Record2h是求积而不是求和……脑子里想着题目是求和…… Analysis请先思考后再展开 题目要的就是：$$\sum_{t|A^B} t (\mod 9901)$$那么其实就是约数和公式啦：【OI之路】02数论算法-7约数个数与和然后把A分解质因数（线性筛搞一搞），就变成了经典的等比数列求和$$p^0+p^1+p^2+…+p^a (\mod 9901)——①$$那有两种做法，一个是二分法（之前说过），以及师兄教的常规操作：$①\times (p-1)$于是我想半天，结果是什么呢？其实……这样会更容易算:$①\times p-①=p^{a+1}-p^0$然后再除回去即可$$ANS=\Pi_{k=1}^{质因数个数} \frac{p_k^{a+1}-1}{p_k-1} (\mod 9901)$$于是就简单了，快速幂加上逆元即可 哦对了再说一句之前做一道noi的dp（寿司晚宴）的时候，学会了一个套路：分解质因数的时候，预处理 sqrt(n) 的即可，因为后面的只会有一个~ 嗯还有，万一没有逆元怎么办？也就是$gcd(9901,p_k-1)=1$那已知p是素数了，也就是说$p_k-1$是9901的倍数本来希望没有，结果一打印，贼多！都怪这模数太小！怎么办？别着急，不是还有二分法吗？反正好像都是logn的算法woc其实直接二分法得了，干嘛写两个 UP 2018.8.9:其实如果没有逆元也是可以做的观察一下，如果$p_k-1$是9901的倍数，那么$p_k \mod 9901=1$所以说此时，等比数列的底数是1，可以直接计算…… 送几组数据:59407 1259407 5940720 101 113 013131 654971933 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量****************const int MAXNUM=7100;const int MOD=9901;//*******************全局定义****************int prime[7000],pr=0;bool v[MAXNUM];//*******************实现******************void getp()&#123; for(int i=2;i&lt;MAXNUM;i++) &#123; if(!v[i]) prime[++pr]=i; for(int j=1;j&lt;=pr and i*prime[j]&lt;MAXNUM;j++) &#123; v[ i*prime[j] ]=1; if(i%prime[j]==0) break; &#125; &#125;&#125;int power(int x,int e)&#123; int ans=1;x%=MOD;//debug while(e&gt;0) &#123; if(e&amp;1) ans=(ans*x)%MOD; x=(x*x)%MOD;e&gt;&gt;=1; &#125; return ans;&#125;int A;int sum(int n)&#123; if(n==1) return A%MOD; if(n&amp;1) return ( sum(n-1)+power(A,n) )%MOD; return (1+power(A,n/2))*sum(n/2) %MOD;&#125;//*******************主函数******************int ans;void calc(int p,int ct)&#123; if( (p-1)%MOD==0 ) &#123; A=p; ans=ans*(1+sum(ct)) %MOD; &#125; else &#123; int t= (power(p,ct+1)-1+MOD)%MOD ;//小心减法 int inv=power(p-1,MOD-2); ans=ans*t%MOD *inv%MOD; &#125;&#125;int main()&#123; getp(); int a,b;scanf("%d%d",&amp;a,&amp;b); if(a&lt;=1)//debug &#123; printf("%d",a); return 0; &#125; ans=1; for(int i=1;i&lt;=pr;i++) &#123; if(a%prime[i]&gt;0) continue; int ct=0;while(a%prime[i]==0) a/=prime[i],ct++; calc(prime[i],ct*b); //calc(prime[i]%MOD,ct*b); if(a==1) break; &#125; if(a&gt;1) calc(a,b); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>逆元</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3240】【Luogu1397】矩阵游戏]]></title>
    <url>%2Fposts%2Fe426.html</url>
    <content type="text"><![CDATA[Source and JudgeNoi2013Bzoj3240Luogu1397 Problem【Brief description】$F[1][1]=1$$F[i][j]=a\times F[i][j-1]+b (j!=1)$$F[i][1]=c\times F[i-1][m]+d (i!=1)$输出F[n][m]除以1,000,000,007的余数。【Input】六个整数n,m,a,b,c,d【Output】F[n][m]除以1,000,000,007的余数【Limited conditions】【Sample input】3 4 1 3 2 6【Sample output】85【Sample explanation】样例中的矩阵为：1 4 7 1026 29 32 3576 79 82 85 Record2h呃我的矩阵是3乘3的，时间可能是别人的两倍以上?反正问题不大 Analysis请先思考后再展开 首先，这个n、m的大小这么奇葩，那就是有一定暗示的了（其实有的时候我就在想为啥非要搞特大、小数据范围来提示？有检验正确性能力即可）（UP：好像有人直接写十进制快速幂+常数优化搞过去了……）那么我们引用伟大的费马小定理：【OI之路】11更高级数论-1定理杂烩这个神奇玩意居然对矩阵也有效！【flag，见后文】在mod MOD（也就是1e9+7）下，设操作矩阵为A，那么$A^{1e9+6}=1 (\mod MOD)$ ，相当于单位矩阵所以对于同一行下，第m个=第m%(MOD-1)个而如果把【一行的转移+m到下一行第一个的转移】看作一个操作矩阵B，同理第n行=第n%(MOD-1)行综上所述，$f[n][m]=f[n\%(MOD-1)][m\%(MOD-1)]$ 然后我到这里就懵逼了：这么大的数字怎么存储？还要写高精度取模？？？如果你也是这么想，嗯英雄所见略同事实上，%(MOD-1)=%( (MOD-1)*10^k )，意思就是说，完全可以放到字符串里面，取一个模一下真是让人涨见识的骚操作QAQ剩下的就是推一个sb矩阵了 UP:发现自己wa了两个点【90分，其实也该满足了】？别着急我也是自信满满地提交，然后看别人题解才看到：a=1和c=1的特殊情况网上清一色“要特判”，但都没讲理由？ 首先，实验证明，我的两个操作矩阵$A^{MOD-1}\neq 1 (\mod MOD)$,事实上循环结长度是MOD为什么会出现这种情况呢？【开始解决flag】我们回顾一下，费马小定理的条件之一：gcd(A,MOD)=1但这里A是一个矩阵呀，怎么会有gcd？咳咳，别着急。前面我们直接啥也不管，以为网上题解说能就直接用了，所以才会有现在的状况 那么我先是问了下师兄，然后两人一起捣鼓半天，大概搞了个解释：注意，所有公式都是在模意义下进行我们回归到最初的公式【以行内转移举例，忽略行数，反正也就是二维】$$f[i]=a\times f[i-1]+b (\mod MOD)——①$$ 我们希望把它变成一个等比数列来搞出一个通项公式【没学过高中数学没关系，我也没学】构造一个b’使满足这个柿子：$$f[i]+b’=a\times (f[i-1]+b’) (\mod MOD)——②$$ 现在通过①和②推导出这道题的$b’=\frac{b}{a-1} (a\neq1)$辣么现在就能搞出一个通项公式啦$$f[i]+b’=a^{i-1}\times (f[1]+b’) (\mod MOD)$$ 既然是等比数列，那就搞上费马小定理吧~【gcd(a,MOD)=1并没有影响，因为题目条件里面限制了a的范围】$$f[i]+\frac{b}{a-1}=a^{ (i-1)\%(MOD-1) }\times (f[1]+\frac{b}{a-1}) (\mod MOD) (a\neq1)$$ 好了，我们搞这么多有什么用呢？师兄的说法：用来给你十进制快速幂呀！啊那行之间怎么转移呢？不会呀这么说原来根本就不是同一个做法好吗。那我干嘛要写在博客上呀 仅仅因为那个$a\neq1$没错我们现在说这么多就是为了解决我们丢了10分的问题【终于回到正题了】不扯了那a=1的时候，其实就变成了一个等差数列，通项公式：$$f[i]=f[1]+b\times (i-1) (\mod MOD)$$ 然后有个东西叫欧拉函数，$\phi(x)=在1到x的正整数中与x互质的数的个数$显然在x为质数的时候，$\phi(x)=x-1$那么在我们刚才矩阵乘法的时候，循环节可以记作$p=\phi(MOD)$由此而知$f[p+1]=f[1]$【当$a\neq1$的时候，p已经算出来了，现在算a=1的情况，p未知】$$f[p+1]=f[1]+b\times p (\mod MOD)$$ 那么$b\times p=0 (\mod MOD)$而这道题中，b一不是MOD的倍数，二不是0，则$p=0 (\mod MOD)$而p肯定又不是0，所以可以考虑把p看作MOD的倍数哇那就是说$$p=MOD 【a=1】$$ $$p=\phi(MOD)=MOD-1 【Otherwise】$$ 哈哈搞定~其实我自己觉得有种东扯扯西扯扯的感觉但好歹也是有理有据的嘛总结：综上所述，我们在搞n和m的时候，分别根据a和c是否是1来决定MOD（详见代码）然后经验就是，这种有特殊条件的定理，先不要引入矩阵乘法，而是把公式搞清楚，把各种细节考虑周到再去优化【虽然这道题也就10分】 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量****************const ll MOD=1e9+7;//*******************全局定义****************struct martix&#123; int row,col; ll m[5][5]; martix() &#123; memset(m,0,sizeof(m)); &#125;&#125;;//*******************实现******************martix cheng(martix a,martix b)&#123; martix c; int n=a.row,m=a.col,p=b.col; c.row=n;c.col=p; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) (c.m[i][j]+=a.m[i][k]*b.m[k][j])%=MOD; return c;&#125;martix pre()&#123; martix c;c.row=c.col=3; c.m[1][1]=c.m[2][2]=c.m[3][3]=1; return c;&#125;martix power(martix a,int e)&#123; martix ans=pre(); while(e&gt;0) &#123; if(e&amp;1) ans=cheng(ans,a); a=cheng(a,a);e&gt;&gt;=1; &#125; return ans;&#125;//*******************主函数******************char s1[1000010],s2[1000010];int main()&#123; ll mod1=MOD-1,mod2=MOD-1; scanf("%s%s",s1+1,s2+1); ll a,b,c,d;scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d); if(a==1) mod1++;if(c==1) mod2++; ll n=0;int t1=strlen(s1+1);for(int i=1;i&lt;=t1;i++) n=(n*10+s1[i]-'0')%mod1; ll m=0;int t2=strlen(s2+1);for(int i=1;i&lt;=t2;i++) m=(m*10+s2[i]-'0')%mod2; if(n==0) n=mod1;if(m==0) m=mod2; martix f1;f1.row=3;f1.col=1;f1.m[1][1]=1;f1.m[2][1]=b;f1.m[3][1]=d; martix A;A.row=3;A.col=3;A.m[1][1]=a;A.m[1][2]=1;A.m[2][2]=1;A.m[3][3]=1; martix B;B.row=3;B.col=3;B.m[1][1]=c;B.m[1][3]=1;B.m[2][2]=1;B.m[3][3]=1; A=power(A,m-1); if(n&gt;1) A=cheng( A,power(cheng(B,A),n-1) ); printf("%lld",cheng(A,f1).m[1][1]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>精品题</tag>
        <tag>难度3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hdu1588】Gauss Fibonacci]]></title>
    <url>%2Fposts%2F7e2f.html</url>
    <content type="text"><![CDATA[Source and JudgeDYGGHDU “Valentines Day” Open Programming Contest 2007-02-14Hdu1588Caioj1488 Problem【Brief description】g[i]=k*i+b。f[0]=0,f[1]=1,f[i]=f[i-1]+f[i-2] (i&gt;=2)求f[ g[0] ]+f[ g[1] ]+…+f[ g[n-1] ]的值，结果需要mod M【Input】多组数据四个整数k,b,n,M【Output】每行一个答案【Limited conditions】每个数不超过1,000,000,000.【Sample input】2 1 4 1002 0 4 100【Sample output】2112【Sample explanation】无 Record30min Analysis请先思考后再展开 那个。。推公式的时候注意矩阵乘法操作顺序不可调转$$f[b]+f[k+b]+f[2\times k+b]…+f[(n-1)\times k+b]$$转化为矩阵A（通常计算斐波拉契的递推矩阵，自己推）$$A^b\times f[0]+A^{k+b}\times f[0]…+A^{(n-1)\times k+b}\times f[0]$$提取公因式$A^b\times f[0]$$$( A^0+A^k…+A^{(n-1)\times k} )\times A^b\times f[0]$$令$B=A^k$$$( B^0+ B^1…+B^{n-1} )\times A^b\times f[0]$$于是就变成了一个等比数列求和问题了 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量**************** //*******************全局定义****************struct martix&#123; int row,col; ll m[5][5]; martix() &#123; memset(m,0,sizeof(m)); &#125;&#125;;ll MOD;//*******************实现******************martix jia(martix a,martix b)&#123; martix c; c.row=a.row;c.col=a.col; for(int i=1;i&lt;=c.row;i++) for(int j=1;j&lt;=c.col;j++) (c.m[i][j]+=a.m[i][j]+b.m[i][j])%=MOD; return c;&#125;martix cheng(martix a,martix b)&#123; martix c; int n=a.row,m=a.col,p=b.col; c.row=n;c.col=p; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) (c.m[i][j]+=a.m[i][k]*b.m[k][j])%=MOD; return c;&#125;martix pre()&#123; martix c;c.row=c.col=2; c.m[1][1]=c.m[2][2]=1; return c;&#125;martix power(martix a,int e)&#123; martix ans=pre(); while(e&gt;0) &#123; if(e&amp;1) ans=cheng(ans,a); a=cheng(a,a);e&gt;&gt;=1; &#125; return ans;&#125;martix B;martix sum(int k)&#123; if(k==1) return B; if(k&amp;1) return jia(sum(k-1),power(B,k)); martix t=sum(k/2); return jia( cheng(t,power(B,k/2)),t );&#125;//*******************主函数******************int main()&#123; martix A;A.row=A.col=2;A.m[1][2]=A.m[2][1]=A.m[2][2]=1; martix f0;f0.row=2;f0.col=1;f0.m[2][1]=1; int k,b,n; while(scanf("%d%d%d%lld",&amp;k,&amp;b,&amp;n,&amp;MOD)!=EOF) &#123; B=power(A,k); printf("%lld\n",cheng( jia(sum(n-1),pre()),cheng(power(A,b),f0) ).m[1][1]); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3233】Matrix Power Series]]></title>
    <url>%2Fposts%2F3bd.html</url>
    <content type="text"><![CDATA[来源和评测点POJ Monthly–2007.06.03, Huang, JinsongPoj3233 题目【题目大意】给出一个n×n矩阵A和正整数k,输出S=A+A^2+A^3+…+A^k，元素模m【输入格式】多组数据。第一行正整数n,k和m。接下来n行包括n个在32,768以内的非负整数【输出格式】S【限定条件】n≤30k≤10^9m&lt;10^4【输入样例】2 2 40 11 1【输出样例】1 22 3【样例解释】无 刷题记录30min 分析请先思考后再展开 二分求等比序列和 代码请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量****************//*******************全局定义****************struct martix&#123; int row,col; int m[40][40]; martix() &#123; memset(m,0,sizeof(m)); &#125;&#125;;int MOD;//*******************实现******************martix jia(martix a,martix b)&#123; martix c; c.row=a.row;c.col=a.col; for(int i=1;i&lt;=c.row;i++) for(int j=1;j&lt;=c.col;j++) (c.m[i][j]+=a.m[i][j]+b.m[i][j])%=MOD; return c;&#125;martix cheng(martix a,martix b)&#123; martix c; int n=a.row,m=a.col,p=b.col; c.row=n;c.col=p; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) (c.m[i][j]+=a.m[i][k]*b.m[k][j])%=MOD; return c;&#125;martix power(martix a,int e)&#123; martix ans=a;e--; while(e&gt;0) &#123; if(e&amp;1) ans=cheng(ans,a); a=cheng(a,a);e&gt;&gt;=1; &#125; return ans;&#125;martix s;martix sum(int k)&#123; if(k==1) return s; if(k&amp;1) return jia(sum(k-1),power(s,k)); martix t=sum(k/2); return jia( cheng(t,power(s,k/2)),t );&#125;//*******************主函数******************int main()&#123; int n,k;scanf("%d%d%d",&amp;n,&amp;k,&amp;MOD); s.row=s.col=n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;s.m[i][j]); s=sum(k); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) printf("%d ",s.m[i][j]); printf("\n"); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF946-F】Fibonacci String Subsequences]]></title>
    <url>%2Fposts%2F6a8a.html</url>
    <content type="text"><![CDATA[Source and JudgeCF946-F Problem【Brief description】定义 F(x) 为 F(x−1) 与 F(x−2) 的连接（其中 F(0)=”0”,F(1)=”1” ）。给出一个长度为n的01字符串 s ，询问 s 在 F(x) 的所有子序列中出现了多少次。【Input】第一行n和x第二行字符串s【Output】如上【Limited conditions】1≤n≤100,0≤x≤100【Sample input】2 411【Sample output】14【Sample explanation】F(4)=101101011101101 11 1 01 111 1101 11 10 011 0110 11 110好难想…… Record30min我会告诉你我看错两次题吗？ Analysis请先思考后再展开 其实就是一个裸区间DPf[i][l][r]表示F(i)的子序列中有多少个s[l,r]然后就三种情况 从左边继承，f[i-1][l][r]，次数默认1；若r=n，右边有2^{ln[i-2]}种选取方案（就是任选） 从右边继承，f[i-2][l][r]，次数默认1；若l=1，左边有2^{ln[i-1]}种选取方案（就是任选） 从两边继承，f[i-1][l][k]*f[i-2][k+1][r]，次数1 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int MOD=1e9+7;const int MAXN=110;ll f[MAXN][MAXN][MAXN];ll g[MAXN];char s[MAXN];int main()&#123; int n,x;scanf("%d%d%s",&amp;n,&amp;x,s+1); for(int i=1;i&lt;=n;i++) f[s[i]=='1'][i][i]=1; g[0]=2;g[1]=2;for(int i=2;i&lt;=x;i++) g[i]=(g[i-1]*g[i-2])%MOD; for(int i=2;i&lt;=x;i++) &#123; for(int l=1;l&lt;=n;l++) &#123; for(int r=l;r&lt;=n;r++) &#123; if(r==n) f[i][l][r]=(f[i][l][r]+f[i-1][l][r]*g[i-2]%MOD)%MOD; else f[i][l][r]=(f[i][l][r]+f[i-1][l][r])%MOD; if(l==1) f[i][l][r]=(f[i][l][r]+f[i-2][l][r]*g[i-1]%MOD)%MOD; else f[i][l][r]=(f[i][l][r]+f[i-2][l][r])%MOD; for(int k=l;k&lt;=r-1;k++) f[i][l][r]=(f[i][l][r]+f[i-1][l][k]*f[i-2][k+1][r]%MOD)%MOD; &#125; &#125; &#125; printf("%lld",f[x][1][n]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度1</tag>
        <tag>精品题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2002】【Luogu3203】弹飞绵羊]]></title>
    <url>%2Fposts%2F8065.html</url>
    <content type="text"><![CDATA[Source and JudgeHNOI2010Bzoj2002Luogu3203 Problem【Brief description】有n个点，一开始有n条边，点只会向比自己编号大的一个点连一条边，其中有的边（保证至少有一条）会连不到点，被弹飞。有两种操作：op=1,x :询问从x点出发，需要经过多少个点（包括x）才会被弹飞op=2,x,k:将x点连向其他点的边删掉，然后从x向x+k连一条边【Input】第一行为一个正整数n，表示点的个数。第二行n个数ki，表示第i个点向第i+ki个点连一条边，若i+ki&gt;n被弹飞。第三行为一个正整数m，表示操作的个数。以下m行，一行表示一个操作。每行开头是一个整数op，op=1时之后有一个整数x代表询问点的编号。op=2时之后有两个整数x，k代表点的编号和改变连边的距离。操作如题意。【Output】如上【Limited conditions】对于20%的数据,n,m&lt;=10000对于100%的数据,n&lt;=200000,m&lt;=100000【Sample input】41 2 1 131 12 1 11 1【Sample output】23【Sample explanation】无 Record1h打错变量了…… Analysis1请先思考后再展开 灰常不容易想出来的解法：LCT主要是因为修改操作，相当于删边和连边，而且结构改变了，所以不能树剖然后把“弹飞”形象化为点n+1但这样并没形成森林过…… Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量****************const int MAXN=210000,MAXM=210000;//*******************全局定义****************struct Nod&#123; int fa,son[2]; int siz; bool fz; Nod() &#123; fa=son[0]=son[1]=fz=0; siz=1; &#125;&#125;p[MAXN];//*******************伸展树******************void pushdown(int x)&#123; if(!p[x].fz) return; p[x].fz=0; swap(p[x].son[0],p[x].son[1]);//debug int lc=p[x].son[0],rc=p[x].son[1]; if(lc&gt;0) p[lc].fz^=1; if(rc&gt;0) p[rc].fz^=1;&#125;void pushup(int x)&#123; p[x].siz=1; int lc=p[x].son[0],rc=p[x].son[1]; if(lc&gt;0) p[x].siz+=p[lc].siz; if(rc&gt;0) p[x].siz+=p[rc].siz;&#125;bool isroot(int x,int rt)&#123; return p[x].fa==rt or (p[p[x].fa].son[0]!=x and p[p[x].fa].son[1]!=x);&#125;void rotate(int x,int w)&#123; int f=p[x].fa,ff=p[f].fa; if(!isroot(f,0)) &#123; if(p[ff].son[0]==f) p[ff].son[0]=x; else if(p[ff].son[1]==f) p[ff].son[1]=x; &#125; p[x].fa=ff; int pson=p[x].son[w]; p[f].son[1-w]=pson; if(pson&gt;0) p[pson].fa=f; p[x].son[w]=f; p[f].fa=x; pushup(f); pushup(x);&#125;int tmp[MAXN];void splay(int x,int rt)&#123; int t=x,s=0; while(!isroot(t,rt)) tmp[++s]=t,t=p[t].fa; pushdown(t);while(s&gt;0) pushdown(tmp[s--]); while(!isroot(x,rt)) &#123; int f=p[x].fa,ff=p[f].fa; if(isroot(f,rt)) &#123; if(p[f].son[0]==x) rotate(x,1); else if(p[f].son[1]==x) rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125;&#125;//*******************LCT******************void access(int x)&#123; int lst=0; while(x&gt;0) &#123; splay(x,0); p[x].son[1]=lst; pushup(x);//debug lst=x;x=p[x].fa; &#125;&#125;void makeroot(int x)&#123; access(x); splay(x,0); p[x].fz^=1;&#125;void split(int x,int y)//y为顶&#123; makeroot(x); access(y); splay(y,0);//debug&#125;void link(int x,int y)//debug方向性&#123; makeroot(x); p[x].fa=y;&#125;void cut(int x,int y)&#123; split(x,y); p[x].fa=0; p[y].son[0]=0; pushup(y);&#125;//*******************实现******************//*******************主函数******************int now[MAXN];int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;now[i]); if(i+now[i]&gt;n) now[i]=n+1-i; link(i,i+now[i]); &#125; int q;scanf("%d",&amp;q); while(q--) &#123; int op,a,b;scanf("%d%d",&amp;op,&amp;a);a++; if(op==1) &#123; split(a,n+1); printf("%d\n",p[n+1].siz-1); &#125; else &#123; scanf("%d",&amp;b); cut(a,a+now[a]); if(a+b&gt;n) b=n+1-a;now[a]=b; link(a,a+now[a]); &#125; &#125;&#125; Analysis2请先思考后再展开 看看能否对上面的算法进行改进要不干脆就真的被弹飞吧！那就是森林了。然后发现根本不用makeroot了于是立刻又快又短！ Code2请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量****************const int MAXN=210000,MAXM=210000;//*******************全局定义****************struct Nod&#123; int fa,son[2]; int siz; Nod() &#123; fa=son[0]=son[1]=0; siz=1; &#125;&#125;p[MAXN];//*******************伸展树******************void pushup(int x)&#123; p[x].siz=1; int lc=p[x].son[0],rc=p[x].son[1]; if(lc&gt;0) p[x].siz+=p[lc].siz; if(rc&gt;0) p[x].siz+=p[rc].siz;&#125;bool isroot(int x,int rt)&#123; return p[x].fa==rt or (p[p[x].fa].son[0]!=x and p[p[x].fa].son[1]!=x);&#125;void rotate(int x,int w)&#123; int f=p[x].fa,ff=p[f].fa; if(!isroot(f,0)) &#123; if(p[ff].son[0]==f) p[ff].son[0]=x; else if(p[ff].son[1]==f) p[ff].son[1]=x; &#125; p[x].fa=ff; int pson=p[x].son[w]; p[f].son[1-w]=pson; if(pson&gt;0) p[pson].fa=f; p[x].son[w]=f; p[f].fa=x; pushup(f); pushup(x);&#125;void splay(int x,int rt)&#123; while(!isroot(x,rt)) &#123; int f=p[x].fa,ff=p[f].fa; if(isroot(f,rt)) &#123; if(p[f].son[0]==x) rotate(x,1); else if(p[f].son[1]==x) rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125;&#125;//*******************LCT******************void access(int x)&#123; int lst=0; while(x&gt;0) &#123; splay(x,0); p[x].son[1]=lst; pushup(x);//debug lst=x;x=p[x].fa; &#125;&#125;void linkfa(int x,int y)&#123; p[x].fa=y;&#125;void cutfa(int x)&#123; access(x); splay(x,0); p[p[x].son[0]].fa=0; p[x].son[0]=0; pushup(x);&#125;//*******************实现******************//*******************主函数******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); if(i+t&lt;=n) linkfa(i,i+t); &#125; int q;scanf("%d",&amp;q); while(q--) &#123; int op,a,b;scanf("%d%d",&amp;op,&amp;a);a++; if(op==1) &#123; access(a); splay(a,0); printf("%d\n",p[a].siz); &#125; else &#123; scanf("%d",&amp;b);cutfa(a); if(a+b&lt;=n) linkfa(a,a+b); &#125; &#125;&#125; Analysis3请先思考后再展开 分块大法好！既然说分块是暴力的优化，先想想暴力：从后往前预处理，然后查询瞬间，修改再次从后往前那么找个【暴力与分块】的关系和【前缀和与树状数组】的关系是类似的，就是前一种查询快，但难修改。那么树状数组让两个操作的时间均衡了。分块也类似如此，设法把修改的时间缩短：对于每个位置，记录两个值：跳出这个块的步数、跳出后到了哪里。于是时间都达到了sqrt(n)了 Code3请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量****************const int MAXN=210000;//*******************全局定义****************int n;int k[MAXN];//*******************分块******************int cnt;int belg[MAXN];int bl[MAXN],br[MAXN];void block()&#123; int qn=sqrt(n);cnt=0; for(int i=1;i&lt;=n;i++) &#123; belg[i]=(i-1)/qn+1; if(belg[i-1]!=belg[i]) &#123; cnt++; br[cnt-1]=i-1; bl[cnt]=i; &#125; &#125; bl[1]=1;br[cnt]=n;&#125;//*******************实现******************int p[MAXN],c[MAXN];void change(int x)&#123; int jp=x+k[x],t=belg[x]; if(jp&gt;n) c[x]=0,p[x]=1; else if(jp&gt;br[t]) c[x]=jp,p[x]=1; else c[x]=c[jp],p[x]=p[jp]+1;&#125;//*******************主函数******************int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;k[i]); block(); for(int i=n;i&gt;=1;i--) change(i); int q;scanf("%d",&amp;q); while(q--) &#123; int op,a;scanf("%d%d",&amp;op,&amp;a);a++; if(op==1) &#123; int ans=0; while(a&gt;0) &#123; ans+=p[a]; a=c[a]; &#125; printf("%d\n",ans); &#125; else &#123; scanf("%d",&amp;k[a]); for(int i=a;i&gt;=bl[belg[a]];i--) change(i); &#125; &#125;&#125; 总结一下LCT：O(Bignlogn)分块：O(nsqrt(n))其实都不是特别好想然后Big的可怕：就算把耗时很高的makeroot去掉，也能硬生生把logn变成sqrt(n)（甚至更慢）]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LCT</tag>
        <tag>伸展树</tag>
        <tag>分块</tag>
        <tag>难度2</tag>
        <tag>精品题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2152】【Luogu2634】聪聪可可]]></title>
    <url>%2Fposts%2F1124.html</url>
    <content type="text"><![CDATA[Source and Judge国家集训队Bzoj2152Luogu2634 Problem【Brief description】给一棵带权树，求任选两个点间路径和是3的倍数的概率【Input】输入的第1行包含1个正整数n。后面n-1行，每行3个整数x、y、w，表示x号点和y号点之间有一条边，上面的数是w。【Output】以既约分数的形式输出（即“a/b”的形式，其中a和b必须互质）如果概率为1，输出“1/1”【Limited conditions】n&lt;=20000【Sample input】51 2 11 3 21 4 12 5 3【Sample output】13/25【Sample explanation】13组点对分别是(1,1) (2,2) (2,3) (2,5)(3,2) (3,3) (3,4) (3,5)(4,3) (4,4) (5,2) (5,3) (5,5) Record40min Analysis请先思考后再展开 以后学会：碰到模后结果，考虑结果的数量会很少然后这种时候值具体是什么毫无意义，记录余数即可 树形DPf[i][0/1/2]表示经过它的链的个数，递归即可 Code请先思考后再展开 12]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj4196】【Luogu2146】软件包管理器]]></title>
    <url>%2Fposts%2F6263.html</url>
    <content type="text"><![CDATA[Source and JudgeNoi2015Bzoj4196Luogu2146 Problem【Brief description】就是给出一个n个点(0~n-1) 的有根树（根为0），和q次操作；初始时树上所有结点均为白；1、将根到x结点的所有结点置为黑，并输出这次操作有多少个元素改变了状态；2、将x结点的子树中所有结点置为白，并输出这次操作有多少个元素改变了状态；【Input】输入文件的第1行包含1个正整数n。随后一行包含n−1个整数，相邻整数之间用单个空格隔开，分别表示1,2,3,…,n−2,n−1点的父亲节点。接下来一行包含1个正整数q，表示询问的总数。之后q行，每行1个询问。询问分为两种：Install x：表示1操作Uninstall x：表示2操作对于每个操作，输出这步操作有多少个点改变了状态。【Output】输出文件包括q行。输出文件的第i行输出1个整数，为第i步操作中改变状态的点数。【Limited conditions】n，q&lt;=100000【Sample input】70 0 0 1 1 55install 5install 6uninstall 1install 4uninstall 0【Sample output】31323【Sample explanation】一开始所有的软件包都处于未安装状态。安装5号软件包，需要安装0,1,5三个软件包。之后安装6号软件包，只需要安装6号软件包。此时安装了0,1,5,6四个软件包。卸载1号软件包需要卸载1,5,6三个软件包。此时只有0号软件包还处于安装状态。之后安装4号软件包，需要安装1,4两个软件包。此时0,1,4处在安装状态。最后，卸载0号软件包会卸载所有的软件包。 Record40min1RE边又忘记开两倍了…… Analysis请先思考后再展开 裸题首先dfs搞出来的编号，重链上是连续的，子树也是连续的于是问题主要在线段树上，要区间修改，区间查询还要返回修改量，所以记录两个值：c（-1为黑，0为混杂，1为白），b（黑点数量）即可 Code请先思考后再展开 12]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1036】【Luogu2590】树的统计]]></title>
    <url>%2Fposts%2Fa490.html</url>
    <content type="text"><![CDATA[Source and JudgeZJOI2008Bzoj1036Luogu2590 Problem【Brief description】一棵树上有n个节点，编号分别为1到n，每个节点都有一个权值w。操作：I. CHANGE u t : 把结点u的权值改为tII. QMAX u v: 询问从点u到点v的路径上的节点的最大权值III. QSUM u v: 询问从点u到点v的路径上的节点的权值和注意：从点u到点v的路径上的节点包括u和v本身【Input】输入文件的第一行为一个整数n，表示节点的个数。接下来n–1行，每行2个整数a和b，表示节点a和节点b之间有一条边相连。接下来一行n个整数，第i个整数wi表示节点i的权值。接下来1行，为一个整数q，表示操作的总数。接下来q行，每行一个操作，以“CHANGE u t”或者“QMAX u v”或者“QSUM u v”的形式给出。【Output】对于每个“QMAX”或者“QSUM”的操作，每行输出一个整数表示要求输出的结果。【Limited conditions】1&lt;=n&lt;=30000，0&lt;=q&lt;=200000；中途操作中保证每个节点的权值w在-30000到30000之间。【Sample input】41 22 34 14 2 1 312QMAX 3 4QMAX 3 3QMAX 3 2QMAX 2 3QSUM 3 4QSUM 2 1CHANGE 1 5QMAX 3 4CHANGE 3 6QMAX 3 4QMAX 2 4QSUM 3 4【Sample output】412210656516【Sample explanation】无（良心数据） Record30min Analysis请先思考后再展开 裸题 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177//Zory-2018//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量****************const int MAXN=31000,MAXM=61000;//*******************全局定义****************//*******************线段树******************struct Seg&#123; int l,r; int lc,rc; int sum,mx;&#125;s[MAXN*2];int cnt=0;int build(int l,int r)&#123; int t=++cnt; s[t].l=l;s[t].r=r; s[t].sum=s[t].mx=0; if(l&lt;r) &#123; int mid=(l+r)&gt;&gt;1; s[t].lc=build(l,mid); s[t].rc=build(mid+1,r); &#125; else s[t].lc=s[t].rc=0; return t;&#125;void change(int x,int pos,int c)&#123; if(s[x].l==s[x].r) &#123; s[x].sum=s[x].mx=c; return; &#125; int mid=(s[x].l+s[x].r)&gt;&gt;1; int lc=s[x].lc,rc=s[x].rc; if(pos&lt;=mid) change(lc,pos,c); else change(rc,pos,c); s[x].sum=s[lc].sum+s[rc].sum; s[x].mx=mymax(s[lc].mx,s[rc].mx);&#125;int asksum(int x,int l,int r)&#123; if(s[x].l==l and s[x].r==r) return s[x].sum; int mid=(s[x].l+s[x].r)&gt;&gt;1; int lc=s[x].lc,rc=s[x].rc; if(r&lt;=mid) return asksum(lc,l,r); if(l&gt;mid) return asksum(rc,l,r); return asksum(lc,l,mid)+asksum(rc,mid+1,r);&#125;int askmx(int x,int l,int r)&#123; if(s[x].l==l and s[x].r==r) return s[x].mx; int mid=(s[x].l+s[x].r)&gt;&gt;1; int lc=s[x].lc,rc=s[x].rc; if(r&lt;=mid) return askmx(lc,l,r); if(l&gt;mid) return askmx(rc,l,r); return mymax( askmx(lc,l,mid),askmx(rc,mid+1,r) );&#125;//*******************邻接表******************struct Nod&#123; int hou; int fa; int dep,tot; int tp,son;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXM];int ln=0;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;void dfs1(int x,int fa)&#123; p[x].fa=fa;p[x].dep=p[fa].dep+1; p[x].tot=1;p[x].son=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dfs1(y,x); p[x].tot+=p[y].tot; if(p[y].tot&gt;p[p[x].son].tot) p[x].son=y; &#125;&#125;//*******************树链剖分****************int ys[MAXN];int id=0;void dfs2(int x,int tp)&#123; ys[x]=++id; p[x].tp=tp; if(p[x].son&gt;0) dfs2(p[x].son,tp); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y==p[x].son or y==p[x].fa) continue; dfs2(y,y); &#125;&#125;//dep小，编号小int solve2(int a,int b)&#123; int ans=-40000; while(p[a].tp!=p[b].tp) &#123; int ta=p[a].tp,tb=p[b].tp; if(p[ta].dep&lt;p[tb].dep) swap(a,b),swap(ta,tb); ans=mymax(ans, askmx(1,ys[ta],ys[a]) ); a=p[ta].fa; &#125; if(p[a].dep&gt;p[b].dep) swap(a,b); return mymax(ans, askmx(1,ys[a],ys[b]) );&#125;int solve3(int a,int b)&#123; int ans=0; while(p[a].tp!=p[b].tp) &#123; int ta=p[a].tp,tb=p[b].tp; if(p[ta].dep&lt;p[tb].dep) swap(a,b),swap(ta,tb); ans+=asksum(1,ys[ta],ys[a]); a=p[ta].fa; &#125; if(p[a].dep&gt;p[b].dep) swap(a,b); return ans+asksum(1,ys[a],ys[b]);&#125;//*******************主函数******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; p[0].dep=0;p[0].tot=0;dfs1(1,0); dfs2(1,1); build(1,n); for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); change(1,ys[i],t); &#125; int Q;scanf("%d",&amp;Q);char ch[10]; while(Q--) &#123; int a,b;scanf("%s%d%d",ch,&amp;a,&amp;b); if(ch[0]=='C') change(1,ys[a],b);//CHANGE if(ch[1]=='M') printf("%d\n",solve2(a,b));//QMAX if(ch[1]=='S') printf("%d\n",solve3(a,b));//QSUM &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC093-b】Grid Components]]></title>
    <url>%2Fposts%2F7ef5.html</url>
    <content type="text"><![CDATA[Source and JudgeARC093-b Problem【Brief description】给出正整数A和B，求一个长宽都在100以内，并且白色联通块和黑色联通块分别是A和B的矩阵保证有解，输出任意一个合法解即可。【Input】正整数A和B【Output】第一行h和w分别表示竖直长度和横向长度然后是矩阵，‘.’表示白色，‘#’表示黑色【Limited conditions】1≤h,w≤1001≤A≤5001≤B≤500【Sample input】3 14【Sample output】1234567898 18........................................##.......####.....#.#.....#........#...#....#.......#.###.#...#......#.......#..#.....#.........#..####.【Sample explanation】无 Record30min Analysis请先思考后再展开 神题啊！有木有所以spj的题就是要乱搞？上次乱搞了一次，这次居然还没学会…… 所以我原本的想法是：哇要是矩阵大小无限制就好了，直接一列，乱搞AC…… 那现在有限制了怎么办呢？首先，h=100，w=100然后分均匀的两边，然后A–,B–然后再黑色那边补白色，白色那边补黑色，只要隔一行就好，这样正在补的联通块只增不减，另一个颜色完全不变！妙不可言地解决了…… Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//Zory-2018//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量*******************//*******************全局定义*******************//*******************实现******************//*******************主函数******************char mp[110][110];int main()&#123; printf("100 100\n"); for(int i=1;i&lt;=100;i++) for(int j=1;j&lt;=100;j++) if(i&lt;=50) mp[i][j]='#'; else mp[i][j]='.'; int a,b;scanf("%d%d",&amp;a,&amp;b); int x,y; x=1;y=1; for(int i=1;i&lt;=a-1;i++) &#123; mp[x][y]='.'; y+=2;if(y&gt;100) x+=2,y=1; &#125; x=100;y=1; for(int i=1;i&lt;=b-1;i++) &#123; mp[x][y]='#'; y+=2;if(y&gt;100) x-=2,y=1; &#125; for(int i=1;i&lt;=100;i++) puts(mp[i]+1);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1095】【Luogu2056】捉迷藏]]></title>
    <url>%2Fposts%2F25f1.html</url>
    <content type="text"><![CDATA[Source and JudgeZJOI2007Bzoj1095Luogu2056其实本质上就是Qtree4Caioj1433Spoj-QTREE4 Problem【Brief description】给定一棵树，每个节点要么是黑色，要么是白色。能执行两个操作：C(hange) i 改变第i个节点的颜色，若原来黑色，则白色；若原来白色，则黑色。G(ame) 开始一次游戏，查询最远的两个黑色节点的距离。【Input】第一行包含一个整数N，表示节点的个数，节点将被编号为1,2,3…N的整数。接下来N-1行每行两个整数a, b，表示节点a与节点b之间有一条边相连。接下来一行包含一个整数Q，表示操作次数。接着Q行，每行一个操作，如上文所示。【Output】对于每一个操作Game，输出一个非负整数，表示最远的两个黑色节点的距离。若只有一个节点是黑色的，输出0；若所有房间的灯都开着，输出-1。【Limited conditions】对于20%的数据，N≤50, M≤100；对于60%的数据，N≤3000, M≤10000；对于100%的数据，N≤100000, M≤500000。【Sample input】81 22 33 43 53 66 76 87GC 1GC 2GC 1G【Sample output】4334【Sample explanation】无 Record5hSpoj仍RE，已弃坑 Analysis请先思考后再展开 开始填坑！（据说可以用括号序列什么的？反正也没快多少，而且Qtree4有边权） 思路：1、通过DFS序，使标号连续，制作ST表来查询距离2、通过重心进行动态点分治（确保深度logn，避免被链卡）3、改颜色操作，维护两个堆 那么这个堆要讲讲： 因为颜色的多变，我们需要一个能删除元素的堆 B堆维护的是以它为根的子树中所有元素到它父亲的距离A堆维护的是其儿子的B堆的堆顶 于是，对于A[i]，其最大值+次大值就是经过它的最长链的长度为什么要两个堆？这是为了限制每个儿子只能有一个贡献，从而不重复 细节还是灰常多的，所以代码有灰常多的注释特别是改颜色的部分，灰常重要，每一句都要深刻理解才好 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241//Zory-2018//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int bin[31];int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=110000,MAXM=510000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Heap//可删堆&#123; priority_queue&lt;int&gt; a,b;//a堆记录全部的状态，b堆记录没用的状态 void push(int x)//加进一个目前有用的状态（将来可能没用了） &#123; a.push(x); &#125; void erase(int x)//删除这个状态 &#123; b.push(x); &#125; void pop()//删除堆顶 &#123; while(b.size() and a.top()==b.top()) a.pop(),b.pop(); a.pop(); &#125; int size() &#123; return a.size()-b.size(); &#125; int top() &#123; while(b.size() and a.top()==b.top()) a.pop(),b.pop(); if(!a.size()) return 0; return a.top(); &#125; int top2() &#123; if(size()==0) return 0; if(size()==1) return top(); int x=top();pop(); int y=top();push(x); return x+y; &#125;&#125;ANS,A[MAXN],B[MAXN];struct Nod&#123; int hou; int dis; bool v; Nod() &#123; hou=0; v=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,c,g;&#125;e[MAXM*2];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln;&#125;//*******************ST表*******************int f[MAXN*2][31];int id,dfn[MAXN];//dfs序void preST(int x,int fa)&#123; dfn[x]=++id;f[id][0]=p[x].dis; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; p[y].dis=p[x].dis+e[k].c; preST(e[k].y,x); f[++id][0]=p[x].dis;//回溯 &#125;&#125;int rmq(int x,int y)&#123; x=dfn[x];y=dfn[y]; if(y&lt;x) swap(x,y); int t=log2(y-x+1); return mymin(f[x][t],f[y-bin[t]+1][t]);&#125;int getdis(int x,int y)&#123; return p[x].dis+p[y].dis-2*rmq(x,y);&#125;//*******************动态点分治*******************int G,sum;int ty[MAXN],siz[MAXN];void getrt(int x,int fa)//fa!=f[x][0]&#123; siz[x]=1;ty[x]=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa or p[y].v) continue; getrt(y,x); siz[x]+=siz[y]; ty[x]=mymax(ty[x],siz[y]); &#125; ty[x]=mymax(ty[x],sum-siz[x]);//另一侧 if(ty[x]&lt;ty[G]) G=x;&#125;int dad[MAXN];void divi(int x,int fa)&#123; dad[x]=fa;p[x].v=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(p[y].v) continue; sum=siz[y];G=0; getrt(y,x); divi(G,x);//分治 &#125;&#125;//*******************实现*******************void turnblack(int x,int v)&#123; if(x==v) &#123; A[x].push(0);//自己 if(A[x].size()==2) ANS.push(A[x].top());//新贡献 &#125; if(!dad[x]) return; //向上更新 int fa=dad[x],dis=getdis(fa,v),tmp=B[x].top(); B[x].push(dis); if(dis&gt;tmp)//取代 &#123; int mx=A[fa].top2(),sz=A[fa].size();//备份 if(tmp&gt;0) A[fa].erase(tmp); A[fa].push(dis); int now=A[fa].top2(); if(now&gt;mx)//取代 &#123; if(sz&gt;=2) ANS.erase(mx); if(A[fa].size()&gt;=2) ANS.push(now); //如果sz=1，则自己是白色或没有黑色，非法 &#125; &#125; turnblack(fa,v);&#125;void turnwhite(int x,int v)&#123; if(x==v) &#123; A[x].erase(0);//自己 if(A[x].size()==1) ANS.erase(A[x].top());//答案非法 &#125; if(!dad[x]) return; //向上更新 int fa=dad[x],dis=getdis(fa,v),tmp=B[x].top(); B[x].erase(dis); if(dis==tmp)//去除 &#123; int mx=A[fa].top2(),sz=A[fa].size();//备份 A[fa].erase(dis); int tp=B[x].top(); if(tp&gt;0) A[fa].push(tp); int now=A[fa].top2(); if(now&lt;mx)//去除 &#123; if(sz&gt;=2) ANS.erase(mx); if(A[fa].size()&gt;=2) ANS.push(now); //如果sz=1，则自己是白色或没有黑色，非法 &#125; &#125; turnwhite(fa,v);&#125;//*******************主函数******************int col[MAXN];int main()&#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; int n;scanf("%d",&amp;n);ln=0; for(int i=1;i&lt;=n-1;i++) &#123; int x,y,c; scanf("%d%d",&amp;x,&amp;y);c=1; //scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);ins(y,x,c); &#125; p[1].dis=0;preST(1,0); int t=log2(id); for(int i=1;i&lt;=t;i++) for(int j=1;j&lt;=id;j++) if(j+bin[i]-1&lt;=id) f[j][i]=mymin(f[j][i-1],f[j+bin[i-1]][i-1]); G=0;ty[G]=INF;sum=n; getrt(1,0);divi(G,0); for(int i=1;i&lt;=n;i++) &#123; col[i]=1; turnblack(i,i); &#125; int tot=n; int Q;scanf("%d",&amp;Q); while(Q--) &#123; char s[5];scanf("%s",s); if(s[0]!='C') &#123; if(tot==0) printf("-1\n");//They have disappeared. else if(tot==1) printf("0\n"); else printf("%d\n",ANS.top()); &#125; else &#123; int x;scanf("%d",&amp;x); if(col[x]==0) tot++,turnblack(x,x); else tot--,turnwhite(x,x); col[x]=1-col[x]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>精品题</tag>
        <tag>难度3</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1003】【Luogu1772】物流运输]]></title>
    <url>%2Fposts%2F90dd.html</url>
    <content type="text"><![CDATA[来源和评测点ZJOI2006NOI导刊2010提高（01）Bzoj1003Luogu1772 题目【题目大意】物流公司要把一批货物从码头A运到码头B。由于货物量比较大，需要n天才能运完。货物运输过程中一般要转停好几个码头。物流公司通常会设计一条固定的运输路线，以便对整个运输过程实施严格的管理和跟踪。由于各种因素的存在，有的时候某个码头会无法装卸货物。这时候就必须修改运输路线，让货物能够按时到达目的地。但是修改路线是—件十分麻烦的事情，会带来额外的成本。因此物流公司希望能够订一个n天的运输计划，使得总成本尽可能地小。【输入格式】第一行是四个整数n(l≤n≤100)、m(l≤m≤20)、K和e。n表示货物运输所需天数，m表示码头总数，K表示每次修改运输路线所需成本，e表示航线条数。接下来e行每行是一条航线描述，包括了三个整数，依次表示航线连接的两个码头编号以及航线长度(&gt;0)。其中码头A编号为1，码头B编号为m。单位长度的运输费用为1。航线是双向的。再接下来一行是一个整数d，后面的d行每行是三个整数P(1&lt;P&lt;m)，a，b(1≤a≤b≤n)。表示编号为P的码头从第a天到第b天无法装卸货物（含头尾）。同一个码头有可能在多个时间段内不可用。但任何时间都存在至少一条从码头A到码头B的运输路线。【输出格式】包括了一个整数表示最小的总成本。总成本=n天运输路线长度之和+K*改变运输路线的次数。【限定条件】30%的数据中N和M均不超过650%的数据中N和M至少有一个数不超过8100%的数据中N和M均不超过100【输入样例】5 5 10 81 2 11 3 31 4 22 3 22 4 43 4 13 5 24 5 242 2 33 1 13 3 34 4 5【输出样例】32【样例解释】上图依次表示第1至第5天的情况，阴影表示不可用的码头。前三天走1-4-5，后两天走1-3-5，这样总成本为(2+2)3+(3+2)2+10=32。 刷题记录30min1AC小心爆int 分析请先思考后再展开 好巧妙！枚举天数区间，狂跑最短路……然后进行灰常简单的DP即可快！狠！准！ 代码请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//Zory-2018//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=30,MAXM=800;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int hou; int d; bool v; bool in; bool ck[110]; Nod() &#123; hou=0; memset(ck,0,sizeof(ck)); &#125;&#125;p[MAXN];struct Edge&#123; int y,c,g;&#125;e[MAXM];int ln=0;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln;&#125;//*******************实现*******************int m;int lst[MAXN];int spfa(int st,int ed)&#123; for(int i=1;i&lt;=m;i++) &#123; p[i].d=INF;p[i].in=1; for(int j=st;j&lt;=ed;j++) if(p[i].ck[j]) &#123; p[i].in=0; break; &#125; &#125; p[1].v=1;p[1].d=0; int tou=1,wei=2;lst[1]=1; while(tou!=wei) &#123; int x=lst[tou++];if(tou==MAXN) tou=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].in and p[y].d&gt;p[x].d+e[k].c) &#123; p[y].d=p[x].d+e[k].c; if(p[y].v==0) &#123; p[y].v=1; lst[wei++]=y; if(wei==MAXN) wei=1; &#125; &#125; &#125; p[x].v=0; &#125; return p[m].d;&#125;//*******************主函数******************int f[110];int main()&#123; int n,K,e;scanf("%d%d%d%d",&amp;n,&amp;m,&amp;K,&amp;e); while(e--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);ins(y,x,c); &#125; int P;scanf("%d",&amp;P); while(P--) &#123; int t,x,y;scanf("%d%d%d",&amp;t,&amp;x,&amp;y); for(int i=x;i&lt;=y;i++) p[t].ck[i]=1; &#125; for(int i=1;i&lt;=n;i++) &#123; int t=spfa(1,i); if(t==INF) f[i]=INF; else f[i]=t*i;//debug 爆int for(int j=1;j&lt;=i-1;j++) &#123; t=spfa(j+1,i);//debug if(t!=INF) f[i]=mymin(f[i],f[j]+K+spfa(j+1,i)*(i-j)); &#125; &#125; printf("%d",f[n]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1037】【Luogu2592】生日聚会]]></title>
    <url>%2Fposts%2F4e5e.html</url>
    <content type="text"><![CDATA[来源和评测点ZJOI2008Bzoj1037Luogu2592 题目【题目大意】今天是hidadz小朋友的生日，她邀请了许多朋友来参加她的生日party。hidadz带着朋友们来到花园中，打算坐成一排玩游戏。为了游戏不至于无聊，就座的方案应满足如下条件：对于任意连续的一段，男孩与女孩的数目之差不超过k。很快，小朋友便找到了一种方案坐了下来开始游戏。hidadz的好朋友Susie发现，这样的就座方案其实是很多的，所以大家很快就找到了一种，那么到底有多少种呢？热爱数学的hidadz和她的朋友们开始思考这个问题……假设参加party的人中共有n个男孩与m个女孩，你是否能解答Susie和hidadz的疑问呢？由于这个数目可能很多，他们只想知道这个数目除以12345678的余数。【输入格式】共3个整数，分别为男孩数目n, 女孩数目m, 常数k【输出格式】题中要求的答案【限定条件】对于30%的数据，n,m≤20；对于100%的数据，n,m≤150，k≤20。【输入样例】1 2 1【输出样例】1【样例解释】无 刷题记录30min1AC 分析请先思考后再展开 别人眼中的水题……网上题解可能都懒得说什么了，于是我一开始并没有理解。在我的美妙构想中，dp式长这样：f[q][w]，觉得男女生差距哪些自己算不就好了？然鹅，这并没有考虑到，我们要求的条件是针对任意一段的差。然后，我们在DP中，假设做到了第i-1个要得出第i个，那么新增加了哪些段呢（因为之前的段已经保证合法性了）？显然就是i的所有后缀那么新增加两个维度变成f[q][w][a][b]来存储任意长度的后缀的男女最大差，以此来作为约束条件。 代码请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//Zory-2018//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MOD=12345678;//*******************全局变量*******************int f[310][160][30][30];//*******************实现*******************//*******************主函数******************int main()&#123; int n,m,k;scanf("%d%d%d",&amp;n,&amp;m,&amp;k); f[0][0][0][0]=1;if(n&gt;m) swap(n,m); for(int i=0;i&lt;=n+m-1;i++) &#123; for(int j=0;j&lt;=n and j&lt;=i;j++) &#123; for(int a=0;a&lt;=k;a++)//男 &#123; for(int b=0;b&lt;=k;b++)//女 &#123; if(f[i][j][a][b]==0) continue;//超级快 if(a&lt;k and j&lt;n)//男 &#123; f[i+1][j+1][a+1][mymax(b-1,0)]+=f[i][j][a][b]; f[i+1][j+1][a+1][mymax(b-1,0)]%=MOD; &#125; if(b&lt;k and i-j&lt;m)//女 &#123; f[i+1][j][mymax(a-1,0)][b+1]+=f[i][j][a][b]; f[i+1][j][mymax(a-1,0)][b+1]%=MOD; &#125; &#125; &#125; &#125; &#125; int ans=0; for(int a=0;a&lt;=k;a++) for(int b=0;b&lt;=k;b++) &#123; ans+=f[n+m][n][a][b]; ans%=MOD; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2298】【Luogu2523】problem c]]></title>
    <url>%2Fposts%2F3d19.html</url>
    <content type="text"><![CDATA[来源和评测点HAOI2011Bzoj2302Luogu2523 题目【题目大意】给n个人安排座位，先给每个人一个1~n的编号，设第i个人的编号为ai（不同人的编号可以相同），接着从第一个人开始，大家依次入座，第i个人来了以后尝试坐到ai，如果ai被占据了，就尝试ai+1，ai+1也被占据了的话就尝试ai+2，……，如果一直尝试到第n个都不行，该安排方案就不合法。然鹅有m个人的编号已经确定(他们或许贿赂了你的上司…)，你只能安排剩下的人的编号，求有多少种合法的安排方案。由于答案可能很大，只需输出其除以M后的余数即可。【输入格式】第一行一个整数T，表示数据组数对于每组数据，第一行有三个整数，分别表示n、m、M若m不为0，则接下来一行有m对整数，p1、q1，p2、q2 ,…, pm、qm，其中第i对整数pi、qi表示第pi个人的编号必须为qi【输出格式】对于每组数据输出一行，若是有解则输出YES，后跟一个整数表示方案数mod M，注意，YES和数之间只有一个空格，否则输出NO【限定条件】1≤T≤10，1≤n≤300，0≤m≤n，2≤M≤10^9，1≤pi、qi≤n 且保证pi互不相同。【输入样例】24 3 101 2 2 1 3 110 3 88827 9 2 9 5 10【输出样例】YES 4NO【样例解释】无 刷题记录1h 分析请先思考后再展开 好难啊赶脚这种东西感觉完全想不出来好吧 首先，一个显然的不合法情况：编号&lt;=i的人少于i个（后面人太多了，冲突）然后具体人的编号是完全不重要的，递推的时候乘上组合数就可以了。然后用一个num[i]记录，已经确定的编号为i的人的个数然后用sum[i]表示num[i]的前缀和，特别的是sum[0]=n-m，表示所有未决定的在极端情况下相当于0，这样sum[i]又多了一个意义：编号&lt;=i的人 最多有多少设f[i][j]表示编号&lt;=i的人，有j个的方案数（同理，i&lt;=j），用k表示编号=i的个数那么，k最小当然就是num[i]，最大则是j-(i-1)，因为sum[i-1]&gt;=i-1然后我们这一轮新选择（除去已经固定的）有num[i]个，总共是sum[i]-num[i]-(j-k)所以得出方程(i=1~n,j=i~sum[i])：$$f[i][j]=\sum_{k=num[i]}^{j-i+1} f[i-1][j-k]\times C_{sum[i]-num[i]-(j-k)}^{k-num[i]}$$时间复杂度$O(Tn^3)$ 代码请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量*******************const int MAXN=310;//*******************全局定义*******************int num[MAXN],sum[MAXN];ll f[MAXN][MAXN];ll C[MAXN][MAXN];//*******************实现*******************//*******************主函数*******************int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; memset(num,0,sizeof(num)); memset(sum,0,sizeof(sum)); memset(f,0,sizeof(f)); memset(C,0,sizeof(C)); int n,m;ll MOD;scanf("%d%d%lld",&amp;n,&amp;m,&amp;MOD); for(int i=1;i&lt;=m;i++) &#123; int a,b; scanf("%d%d",&amp;a,&amp;b); num[b]++; &#125; C[0][0]=1;//debug for(int i=1;i&lt;=n;i++) &#123; C[i][0]=1; for(int j=1;j&lt;=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD; &#125; bool bk=0; sum[0]=n-m; for(int i=1;i&lt;=n;i++) &#123; sum[i]=sum[i-1]+num[i]; if(sum[i]&lt;i) bk=1; &#125; if(bk) &#123; printf("NO\n"); continue; &#125; f[0][0]=1; for(int i=1;i&lt;=n;i++) &#123; for(int j=i;j&lt;=sum[i];j++) &#123; for(int k=num[i];k&lt;=j-i+1;k++) &#123; f[i][j]=(f[i][j]+f[i-1][j-k]*C[ sum[i]-num[i]-(j-k) ][ k-num[i] ]%MOD)%MOD; &#125; &#125; &#125; printf("YES %lld\n",f[n][n]); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2298】【Luogu2519】problem a]]></title>
    <url>%2Fposts%2Ff583.html</url>
    <content type="text"><![CDATA[来源和评测点HAOI2011Bzoj2298Luogu2519 题目【题目大意】一次考试共有n个人参加，第i个人说：“有ai个人分数比我高，bi个人分数比我低。”问最少有几个人没有说真话(可能有相同的分数)。【输入格式】第一行一个整数n，接下来n行每行两个整数，第i+1行的两个整数分别代表ai、bi【输出格式】一个整数，表示最少有几个人说谎【限定条件】1≤n≤1000000≤ai、bi≤n【输入样例】32 00 22 2【输出样例】1【样例解释】无 刷题记录1h 分析请先思考后再展开 假话=n-真话，最少假话=最多真话 定位可能的区间[ai+1,n-bi]为[li,ri]，直接跳过l&gt;r的情况（显然的假话） 将所有区间排序，从而获得有哪些是相同的[li,ri]，合并为一个块 给这个块定义一个价值vi：最大可能人数（如果比ri-li+1多，多余的忽略，显然的假话） 开始DP。设f[i]表示到当前块的真话最大值然后二分查找，得到编号最大（最优秀）且rj&lt;li的j，f[i]=max(f[i-1],f[j]+vi) ANS=n-f[块数]时间复杂度O(nlogn) 代码请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=110000;//*******************全局定义*******************struct Block&#123; int l,r,v;&#125;t[MAXN],p[MAXN];int f[MAXN];//*******************实现*******************bool cmp(Block a,Block b)&#123; if(a.r!=b.r) return a.r&lt;b.r; return a.l&lt;b.l;&#125;int m;int find2(int l,int r,int d)&#123; int ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(p[mid].r&lt;d) ans=mid,l=mid+1; else r=mid-1; &#125; if(ans&lt;0) ans=0; return ans;&#125;//*******************主函数*******************int main()&#123; int tn;scanf("%d",&amp;tn); int n=0; for(int i=1;i&lt;=tn;i++) &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); if(a+1+b&lt;=tn) t[++n].l=a+1,t[n].r=tn-b; &#125; sort(t+1,t+n+1,cmp); m=0; for(int i=1;i&lt;=n;i++) &#123; if(i==1 or t[i-1].l!=t[i].l or t[i-1].r!=t[i].r) p[++m]=t[i],p[m].v=1; else if(p[m].v&lt;p[m].r-p[m].l+1) p[m].v++; &#125; f[1]=p[1].v; for(int i=2;i&lt;=m;i++) &#123; int j=find2(1,i-1,p[i].l); f[i]=mymax(f[i-1],f[j]+p[i].v); &#125; printf("%d",tn-f[m]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj4069】【Luogu3646】巴厘岛的雕塑]]></title>
    <url>%2Fposts%2Fa4aa.html</url>
    <content type="text"><![CDATA[来源和评测点Apio2015 Bali SculpturesBzoj4069Luogu3646Uoj110 题目【题目大意】给出一些有序的值，在连续的情况下进行分组，并且a&lt;=组的数量&lt;=b求最小的 所有（组的和）的按位或值。【输入格式】输入的第一行包含三个用空格分开的整数N,A,B第二行包含N个用空格分开的整数。【输出格式】输出一行一个数，表示最小的按位或值。【限定条件】子任务1 （9 分）1&lt;=N&lt;=201&lt;=A&lt;=B&lt;=N0&lt;=Yi&lt;=1000000000子任务2 （16 分）1&lt;=N&lt;=501&lt;=A&lt;=B&lt;=min{20,N}0&lt;=Yi&lt;=10子任务3 （21 分）1&lt;=N&lt;=100A=11&lt;=B&lt;=N0&lt;=Yi&lt;=20子任务4 （25 分）1&lt;=N&lt;=1001&lt;=A&lt;=B&lt;=N0&lt;=Yi&lt;=1000000000子任务5 （29 分）1&lt;=N&lt;=2000A=11&lt;=B&lt;=N0&lt;=Yi&lt;=1000000000【输入样例】6 1 38 1 2 1 5 4【输出样例】11【样例解释】分为2组，(8,1,2)和(1,5,4)，它们的和是 (11) 和 (10)，最终优美度是 (11 OR 10)=11，不难验证，这也是最终优美度的最小值。 刷题记录1h 分析请先思考后再展开 显然，直接写DP是不行的，因为区间小并不代表最终小。既然是按位或，可以考虑数位DP。然后区间静态求和，前缀和是不能少滴。 然后网上看到一句话： 对于数位极值问题，应该贪心地优先从高位开始考虑，极小值优先0，极大值优先1 然后就可以愉快地考虑DP了：假设现在在努力地把右数第k位变成0，那么我们就要尽量让所有和的第k位为0。并且前面的已经解决，用tmp表示现在已经能变成0的位置（所以最后输出答案就是tot-tmp） 然后f[i][p]表示前面i个数分p段能否第k位是0（状压），然后n^2来常规DP即可转移条件：( (sum[i]-sum[j])&amp;tmp )==0 （也就是tmp为1的地方这一段的和必须是0，否则前功尽弃）那么这个复杂度是O(60*n^3)的，而最后一个子任务是2000，会TLE然后发现这一次，A=1，那么怎么利用这个条件呢？考虑贪心一波：因为现在的限制只有B，那么当然是段数越小，成功率越高。设g[i]表示前i个数最小分多少段能第k位是0成功变成O(60*n^2) 代码请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;//*******************全局常量*******************const int MAXN=2100;//*******************全局定义*******************typedef long long ll;int n,A,B;ll sum[MAXN];ll bin[70];//*******************实现*******************bool f[MAXN][MAXN];ll dp1(ll kk)&#123; ll tmp=0; for(int k=kk-1;k&gt;=0;k--) &#123; tmp+=bin[k];//先假设成功 memset(f,0,sizeof(f)); for(int i=1;i&lt;=n;i++) f[i][1]=( (sum[i]&amp;tmp)==0 ); bool bk=(A==1 and f[n][1]); for(int p=2;p&lt;=B;p++) &#123; if(bk) break; for(int i=p;i&lt;=n;i++) &#123; for(int j=p-1;j&lt;=i-1;j++) if(f[j][p-1] and ((sum[i]-sum[j])&amp;tmp)==0) &#123; f[i][p]=1;break; &#125; if(p&gt;=A and f[n][p]) &#123;bk=1;break;&#125; &#125; &#125; if(!bk) tmp-=bin[k]; &#125; return (bin[kk]-1)-tmp;&#125;int g[MAXN];ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;ll dp2(ll kk)&#123; ll tmp=0; for(int k=kk-1;k&gt;=0;k--) &#123; tmp+=bin[k];//先假设成功 memset(g,63,sizeof(g));g[0]=0; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=i-1;j++) if( ((sum[i]-sum[j])&amp;tmp)==0 ) g[i]=mymin(g[i],g[j]+1); if(g[n]&gt;B) tmp-=bin[k]; &#125; return (bin[kk]-1)-tmp;&#125;//*******************主函数*******************int main()&#123; scanf("%d%d%d",&amp;n,&amp;A,&amp;B); for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); sum[i]=sum[i-1]+t; &#125; int kk; for(kk=0;kk&lt;=60;kk++) &#123; bin[kk]=(kk==0)?1:(bin[kk-1]&lt;&lt;1); if(bin[kk]-1&gt;=sum[n]) return printf("%lld",(A&gt;1)?dp1(kk):dp2(kk)),0; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数位DP</tag>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj4197】【Luogu2150】寿司晚宴]]></title>
    <url>%2Fposts%2Fbe34.html</url>
    <content type="text"><![CDATA[来源和评测点Noi2015Bzoj4197Loj2131Uoj129Luogu2150 题目【题目大意】为了庆祝NOI的成功开幕，主办方为大家准备了一场寿司晚宴。小G和小W作为参加NOI的选手，也被邀请参加了寿司晚宴。在晚宴上，主办方为大家提供了n−1种不同的寿司，编号1,2,3,……,n-1，其中第种寿司的美味度为i+1（即寿司的美味度为从2到n）。现在小G和小W希望每人选一些寿司种类来品尝，他们规定一种品尝方案为不和谐的当且仅当：小G品尝的寿司种类中存在一种美味度为x的寿司，小W品尝的寿司中存在一种美味度为y的寿司，而x与y不互质。现在小G和小W希望统计一共有多少种和谐的品尝寿司的方案（对给定的正整数p取模）。注意一个人可以不吃任何寿司。【输入格式】第1行包含2个正整数n，p中间用单个空格隔开，表示共有n种寿司，最终和谐的方案数要对p取模。【输出格式】输出一行包含1个整数，表示所求的方案模p的结果。【限定条件】2≤n≤5000&lt;p≤1000000000【输入样例】100 100000000【输出样例】3107203【样例解释】无 刷题记录2h1WA1AC以后有膜数的问题，出现减法一定要小心！可能原本正数，膜完再减就变成负数了！ 分析请先思考后再展开 又膜了题解，还特别不好理解…… 首先明确：选择了一种寿司，其实是选择了一些质因数。那么继续面向数据编程，2~n的数，最多包含一个质因数是大于$\sqrt{n}$的而在这之下的质因数个数只有8个：2,3,5,7,11,13,17,19那么是可以用256个状态表示每个数的组成的（注意！！质因数的数量是完全不重要的，也就是说我们记录的只是集合！）那剩下那个大质因数（没有的话用1表示）怎么处理呢？因为这个质因数只能选择一个人，那么以这个排一次序，相同的这个只能选择一个人，看作是一个块（如果没有，则视为不同的块） 那么开始推公式： 定义（在同一个块中）：$$f[s1][s2]=两个人的这种状态下，合法方案的数量$$$$g1[s1][s2]表示两个人的这种状态下，并且这一块的质因数选择第一个或者不选的合法方案的数量$$$$g2[s1][s2]表示两个人的这种状态下，并且这一块的质因数选择第二个或者不选的合法方案的数量$$ 计算1) 一个新的块开始$$g1[s1][s2]=g2[s1][s2]=f[s1][s2]（相当于不选）$$2) 像采药一样倒着DP来避免后效性$$g[s|j]+=f[s]（状态的包含）$$3) 一个块结束（因为不选的部分两边都重复了）$$f[s1][s2]=g1[s1][s2]+g2[s1][s2]-f[s1][s2]$$ 然后自己注意一下合法状态的判断就好了，都是位运算 这道题最巧妙的地方在于对大质因数的处理，以及对状态压缩的洞察力。 代码请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=510,MAXS=300;const int PRIME[8]=&#123;2,3,5,7,11,13,17,19&#125;;//*******************全局定义*******************int bin[10];struct Num&#123; int bit; int left;&#125;a[MAXN];bool cmp(Num a,Num b) &#123;return a.left&lt;b.left;&#125;//*******************实现*******************ll MOD;ll Mod(ll x) &#123; return (x%MOD+MOD)%MOD;&#125;int fuk(int &amp;x)&#123; int ans=0; for(int i=0;i&lt;8;i++) &#123; if(x%PRIME[i]==0) &#123; ans+=bin[i]; while(x%PRIME[i]==0) x/=PRIME[i]; &#125; &#125; return ans;&#125;//*******************主函数*******************ll f[MAXN][MAXN];ll g1[MAXN][MAXN],g2[MAXN][MAXN];int main()&#123; bin[0]=1;for(int i=1;i&lt;=8;i++) bin[i]=bin[i-1]&lt;&lt;1; int n;scanf("%d%lld",&amp;n,&amp;MOD); for(int now=2;now&lt;=n;now++) a[now].left=now,a[now].bit=fuk(a[now].left); sort(a+2,a+n+1,cmp); f[0][0]=1;int tot=bin[8]-1; for(int i=2;i&lt;=n;i++) &#123; if(i==2 or a[i].left==1 or a[i-1].left!=a[i].left) &#123; memcpy(g1,f,sizeof(f)); memcpy(g2,f,sizeof(f)); &#125; for(int s1=tot;s1&gt;=0;s1--) for(int s2=tot;s2&gt;=0;s2--) &#123; if( (s1&amp;s2)!=0 ) continue;//debug if( (a[i].bit&amp;s2)==0 ) g1[s1|a[i].bit][s2]=(g1[s1|a[i].bit][s2]+f[s1][s2])%MOD; if( (s1&amp;a[i].bit)==0 ) g2[s1][s2|a[i].bit]=(g2[s1][s2|a[i].bit]+f[s1][s2])%MOD; &#125; if(i==n or a[i].left==1 or a[i].left!=a[i+1].left) &#123; for(int s1=0;s1&lt;=tot;s1++) for(int s2=0;s2&lt;=tot;s2++) if( (s1&amp;s2)==0 ) f[s1][s2]=Mod(g1[s1][s2]+g2[s1][s2]-f[s1][s2]); &#125; &#125; int ans=0; for(int s1=0;s1&lt;=tot;s1++) for(int s2=0;s2&lt;=tot;s2++) if( (s1&amp;s2)==0 )//debug ans=(ans+f[s1][s2])%MOD; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度2</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1131】【Luogu3160】时态同步]]></title>
    <url>%2Fposts%2F2e88.html</url>
    <content type="text"><![CDATA[来源和评测点ZJOI2007Bzoj1060Luogu1131 题目【题目大意】小Q在电子工艺实习课上学习焊接电路板。一块电路板由若干个元件组成，我们不妨称之为节点，并将其用数字1,2,3….进行标号。电路板的各个节点由若干不相交的导线相连接，且对于电路板的任何两个节点，都存在且仅存在一条通路（通路指连接两个元件的导线序列）。在电路板上存在一个特殊的元件称为“激发器”。当激发器工作后，产生一个激励电流，通过导线传向每一个它所连接的节点。而中间节点接收到激励电流后，得到信息，并将该激励电流传向与它连接并且尚未接收到激励电流的节点。最终，激烈电流将到达一些“终止节点”――接收激励电流之后不再转发的节点。激励电流在导线上的传播是需要花费时间的，对于每条边e，激励电流通过它需要的时间为te，而节点接收到激励电流后的转发可以认为是在瞬间完成的。现在这块电路板要求每一个“终止节点”同时得到激励电路――即保持时态同步。由于当前的构造并不符合时态同步的要求，故需要通过改变连接线的构造。目前小Q有一个道具，使用一次该道具，可以使得激励电流通过某条连接导线的时间增加一个单位。请问小Q最少使用多少次道具才可使得所有的“终止节点”时态同步？【输入格式】第一行包含一个正整数N，表示电路板中节点的个数。第二行包含一个整数S，为该电路板的激发器的编号。接下来N-1行，每行三个整数a,b,t。表示该条导线连接节点a与节点b，且激励电流通过这条导线需要t个单位时间【输出格式】仅包含一个整数V，为小Q最少使用的道具次数【限定条件】对于40%的数据，N≤1000对于100%的数据，N≤500000对于所有的数据，te≤1000000【输入样例】311 2 11 3 3【输出样例】2【样例解释】无 刷题记录30min 分析请先思考后再展开 sb题中午睡觉无聊想的 代码请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;ll mymax(ll x,ll y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=510000;//*******************全局定义*******************struct nod&#123; int hou; int fa; ll dep,mx; nod() &#123; hou=dep=mx=0; &#125;&#125;p[MAXN];struct edge&#123; int y,g; ll c;&#125;e[MAXN*2];int ln=0;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln;&#125;//*******************实现*******************void dfs1(int x,int fa)&#123; p[x].fa=fa;p[x].mx=p[x].dep; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; p[y].dep=p[x].dep+e[k].c; dfs1(y,x); p[x].mx=mymax(p[x].mx,p[y].mx); &#125;&#125;ll mx;ll ans=0;void dfs2(int x,ll inc)&#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==p[x].fa) continue; ll d=mx-(p[y].mx+inc); if(d&gt;0) &#123; ans+=d; dfs2(y,inc+d); &#125; else dfs2(y,inc); &#125;&#125;//*******************主函数*******************int main()&#123; int n,st;scanf("%d%d",&amp;n,&amp;st); for(int i=1;i&lt;=n-1;i++) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);ins(y,x,c); &#125; dfs1(st,0); mx=p[st].mx; dfs2(st,0); printf(BIGN,ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度1</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2064】分裂]]></title>
    <url>%2Fposts%2Fdf4.html</url>
    <content type="text"><![CDATA[来源和评测点和谐社会模拟赛Bzoj2064 题目【题目大意】给定一个初始集合和目标集合，有两种操作：1.合并集合中的两个元素，新元素为两个元素之和 2.分裂集合中的一个元素，得到的两个新元素之和等于原先的元素。要求用最小次数使初始集合变为目标集合，求最小次数。【输入格式】第一行一个数n1，表示当时的元素量，接下来n1个数分别表示各元素的值。 第二行一个数n2，表示现在的元素量，接下来n2个数分别表示各元素的值。【输出格式】一行一个数表示最小次数。【限定条件】对于30%的数据，n1,n2&lt;=6对于100%的数据，n1,n2&lt;=10，每个数&lt;=50【输入样例】1 63 1 2 3【输出样例】2【样例解释】无 刷题记录30min1AC 分析请先思考后再展开 首先，本着面向数据编程的观点，我们发现数据范围灰常小！那么有基本上两种可能： 一般的算法难以解决的问题 状压DP看起来好像后面这个比较靠谱呀，因为这个题目好像不算太恶心但是压什么呢？通常都是选和不选的01但这道题不是选不选的问题呀，元素不是不变的于是我的思路一度卡顿…… 算了，还是先观察题目吧，看看能不能转化模型？ 精简题意（我上面已经精简了） 考虑题目要求的是最小次数，虽然DP和贪心差别很大，但先考虑一下极端情况：1) 最坏情况(n-1)+(m-1)=n+m-2，也就是全部加起来再分开2) 如果稍微好一点，恰好有两部分对应和相等，那么合并和分离就都减少了一次也就是(n-2)+(m-2)=n+m-43) 那么如果有k部分对应相等，显然次数就是n+m-2*k4) 用最好情况验证一下，次数是0,那么k=n=m，n+m-2*k=0 哇这下子就好办了！求出一个最大的k就好了。更好的是，求最大的k，根本就不用真的去合并、分割于是祭出状态压缩大法！用二进制表示选取状态。f[s1][s2]表示集合1和集合2的子集s1和s2的最大ksum[s]表示状态s的和f[s1][s2]=max(f[s1^i][s2^j])+bool(sum[s1]==sum[s2]) 以上就是网上普遍的解法了，然鹅我有幸又看到一篇文章他的方法也挺巧妙的，主要是简化上面的方程（复杂度不变）首先，sum数组要开两个，有点麻烦，因为两个状态都是一起用的，考虑状态全部合二为一（最大长度从10变20）然后集合1是正数，集合2是负数，那么如果sum[s]=0表示和相同然后为了避免冲突，sum不能乱算（挺巧妙的）：sum[s]=sum[lowbit(s)]+sum[s-lowbit(s)]然后f也可以把状态合二为一 代码请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int read()&#123; int s=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') s=s*10+c-'0',c=getchar(); return s;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=1100000;//*******************全局定义*******************int bin[26];int f[MAXN],sum[MAXN];//*******************实现*******************inline int lowbit(int x) &#123;return x&amp;(-x);&#125;//*******************主函数*******************int main()&#123; bin[0]=1;for(int i=1;i&lt;=25;i++) bin[i]=bin[i-1]&lt;&lt;1; int n,m; scanf("%d",&amp;n);for(int i=1;i&lt;=n;i++) sum[bin[i-1]]=read(); scanf("%d",&amp;m);for(int i=1;i&lt;=m;i++) sum[bin[n+i-1]]=-read(); int tot=bin[n+m]-1; for(int s=1;s&lt;=tot;s++) &#123; int t=lowbit(s);sum[s]=sum[t]+sum[s^t]; for(int j=1;j&lt;=n+m;j++) if(s&amp;bin[j-1]) f[s]=mymax(f[s],f[s^bin[j-1]]); if(sum[s]==0) f[s]++; //s的和对应，则为后面作贡献 &#125; printf("%d",n+m-2*f[tot]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度2</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1827】【Luogu2986】【Bzoj3743】奶牛大集会]]></title>
    <url>%2Fposts%2F4b22.html</url>
    <content type="text"><![CDATA[来源和评测点USACO2010 MAR GoldGreat Cow GatheringBzoj1827Luogu2986 双倍经验：Coci2015 KampBzoj3743 题目【题目大意】给出n个点，由n-1条边连接ai和bi，长度为li，形成一棵树，每个点有ci个奶牛。现在要选一个点，使其他点的奶牛到这里距离×数量之和最小。【输入格式】第一行：一个整数N。第二到N+1行：第i+1行有一个整数Ci第N+2到2*N行：第i+N+1行有3个整数：Ai,Bi和Li。【输出格式】最小的距离×数量之和【限定条件】1&lt;=N&lt;=100,0001&lt;=Ai&lt;=N1&lt;=Bi&lt;=N0&lt;=Ci&lt;=1,0001&lt;=Li&lt;=1,000【输入样例】5110021 3 12 3 23 4 34 5 3【输出样例】15【样例解释】 刷题记录30min忘记开long long，WA了一发 分析请先思考后再展开 这道题真心水啊，给之前被DP虐惨的我找回一点点信心……首先一看就是一棵树，那除了树形DP还能是什么~然后用a表示来自父亲的费用，b表示来自儿子的费用a还要容斥一下，还好有样例……$$a_top=(size[rt]-size[x])\times L_fa$$ $$a_brother=b[fa]-b[x]-size[b]\times L_son$$ $$a[x]=a[fa]+a_top+a_brother$$ $$b[x]=\sum b[son]+size[x]\times L_son$$ 然后就是因为方向不同，所以要dfs两次复杂度O(2n)，这n比较小，主要是这出题人把边搞大了 代码请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=110000,MAXM=210000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int hou; ll a,b; ll size; int fa; nod() &#123; fa=hou=a=b=size=0; &#125;&#125;p[MAXN];struct edge&#123; int y,g; ll c;&#125;e[MAXM];int ln=0;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln;&#125;//*******************实现*******************void dfs1(int x,int fa)//自底向上&#123; p[x].fa=fa; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y==fa) continue; dfs1(y,x); p[x].size+=p[y].size; p[x].b+=p[y].b+p[y].size*e[k].c; &#125;&#125;int n;ll ans=ll(INF)*ll(INF);void dfs2(int x)//自上而下&#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y==p[x].fa) continue; ll top=(p[1].size-p[y].size)*e[k].c; ll brother=p[x].b-p[y].b-p[y].size*e[k].c; p[y].a=p[x].a+top+brother; ans=mymin(ans,p[y].a+p[y].b); dfs2(y); &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i].size); for(int i=1;i&lt;=n-1;i++) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);ins(y,x,c); &#125; dfs1(1,0); dfs2(1); ans=mymin(ans,p[1].b); printf(BIGN,ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1801】【Luogu2051】中国象棋]]></title>
    <url>%2Fposts%2Fdc53.html</url>
    <content type="text"><![CDATA[来源和评测点Ahoi2009 Day2Bzoj1801Luogu2051 题目【题目大意】在一个N行M列的棋盘上，让你放若干个炮（可以是0个），使得没有一个炮可以攻击到另一个炮，请问有多少种放置方法。中国象棋中炮的行走方式是：一个炮攻击到另一个炮，当且仅当它们在同一行或同一列中，且它们之间恰好有一个棋子。【输入格式】一行包含两个整数N，M，之间由一个空格隔开。【输出格式】总共的方案数，由于该值可能很大，只需给出方案数模9999973的结果。【限定条件】30%的数据中N和M均不超过650%的数据中N和M至少有一个数不超过8100%的数据中N和M均不超过100【输入样例】1 3【输出样例】7【样例解释】除了3个格子里都塞满了炮以外，其它方案都是可行的，所以一共有2*2*2-1=7种方案。 刷题记录1h 分析请先思考后再展开 唉我的DP真的菜，打算多做点这道题的状态表示也不是太好想： 列的顺序是无关紧要的 显然每一行、列只能放0~2个棋子那么什么是重要的呢？0~2，这个状态量好像很少，但怎么表示呢？既然顺序不重要，那重要的自然就是内容了，而且内容只有三种情况那我们可以把每一列分类：0个为一类，1个为一类，2个为一类而且这三类的总和是m 想到了这个，基本上问题就迎刃而解了考虑DP状态的转移，以行来递推，f[i][q][w]表示前i行，有q列是有1个棋子的，w列是有2个棋子的，那么当然1个棋子的有(m-q-w)个 什么也不放，状态量有1个，状态值f[i-1][j][k] 放1个在原本棋子数量为0的列，状态量有m-(j-1)-k个，状态值f[i-1][j-1][k] 放1个在原本棋子数量为1的列，状态量有j+1个，状态值f[i-1][j+1][k-1] 放2个在原本棋子数量为0的列，状态量有C(m-(j-1)-k,2)个，状态值f[i-1][j-2][k] 放2个在原本棋子数量为0、1的列，状态量有(m-j-(k-1))*j个，状态值[i-1][j][k-1] 放2个在原本棋子数量为1的列，状态量有C(j+1,2)个，状态值f[i-1][j+2][k-2]出现了组合数呀！n还算挺大的怎么办?之前就卡这里了发现都是选取2个，所以不需要用阶乘的公式了hh直接n*(n-1)/2，爽 代码请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量*******************const int MOD=9999973;//*******************全局定义*******************int f[110][110][110];//*******************实现*******************ll getf(int i,int q,int w)&#123; if(i&lt;0 or q&lt;0 or w&lt;0) return 0; return f[i][q][w];&#125;int C2(int x)&#123; return x*(x-1)&gt;&gt;1;&#125;//*******************主函数*******************int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); int ans=0;f[0][0][0]=1; for(int i=1;i&lt;=n;i++) &#123; for(int q=0;q&lt;=m;q++) &#123; for(int w=0;w+q&lt;=m;w++) &#123; f[i][q][w]=f[i-1][q][w]; f[i][q][w]=( f[i][q][w]+getf(i-1,q-1,w)*(m-(q-1)-w)%MOD )%MOD; f[i][q][w]=( f[i][q][w]+getf(i-1,q+1,w-1)*(q+1)%MOD )%MOD; f[i][q][w]=( f[i][q][w]+getf(i-1,q-2,w)*C2(m-(q-2)-w)%MOD )%MOD; f[i][q][w]=( f[i][q][w]+getf(i-1,q,w-1)*(m-q-(w-1))%MOD*q%MOD )%MOD; f[i][q][w]=( f[i][q][w]+getf(i-1,q+2,w-2)*C2(q+2)%MOD )%MOD; if(i==n) ans=(ans+getf(i,q,w))%MOD; &#125; &#125; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj1904】King's Quest]]></title>
    <url>%2Fposts%2Ffc.html</url>
    <content type="text"><![CDATA[来源和评测点Poj1904Caioj1149 题目【题目大意】给出n个男生（2000以内），在保证存在完备匹配的条件下，给出一些男生喜欢的女生的信息（20w以内），那么本着有福同享的观点，求出每个男生“应该喜欢”的女生的编号。“应该喜欢”的定义：任选其中一个来与对应男生匹配，其他的男生依然能够找到匹配对象。（可以理解为，每一个都能作为一条强制匹配的边）【输入格式】第一行一个整数n(1&lt;=n&lt;=2000).下来n行，每行第一个数ki表示第i只男生喜欢的女生数目，下来ki只女生的编号。所有ki的总和不超过 200000。【输出格式】输出每个男生可以匹配的女生的编号（从小到大输出），且其他男生和女生依然能一一匹配。【输入样例】42 1 22 1 22 2 32 3 4【输出样例】1 21 234 刷题记录30min 分析题目相当于求所有可能在完美匹配中的边 CommonAnts的解释：建（二分图的）增广路DAG 同一侧的两个点i,j，从i到j连一条有向边，当且仅当存在另一侧的点k使得ik在匹配上,kj不在 那么一条当前不在最大匹配上的边可能在最大匹配上，当且仅当它在一条以某个未匹配点为终点的路径上（这个题是完美匹配，不存在这种情况），或者对应的某条边在增广路图的环上 所以只要判这条未匹配边对应的边是不是在某个SCC里就好了 代码1（CommonAnts版）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=2100,MAXM=210000;//*******************全局定义*******************struct nod&#123; int hou; int belg,dfn,low; bool v; nod() &#123; v=dfn=hou=0; &#125;&#125;p[2*MAXN];struct edge&#123; int x,y,g; int fs; edge() &#123; fs=0; &#125;&#125;e[MAXM*3];int ln=0;void ins(int x,int y)&#123; ln++; e[ln].x=x; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************强连通*******************int n;int cnt,id;int sta[3*MAXN],top;void tarjan(int x)&#123; p[x].dfn=p[x].low=++id; sta[++top]=x;p[x].v=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y&gt;n) continue;//debug if(p[y].dfn==0) tarjan(y),p[x].low=mymin(p[x].low,p[y].low); else if(p[y].v) p[x].low=mymin(p[x].low,p[y].dfn); &#125; if(p[x].low==p[x].dfn) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].v=0;p[t].belg=cnt; if(t==x) break; &#125; &#125;&#125;//*******************匈牙利*******************int chw[MAXN],match[MAXN];int ti;bool findmatch(int x)&#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y-n; if(chw[y]&lt;ti) &#123; chw[y]=ti; if(match[y]==0 or findmatch(match[y])) &#123; match[y]=x; return 1; &#125; &#125; &#125; return 0;&#125;//*******************主函数*******************int ans[MAXN],as;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); while(t--) &#123; int y;scanf("%d",&amp;y); ins(i,n+y); &#125; &#125; memset(chw,0,sizeof(chw)); for(ti=1;ti&lt;=n;ti++) findmatch(ti); for(int i=1;i&lt;=n;i++) &#123; for(int k=p[i].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y-n; if(y&lt;=0) continue;//debug if(match[y]!=i)//失败的边 &#123; ins(match[y],i); e[k].fs=ln; &#125; &#125; &#125; cnt=0;id=0;top=0; for(int i=1;i&lt;=n;i++) if(p[i].dfn==0) tarjan(i); for(int i=1;i&lt;=n;i++) &#123; as=0; for(int k=p[i].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y-n; if(e[k].fs&gt;0)//失败的边 &#123; int xx=e[e[k].fs].x,yy=e[e[k].fs].y; if(p[xx].belg==p[yy].belg) ans[++as]=y; &#125; if(y&gt;0 and match[y]==i) ans[++as]=y;//成功的边 &#125; sort(ans+1,ans+as+1); printf("%d ",as);for(int j=1;j&lt;=as;j++) printf("%d ",ans[j]); printf("\n"); &#125;&#125; 代码2（自己版）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=2100,MAXM=210000;//*******************全局定义*******************struct nod&#123; int hou; int belg,dfn,low; bool v; nod() &#123; v=dfn=hou=0; &#125;&#125;p[2*MAXN];struct edge&#123; int x,y,g;&#125;e[MAXM];int ln=0;void ins(int x,int y)&#123; ln++; e[ln].x=x; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************强连通*******************int cnt,id;int sta[2*MAXN],top;void tarjan(int x)&#123; p[x].dfn=p[x].low=++id; sta[++top]=x;p[x].v=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y),p[x].low=mymin(p[x].low,p[y].low); else if(p[y].v) p[x].low=mymin(p[x].low,p[y].dfn); &#125; if(p[x].low==p[x].dfn) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].v=0;p[t].belg=cnt; if(t==x) break; &#125; &#125;&#125;//*******************匈牙利*******************int n;int chw[MAXN],match[MAXN];int ti;bool findmatch(int x)&#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y-n; if(chw[y]&lt;ti) &#123; chw[y]=ti; if(match[y]==0 or findmatch(match[y])) &#123; match[y]=x; return 1; &#125; &#125; &#125; return 0;&#125;//*******************主函数*******************int ans[MAXN],as;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); while(t--) &#123; int y;scanf("%d",&amp;y); ins(i,n+y); &#125; &#125; memset(chw,0,sizeof(chw)); for(ti=1;ti&lt;=n;ti++) findmatch(ti); for(int i=1;i&lt;=n;i++) ins(n+i,match[i]); cnt=0;id=0;top=0; for(int i=1;i&lt;=2*n;i++) if(p[i].dfn==0) tarjan(i); for(int i=1;i&lt;=n;i++) &#123; as=0; for(int k=p[i].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[i].belg==p[y].belg) ans[++as]=y-n; &#125; sort(ans+1,ans+as+1); printf("%d ",as);for(int j=1;j&lt;=as;j++) printf("%d ",ans[j]); printf("\n"); &#125;&#125; 更新于2018.9.10今天是教师节，然而完全不想去看初中的老师…… 说正事，这道题现在看来就是求可行边相关的介绍，请前往oi之路中的二分图一章，有对lyd的做法的注解]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>二分图</tag>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3679】数字之积]]></title>
    <url>%2Fposts%2F304d.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj3679 题目【题目大意】一个数x各个数位上的数之积记为f(x) （不含前导零）求[L,R)中满足0&lt;f(x)&lt;=n的数的个数。【输入格式】第一行一个数n第二行两个数L、R【输出格式】一个数，即满足条件的数的个数【限定条件】0&lt;L&lt;R&lt;10^18,n&lt;=10^9【输入样例】519 22【输出样例】1【样例解释】无 刷题记录30min 分析请先思考后再展开 首先，按照题解的说法以2、3、5、7这些质因数组成的，int范围内的大概只有几千个，所以可以记录下来，排个序，搞个前缀和，然后用这个乘积来递推。 然后就是经典的套路了：先不考虑前导零的问题预处理然后处理位数&lt;M的情况，然后再一位位处理位数=M的情况即可 注意这一题因为是乘积，碰到0就要退出。 代码请先思考后再展开 网上很多奇奇怪怪的代码呀反正我这次尽全力优化了时间并且清晰易懂12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量*******************//*******************全局定义*******************ll r2[40],r3[40],r5[40],r7[40],r10[40];ll f[20][10000];int cnt;int g[10000];//*******************实现*******************int num[20],ln;ll dp(ll x,int n)&#123; ll xx=x;ln=0; while(xx&gt;0) num[++ln]=int(xx%10),xx/=10; ll ans=0,pst=1; for(int i=ln;i&gt;=1;i--) for(int k=1;k&lt;=cnt;k++) ans+=f[i][k];//位数&lt;ln for(int i=ln;i&gt;=1;i--) &#123; int now=num[i]; for(int k=1;k&lt;=cnt;k++) for(int j=1;j&lt;now;j++) if(pst*ll(j)*ll(g[k])&lt;=ll(n)) ans+=f[i][k];//位数=ln pst*=ll(now); if(!pst or pst&gt;ll(n)) return ans;//无贡献 &#125; return ans+(pst&lt;=ll(n));//最后这个是无法统计的x自己&#125;//*******************主函数*******************int main()&#123; memset(f,0,sizeof(f)); r2[0]=r3[0]=r5[0]=r7[0]=r10[0]=1;//debug for(int i=1;i&lt;=35;i++) r2[i]=r2[i-1]*2; for(int i=1;i&lt;=25;i++) r3[i]=r3[i-1]*3; for(int i=1;i&lt;=18;i++) r5[i]=r5[i-1]*5; for(int i=1;i&lt;=15;i++) r7[i]=r7[i-1]*7; for(int i=1;i&lt;=19;i++) r10[i]=r10[i-1]*10; int n;ll a,b;scanf("%d%lld%lld",&amp;n,&amp;a,&amp;b); cnt=0; for(int i=0;i&lt;=35;i++) for(int j=0;j&lt;=25;j++) for(int x=0;x&lt;=18;x++) for(int y=0;y&lt;=15;y++) &#123; ll k=r2[i]*r3[j]*r5[x]*r7[y]; if(0&lt;k and k&lt;=ll(n)) g[++cnt]=k; else break;//剪枝 &#125; sort(g+1,g+1+cnt);//有序性 f[1][1]=1; for(int i=1;i&lt;=19;i++) &#123; for(int k=1;k&lt;=cnt;k++) &#123; if(f[i-1][k]==0) continue;//剪枝 for(int j=1;j&lt;=9;j++) &#123; ll ss=ll(g[k])*ll(j);if(ss&gt;ll(n)) break;//剪枝 int pos=lower_bound(g+1,g+1+cnt,int(ss))-g;//其实只是懒得打二分查找 f[i][pos]+=f[i-1][k]; &#125; &#125; &#125; //[a,b) //[a,b-1] printf("%lld",dp(b-1,n)-dp(a-1,n));&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数位DP</tag>
        <tag>难度2</tag>
        <tag>精品题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1833】【Luogu2602】数字计数]]></title>
    <url>%2Fposts%2F9f3.html</url>
    <content type="text"><![CDATA[来源和评测点ZJOI2010 Day1Bzoj1833Luogu2602 题目【题目大意】给定两个正整数a和b，求在[a,b]中的所有整数中，每个数码(digit)各出现了多少次。【输入格式】输入文件中仅包含一行两个整数a、b，含义如上所述。【输出格式】输出文件中包含一行10个整数，分别表示0-9在[a,b]中出现了多少次。【限定条件】30%的数据中，a&lt;=b&lt;=10^6；100%的数据中，a&lt;=b&lt;=10^12。【输入样例】1 99【输出样例】9 20 20 20 20 20 20 20 20 20【样例解释】无 刷题记录1h 分析请先思考后再展开 暴力好像30吧虽然数位DP的特征还是很明显的感觉这题还是挺难的，特别不好想当然核心思想依然是忽略前导零来预处理dp，最后分类讨论得出结果。f[i]表示0~10^{i-1}的出现次数（不忽略前导零，所以都一样） 好像计算“包含i”的数字量会更难？总而言之，这道题理解容易，写出来难，很多细节所以最好看完题解，打完一次后全部删掉再打一次哦 代码请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量*******************//*******************全局定义*******************ll oct[15];ll f[15];ll ans[10];//*******************实现*******************int num[15],ln;void dp(ll x,int fg)&#123; ll ret=x;ln=0; while(x&gt;0) num[++ln]=x%10,x/=10; //总位数&lt;m for(int i=1;i&lt;=ln-1;i++)//总位数 for(int j=0;j&lt;=9;j++)//首位 ans[j]+=(f[i-1]*9+(j&gt;0)*oct[i-1])*fg; //0特殊处理，因为不能放在首位 //总位数=m，逐个解决 for(int i=ln;i&gt;=1;i--) &#123; ret-=num[i]*oct[i-1]; //当前最高位不是上限，自己的数量 for(int j=(i==ln);j&lt;=num[i]-1;j++) ans[j]+=oct[i-1]*fg;//仅在首位 //当前最高位不是上限，后面的数量 for(int j=0;j&lt;=9;j++) ans[j]+=( (num[i]-(i==ln))*f[i-1] )*fg;//0(1)~num[i]-1 //当前最高位是上限，即剩余部分 ans[num[i]]+=(ret+1)*fg;//0~ret &#125;&#125;//*******************主函数*******************int main()&#123; memset(f,0,sizeof(f)); oct[0]=1; for(int i=1;i&lt;=13;i++) &#123; f[i]=oct[i-1]+f[i-1]*10;//首位+非首位 oct[i]=oct[i-1]*10; &#125; ll a,b;scanf("%lld%lld",&amp;a,&amp;b); dp(b,1);dp(a-1,-1); for(int i=0;i&lt;=9;i++) printf("%lld ",ans[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数位DP</tag>
        <tag>难度2</tag>
        <tag>精品题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1026】【Luogu2657】windy数]]></title>
    <url>%2Fposts%2F4670.html</url>
    <content type="text"><![CDATA[来源和评测点SCOI2009 Day1Bzoj1026Luogu2657 题目【题目大意】windy定义了一种windy数。不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。windy想知道，在A和B之间，包括A和B，总共有多少个windy数？【输入格式】包含两个整数，A B。【输出格式】一个整数【限定条件】1&lt;=A&lt;=B&lt;=2000000000【输入样例】25 50【输出样例】20【样例解释】无 刷题记录20min1AC 分析数位DP入门题分类讨论即可 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************//*******************全局定义*******************int c[11],ln;int f[11][10];//*******************实现*******************int dp()&#123; int ans=0; for(int i=1;i&lt;=ln-1;i++)//首位0 for(int j=1;j&lt;=9;j++)//非首位 ans+=f[i][j]; for(int i=1;i&lt;=c[ln]-1;i++) ans+=f[ln][i];//首位1 for(int i=ln-1;i&gt;=1;i--)//首位2的次位 &#123; for(int j=0;j&lt;=c[i]-1;j++) &#123; if(myabs(c[i+1]-j)&gt;=2) ans+=f[i][j]; &#125; if(myabs(c[i+1]-c[i])&lt;2) break;//剪枝，后面都是0 if(i==1) ans++;//b &#125; return ans;&#125;int solve(int x)&#123; ln=0; while(x&gt;0) &#123; c[++ln]=x%10; x/=10; &#125; return dp();&#125;//*******************主函数*******************int main()&#123; memset(f,0,sizeof(f)); int a,b;scanf("%d%d",&amp;a,&amp;b); for(int i=0;i&lt;=9;i++) f[1][i]=1; for(int i=2;i&lt;=10;i++) for(int x=0;x&lt;=9;x++) for(int y=0;y&lt;=9;y++) if(myabs(x-y)&gt;=2) f[i][x]+=f[i-1][y]; printf("%d",solve(b)-solve(a-1));&#125; UP 2018.8.28:写了个记忆化搜索的版本好写好理解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=30; const int INF=0x3f3f3f3f; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int f[15][10]; bool v[15][10]; int num[15]; int calc(int ln,int lst,bool prezero,bool mask) &#123; if(ln==0) return 1; if(!mask and !prezero and v[ln][lst]) return f[ln][lst]; int tot=0,mx=mask?num[ln]:9; for(int now=0;now&lt;=mx;now++) if(prezero or myabs(lst-now)&gt;=2) tot+=calc(ln-1,now,prezero and now==0,mask and now==mx); if(!mask and !prezero) v[ln][lst]=1,f[ln][lst]=tot; return tot; &#125; int solve(int x) &#123; int n=0;while(x&gt;0) num[++n]=x%10,x/=10; return calc(n,0,1,1); &#125; void main() &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); printf("%d",solve(b)-solve(a-1)); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数位DP</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1087】【Luogu1896】互不侵犯]]></title>
    <url>%2Fposts%2Ff44c.html</url>
    <content type="text"><![CDATA[来源和评测点SCOI2005Bzoj1087Luogu1896 题目【题目大意】在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。【输入格式】只有一行，包含两个数N，K【输出格式】方案数【限定条件】1&lt;=N&lt;=9,0&lt;=K&lt;=N*N【输入样例】3 2【输出样例】16【样例解释】无 刷题记录1h记得开long long 分析状态DP，虽然看起来打表也可以拿不少分？压缩每一行的状态，合法性：(s&amp;(s&gt;&gt;1))==0行转移合法性：(s1&amp;(s2&gt;&gt;1))==0 and (s1&amp;(s2&lt;&lt;1))==0 and (s1&amp;s2)==0 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量*******************//*******************全局定义*******************ll f[10][1000][100];//debugint state[1000],stc[1000];//*******************实现*******************int calc(int s)&#123; int t=0; while(s&gt;0) &#123; if( (s&amp;1)==1 ) t++; s=s&gt;&gt;1; &#125; return t;&#125;//*******************主函数*******************int main()&#123; int n,k;scanf("%d%d",&amp;n,&amp;k); int st=0; for(int i=0;i&lt;=(1&lt;&lt;n)-1;i++) if( (i&amp;(i&lt;&lt;1))==0 ) &#123; state[++st]=i; stc[st]=calc(i); f[1][i][stc[st]]=1; &#125; for(int i=2;i&lt;=n;i++)//行数 for(int j1=1;j1&lt;=st;j1++)//前状态 for(int j2=1;j2&lt;=st;j2++)//后状态 &#123; int s1=state[j1],s2=state[j2]; if( (s2&amp;s1)==0 and (s2&amp;(s1&lt;&lt;1))==0 and (s2&amp;(s1&gt;&gt;1))==0 )//转移合法性 &#123; int k1=stc[j1],k2=stc[j2]; for(int b=k1;b+k2&lt;=k;b++)//前棋子总数 f[i][s2][b+k2]+=f[i-1][s1][b]; &#125; &#125; ll ans=0; for(int i=1;i&lt;=st;i++) ans+=f[n][state[i]][k]; printf(BIGN,ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度2</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1911】【Luogu3628】特别行动队]]></title>
    <url>%2Fposts%2F8530.html</url>
    <content type="text"><![CDATA[来源和评测点APIO2010Bzoj1911Luogu3628 题目【题目大意】【输入格式】【输出格式】【限定条件】【输入样例】4-1 10 -202 2 3 4【输出样例】9【样例解释】无 刷题记录1h1AC 分析不等式一定要注意负数的时候要变号！ 1.化简DP公式f[i]=f[j]+a×sqr(sum[i]-sum[j])+b×(sum[i]-sum[j])+c 2.证明决策单调性假设j1&lt;j2&lt;i已知对于i，j2优于j1，本题追求大，所以f[j1]+a×sqr(sum[i]-sum[j1])+b×(sum[i]-sum[j1])&lt;=f[j2]+a×sqr(sum[i]-sum[j2])+b×(sum[i]-sum[j2])——-①现在要证明对于t(t&gt;i)，j2同样优于j1即证明f[j1]+a×sqr(sum[t]-sum[j1])+b×(sum[t]-sum[j1])&lt;=f[j2]+a×sqr(sum[t]-sum[j2])+b×(sum[t]-sum[j2])——-① 为了从①证明②，两式取差（注意a&lt;0）即 sqr(sum[t]-sum[j1])-sqr(sum[i]-sum[j1])&gt;=sqr(sum[t]-sum[j2])-sqr(sum[i]-sum[j2])即 -2×sum[t]×sum[j1]-2×sum[i]×sum[j1]&gt;=-2×sum[t]×sum[j1]-2×sum[i]×sum[j1]即 (sum[i]+sum[t])×sum[j1]&lt;=(sum[i]+sum[t])×sum[j2]即 sum[j1]&lt;=sum[j2]这是显而易见的，故②得证 所以这次如果选了j2，j1将没有任何用处，可淘汰 3.确定比较状态优劣的斜率方程只能用于相邻的状态比较斜率=(y1-y2)/(x1-x2) f[j1]-2a×sum[i]×sum[j1]+a×sqr(sum[j1])-b×sum[j1]&lt;=f[j2]-2a×sum[i]×sum[j2]+a×sqr(sum[j2])-b×sum[j2]f[j1]-f[j2]+a×sqr(sum[j1])-b×sum[j1]-a×sqr(sum[j2])+b×sum[j2]&lt;=2×a×sum[i]×(sum[j1]-sum[j2])(f[j1]-f[j2])+a×sqr(sum[j1])-a×sqr(sum[j2])-b×sum[j1]+b×sum[j2]&lt;=2×a×sum[i]×(sum[j1]-sum[j2])((f[j1]-f[j2])+a×sqr(sum[j1])-a×sqr(sum[j2])-b×sum[j1]+b×sum[j2]) / (sum[j1]-sum[j2]) &gt;= 2×a×sum[i]满足则j2更优 那么把状态变成点( sum[j],f[j]+a×sqr(sum[j])-b×sum[j] ) 4.单调队列维护满足: 相邻斜率不递减故形状为一个向下的凸壳（形如丿字） 一、去头（两者比较）将2×a×sum[i]理解为i给出的标杆，假如“头与头后一个斜率”小于标杆，意味着后一个更优秀，将头剔除 二、继承从当前最优秀的头继承 三、铺垫与维护（三者比较）将当前状态放入队列，并两两比较删除无用状态，保证相邻斜率不递减删除正确性证明：对于a和b的斜率x&lt;=b和c的斜率y被删除的末尾，在（末尾前一个，末尾，当前状态）中必定不是最优状态，因为斜率必定不如他们哪怕是这种极端情况： ○ ○○斜率越大，则越靠近标杆，也就意味着后面这个越优秀（虽然在小于标杆的时候依然是前面的优秀，但我这里的意思是同样的前者下，后者1会比后者2更优秀）斜率为0意味着同样优秀，那么当然是后面的更好了总而言之，斜率越小越优秀 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;double mysqr(double x) &#123;return x*x;&#125;//*******************全局常量*******************const int MAXN=1000010;const int INF=0x3f3f3f3f;const double eps=1e-7;//*******************全局定义*******************int n;double a,b,c;double sum[MAXN];double f[MAXN];//*******************实现*******************double X(int x)&#123; return 2.0*a*sum[x];&#125;double Y(int x)&#123; return f[x]+a*mysqr(sum[x])-b*sum[x];&#125;double slop(int x,int y)&#123; return ( Y(x)-Y(y) )/( X(x)-X(y) );&#125;int g[MAXN];void solve()&#123; int tou=1,wei=1; for(int i=1;i&lt;=n;i++) &#123; while(tou&lt;wei and slop(g[tou],g[tou+1])&lt;=sum[i]) tou++; int j=g[tou]; f[i]=f[j]+a*mysqr(sum[i]-sum[j])+b*(sum[i]-sum[j])+c; while(tou&lt;wei and slop(g[wei-1],g[wei])&gt;slop(g[wei],i)) wei--; g[++wei]=i; &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%d%lf%lf%lf",&amp;n,&amp;a,&amp;b,&amp;c); for(int i=1;i&lt;=n;i++) &#123; double t;scanf("%lf",&amp;t); sum[i]=sum[i-1]+t; &#125; solve(); printf("%.0lf",f[n]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>斜率优化</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1835】【Luogu2605】基站选址]]></title>
    <url>%2Fposts%2Fedb5.html</url>
    <content type="text"><![CDATA[来源和评测点ZJOI2010 Day1Bzoj1835Luogu2605 题目【题目大意】有N个村庄坐落在一条直线上，第i(i&gt;1)个村庄距离第1个村庄的距离为Di。需要在这些村庄中建立不超过K个通讯基站，在第i个村庄建立基站的费用为Ci。如果在距离第i个村庄不超过Si的范围内建立了一个通讯基站，那么就村庄被基站覆盖了。如果第i个村庄没有被覆盖，则需要向他们补偿，费用为Wi。现在的问题是，选择基站的位置，使得总费用最小。【输入格式】第一行包含两个整数N,K，含义如上所述。第二行包含N-1个整数，分别表示D2,D3,…,DN ，这N-1个数是递增的。第三行包含N个整数，表示C1,C2,…CN。第四行包含N个整数，表示S1,S2,…,SN。第五行包含N个整数，表示W1,W2,…,WN。【限定条件】40%的数据中，N&lt;=500；100%的数据中，K&lt;=N，K&lt;=100，N&lt;=20000，Wi&lt;=10000，Ci&lt;=10000Di&lt;=1000000000，Si&lt;=1000000000【输出格式】仅一个整数，表示最小的总费用。【输入样例】3 21 22 3 21 1 010 20 30【输出样例】4【样例解释】无 刷题记录2h1AC 分析不得不说，这道题的思路灰常神 F[m][i]表示已经放置了m个基站，第m个基站放置在第i个村庄第i个村庄及之前的村庄的总最少花费(包括建立基站的花费和赔偿的花费),转移的时候,F[m][i]=min(F[m-1][j]+cost(j,i))+c[i]cost(j,i)表示在点j和点i各建立一个基站，j和i之间不建立基站时，j和i之间需要的总赔偿。 省空间首选vector，用于存储每个点被哪些点依赖，用于更新外层枚举m，然后每次循环才重构，避免后效性 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=21000;const int INF=0x3f3f3f3f;//*******************全局定义*******************int d[MAXN],c[MAXN],s[MAXN],w[MAXN];int st[MAXN],ed[MAXN];int f[MAXN];vector&lt;int&gt; fd[MAXN];//快速查找，省空间首选//*******************线段树*******************struct nod&#123; int l,r; int lc,rc; int mi,lz;&#125;m[2*MAXN];int cnt;int build(int l,int r)&#123; int t=++cnt; m[t].l=l;m[t].r=r;m[t].lz=0; if(l==r) m[t].mi=f[l];//初始cost=0 else &#123; int mid=(l+r)&gt;&gt;1; m[t].lc=build(l,mid); m[t].rc=build(mid+1,r); m[t].mi=mymin(m[m[t].lc].mi,m[m[t].rc].mi); &#125; return t;&#125;void update(int x)&#123; if(m[x].lz==0) return; int lc=m[x].lc,rc=m[x].rc; m[lc].mi+=m[x].lz;m[lc].lz+=m[x].lz; m[rc].mi+=m[x].lz;m[rc].lz+=m[x].lz; m[x].lz=0;&#125;void change(int x,int l,int r,int c)&#123; if(l&gt;r) return;//debug if(m[x].l==l and m[x].r==r) &#123; m[x].mi+=c; m[x].lz+=c; return; &#125; update(x); int mid=(m[x].l+m[x].r)/2,lc=m[x].lc,rc=m[x].rc; if(r&lt;=mid) change(lc,l,r,c); else if(l&gt;mid) change(rc,l,r,c); else change(lc,l,mid,c),change(rc,mid+1,r,c); m[x].mi=mymin(m[m[x].lc].mi,m[m[x].rc].mi);//debug&#125;int ask(int x,int l,int r)&#123; if(l&gt;r) return 0;//debug if(m[x].l==l and m[x].r==r) return m[x].mi; update(x); int mid=(m[x].l+m[x].r)/2,lc=m[x].lc,rc=m[x].rc; if(r&lt;=mid) return ask(lc,l,r); if(l&gt;mid) return ask(rc,l,r); return mymin(ask(lc,l,mid),ask(rc,mid+1,r)); &#125;//*******************实现*******************int n,k;void dp()&#123; int tmp=0; for(int i=1;i&lt;=n;i++)//prepare &#123; f[i]=tmp+c[i]; for(int j=0;j&lt;fd[i].size();j++) tmp+=w[fd[i][j]]; //现在刚刚好，那么以后就成了负担 &#125; int ans=f[n]; for(int i=2;i&lt;=k;i++) &#123; cnt=0;build(1,n); for(int i=1;i&lt;=n;i++) &#123; f[i]=ask(1,1,i-1)+c[i];//最优继承 for(int k=0;k&lt;fd[i].size();k++) &#123; int x=fd[i][k]; change(1,1,st[x]-1,w[x]); //现在刚刚好，那么以后就成了负担 &#125; &#125; ans=mymin(ans,f[n]); &#125; printf("%d",ans);&#125;//*******************主函数*******************int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=2;i&lt;=n;i++) scanf("%d",&amp;d[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;c[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;s[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]); n++;k++;//此点必选，用于统计答案 d[n]=INF;w[n]=INF;c[n]=0; for(int i=1;i&lt;=n;i++) &#123; int l=lower_bound(d+1,d+1+n,d[i]-s[i])-d; int r=lower_bound(d+1,d+1+n,d[i]+s[i])-d; if(d[r]&gt;d[i]+s[i]) r--; st[i]=l;ed[i]=r; fd[ed[i]].push_back(i); &#125; dp();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>DP</tag>
        <tag>精品题</tag>
        <tag>难度3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1597】【Luogu1010】土地购买]]></title>
    <url>%2Fposts%2Fc717.html</url>
    <content type="text"><![CDATA[来源和评测点Usaco2008 Mar GoldBzoj1597LuogucCaioj1140 题目【题目大意】有N块长方形的土地，每块土地的价格是它的面积，但FJ可以同时购买多块土地。这些土地的价格是它们最大的长乘以它们最大的宽, 但是土地的长宽不能交换。如果FJ买一块3×5的地和一块5×3的地，则他需要付5×5=25。FJ希望买下所有的土地，但是他发现分组来买这些土地可以节省经费。他需要你帮助他找到最小的经费。【输入格式】第1行一个整数N。下来N行。第i+1行包含两个数，分别为第i块土地的长和宽。【限定条件】(1 &lt;= N &lt;= 50,000每块土地的长宽满足1&lt;=宽&lt;=1,000,000;1&lt;=长&lt;=1,000,000)【输出格式】求最小的可行费用。【输入样例】4100 115 1520 51 100【输出样例】500【样例解释】FJ分3组买这些土地:第一组:100×1,第二组1×100,第三组20×5 和 15×15。每组的价格分别为100,100,300, 总共500 刷题记录30min 分析灰常妙的一点：使用排序进行除杂（被完全覆盖的土地可以被忽略）神奇的一幕出现了，可以实现长递增，宽递减（主要是题目特性）于是就可以瞬间获得区间打包的费用！ 想通这个以后接下来就甚至比上一题还简单了部分省略 1.化简DP公式a[i]=长 b[i]=宽f[i]=min(f[j]+a[i]*b[j+1]) 2.证明决策单调性假设j1&lt;j2&lt;i已知对于i，j2优于j1，本题追求小，所以假设f[j2]+a[i]*b[j2+1]&lt;=f[j1]+a[i]*b[j1+1]——————-①是否f[j2]+a[t]*b[j2+1]&lt;=f[j1]+a[t]*b[j1+1]——————-②为了从①证明②，两式取差得证所以这次如果选了j2，j1将没有任何用处，可淘汰 3.确定比较状态优劣的斜率方程只能用于相邻的状态比较斜率=(y1-y2)/(x1-x2) f[j2]+a[i]*b[j2+1]&lt;=f[j1]+a[i]*b[j1+1](f[j2]-f[j1])/(b[j1+1]-b[j2+1])&lt;=a[i]满足则j2更优 那么把状态变成点( b[j],f[j] ) 4.单调队列维护满足: 相邻斜率不递减故形状为一个向下的凸壳（形如丿字） 一、去头（两者比较）将a[]理解为i给出的标杆，假如“头与头后一个斜率”小于标杆，意味着后一个更优秀，将头剔除 二、继承从当前最优秀的头继承 三、铺垫与维护（三者比较）将当前状态放入队列，并两两比较删除无用状态，保证相邻斜率不递减删除正确性证明：对于a和b的斜率x&lt;=b和c的斜率y被删除的末尾，在（末尾前一个，末尾，当前状态）中必定不是最优状态，因为斜率必定不如他们哪怕是这种极端情况： ○ ○○斜率越大，则越靠近标杆，也就意味着后面这个越优秀（虽然在小于标杆的时候依然是前面的优秀，但我这里的意思是同样的前者下，后者1会比后者2更优秀）斜率为0意味着同样优秀，那么当然是后面的更好了总而言之，斜率越小越优秀 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量*******************const int MAXN=51000;//*******************全局定义*******************struct nod&#123; double a,b;&#125;p[MAXN];bool cmp(nod a,nod b)&#123; return (a.a&lt;b.a) or (a.a==b.a and a.b&lt;b.b);&#125;double f[MAXN];//*******************实现*******************double X(int x)&#123; return p[x].b;&#125;double Y(int x)&#123; return f[x];&#125;double slop(int x,int y)&#123; return ( Y(y)-Y(x) )/( X(x+1)-X(y+1) );&#125;int tp;int g[MAXN];void solve()&#123; int tou=1,wei=1; for(int i=1;i&lt;=tp;i++) &#123; while(tou&lt;wei and slop(g[tou+1],g[tou])&lt;=p[i].a) tou++; int j=g[tou]; f[i]=f[j]+p[i].a*p[j+1].b; while(tou&lt;wei and slop(g[wei-1],g[wei])&gt;=slop(g[wei],i)) wei--; g[++wei]=i; &#125;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lf%lf",&amp;p[i].a,&amp;p[i].b); sort(p+1,p+1+n,cmp); tp=1; for(int i=2;i&lt;=n;i++) &#123; while(tp&gt;0 and p[tp].b&lt;=p[i].b) tp--; p[++tp]=p[i]; &#125; solve(); printf("%.0lf",f[tp]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>单调队列</tag>
        <tag>斜率优化</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1010】【Luogu3195】玩具装箱]]></title>
    <url>%2Fposts%2Fdae0.html</url>
    <content type="text"><![CDATA[来源和评测点HNOI2008Bzoj1010Luogu3195Caioj1138 题目【题目大意】P教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。P教授有编号为1…N的N件玩具，第i件玩具经过压缩后变成一维长度为Ci。为了方便整理，P教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第i件玩具到第j个玩具放到一个容器中，那么容器的长度将为 x=j-i+Sigma(Ck) i&lt;=K&lt;=j制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为x,其制作费用为(X-L)^2.其中L是一个常量。P教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过L。但他希望费用最小.【输入格式】第一行输入两个整数N，L.接下来N行输入Ci.【限定条件】1&lt;=N&lt;=50000,1&lt;=L,Ci&lt;=10^7【输出格式】输出最小费用【输入样例】5 434214【输出样例】1【样例解释】无 刷题记录1h 分析1.化简DP公式sum[i]=sum[i-1]+c[i]f[i]=选择物品i后1~i最小花费f[i]=f[j]+sqr(sum[i]-sum[j]+i-(j+1)-l)f[i]=f[j]+sqr(sum[i]+i-sum[j]-j-1-l)设s[i]=sum[i]+i,L=l+1f[i]=f[j]+sqr(s[i]-s[j]-L) 2.证明决策单调性假设j1&lt;j2&lt;i已知对于i，j2优于j1，本题追求小，所以f[j2]+sqr(s[i]-s[j2]-L)&lt;f[j1]+sqr(s[i]-s[j1]-L)——————-①现在要证明对于t(t&gt;i)，j2同样优于j1，易得s[t]=s[i]+v即证明f[j2]+sqr(s[i]-s[j2]-L+v)&lt;f[j1]+sqr(s[i]-s[j1]-L+v)———② 为了从①证明②，两式取差证明 2*(s[i]-s[j2]-L)*v+v*v&lt;=2*(s[i]-s[j1]-L)*v+v*v 即可即 -2*s[j2]*v&lt;=-2*s[j1]*v即 s[j2]&gt;=s[j1]这是显而易见的，故②得证 所以这次如果选了j2，j1将没有任何用处，可淘汰 3.确定比较状态优劣的斜率方程只能用于相邻的状态比较斜率=(y1-y2)/(x1-x2) f[j2]+sqr(s[i]-s[j2]-L)&lt;f[j1]+sqr(s[i]-s[j1]-L)[ (f[j2]+s[j2]*s[j2])-(f[j1]+s[j1]*s[j1]) ]/[ s[j2]-s[j1] ] &lt; 2*(s[i]-L)满足则j2更优 那么把状态变成点( s[j],f[j]+sqr(s[j]) ) 4.单调队列维护满足: 相邻斜率不递减故形状为一个向下的凸壳（形如丿字） 一、去头（两者比较）将2*(s[i]-L)理解为i给出的标杆，假如“头与头后一个斜率”小于标杆，意味着后一个更优秀，将头剔除 二、继承从当前最优秀的头继承 三、铺垫与维护（三者比较）将当前状态放入队列，并两两比较删除无用状态，保证相邻斜率不递减删除正确性证明：对于a和b的斜率x&lt;=b和c的斜率y被删除的末尾，在（末尾前一个，末尾，当前状态）中必定不是最优状态，因为斜率必定不如他们哪怕是这种极端情况： ○ ○○斜率越大，则越靠近标杆，也就意味着后面这个越优秀（虽然在小于标杆的时候依然是前面的优秀，但我这里的意思是同样的前者下，后者1会比后者2更优秀）斜率为0意味着同样优秀，那么当然是后面的更好了总而言之，斜率越小越优秀 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;ll mysqr(ll x) &#123;return x*x;&#125;//*******************全局常量*******************const int MAXN=51000;//*******************全局定义*******************int n;double L;double sum[MAXN],s[MAXN];double f[MAXN];//*******************实现*******************double X(int x)&#123; return s[x];&#125;double Y(int x)&#123; return f[x]+mysqr(s[x]);&#125;double slop(int x,int y)&#123; return ( Y(x)-Y(y) )/( X(x)-X(y) );&#125;int g[MAXN];void solve()&#123; int tou=1,wei=1;g[1]=0;f[0]=0; for(int i=1;i&lt;=n;i++) &#123; while(tou&lt;wei and slop(g[tou],g[tou+1])&lt;=2*(s[i]-L)) tou++; int j=g[tou];f[i]=f[j]+mysqr(s[i]-s[j]-L); while(tou&lt;wei and slop(g[wei-1],g[wei])&gt;slop(g[wei],i)) wei--; g[++wei]=i; &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%d%lf",&amp;n,&amp;L);L+=1.0; for(int i=1;i&lt;=n;i++) &#123; double t;scanf("%lf",&amp;t); sum[i]=sum[i-1]+t; s[i]=sum[i]+i; &#125; solve(); printf("%.0lf",f[n]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>单调队列</tag>
        <tag>斜率优化</tag>
        <tag>难度2</tag>
        <tag>精品题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj2823】Sliding Window]]></title>
    <url>%2Fposts%2Fe1c7.html</url>
    <content type="text"><![CDATA[来源和评测点POJ Monthly–2006.04.28, IkkiPoj2823Caioj1172 题目【题目大意】给定一个n个数的数列，从左至右输出每个长度为m的数列段内的最大数何最小数。【输入格式】第一行两个整数n和m，下来给出n个整数。【限定条件】1&lt;=n&lt;=200000,m&lt;=n【输出格式】第一行表示每连续m个数的最大值。第二行表示每连续m个数的最小值。【输入样例】8 31 3 -1 -3 5 3 6 7【输出样例】-1 -3 -3 -3 3 33 3 5 5 6 7【样例解释】无 刷题记录30min5WA1AC 分析裸题 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll; //*******************全局常量*******************const int MAXN=1100000;//*******************全局定义*******************int n,k;int a[MAXN];struct nod&#123; int s,p;&#125;g1[MAXN],g2[MAXN];//*******************实现*******************int f1[MAXN],f2[MAXN];void dp()&#123; int tou1=1,wei1=0; int tou2=1,wei2=0; for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); while(tou1&lt;=wei1 and g1[wei1].s&gt;=t) wei1--; while(tou2&lt;=wei2 and g2[wei2].s&lt;=t) wei2--; g1[++wei1].s=t;g1[wei1].p=i; g2[++wei2].s=t;g2[wei2].p=i; while(tou1&lt;=wei1 and g1[tou1].p+k-1&lt;i) tou1++; while(tou2&lt;=wei2 and g2[tou2].p+k-1&lt;i) tou2++; if(i&gt;=k) &#123; f1[i]=g1[tou1].s; f2[i]=g2[tou2].s; &#125; &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%d%d",&amp;n,&amp;k); dp(); for(int i=k;i&lt;=n;i++) printf("%d ",f1[i]);printf("\n"); for(int i=k;i&lt;=n;i++) printf("%d ",f2[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1079】【Luogu2476】着色方案]]></title>
    <url>%2Fposts%2F968.html</url>
    <content type="text"><![CDATA[来源和评测点SCOI2008 Day2Bzoj1079Luogu2476 题目【题目大意】有n个木块排成一行，从左到右依次编号为1~n。你有k种颜色的油漆，其中第i种颜色的油漆足够涂ci个木块。所有油漆刚好足够涂满所有木块，即c1+c2+…+ck=n。相邻两个木块涂相同色显得很难看，所以你希望统计任意两个相邻木块颜色不同的着色方案。【输入格式】第一行为一个正整数k，第二行包含k个整数c1, c2, … , ck。【限定条件】50%的数据满足：1&lt;=k&lt;=5,1&lt;=ci&lt;=3100%的数据满足：1&lt;=k&lt;=15,1&lt;=ci&lt;=5【输出格式】输出一个整数，即方案总数模1,000,000,007的结果。【输入样例】101 1 2 2 3 3 4 4 5 5【输出样例】85937576【样例解释】无 刷题记录2h 分析1不愧是十年前的题目，连暴力分都给50 代码11234567891011121314151617181920212223242526272829303132333435363738394041//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MOD=1000000007;//*******************全局定义*******************int a[76];int n,k;int c[20];//*******************实现*******************int ans=0;void dfs(int x)&#123; if(x&gt;n) &#123; ans=(ans+1)%MOD; return; &#125; for(int i=1;i&lt;=k;i++) &#123; if(a[x-1]==i or c[i]&lt;=0) continue; a[x]=i; c[i]--; dfs(x+1); c[i]++; &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%d",&amp;k); for(int i=1;i&lt;=k;i++) scanf("%d",&amp;c[i]),n+=c[i]; dfs(1); printf("%d",ans);&#125; 分析2不得不说这道题灰常好想设i是现在的颜色，从j颜色而来$$F[x][i]=\sum_{j=1}^{k} F[x-1][j] (i!=j)$$那么通常而言，上面的这个约束条件要转化为一个操作矩阵然后把F[x]变成一个矩阵，m[i][1]表示用颜色i的方案数那么$$ANS=\sum_{i=1}^{k} F[n].m[i][1]$$是不是找到窍门了？ 老规矩，F[].m[i][1]=A[][]*F[].m[j][1]所以A[i][j]，也就是说当j可以到i的时候，A[i][j]=1 那么A^t表示跳转了t次，长度为t+1，最后变成颜色j的方案量 我说的有没有道理？ 有个屁！第i种颜色的油漆足够涂ci个木块？？？？？我真的是做矩阵做疯了，居然还自以为找到了感觉……这种限制显然是矩阵乘法无法解决的事实证明省选题不能小瞧啊，连续两次了 重新写DP方程f[a][b][c][d][e][f][g][h][i][j][k][l][m][n][o]这是一个5^15的DP，显然是不可行的，空间、代码复杂度都过大那么观察题目的特性：既然只要求方案数，那么在不考虑“不相邻”的条件下，对于剩余t次的两种颜色其实是等效的，于是就从5^15变成了15^5：f[a][b][c][d][e]接下来考虑特殊条件其实也很简单：多开一维，记录这一段的前一个是什么类型的颜色当前一个是b，那么现在它变成了a，用a的时候-1即可然后可以理解为从前往后确定 代码21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll; //*******************全局常量*******************const int MOD=1000000007;//*******************全局定义*******************ll f[6][16][16][16][16][16];bool bk[6][16][16][16][16][16];//*******************实现*******************ll dp(int first,int a,int b,int c,int d,int e)&#123; if(bk[first][a][b][c][d][e]) return f[first][a][b][c][d][e]; if(a+b+c+d+e==0) return 1; ll t=0; if(a&gt;0) t+=(a-(first==2))*dp(1,a-1,b,c,d,e)%MOD; if(b&gt;0) t+=(b-(first==3))*dp(2,a+1,b-1,c,d,e)%MOD; if(c&gt;0) t+=(c-(first==4))*dp(3,a,b+1,c-1,d,e)%MOD; if(d&gt;0) t+=(d-(first==5))*dp(4,a,b,c+1,d-1,e)%MOD; if(e&gt;0) t+=e*dp(5,a,b,c,d+1,e-1)%MOD; bk[first][a][b][c][d][e]=1; return f[first][a][b][c][d][e]=t%MOD;&#125;//*******************主函数*******************int s[6];int main()&#123; memset(bk,0,sizeof(bk)); int k;scanf("%d",&amp;k); for(int i=1;i&lt;=k;i++) &#123; int t; scanf("%d",&amp;t); s[t]++; &#125; printf(BIGN,dp(0,s[1],s[2],s[3],s[4],s[5]));&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度2</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1875】【Luogu2151】HH去散步]]></title>
    <url>%2Fposts%2F3469.html</url>
    <content type="text"><![CDATA[来源和评测点SDOI2009 Day1Bzoj1875Luogu2151 题目【题目大意】HH有个一成不变的习惯，喜欢饭后百步走。所谓百步走，就是散步，就是在一定的时间内，走过一定的距离。但是同时HH又是个喜欢变化的人，所以他不会立刻沿着刚刚走来的路走回。 又因为HH是个喜欢变化的人，所以他每天走过的路径都不完全一样，他想知道他究竟有多少种散步的方法。现在给你学校的地图（假设每条路的长度都是一样的都是1），问长度为t，从给定地点A走到给定地点B共有多少条符合条件的路径【输入格式】第一行：五个整数N，M，t，A，B。N表示学校里的路口的个数M表示学校里的 路的条数t表示HH想要散步的距离A表示散步的出发点B则表示散步的终点。接下来M行每行一组Ai，Bi，表示从路口Ai到路口Bi有一条路。数据保证Ai ！= Bi,但不保证任意两个路口之间至多只有一条路相连接。路口编号从0到N -1。同一行内所有数据均由一个空格隔开，行首行尾没有多余空格。没有多余空行。答案模45989。【限定条件】N≤20，M≤60，t≤2^30，0≤A,B【输出格式】一行，表示答案。【输入样例】4 5 3 0 00 10 20 32 13 2【输出样例】4【样例解释】无 刷题记录30min3WA1AC 分析不能立刻走回头路!没理解这句话还以为是煞笔题…… 首先，考虑DP方程，用边去推导（主要是因为不能立刻走回头路，而且有重边，这都主要跟边有关系）$f[i][k]=\sum f[j][k2] (k:j=&gt;i,k!=oth[k2])$那么因为t灰常大，但是这个【上一条边】是与以后决策无关的所以引入矩阵乘法，利用快速幂加速 设起始边i，终止边j构造t=1的初始矩阵A当$y[i]=x[j]$,i连接j,且$i!=oth[j]$则$A[j][i]=1$ 为什么是反的？考虑矩阵乘法的定义，以及我们通常用的列向量：$A[][]\times st[i][1]=ed[j][1]$发现必须是$A[j][i]$ 这个判断矩乘的方法是我自己想的，好像网上也没人这样用。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;//*******************全局常量*******************const int MAXN=150;const int MOD=45989;//*******************全局定义*******************struct Martix&#123; int row,col; int m[MAXN][MAXN]; Martix(int r=0,int c=0) &#123; row=r;col=c; memset(m,0,sizeof(m)); &#125;&#125;;//*******************实现*******************Martix one(int row)&#123; Martix ans(row,row); for(int i=1;i&lt;=row;i++) ans.m[i][i]=1; return ans;&#125;Martix mul(Martix a,Martix b)&#123; Martix c(a.row,b.col); for(int i=1;i&lt;=c.row;i++) for(int j=1;j&lt;=c.col;j++) for(int k=1;k&lt;=a.col;k++) c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]%MOD)%MOD; return c;&#125;Martix power(Martix a,int e)&#123; Martix ans=one(a.row); while(e&gt;0) &#123; if(e&amp;1) ans=mul(ans,a); a=mul(a,a);e&gt;&gt;=1; &#125; return ans;&#125;struct Edge&#123; int x,y,oth;&#125;e[MAXN];int ln=0;void ins(int x,int y)&#123; e[++ln]=(Edge)&#123;x,y,ln+1&#125;; e[++ln]=(Edge)&#123;y,x,ln-1&#125;;&#125;//*******************主函数*******************int main()&#123; int n,m,t,st,ed;scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;t,&amp;st,&amp;ed); for(int i=1;i&lt;=m;i++) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); ins(x,y); &#125; Martix stm(ln,1);for(int k=1;k&lt;=ln;k++) stm.m[k][1]=(e[k].x==st); Martix A(ln,ln); for(int k1=1;k1&lt;=ln;k1++) for(int k2=1;k2&lt;=ln;k2++) A.m[k2][k1]=(e[k1].oth!=k2 and e[k1].y==e[k2].x); Martix edm=mul(power(A,t-1),stm); int ans=0; for(int k=1;k&lt;=ln;k++) if(e[k].y==ed) ans=(ans+edm.m[k][1])%MOD; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>DP</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC092-D】Two Sequences]]></title>
    <url>%2Fposts%2F77c7.html</url>
    <content type="text"><![CDATA[来源和评测点ARC092-D 题目【题目大意】给出两个长度为N的整数序列Ai和Bi，共有N^2个(Ai+Bi)，求他们的XOR值。【输入格式】Na1 a2 … aNb1 b2 … bN【限定条件】所有输入都是整数1≤N≤200,0000≤ai,bi&lt;2^28【输出格式】结果【输入样例】64 6 0 0 3 30 5 6 5 0 3【输出样例】8【样例解释】无 刷题记录2h3TLE1AC 分析被卡常了……记住，少点%啊 这道题还是很有意思的首先呢，直接枚举显然是不行的那么找找特殊性质异或，当然就跟奇偶性有关了然后？嗯我比赛的时候就是想到这里就不会了这个复杂度看起来就像是nlogn我们先按照位来处理。但a+b这种东西很烦啊，因为会有进位不过至少，我们处理第i位的时候i前面的就不用考虑了，%掉就好 然后，我们统计第i位是1的数量，判断奇偶性就好了。显然我们可以得到一个结果的有效范围$$[2^i,2^{i+1}-1] （不进位）$$和$$[2^{i+1}+2^i,2^{i+2}-1] （进位）$$那么枚举n个数字作为加数，不就得到了另一个加数的有效范围了吗nlogn排序后二分查找就好了（事实证明我的查找还是打得不熟练）假设第j个数字的对应数量有tj个，那么答案就是$$ANS=\sum_{i=0}^{29} ( ( (\sum_{j=1}^{n} tj) \&amp; 1)&lt;&lt;i )$$ 好久没有给卡常了……总时间$O(nlog^2n)$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;//*******************全局常量*******************const int MAXN=210000;//*******************全局定义*******************ll q[MAXN],w[MAXN];ll bin[35];int n;//*******************实现*******************/*debugbool cmp(ll a,ll b)&#123; return (a%bin[f+1])&lt;(b%bin[f+1]);&#125;*///*******************主函数*******************ll w2[MAXN];int main()&#123; bin[0]=1;for(int i=1;i&lt;=32;i++) bin[i]=bin[i-1]&lt;&lt;1; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;q[i]); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;w[i]); ll ans=0; for(int f=0;f&lt;=29;f++) &#123; for(int i=1;i&lt;=n;i++) w2[i]=w[i]%bin[f+1]; sort(w2+1,w2+1+n); ll t=0; for(int i=1;i&lt;=n;i++) &#123; ll now=q[i]%bin[f+1],ss=0; ll l,r; int bf; l=bin[f];r=bin[f+1]-1; l=lower_bound(w2+1,w2+n+1,l-now)-w2; r=upper_bound(w2+1,w2+n+1,r-now)-w2-1; bf=r-l+1;if(bf&gt;0) ss+=bf; l=bin[f+1]+bin[f];r=bin[f+2]-1; l=lower_bound(w2+1,w2+n+1,l-now)-w2; r=upper_bound(w2+1,w2+n+1,r-now)-w2-1; bf=r-l+1;if(bf&gt;0) ss+=bf; t=(t+ (ss&amp;1) )&amp;1; &#125; ans+=(t&lt;&lt;f); &#125; printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2330】【Luogu3275】糖果]]></title>
    <url>%2Fposts%2Fcc92.html</url>
    <content type="text"><![CDATA[来源和评测点SCOI2011 Day1Bzoj2330Luogu3275 题目【题目大意】幼儿园里有N个小朋友，lxhgww老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候，lxhgww需要满足小朋友们的K个要求。幼儿园的糖果总是有限的，lxhgww想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。【输入格式】输入的第一行是两个整数N，K。接下来K行，表示这些点需要满足的关系，每行3个数字X，A，B。如果X=1，表示第A个小朋友分到的糖果必须和第B个小朋友分到的糖果一样多；如果X=2，表示第A个小朋友分到的糖果必须少于第B个小朋友分到的糖果；如果X=3，表示第A个小朋友分到的糖果必须不少于第B个小朋友分到的糖果；如果X=4，表示第A个小朋友分到的糖果必须多于第B个小朋友分到的糖果；如果X=5，表示第A个小朋友分到的糖果必须不多于第B个小朋友分到的糖果；【限定条件】N&lt;=100000,K&lt;=100000，1&lt;=X&lt;=5，1&lt;=A, B&lt;=N【输出格式】输出一行，表示lxhgww老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，就输出-1。【输入样例】5 71 1 22 3 24 4 13 4 55 4 52 3 54 5 1【输出样例】11【样例解释】d[1]=d[2]d[3]&lt;d[2]d[4]&gt;d[1]d[4]&gt;=d[5]d[4]&lt;=d[5]d[3]&lt;d[5]d[5]&gt;d[1] 刷题记录1.5h吃了屎一样难受！居然输出的时候忘记打else了！ 分析具体跑最长路还是最短路，其实都没有问题下文以最长路为例 a=ba&gt;=b+0,ins(b,a,0)a&lt;=b+0,b&gt;=a+0,ins(a,b,0) aa,b&gt;=a+1,ins(a,b,1) a&gt;=ba&gt;=b+0,ins(b,a,0) a&gt;ba&gt;=b+1,ins(b,a,1) a&lt;=bb&gt;=a+0,ins(a,b,0)为了判断是否存在正环，不得不用spfa最后，我们找到了满足不等式组的一组解为了求出答案要求的最小，将最小值平移到1即可 up 2018.9.1其实有可能，数据强行卡spfa可以自己加上酸辣粉优化 正规做法是找题目性质，发现边权都是0或者1所以可以考虑直接判断是否存在正环（用tarjan，累加环总长度即可）没有的话，可以在缩点后的dag上直接拓扑来最短路 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=110000,MAXM=210000;//*******************全局定义*******************struct nod&#123; int hou; int ru,d; bool v; nod() &#123; hou=0; &#125;&#125;p[MAXN];struct edge&#123; int y,c,g;&#125;e[MAXM];int ln=0;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y; e[ln].c=c; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************queue&lt;int&gt; lst;bool spfa(int st,int n)&#123; for(int i=1;i&lt;=n;i++)//debug &#123; p[i].v=1; p[i].ru=1; p[i].d=1; lst.push(i); &#125; while(!lst.empty()) &#123; int x=lst.front();lst.pop();p[x].v=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].d&lt;p[x].d+e[k].c) &#123; p[y].d=p[x].d+e[k].c; if(p[y].v==0) &#123; p[y].v=1; lst.push(y); p[y].ru++; if(p[y].ru&gt;n) return 0; &#125; &#125; &#125; &#125; return 1;&#125;//*******************主函数*******************int main()&#123; int n,k;scanf("%d%d",&amp;n,&amp;k); bool bk=0; while(k--) &#123; int op,a,b;scanf("%d%d%d",&amp;op,&amp;a,&amp;b); if(op==1) ins(a,b,0),ins(b,a,0); if(op==2) &#123;ins(a,b,1);if(a==b) bk=1;&#125; if(op==3) ins(b,a,0); if(op==4) &#123;ins(b,a,1);if(a==b) bk=1;&#125; if(op==5) ins(a,b,0); &#125; if(bk or !spfa(0,n)) printf("-1"); else//debug &#123; long long all=0; for(int i=1;i&lt;=n;i++) all+=p[i].d; printf("%lld",all); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3683】Priest John's Busiest Day]]></title>
    <url>%2Fposts%2F632.html</url>
    <content type="text"><![CDATA[来源和评测点POJ Founder Monthly Contest – 2008.08.31, Dagger and FacerPoj3683 题目【题目大意】John是小镇唯一的牧师，他希望参加n个婚礼，每个婚礼计划在Si~Ti举行婚礼。婚礼有个仪式必须要John参加，但他不能同时参加两个仪式。仪式时间是Si~Si+Di或者Ti-Di~Ti。请替John安排他的日程表题意强调：一个仪式8:30结束，另一个8:30开始，不算冲突【输入格式】第一行整数n(1≤n≤1000)接下来n行，表示Si,Ti和Di（Si&lt;=Ti，Di&lt;=Ti-Si）Si和Ti的格式是hh:mm【输出格式】如果无解，输出NO否则输出YES,并且接下来n行，每行表示他参加的仪式时间。要按照每个婚礼的输入的顺序输出！（因为这是spj嘛）本题有特判。【输入样例】208:00 09:00 3008:15 09:00 20【输出样例】YES08:00 08:3008:40 09:00 刷题记录2h1AC做题 做得好慢啊本来抱着MLE的想法提交的，结果很小嘛~ 分析第一次做要输出方案的2-SAT，感觉好繁琐就是跟着伟大的神教程做得：csdn-jarjingx 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************//*******************全局定义*******************int cnt;//*******************强连通*******************struct nod&#123; int dfn,low; int belg; bool v; int hou; int st,ed;&#125;p[2100];struct edge&#123; int x,y,g;&#125;e[4100000];int ln;void ins(int x,int y)&#123; ln++; e[ln].x=x; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;int sta[2100],top;int id;void tarjan(int x)&#123; sta[++top]=x;p[x].v=1; p[x].dfn=p[x].low=++id; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y); if(p[y].v==1) p[x].low=mymin(p[x].low,p[y].low); &#125; if(p[x].dfn==p[x].low) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].v=0; p[t].belg=cnt; if(t==x) break; &#125; &#125;&#125;//*******************实现定义*******************int hread(void)&#123; int h,m; scanf("%d:%d",&amp;h,&amp;m); return h*60+m;&#125;void hwrite(int tm)&#123; int a=tm/60; if(a&lt;10) printf("0%d:",a); else printf("%d:",a); int b=tm%60; if(b&lt;10) printf("0%d ",b); else printf("%d ",b);&#125;struct nod2&#123; int hou; int ru; int oth; int tag;&#125;pt[2100];struct edge2&#123; int y,g;&#125;eg[4100000];int ln2;void ins2(int x,int y)&#123; ln2++; eg[ln2].y=y; eg[ln2].g=pt[x].hou; pt[x].hou=ln2;&#125;//*******************拓扑*******************int fs,ss[2100];void topsort(int x)&#123; ss[++fs]=x;pt[x].ru=-1; for(int k=pt[x].hou;k&gt;0;k=eg[k].g) &#123; int y=eg[k].y; pt[y].ru--; if(pt[y].ru==0) topsort(y); &#125;&#125;//*******************实现*******************bool okay(int x,int y)&#123; if(p[x].st&gt;p[y].st) swap(x,y); return p[x].ed&lt;=p[y].st;&#125;int getoth(int x) &#123;return x&amp;1?x+1:x-1;&#125;void dfs(int x)&#123; pt[x].tag=-1; for(int k=pt[x].hou;k&gt;0;k=eg[k].g) &#123; int y=eg[k].y; if(pt[y].tag==0) dfs(y); &#125;&#125;bool solve(int n)&#123; ln=cnt=top=id=0; for(int i=1;i&lt;=2*n;i++) &#123; p[i].dfn=0; p[i].v=0; p[i].hou=0; &#125; for(int i=1;i&lt;=2*n;i++) for(int j=i+1;j&lt;=2*n;j++) if(!okay(i,j)) &#123; ins(i,getoth(j)); ins(j,getoth(i)); &#125; for(int i=1;i&lt;=2*n;i++) if(p[i].dfn==0) tarjan(i); ln2=0; for(int i=1;i&lt;=cnt;i++) &#123; pt[i].hou=0; pt[i].ru=0; pt[i].tag=0; &#125; for(int i=1;i&lt;=n;i++) &#123; int fx=p[2*i-1].belg,fy=p[2*i].belg; if(fx==fy) return 0; else &#123; pt[fx].oth=fy; pt[fy].oth=fx; &#125; &#125; for(int i=1;i&lt;=ln;i++) &#123; int x=e[i].x,y=e[i].y; int fx=p[x].belg,fy=p[y].belg; if(fx!=fy) ins2(fy,fx),pt[fx].ru++;//反边 &#125; fs=0; for(int i=1;i&lt;=cnt;i++) if(pt[i].ru==0) topsort(i); for(int i=1;i&lt;=cnt;i++) &#123; int x=ss[i]; if(pt[x].tag==0) &#123; pt[x].tag=1; dfs(pt[x].oth); &#125; &#125; printf("YES\n"); for(int i=1;i&lt;=2*n;i++) if(pt[p[i].belg].tag==1) hwrite(p[i].st),hwrite(p[i].ed),printf("\n"); return 1;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int s=hread(),t=hread(),d;scanf("%d",&amp;d); p[2*i-1].st=s;p[2*i-1].ed=s+d; p[2*i].st=t-d;p[2*i].ed=t; &#125; if(!solve(n)) printf("NO");&#125; other solution from lydUP 2018.9.6:具体方法参考更新后的2-sat教程]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>难度2</tag>
        <tag>拓扑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3207】Panda's Trick]]></title>
    <url>%2Fposts%2F9ebb.html</url>
    <content type="text"><![CDATA[来源和评测点Poj3207 题目【题目大意】在一个圆上，有n个点（0~n-1），m条边，边可以在圆内或圆外（圆内即线段）保证每个点最多和一条边相连判断能否每条边不相交【输入格式】第一行n和m（n≤1000, m≤500）接下来m行，a和b表示连边【输出格式】如果不重合，输出panda is telling the truth…否则输出the evil panda is lying again【输入样例】4 20 13 2【输出样例】panda is telling the truth… 刷题记录20min 分析2-SAT显然：如果两条边在圆内相交，则在圆外也一定相交于是就产生了两种情况，并且会有互斥关系，套上模板即可对了，因为建图出来的是双向边，用并查集也是没毛病的。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=1100,MAXM=1100000;//*******************全局定义*******************int cnt;struct nod&#123; int dfn,low; int belg; bool v; int hou;&#125;p[MAXN];struct edge&#123; int y,g;&#125;e[MAXM];int ln;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int sta[MAXN],top;int id;void tarjan(int x)&#123; sta[++top]=x;p[x].v=1; p[x].dfn=p[x].low=++id; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y); if(p[y].v==1) p[x].low=mymin(p[x].low,p[y].dfn); &#125; if(p[x].dfn==p[x].low) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].v=0; p[t].belg=cnt; if(t==x) break; &#125; &#125;&#125;//*******************主函数*******************int st[MAXM],ed[MAXM];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); ln=id=top=cnt=0; for(int i=1;i&lt;=m;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y);x++,y++; st[i]=mymin(x,y);ed[i]=mymax(x,y); &#125; for(int i=1;i&lt;=2*m;i++) &#123; p[i].dfn=0; p[i].hou=0; p[i].belg=0; p[i].v=0; &#125; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=m;j++) if(st[i]&lt;st[j] and st[j]&lt;ed[i] and ed[i]&lt;ed[j]) &#123; ins(2*i,2*j-1); ins(2*j-1,2*i); ins(2*j,2*i-1); ins(2*i-1,2*j); &#125; for(int i=1;i&lt;=2*m;i++) if(p[i].dfn==0) tarjan(i); bool bk=0; for(int i=1;i&lt;=m;i++) if(p[2*i-1].belg==p[2*i].belg) bk=1; if(bk) printf("the evil panda is lying again"); else printf("panda is telling the truth...");&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1405】聚会]]></title>
    <url>%2Fposts%2F46fd.html</url>
    <content type="text"><![CDATA[来源和评测点Caioj1405 题目【题目大意】n对夫妻参加一个聚会，每对夫妻只有1人可以列席。在2n个人中，某些人之间有矛盾,夫妻之间不会有矛盾。有矛盾的2个人不会同时出现在聚会上。问有没有可能会有n个人同时列席？【输入格式】第一行：一个正整数n(1&lt;=n&lt;=1000)，表示有n对夫妻被邀请第一行：一个正整数m(m&lt;(n-1)*(n-1))，表示有m对矛盾关系接下来的m行，每行四个正整数A1,A2,C1,C2。A1,A2分别表示夫妻的编号。C1,C2表示矛盾者是妻子还是丈夫，0表示妻子，1表示丈夫多组数据，当n=0时结束【输出格式】如果存在这种情况，输出YES；否则输出NO【输入样例】210 1 1 10【输出样例】YES 刷题记录20min1WA1AC 分析2-SAT裸题 代码12]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1997】Planar]]></title>
    <url>%2Fposts%2Fc3c1.html</url>
    <content type="text"><![CDATA[来源和评测点Hnoi2010Bzoj1997 题目【题目大意】【输入格式】【输出格式】【输入样例】26 91 41 51 62 42 52 63 43 53 61 4 2 5 3 65 51 22 33 44 55 11 2 3 4 5【输出样例】NOYES 刷题记录30min2TLE(空间开小)2AC(有bug) 分析神奇的平面图定理：m&lt;=3*n+6（不然空间会爆的，其他就很简单啦）之前说过，如果两条边在圆内相交，则在圆外也一定相交那么哈密顿回路是可以拉成一个圆的 对了，因为建图出来的是双向边，用并查集也是没毛病的。 嗯这题除了空间上的问题，也算是独立完成了吧…… UP 2018.9.10:这里用到的公式可以前往oi之路的定理杂烩查看详细信息 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=1300,MAXM=1500000;//*******************全局定义*******************int cnt;struct nod&#123; int dfn,low; int belg; bool v; int hou;&#125;p[MAXN];struct edge&#123; int y,g;&#125;e[MAXM];int ln;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int sta[MAXN],top;int id;void tarjan(int x)&#123; sta[++top]=x;p[x].v=1; p[x].dfn=p[x].low=++id; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y); if(p[y].v==1) p[x].low=mymin(p[x].low,p[y].low); &#125; if(p[x].dfn==p[x].low) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].v=0; p[t].belg=cnt; if(t==x) break; &#125; &#125;&#125;//*******************主函数*******************int st[MAXM],ed[MAXM];int ptd[MAXN];bool solve(int n,int m)&#123; if(m&gt;3*n+6) return 1; memset(p,0,sizeof(p)); ln=id=top=cnt=0; for(int i=1;i&lt;=m;i++) &#123; st[i]=ptd[st[i]]; ed[i]=ptd[ed[i]]; if(st[i]&gt;ed[i]) swap(st[i],ed[i]); if( st[i]+1==ed[i] or (st[i]==n and ed[i]==1)) &#123; st[i]=st[m]; ed[i]=ed[m]; m--; i--; &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; for(int j=i+1;j&lt;=m;j++) &#123; if( (st[i]&lt;st[j] and st[j]&lt;ed[i] and ed[i]&lt;ed[j])or (st[j]&lt;st[i] and st[i]&lt;ed[j] and ed[j]&lt;ed[i]) ) &#123; ins(2*i,2*j-1); ins(2*j-1,2*i); ins(2*j,2*i-1); ins(2*i-1,2*j); &#125; &#125; &#125; for(int i=1;i&lt;=2*m;i++) if(p[i].dfn==0) tarjan(i); for(int i=1;i&lt;=m;i++) if(p[2*i-1].belg==p[2*i].belg) return 1; return 0;&#125;int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf("%d%d",&amp;st[i],&amp;ed[i]); for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); ptd[t]=i; &#125; if(solve(n,m)) printf("NO\n"); else printf("YES\n"); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF19E】【Bzoj4424】Fairy]]></title>
    <url>%2Fposts%2F59cc.html</url>
    <content type="text"><![CDATA[来源和评测点CF19EBzoj4424 题目【题目大意】给定n个点，m条边的无向图，可以从图中删除一条边，问删除哪些边可以使图变成一个二分图。（补充：只能是每次一条）【输入格式】第1行包含两个整数n，m。分别表示点数和边数。第2到m+1行每行两个数x，y表示有一条（x,y）的边。【输出格式】输出第一行一个整数，表示能删除的边的个数。接下来一行按照从小到大的顺序输出边的序号。【输入样例】4 41 21 32 43 4【输出样例】41 2 3 4 刷题记录3h 分析首先，确保理解题意无误后，各种画图探究二分图的性质发现所谓二分图，就是不能有奇数环 长姿势：对于一个图，可以考虑建立dfs序树，将边分为生成树边和返祖边（回边）从而对于环或者之类的东西一目了然（因为树是没有环的） 然后在这里：DaD3zZ它提到了单返祖边，但我并不觉得返祖边数量有任何影响所以他的意思应该是，程序设计的时候，因为是建立dfs序树，所以只能处理单返祖边？ 说说我的看法：1.如果没有奇数环，那么输出所有边，因为这样都可以符合要求2.1)必须删除的是奇数环的公共边，否则还会有奇数环剩余2.2)不能是任何一个偶环的部分，否则会产生新的奇数环引用几张图片，大家思考一下：呃外站图片，懒得下载下来了，如果哪天csdn炸了(其实几率不大)或者文章删除了，评论即可。 打上标记输出即可注意可能会有重边和负环，而且不一定联通。负环：看作奇数环即可重边：看作返祖边即可联通：没进入过的进入即可反正就是别太操心特殊情况，然后排除掉，要一视同仁~ 写下来详细说说怎么DP吧（开始涉及细节了，想独立思考的请跳过）先区分树边和返祖边，然后枚举返祖边判断环的奇偶性（有返祖边就有环）如果奇数环个数=0，直接输出全部然后结束程序。否则，如果是返祖边，如果奇数环=1，那么可以，否则显然就不是奇数环的公公共边了。然后计算每条树边被多少个奇数环包含，从而判断是否是公共边接下来用点来标记网上好像没人说，但想半天后忽然发现，接下来这个其实类似于树上差分！（解释一下，树上差分大概就是其他位置的树上前缀和不变）每个点上面的odd、ever分别表示它的父亲树边在多少个偶数、奇数环中回溯的时候再转移到边上，这样避免了处理双向边的繁琐，最后按顺序枚举输出。 最后的最后，补充一个降低代码复杂的方法，因为我们在建树的时候建立的是双向边，令ln=1，然后这样建边的时候同一条边的编号一个是奇数一个是偶数，可以用异或处理了，而且除以2后就合并了。 真的是最后了，因为是双向建边，可以向下的时候不能是（标记为不是返祖边），而是（标记为树边）应该挺好理解的~ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=1000010;//*******************全局定义*******************struct road&#123; int x,y; int odd,even;//奇、偶 bool sb;//树边&#125;rd[MAXN];struct nod&#123; int hou; int dep; int odd,even;//奇、偶&#125;p[MAXN];struct edge&#123; int y,g;&#125;e[MAXN*2];int ln=1;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************bool v[MAXN];void dfs1(int x,int dep)&#123; p[x].dep=dep;v[x]=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(v[y]==0) &#123; dfs1(y,dep+1); rd[k/2].sb=1; &#125; &#125;&#125;void dfs2(int x)&#123; v[x]=1;//debug for(int k=p[x].hou;k&gt;0;k=e[k].g) if(rd[k/2].sb=1) &#123; int y=e[k].y; if(v[y]==1) continue;//debug dfs2(y); p[x].odd+=p[y].odd; p[x].even+=p[y].even;//树上前缀和 rd[k/2].odd=p[y].odd; rd[k/2].even=p[y].even; &#125;&#125;//*******************主函数*******************int ans[MAXN];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;rd[i].x,&amp;rd[i].y); rd[i].odd=rd[i].even=rd[i].sb=0; ins(rd[i].x,rd[i].y);ins(rd[i].y,rd[i].x); &#125; memset(v,0,sizeof(v)); for(int i=1;i&lt;=n;i++) if(v[i]==0) dfs1(i,1); int cnt=0;//奇数环个数 for(int i=1;i&lt;=m;i++) if(rd[i].sb==0) &#123; int x=rd[i].x,y=rd[i].y; if(p[x].dep&gt;p[y].dep) swap(x,y); if( (p[y].dep-p[x].dep)%2==1 ) p[x].even--,p[y].even++;//偶数环 else p[x].odd--,p[y].odd++,cnt++,rd[i].odd=1;//奇数环，特别处理一下返祖边 &#125; if(cnt==0) &#123; printf("%d\n",m); for(int i=1;i&lt;=m;i++) if(i&lt;m) printf("%d ",i); else printf("%d\n",i); return 0; &#125; memset(v,0,sizeof(v)); for(int i=1;i&lt;=n;i++) if(v[i]==0) dfs2(i); int ansn=0; for(int i=1;i&lt;=m;i++) &#123; if(rd[i].sb)//树边 &#123; if(rd[i].even==0 and rd[i].odd==cnt) ans[++ansn]=i; &#125; else//返祖边特判 &#123; if(rd[i].odd==cnt) ans[++ansn]=i; &#125; &#125; printf("%d\n",ansn); for(int i=1;i&lt;=ansn;i++) if(i&lt;ansn) printf("%d ",ans[i]); else printf("%d\n",ans[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj4520】K远点对]]></title>
    <url>%2Fposts%2F673d.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj4520 题目【题目大意】已知平面内N个点的坐标，求欧氏距离下的第K远点对。【输入格式】输入文件第一行为用空格隔开的两个整数N，K。接下来N行，每行两个整数X,Y，表示一个点的坐标。1&lt;=N&lt;=100000，1&lt;=K&lt;=100，K&lt;=N*(N−1)/2，0&lt;=X,Y&lt;2^31。【输出格式】出文件第一行为一个整数，表示第K远点对的距离的平方（一定是个整数）。【输入样例】10 50 00 11 01 12 02 11 20 23 03 1【输出样例】9 刷题记录20min 分析kdtree，k固定因为每个距离维护了两次，用2*k大小的小根堆维护，相当于维护了前k个值，并且堆顶正是第k个 长姿势：对于k确定的第k大，用一个堆维护会灰常方便 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;typedef unsigned long long ll;//严格来说这样才对ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;ll mymax(ll x,ll y) &#123;return x&gt;y?x:y;&#125;ll myabs(ll x) &#123;return x&gt;0?x:-x;&#125;ll mysqr(ll x) &#123;return x*x;&#125;//*******************全局常量*******************const int MAXN=110000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; ll d[2];//自己 ll mi[2],mx[2];//管理区间 int son[2];//左右区间 nod() &#123; son[0]=son[1]=0; &#125;&#125;p[MAXN];//*******************kdtree*******************int D;bool cmp(nod a,nod b)&#123; return (a.d[D]&lt;b.d[D]) or (a.d[D]==b.d[D] and a.d[1-D]&lt;b.d[1-D]);&#125;void update(int f,int x)&#123; p[f].mi[0]=mymin(p[f].mi[0],p[x].mi[0]);p[f].mx[0]=mymax(p[f].mx[0],p[x].mx[0]); p[f].mi[1]=mymin(p[f].mi[1],p[x].mi[1]);p[f].mx[1]=mymax(p[f].mx[1],p[x].mx[1]);&#125;ll getdis(int t,ll x,ll y)//估价最好情况&#123; return mymax(mysqr(p[t].mi[0]-x),mysqr(p[t].mx[0]-x))+ mymax(mysqr(p[t].mi[1]-y),mysqr(p[t].mx[1]-y));&#125;//*******************实现*******************int root;int build(int l,int r,int d)&#123; if(l&gt;r) return 0; int mid=(l+r)/2; D=d;nth_element(p+l,p+mid,p+r+1,cmp);//尽量平衡 p[mid].mi[0]=p[mid].mx[0]=p[mid].d[0]; p[mid].mi[1]=p[mid].mx[1]=p[mid].d[1]; if(l&lt;=mid-1) p[mid].son[0]=build(l,mid-1,1-d),update(mid,p[mid].son[0]); if(mid+1&lt;=r) p[mid].son[1]=build(mid+1,r,1-d),update(mid,p[mid].son[1]); return mid;&#125;int cnt;void insert(ll x,ll y)&#123; int t=++cnt; p[t].d[0]=p[t].mi[0]=p[t].mx[0]=x; p[t].d[1]=p[t].mi[1]=p[t].mx[1]=y; if(root==0) root=t; else &#123; int f=root; for(D=0;1;D=1-D) &#123; update(f,t); int tmp=cmp(p[f],p[t]); if(p[f].son[tmp]==0) &#123; p[f].son[tmp]=t; break; &#125; f=p[f].son[tmp]; &#125; &#125;&#125;priority_queue&lt; ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt; q;void ask(int t,ll x,ll y)&#123; ll dis=mysqr(p[t].d[0]-x)+mysqr(p[t].d[1]-y); if(dis!=0 and dis&gt;q.top()) q.pop(),q.push(dis); int lc=p[t].son[0],rc=p[t].son[1]; ll f[2]; f[0]=(lc&gt;0)?getdis(lc,x,y):0; f[1]=(rc&gt;0)?getdis(rc,x,y):0; bool tmp=(f[1]&lt;=f[0]); if(f[tmp]&gt;q.top()) ask(p[t].son[tmp],x,y); if(f[1-tmp]&gt;q.top()) ask(p[t].son[1-tmp],x,y);&#125;//*******************主函数*******************int main()&#123; int n,k;scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%lld%lld",&amp;p[i].d[0],&amp;p[i].d[1]); root=build(1,n,0); while(q.size()&lt;2*k) q.push(0); for(int i=1;i&lt;=n;i++) ask(root,p[i].d[0],p[i].d[1]); printf("%lld",q.top());&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>kdtree</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1941】Hide and Seek]]></title>
    <url>%2Fposts%2F87ed.html</url>
    <content type="text"><![CDATA[来源和评测点Sdoi2010Bzoj1941 题目【题目大意】小猪iPig在PKU刚上完了无聊的猪性代数课，天资聪慧的iPig被这门对他来说无比简单的课弄得灰常寂寞。为了消除寂寞感，他决定和他的好朋友giPi（鸡皮）玩一个更加寂寞的游戏—捉迷藏。但是，他们觉得，玩普通的捉迷藏没什么意思，还是不够寂寞，于是，他们决定玩寂寞无比的螃蟹版捉迷藏，顾名思义，就是说他们在玩游戏的时候只能沿水平或垂直方向走。一番寂寞的剪刀石头布后，他们决定iPig去捉giPi。由于他们都很熟悉PKU的地形了，所以giPi只会躲在PKU内n个隐秘地点，显然iPig也只会在那n个地点内找giPi。游戏一开始，他们选定一个地点，iPig保持不动，然后giPi用30秒的时间逃离现场（显然，giPi不会呆在原地）。然后iPig会随机地去找giPi，直到找到为止。由于iPig很懒，所以他到总是走最短的路径，而且，他选择起始点不是随便选的，他想找一个地点，使得该地点到最远的地点和最近的地点的距离差最小。iPig现在想知道这个距离差最小是多少。由于iPig现在手上没有电脑，所以不能编程解决这个如此简单的问题，所以他马上打了个电话，要求你帮他解决这个问题。iPig告诉了你PKU的n个隐秘地点的坐标，请你编程求出iPig的问题。【输入格式】第一行输入一个整数N 第2~N+1行，每行两个整数X，Y，表示第i个地点的坐标【输出格式】一个整数，为距离差的最小值。【输入样例】40 01 00 11 1【输出样例】1 刷题记录30min1AC 分析kdtree暴力枚举即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=510000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int d[2];//自己 int son[2];//左右区间 int mi[2],mx[2];//管理区间 nod() &#123; son[0]=son[1]=0; &#125;&#125;p[MAXN];int root;//*******************kdtree*******************int D;bool cmp(nod a,nod b)&#123; return (a.d[D]&lt;b.d[D]) or (a.d[D]==b.d[D] and a.d[1-D]&lt;b.d[1-D]);&#125;void update(int f,int x)&#123; p[f].mi[0]=mymin(p[f].mi[0],p[x].mi[0]);p[f].mx[0]=mymax(p[f].mx[0],p[x].mx[0]); p[f].mi[1]=mymin(p[f].mi[1],p[x].mi[1]);p[f].mx[1]=mymax(p[f].mx[1],p[x].mx[1]);&#125;int getdis(int t,int x,int y,int op)//最近&#123; if(op==0) &#123; int ans=0;//在内部 if(x&lt;p[t].mi[0]) ans+=p[t].mi[0]-x;//左 if(p[t].mx[0]&lt;x) ans+=x-p[t].mx[0];//右 if(p[t].mx[1]&lt;y) ans+=y-p[t].mx[1];//上 if(y&lt;p[t].mi[1]) ans+=p[t].mi[1]-y;//下 return ans; &#125; else &#123; return mymax(myabs(x-p[t].mx[0]),myabs(x-p[t].mi[0]))+ mymax(myabs(y-p[t].mx[1]),myabs(y-p[t].mi[1])); &#125; &#125;//*******************实现*******************int build(int l,int r,int d)&#123; if(l&gt;r) return 0; int mid=(l+r)/2;D=d; nth_element(p+l,p+mid,p+r+1,cmp);//尽量平衡 p[mid].mi[0]=p[mid].mx[0]=p[mid].d[0]; p[mid].mi[1]=p[mid].mx[1]=p[mid].d[1]; if(l&lt;=mid-1) p[mid].son[0]=build(l,mid-1,1-d),update(mid,p[mid].son[0]); if(mid+1&lt;=r) p[mid].son[1]=build(mid+1,r,1-d),update(mid,p[mid].son[1]); return mid;&#125;int ans;void ask(int now,int x,int y,int op)&#123; int dis=myabs(p[now].d[0]-x)+myabs(p[now].d[1]-y);//自身 if(dis!=0) &#123; if(op==0) ans=mymin(ans,dis); else ans=mymax(ans,dis); &#125; int f[2],lc=p[now].son[0],rc=p[now].son[1]; if(op==0) &#123; f[0]=lc?getdis(lc,x,y,op):INF; f[1]=rc?getdis(rc,x,y,op):INF; bool tmp=(f[1]&lt;=f[0]); if(f[tmp]&lt;ans) ask(p[now].son[tmp],x,y,op); if(f[1-tmp]&lt;ans) ask(p[now].son[1-tmp],x,y,op); &#125; else &#123; f[0]=lc?getdis(lc,x,y,op):0; f[1]=rc?getdis(rc,x,y,op):0; bool tmp=(f[1]&gt;=f[0]); if(f[tmp]&gt;ans) ask(p[now].son[tmp],x,y,op); if(f[1-tmp]&gt;ans) ask(p[now].son[1-tmp],x,y,op); &#125;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].d[0],&amp;p[i].d[1]); root=build(1,n,0); int mi=INF; for(int i=1;i&lt;=n;i++) &#123; ans=0; ask(root,p[i].d[0],p[i].d[1],1); int t=ans;ans=INF; ask(root,p[i].d[0],p[i].d[1],0); mi=mymin(mi,t-ans); &#125; printf("%d",mi);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>kdtree</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1206】最近点对]]></title>
    <url>%2Fposts%2Fa1d3.html</url>
    <content type="text"><![CDATA[来源和评测点Caioj1206 题目【题目大意】给出n个点的坐标，求最近两点间的距离。【输入格式】第一行一个整数n(2≤n≤50000)。下来n行，每行两个实数x和y表示点坐标。【输出格式】一行一个实数，表示最近两点间的距离（保留4位小数）。【输入样例】50 00 55 05 52 0【输出样例】2.0000 刷题记录30min1WA1AC 分析kdtree记得开long long 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;ll mymax(ll x,ll y) &#123;return x&gt;y?x:y;&#125;ll myabs(ll x) &#123;return x&gt;0?x:-x;&#125;ll mysqr(ll x) &#123;return x*x;&#125;//*******************全局常量*******************const int MAXN=51000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; ll d[2];//自己 ll mi[2],mx[2];//管理区间 int son[2];//左右区间 nod() &#123; son[0]=son[1]=0; &#125;&#125;p[MAXN];//*******************kdtree*******************int D;bool cmp(nod a,nod b)&#123; return (a.d[D]&lt;b.d[D]) or (a.d[D]==b.d[D] and a.d[1-D]&lt;b.d[1-D]);&#125;void update(int f,int x)&#123; p[f].mi[0]=mymin(p[f].mi[0],p[x].mi[0]);p[f].mx[0]=mymax(p[f].mx[0],p[x].mx[0]); p[f].mi[1]=mymin(p[f].mi[1],p[x].mi[1]);p[f].mx[1]=mymax(p[f].mx[1],p[x].mx[1]);&#125;ll getdis(int t,ll x,ll y)//估价最好情况&#123; ll xx=mymax(0,p[t].mi[0]-x)+mymax(0,x-p[t].mx[0]); ll yy=mymax(0,y-p[t].mx[1])+mymax(0,p[t].mi[1]-y); return xx*xx+yy*yy;&#125;//*******************实现*******************int root;int build(int l,int r,int d)&#123; if(l&gt;r) return 0; int mid=(l+r)/2; D=d;nth_element(p+l,p+mid,p+r+1,cmp);//尽量平衡 p[mid].mi[0]=p[mid].mx[0]=p[mid].d[0]; p[mid].mi[1]=p[mid].mx[1]=p[mid].d[1]; if(l&lt;=mid-1) p[mid].son[0]=build(l,mid-1,1-d),update(mid,p[mid].son[0]); if(mid+1&lt;=r) p[mid].son[1]=build(mid+1,r,1-d),update(mid,p[mid].son[1]); return mid;&#125;int cnt;void insert(ll x,ll y)&#123; int t=++cnt; p[t].d[0]=p[t].mi[0]=p[t].mx[0]=x; p[t].d[1]=p[t].mi[1]=p[t].mx[1]=y; if(root==0) root=t; else &#123; int f=root; for(D=0;1;D=1-D) &#123; update(f,t); int tmp=cmp(p[f],p[t]); if(p[f].son[tmp]==0) &#123; p[f].son[tmp]=t; break; &#125; f=p[f].son[tmp]; &#125; &#125;&#125;ll ans;void ask(int t,ll x,ll y)&#123; ll dis=mysqr(p[t].d[0]-x)+mysqr(p[t].d[1]-y); /*if(dis==0) return;//自身 ans=mymin(ans,dis);*/ if(dis!=0) ans=mymin(ans,dis); //UP: caioj神水数据，一看就是错的 int lc=p[t].son[0],rc=p[t].son[1]; ll f[2]; f[0]=(lc&gt;0)?getdis(lc,x,y):INF; f[1]=(rc&gt;0)?getdis(rc,x,y):INF; bool tmp=(f[1]&lt;=f[0]); if(f[tmp]&lt;ans) ask(p[t].son[tmp],x,y); if(f[1-tmp]&lt;ans) ask(p[t].son[1-tmp],x,y);&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld%lld",&amp;p[i].d[0],&amp;p[i].d[1]); root=build(1,n,0); ans=INF; for(int i=1;i&lt;=n;i++) ask(root,p[i].d[0],p[i].d[1]); printf("%.4lf",sqrt(double(ans)));&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>kdtree</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2648】【Bzoj2716】SJY摆棋子]]></title>
    <url>%2Fposts%2F5728.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj2648Bzoj2716 题目【题目大意】在一个棋盘上，有N个黑色棋子。他每次要么放到棋盘上一个黑色棋子，要么放上一个白色棋子。如果是白色棋子，他会找出距离这个白色棋子最近的黑色棋子。此处的距离是 曼哈顿距离 即(|x1-x2|+|y1-y2|) 。现在给出N&lt;=500000个初始棋子和M&lt;=500000个操作。对于每个白色棋子，输出距离这个白色棋子最近的黑色棋子的距离。同一个格子可能有多个棋子。【输入格式】第一行两个数 N M以后N行，每行两个数x y（原题面错误）以后M行，每行3个数 t x y如果t=1 那么放下一个黑色棋子如果t=2 那么放下一个白色棋子【输出格式】对于每个T=2 输出一个最小距离【输入样例】2 31 12 32 1 21 3 32 4 2【输出样例】12 刷题记录1h4WA1AC 分析kdtree 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=1100000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int d[2];//自己 int son[2];//左右区间 int mi[2],mx[2];//管理区间 nod() &#123; son[0]=son[1]=0; &#125;&#125;p[MAXN];int root;//*******************kdtree*******************int D;bool cmp(nod a,nod b)&#123; return (a.d[D]&lt;b.d[D]) or (a.d[D]==b.d[D] and a.d[1-D]&lt;b.d[1-D]);&#125;void update(int f,int x)&#123; p[f].mi[0]=mymin(p[f].mi[0],p[x].mi[0]);p[f].mx[0]=mymax(p[f].mx[0],p[x].mx[0]); p[f].mi[1]=mymin(p[f].mi[1],p[x].mi[1]);p[f].mx[1]=mymax(p[f].mx[1],p[x].mx[1]);&#125;int getdis(int t,int x,int y)//估价最好情况&#123; int ans=0;//在内部 if(x&lt;p[t].mi[0]) ans+=p[t].mi[0]-x;//左 if(p[t].mx[0]&lt;x) ans+=x-p[t].mx[0];//右 if(p[t].mx[1]&lt;y) ans+=y-p[t].mx[1];//上 if(y&lt;p[t].mi[1]) ans+=p[t].mi[1]-y;//下 /* 神TM复制的时候忘记改x为y，然后居然水了无数点 ans=mymax(p[t].mi[0]-x,0)+mymax(x-p[t].mx[0],0)+ mymax(p[t].mi[1]-y,0)+mymax(y-p[t].mx[1],0);*/ return ans;&#125;//*******************实现*******************int build(int l,int r,int d)&#123; if(l&gt;r) return 0;//debug int mid=(l+r)/2;D=d;//debug nth_element(p+l,p+mid,p+r+1,cmp);//尽量平衡 p[mid].mi[0]=p[mid].mx[0]=p[mid].d[0]; p[mid].mi[1]=p[mid].mx[1]=p[mid].d[1]; if(l&lt;=mid-1) p[mid].son[0]=build(l,mid-1,1-d),update(mid,p[mid].son[0]); if(mid+1&lt;=r) p[mid].son[1]=build(mid+1,r,1-d),update(mid,p[mid].son[1]); return mid;&#125;int cnt;void insert(int x,int y)&#123; int t=++cnt; p[t].d[0]=p[t].mi[0]=p[t].mx[0]=x; p[t].d[1]=p[t].mi[1]=p[t].mx[1]=y; if(root==0) root=t; else &#123; int f=root; for(D=0;1;D=1-D) &#123; update(f,t); int tx=!cmp(p[t],p[f]); if(p[f].son[tx]==0) &#123; p[f].son[tx]=t; break; &#125; f=p[f].son[tx]; &#125; &#125;&#125;int ans;void ask(int now,int x,int y)&#123; ans=mymin(ans,myabs(p[now].d[0]-x)+myabs(p[now].d[1]-y));//自身 int f[2],lc=p[now].son[0],rc=p[now].son[1]; f[0]=lc?getdis(lc,x,y):INF; f[1]=rc?getdis(rc,x,y):INF; bool tmp=!(f[0]&lt;=f[1]); if(f[tmp]&lt;ans) ask(p[now].son[tmp],x,y); if(f[1-tmp]&lt;ans) ask(p[now].son[1-tmp],x,y);&#125;//*******************主函数*******************int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].d[0],&amp;p[i].d[1]); root=build(1,n,0);cnt=n; while(m--) &#123; int op,x,y;scanf("%d%d%d",&amp;op,&amp;x,&amp;y); if(op==1) insert(x,y); else ans=INF,ask(root,x,y),printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>kdtree</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1051】受欢迎的牛]]></title>
    <url>%2Fposts%2Fc794.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj1051 题目【题目大意】每一头牛的愿望就是变成一头最受欢迎的牛。现在有N头牛，给你M对整数(A,B)，表示牛A认为牛B受欢迎。这种关系是具有传递性的，如果A认为B受欢迎，B认为C受欢迎，那么牛A也认为牛C受欢迎。你的任务是求出有多少头牛被所有的牛认为是受欢迎的。【输入格式】第一行两个数N,M。接下来M行，每行两个数A,B，意思是A认为B是受欢迎的（给出的信息有可能重复，即有可能出现多个A,B）N&lt;=10000,M&lt;=50000【输出格式】一个数，即有多少头牛被所有的牛认为是受欢迎的。【输入样例】3 31 22 12 3【输出样例】1 刷题记录30min1WA1AC 分析一开始还乱想到差分约束…… 引用1：由题可得，受欢迎的奶牛只有可能是图中唯一的出度为零的强连通分量中的所有奶牛，所以若出现两个以上出度为0的强连通分量则不存在明星奶牛，因为那几个出度为零的分量的爱慕无法传递出去。那唯一的分量能受到其他分量的爱慕同时在分量内相互传递，所以该分量中的所有奶牛都是明星 引用2：在有向图中，如果有且仅有一个点的出度为0 （没有指向其他点的边），那么该点可以被所有点遍历到；反之，该图中没有可以被所有点遍历到的点。在有向图中，如果一个点可以被所有点遍历到，那么这个点的出度为0。可用反证法证明。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=21000,MAXM=51000;//*******************全局定义*******************int size[MAXN];int cnt;struct nod&#123; int hou; int dfn,low; bool v; int belg;&#125;p[MAXN];struct edge&#123; int x,y,g;&#125;e[MAXM];int ln;void ins(int x,int y)&#123; ln++; e[ln].x=x; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int sta[MAXN],top;int id;void tarjan(int x)&#123; sta[++top]=x;p[x].v=1; p[x].dfn=p[x].low=++id; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y),p[x].low=mymin(p[x].low,p[y].low); else if(p[y].v) p[x].low=mymin(p[x].low,p[y].dfn); &#125; if(p[x].dfn==p[x].low) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].belg=cnt; size[cnt]++; p[t].v=0; if(t==x) break; &#125; &#125;&#125;//*******************主函数*******************int out[MAXN];int main()&#123; int T=1;//scanf("%d",&amp;T); while(T--) &#123; memset(p,0,sizeof(p)); memset(size,0,sizeof(size)); cnt=ln=id=0; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); ins(x,y); &#125; top=0; for(int i=1;i&lt;=n;i++) if(p[i].dfn==0) tarjan(i); memset(out,0,sizeof(out)); for(int i=1;i&lt;=ln;i++) &#123; int x=p[e[i].x].belg,y=p[e[i].y].belg; if(x!=y) out[x]++; &#125; int b=0,ans; for(int i=1;i&lt;=cnt;i++) if(out[i]==0) b++,ans=size[i]; if(b!=1) printf("0\n"); else printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hdu2767】Proving Equivalences]]></title>
    <url>%2Fposts%2F1075.html</url>
    <content type="text"><![CDATA[来源和评测点Hdu2767显然我没看懂原题目……Caioj1148 题目【题目大意】给出一个有向图有n个点和m条有向边，问加上最少的边，使它成为一个强连通图。（什么是强连通图：任意两个点都能连通的）【输入格式】第一行一个整数N（1≤N≤100）表示下来有N组数据。每组数据第一行为两个整数n(1≤n≤20000)和m(0≤m≤50000)，表示n个点和m条有向边。下来m行，每行两个整数x和y，表示一条x到y的有向边(1≤x,y≤n且x!=y)。【输出格式】每组数据输出一行，一个整数，表示最少需要添加的有向边的数目。【输入样例】24 03 21 21 3【输出样例】42 刷题记录30min1RE7WA2AC 分析缩点后，统计max（入度=0，出度=0）即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=21000,MAXM=51000;//*******************全局定义*******************int cnt;struct nod&#123; int hou; int dfn,low; bool v; int belg;&#125;p[MAXN];struct edge&#123; int x,y,g;&#125;e[MAXM];int ln;void ins(int x,int y)&#123; ln++; e[ln].x=x; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int sta[MAXN],top;int id;void tarjan(int x)&#123; sta[++top]=x;p[x].v=1; p[x].dfn=p[x].low=++id; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y),p[x].low=mymin(p[x].low,p[y].low); else if(p[y].v) p[x].low=mymin(p[x].low,p[y].dfn); &#125; if(p[x].dfn==p[x].low) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].belg=cnt; p[t].v=0; if(t==x) break; &#125; &#125;&#125;//*******************主函数*******************int in[MAXN],out[MAXN];int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; memset(p,0,sizeof(p)); cnt=ln=id=0; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); ins(x,y); &#125; top=0; for(int i=1;i&lt;=n;i++) if(p[i].dfn==0) tarjan(i); if(cnt==1)//debug &#123; printf("0\n"); continue; &#125; memset(in,0,sizeof(in)); memset(out,0,sizeof(out)); for(int i=1;i&lt;=ln;i++) &#123; int x=p[e[i].x].belg,y=p[e[i].y].belg; if(x!=y) &#123; out[x]++; in[y]++; &#125; &#125; int a=0,b=0; for(int i=1;i&lt;=cnt;i++) &#123; if(in[i]==0) a++; if(out[i]==0) b++; &#125; printf("%d\n",mymax(a,b)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Vijos1023】Victoria的舞会3]]></title>
    <url>%2Fposts%2Fa373.html</url>
    <content type="text"><![CDATA[来源和评测点Vijos1023 题目【题目大意】Victoria准备邀请n个已经确定的人，可是问题来了：这n个人每一个人都有一个小花名册，名册里面写着他能够通知到的人的名字。比如说在A的人名单里写了B，那么表示A能够通知到B；但是B的名单里不见的有A，也就是说B不见得通知到A。Victoria觉得需要确定自己需要通知多少个人m，能够实际将所有人n都通知到。并求出一种方案以确定m的最小值是多少。注意：自己的名单里面不会有自己的名字。Victoria可以自身通知到所有n个人。【输入格式】第一行一个数n。接下来n行，每i+1行表示编号为i的人的小花名册名单，名单以0结束。1&lt;=n&lt;=200。【输出格式】仅一行，如无解则输出‘NO’；否则输出最小的k的值。【输入样例】18011 000016 014 00002 13 0011 07 006 000【输出样例】14 刷题记录30min1WA1AC 分析强连通分量裸题缩点后，统计入度=0即可 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=210,MAXM=41000;//*******************全局定义*******************int cnt=0;int ru[MAXN];struct nod&#123; int hou; int dfn,low; bool v; int belg; nod() &#123; hou=0; dfn=0; v=0; &#125;&#125;p[MAXN];struct edge&#123; int x,y,g;&#125;e[MAXM];int ln=0;void ins(int x,int y)&#123; ln++; e[ln].x=x; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int sta[MAXN],top=0;int id=0;void tarjan(int x)&#123; sta[++top]=x;p[x].v=1; p[x].dfn=p[x].low=++id; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y),p[x].low=mymin(p[x].low,p[y].low); else if(p[y].v) p[x].low=mymin(p[x].low,p[y].dfn); &#125; if(p[x].dfn==p[x].low) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].belg=cnt; p[t].v=0; if(t==x) break; &#125; &#125;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; while(1) &#123; int x;scanf("%d",&amp;x); if(x==0) break; ins(i,x); &#125; &#125; for(int i=1;i&lt;=n;i++) if(p[i].dfn==0) tarjan(i); for(int i=1;i&lt;=ln;i++) &#123; int x=e[i].x,y=e[i].y; if(p[x].belg==p[y].belg) continue; ru[p[y].belg]++; &#125; int ans=0; for(int i=1;i&lt;=cnt;i++) if(ru[i]==0) ans++;//debug printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Vijos1094】关系运算图]]></title>
    <url>%2Fposts%2Fe843.html</url>
    <content type="text"><![CDATA[来源和评测点Vijos1094 题目【题目大意】给出一有向图，图中每条边都被标上了关系运算符‘&lt;’,‘&gt;’,‘=’。现在要给图中每个顶点标上一个大于等于0,小于等于k的某个整数使所有边上的符号得到满足。若存在这样的k，则求最小的k，若任何k都无法满足则输出NO。例如下表中最小的k为2。结点1&gt;结点2结点2&gt;结点3结点2&gt;结点4结点3=结点4如果存在这样的k，输出最小的k值；否则输出‘NO’。【输入格式】共二行，第一行有二个空格隔开的整数n和m。n表示G的结点个数，m表示G的边数，其中1&lt;=n&lt;=1000, 0&lt;=m&lt;=10000。全部结点用1到n标出，图中任何二点之间最多只有一条边，且不存在自环。第二行共有3m个用空格隔开的整数，第3i-2和第3i-1（1&lt;=i&lt;=m）个数表示第i条边的顶点。第3i个数表示第i条边上的符号，其值用集合{-1，0，1}中的数表示：-1表示‘&lt;’, 0 表示‘=’, 1表示‘&gt;’。【输出格式】仅一行，如无解则输出‘NO’；否则输出最小的k的值。【输入样例】4 41 2 -1 2 3 0 2 4 -1 3 4 -1【输出样例】2 刷题记录30min4WA2AC 分析d[i]&lt;d[j]d[i]&lt;=d[j]-1ins(j,i,-1) d[i]=d[j]ins(j,i,0)ins(j,i,0) d[i]&gt;d[j]d[i]&gt;=d[j]+1d[j]&lt;=d[i]-1ins(i,j,-1) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=1100,MAXM=21000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int hou; int v; int r; int d; nod() &#123; hou=v=r=0; d=INF; &#125;&#125;p[MAXN];struct edge&#123; int y,c,g;&#125;e[MAXM];int ln=0;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y; e[ln].c=c; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int n,m;int mx=0,mi=0;int lst[MAXN];bool spfa(int st)&#123; int top=0; lst[++top]=st; p[st].v=1;p[st].r=1;p[st].d=0; while(top&gt;0) &#123; int x=lst[top--]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].d&gt;p[x].d+e[k].c) &#123; p[y].d=p[x].d+e[k].c; if(p[y].v==0) &#123; p[y].v=1; p[y].r++; if(p[y].r&gt;n) return 0; lst[++top]=y; &#125; &#125; &#125; p[x].v=0; &#125; return 1;&#125;bool check()&#123; for(int i=1;i&lt;=n;i++) if(p[i].r==0) if(!spfa(i)) return 0; for(int i=1;i&lt;=n;i++) mi=mymin(mi,p[i].d); return 1;&#125;//*******************主函数*******************int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); if(c&lt;0) ins(y,x,-1); if(c==0) ins(x,y,0),ins(y,x,0); if(c&gt;0) ins(x,y,-1); &#125; if(!check()) printf("NO"); else printf("%d",-mi);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj1716】差分约束4整数区间]]></title>
    <url>%2Fposts%2F75d0.html</url>
    <content type="text"><![CDATA[来源和评测点Poj1716Caioj1403 题目【题目大意】给出n个区间，每个区间内至少有两个数被选中，问最少需要选出多少个数【输入格式】第一行：一个整数n(1&lt;=n&lt;=10000)接下来n行：每行两个数a,b(0&lt;=a&lt;b&lt;=10000)，表示一个区间的开始点和结束点【输出格式】第一行：一个整数，表示最少选出多少个数若出现了负环，只需要输出”-1”（不包含括号）【输入样例】43 62 40 24 7【输出样例】4 刷题记录30min无数TLE caioj真的恶心不用栈并且全部放入而是用队列或者spfa全优化都过不了-1的一个点 分析s[b]-s[a-1]&gt;=22&lt;=s[b]-s[a-1]s[a-1]&lt;=s[b]-2 s[i]-s[i-1]&lt;=1s[i]&lt;=s[i-1]+1 s[i]-s[i-1]&gt;=0s[i-1]&lt;=s[i] ans:s[mx]-s[mi] 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=51000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int hou; bool v; int r; int s;&#125;p[MAXN];struct edge&#123; int y,c,g;&#125;e[MAXN*3];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y; e[ln].c=c; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int lst[MAXN];bool spfa(int st,int n)&#123; int tou=1,wei=2; p[st].s=0;p[st].v=1; lst[tou]=st;//边是从高往低建的 while(tou!=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].s&gt;p[x].s+e[k].c) &#123; p[y].s=p[x].s+e[k].c; if(p[y].v==0) &#123; p[y].v=1; p[y].r++; if(p[y].r&gt;n-1) return 0; lst[wei++]=y;if(wei==MAXN) wei=1; &#125; &#125; &#125; p[x].v=0; tou++;if(tou==MAXN) tou=1; &#125; return 1;&#125;int mi,mx;bool check()&#123; for(int i=mi;i&lt;=mx;i++) if(p[i].r==0) if(!spfa(i,mx-mi+1)) return 0; return 1;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); mx=-INF;mi=INF;ln=0; for(int i=0;i&lt;=MAXN-1;i++) &#123; p[i].hou=0; p[i].r=p[i].v=0; p[i].s=INF; &#125; for(int i=1;i&lt;=n;i++) &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); a++;b++;//debug ins(b,a-1,-2); mi=mymin(mi,a-1);mx=mymax(mx,b); &#125; for(int i=mi+1;i&lt;=mx;i++) &#123; ins(i-1,i,1); ins(i,i-1,0); &#125; if(spfa(mx,mx-mi+1)) printf("%d",p[mx].s-p[mi].s); else printf("-1");&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1402】差分约束3消息可靠吗]]></title>
    <url>%2Fposts%2F3a06.html</url>
    <content type="text"><![CDATA[来源和评测点Caioj1402 题目【题目大意】给出n个点和m条约束信息。信息表述为(P a b c)表示a在b北方距离c单位的位置，或者(V a b)表示a在b的北方。问是否可能存在符合以上m个要求的点【输入格式】第一行：两个整数n和m,(0&lt;n&lt;=1000),(1&lt;=M&lt;=100000)接下来m行：每行输入(P a b c)或者(V a b)，意思如上所示多组数据，当n=0时结束【输出格式】若存在这样的点则输出”Reliable”（不包含括号），不存在输出”Unreliable”（不包含括号）【输入样例】3 4P 1 2 1P 2 3 1V 1 3P 1 3 15 5V 1 2V 2 3V 3 4V 4 5V 3 50【输出样例】UnreliableReliable 刷题记录30min6TLE1WA1AC 分析p1s[a]-s[b]&lt;=cs[a]&lt;=s[b]+cp2s[a]-s[b]&gt;=cc&lt;=s[a]-s[b]s[b]&lt;=s[a]-cvs[a]&gt;s[b]s[a]&gt;=s[b]+1s[b]&lt;=s[a]-1 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=51000,MAXM=310000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int hou; bool v; int r; int s;&#125;p[MAXN];struct edge&#123; int y,c,g;&#125;e[MAXM];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y; e[ln].c=c; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int lst[MAXN];bool spfa(int st,int n)&#123; int tou=1,wei=2; p[st].s=0;p[st].v=1; lst[tou]=st;//边是从高往低建的 while(tou!=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].s&gt;p[x].s+e[k].c) &#123; p[y].s=p[x].s+e[k].c; if(p[y].v==0) &#123; p[y].v=1; p[y].r++; if(p[y].r&gt;n-1) return 0; lst[wei++]=y;if(wei==MAXN) wei=1; &#125; &#125; &#125; p[x].v=0; tou++;if(tou==MAXN) tou=1; &#125; return 1;&#125;int mi,mx;bool check()&#123; for(int i=mi;i&lt;=mx;i++) if(p[i].r==0) if(!spfa(i,mx-mi+1)) return 0; return 1;&#125;//*******************主函数*******************char s[20];int main()&#123; int n,m; while(scanf("%d",&amp;n) and n&gt;0) &#123; scanf("%d",&amp;m); mx=-INF;mi=INF;ln=0; for(int i=0;i&lt;=MAXN-1;i++) &#123; p[i].hou=0; p[i].r=p[i].v=0; p[i].s=INF; &#125; bool bk=1; for(int i=1;i&lt;=m;i++) &#123; int a,b;scanf("%s%d%d",s,&amp;a,&amp;b); if(s[0]=='P') &#123; int c;scanf("%d",&amp;c); if(a==b and c&gt;0) bk=0; ins(b,a,c);ins(a,b,-c); &#125; else &#123; if(a==b) bk=0; ins(a,b,-1); &#125; mi=mymin(mi,mymin(a,b)); mx=mymax(mx,mymax(a,b)); &#125; if(bk and check()) printf("Reliable\n"); else printf("Unreliable\n"); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF#469Div2-C】Zebras]]></title>
    <url>%2Fposts%2F8404.html</url>
    <content type="text"><![CDATA[来源和评测点Codeforces Round #469 (Div.2)CF#469Div2-C 题目【题目大意】Zebra:0和1交替出现，开头结尾都是0。给出字符串，分割成子序列（不一定连续），必须每一个都是Zebra【输入格式】只有一行，01字符串无解输出-1【约束条件】长度不超过200000【输出格式】有spj第一行子序列个数每行开头，当前子序列长度，然后是由哪些位置组成以上按照从小到大排序【输入样例】0010100【输出样例】33 1 3 43 2 5 61 7 刷题记录1h1WA1TLE比完赛后1RE1AC 分析我打了个很丑的暴力，然后是一个个子序列寻找的，超慢然后根本没考虑过可以跑一遍过重点是STL的妙用，确保正确性，同时动态空间 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;using namespace std;//*******************全局常量*******************//*******************全局定义*******************char s[200010];vector&lt;int&gt; f[200010];set&lt;int&gt; s0,s1;int n,m;//*******************实现*******************bool solve()&#123; for(int i=1;i&lt;=n;i++) &#123; if(s[i]=='0') &#123; if(s1.empty()) &#123; f[++m].push_back(i); s0.insert(m); &#125; else &#123; int x=*s1.begin(); f[x].push_back(i); s1.erase(x); s0.insert(x); &#125; &#125; else &#123; if(s0.empty()) return 0; int x=*s0.begin(); f[x].push_back(i); s0.erase(x); s1.insert(x); &#125; &#125; if(!s1.empty()) return 0; return 1;&#125;void output()&#123; printf("%d\n",m); for(int i=1;i&lt;=m;i++) &#123; printf("%d ",f[i].size()); for(int j=0;j&lt;=f[i].size()-1;j++) printf("%d ",f[i][j]); printf("\n"); &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%s",s+1); n=strlen(s+1);m=0; if(solve()) output(); else printf("-1\n");&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj1364】差分约束2国王]]></title>
    <url>%2Fposts%2F34e8.html</url>
    <content type="text"><![CDATA[来源和评测点Poj1364Caioj1401 题目【题目大意】给出不超过n的数和m个关系。然后给出ai,bi，接着输入gt或者lt，最后给出di。它们分别表示从a[ai]开始a[ai]+a[ai+1]+…+a[ai+bi]这些数的和小于(lt)di或大于(gt)di。问是否存在满足m个关系的数列【输入格式】第一行：两个整数n和m(0&lt;n&lt;=100),(0&lt;m&lt;=100)接下来m行：每行输入ai,bi,gt或者lt,di多组数据，当n=0时结束【输出格式】若存在这样的数列则输出”lamentable kingdom”（不包含引号），否则输出”successful conspiracy”（不包含引号）。【输入样例】4 21 2 gt 02 2 lt 21 21 0 gt 01 0 lt 00【输出样例】lamentable kingdomsuccessful conspiracy 刷题记录20min 分析lt:s[a+b]-s[a-1]&lt;ds[a+b]-s[a-1]&lt;=d-1s[a+b]&lt;=s[a-1]+d-1gt:s[a+b]-s[a-1]&gt;ds[a+b]-s[a-1]&gt;=d+1d+1&lt;=s[a+b]-s[a-1]s[a-1]&lt;=s[a+b]-d-1 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=51000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int hou; bool v; int r; int s;&#125;p[MAXN];struct edge&#123; int y,c,g;&#125;e[MAXN*3];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y; e[ln].c=c; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int lst[MAXN];bool spfa(int st,int n)&#123; int tou=1,wei=2; p[st].s=0;p[st].v=1; lst[tou]=st;//边是从高往低建的 while(tou!=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].s&gt;p[x].s+e[k].c) &#123; p[y].s=p[x].s+e[k].c; if(p[y].v==0) &#123; p[y].v=1; p[y].r++; if(p[y].r&gt;n-1) return 0; lst[wei++]=y;if(wei==MAXN) wei=1; &#125; &#125; &#125; p[x].v=0; tou++;if(tou==MAXN) tou=1; &#125; return 1;&#125;int mi,mx;bool check()&#123; for(int i=mi;i&lt;=mx;i++) if(p[i].r==0) if(!spfa(i,mx-mi+1)) return 0; return 1;&#125;//*******************主函数*******************char s[20];int main()&#123; int n,m; while(scanf("%d",&amp;n) and n&gt;0) &#123; scanf("%d",&amp;m); mx=-INF;mi=INF;ln=0; for(int i=0;i&lt;=n;i++) &#123; p[i].hou=0; p[i].r=p[i].v=0; p[i].s=INF; &#125; for(int i=1;i&lt;=m;i++) &#123; int a,b,d;scanf("%d%d%s%d",&amp;a,&amp;b,s,&amp;d); if(s[0]=='l') ins(a-1,a+b,d-1); else ins(a+b,a-1,-d-1); mi=mymin(mi,a-1);mx=mymax(mx,a+b); &#125; if(check()) printf("lamentable kingdom\n"); else printf("successful conspiracy\n"); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1400】差分约束1区间]]></title>
    <url>%2Fposts%2Fa10d.html</url>
    <content type="text"><![CDATA[来源和评测点Caioj1400 题目【题目大意】给出n个区间，每个整数区间ai~bi中至少有ci个点。求整个区间中最少的点数【输入格式】第一行：一个整数n(1&lt;=n&lt;=50000)接下来n行每行三个整数ai,bi,ci（0&lt;=ai&lt;=bi&lt;=50000）,（1&lt;=ci&lt;=bi-ai+1）【输出格式】一个整数，表示整个区间中最少有多少个点【输入样例】53 7 38 10 36 8 11 3 110 11 1【输出样例】6 刷题记录20min 分析令s[i]=1~i的数量约束条件：s[i]-s[i-1]&gt;=0s[i]-s[i-1]&lt;=1s[b]-s[a-1]&gt;=c对应最短路中的松弛操作即d[j]&lt;=d[i]+c[k] ins(i,j,c[k])现在条件变成s[i-1]&lt;=s[i] ins(i,i-1,0)s[i]&lt;=s[i-1]+1 ins(i-1,i,1)s[a-1]&lt;=s[b]-c ins(b,a-1,-c)以前让d[i]最小现在让s[i]最小 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=51000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int hou; bool v; int r; int s; nod() &#123; hou=r=v=0; s=INF; &#125;&#125;p[MAXN];struct edge&#123; int y,c,g;&#125;e[MAXN*3];int ln=0;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y; e[ln].c=c; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int mi=INF,mx=-INF;int lst[MAXN];bool spfa()&#123; int tou=1,wei=2; p[mx].s=0;p[mx].v=1; lst[tou]=mx;//边是从高往低建的 while(tou!=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].s&gt;p[x].s+e[k].c) &#123; p[y].s=p[x].s+e[k].c; if(p[y].v==0) &#123; p[y].v=1; p[y].r++; if(p[y].r&gt;mx-mi) return 0;//n-1=mx-mi+1-1 lst[wei++]=y; if(wei==MAXN) wei=1; &#125; &#125; &#125; tou++;p[x].v=0; if(tou==MAXN) tou=1; &#125; return 1;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int a,b,c;scanf("%d%d%d",&amp;a,&amp;b,&amp;c); ins(b,a-1,-c); mi=mymin(mi,a-1);mx=mymax(mx,b); &#125; for(int i=mi+1;i&lt;=mx;i++) &#123; ins(i-1,i,1); ins(i,i-1,0); &#125; if(spfa()) printf("%d\n",p[mx].s-p[mi].s);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3932】【Luogu3168】任务查询系统]]></title>
    <url>%2Fposts%2F9028.html</url>
    <content type="text"><![CDATA[来源和评测点CQOI2015Bzoj3932Luogu3168 题目【题目大意】电脑有n个任务需要执行，任务i在si到ei时正在工作，优先级为p给m个询问，每个询问给出一个时间点xi和一个数ki。问在xi这个时间点时，所有正在工作的任务中优先级从小到大排列，前ki个的优先级之和是多少【输入格式】输入文件第一行包含两个空格分开的正整数m和n，分别表示任务总数和时间范围。接下来m行，每行包含三个空格分开的正整数Si、Ei和Pi(Si&lt;=Ei)，描述一个任务。接下来n行，每行包含四个空格分开的整数Xi、Ai、Bi和Ci，描述一次查询。查询的参数Ki需要由公式 Ki=1+(Ai*Pre+Bi) mod Ci计算得到。其中Pre表示上一次查询的结果，对于第一次查询，Pre=1。1&lt;=m,n,Si,Ei,Ci&lt;=100000，0&lt;=Ai,Bi&lt;=100000，1&lt;=Pi&lt;=10000000，Xi为1到n的一个排列【输出格式】输出共n行，每行一个整数，表示查询结果。【输入样例】4 31 2 62 3 31 3 23 3 43 1 3 21 1 3 42 2 4 3【输出样例】2811 刷题记录分析把每一秒看作一个操作来可持续化好吧其实就是有着权值线段树的前缀和 然鹅，这题居然不卡暴力……基于【面向数据编程】和【以题目为导向】，暂时就不写正解了，精A飘过 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int qread1(void)&#123; char c=getchar();int d=0; while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') d=d*10+c-'0',c=getchar(); return d;&#125;ll qread2(void)&#123; char c=getchar();ll d=0; while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') d=d*10+c-'0',c=getchar(); return d;&#125;//*******************全局常量*******************const int MAXN=110000;//*******************全局定义*******************struct nod&#123; int a,b; ll c;&#125;p[MAXN];bool operator &lt; (nod x,nod y)&#123; return x.c&lt;y.c;&#125;//*******************实现*******************//*******************主函数*******************int main()&#123; int m,n;scanf("%d%d",&amp;m,&amp;n); for(int i=1;i&lt;=m;i++) p[i].a=qread1(),p[i].b=qread1(),p[i].c=qread2(); sort(p+1,p+1+m); ll pre=1; for(int i=1;i&lt;=n;i++) &#123; int x=qread1();ll a=qread2(),b=qread2(),c=qread2(); ll k=1+(a*pre+b)%c;pre=0; for(int i=1,j=0;i&lt;=m and j&lt;k;i++) if(p[i].a&lt;=x and x&lt;=p[i].b) pre+=p[i].c,j++; printf("%lld\n",pre); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC063-E】木と整数]]></title>
    <url>%2Fposts%2Fe20b.html</url>
    <content type="text"><![CDATA[来源和评测点ARC063-E 题目【题目大意】给出一棵N个节点的数，标号从1到N，第i(1≦i≦N−1)条边连接Ai和Bi。Takahashi给K个节点填上数字，其它节点留空。Aoki想把剩下的节点填好，并满足以下条件：任意两个由一条边直接连接的节点，上面的数字差是1。如果有多个解，输出一个即可。Aoki填上的数字可能是负数或者比10^6大。【输入格式】NA1 B1A2 B2:AN−1 BN−1KV1 P1V2 P2:VK PK【约束条件】1≦N≦10^51≦K≦N1≦Ai,Bi≦N (1≦i≦N−1)1≦Vj≦N (1≦j≦K)0≦Pj≦10^5 (1≦j≦K)给出的图一定是树。所有vj不重复。【输出格式】用Yes或No表示是否有解。如果有，输出N行，表示那个节点的某个合法值。【输入样例】51 23 14 33 522 65 7【输出样例】Yes56657 刷题记录1h2RE1AC 分析维护一个有效的范围和奇偶性，树形DP即可然后数组漏了个0是什么鬼…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=110000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int hou; int val; int mi,mx; int jo;//-1,0,1&#125;p[MAXN];struct edge&#123; int y,g;&#125;e[2*MAXN];//*******************实现*******************int ln=0;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;bool bk=1;void dfs(int x,int fa)&#123; if(bk==0) return; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y==fa) continue; dfs(y,x); if(p[x].jo!=-1 and p[x].jo==p[y].jo) &#123; bk=0; return; &#125;//本来相邻或者递推得来 p[x].mi=mymax(p[x].mi,p[y].mi-1); p[x].mx=mymin(p[x].mx,p[y].mx+1); if(p[y].jo!=-1) p[x].jo=p[y].jo^1;//信息的合并 &#125; if(p[x].jo!=-1 and p[x].mi==p[x].mx and p[x].mi%2!=p[x].jo) &#123; bk=0; return; &#125;//检查 if(p[x].mi&gt;p[x].mx) &#123; bk=0; return; &#125;&#125;void dfs2(int x,int fa)&#123; if(p[x].val==-1) &#123; if(fa==0) &#123; if(p[x].mi%2==p[x].jo) p[x].val=p[x].mi; else p[x].val=p[x].mi+1; &#125; else &#123; if(p[x].mi&lt;=p[fa].val-1 and p[fa].val-1&lt;=p[x].mx) p[x].val=p[fa].val-1;//debug else p[x].val=p[fa].val+1; &#125; &#125; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y==fa) continue; dfs2(y,x); &#125;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; p[i].hou=0; p[i].val=-1; p[i].mi=-INF;p[i].mx=INF; p[i].jo=-1; &#125; for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; int k;scanf("%d",&amp;k); for(int i=1;i&lt;=k;i++) &#123; int a,b; scanf("%d%d",&amp;a,&amp;b); p[a].val=p[a].mi=p[a].mx=b; p[a].jo=b%2; &#125; dfs(1,0);//自下而上 if(bk==0) printf("No\n"); else &#123; printf("Yes\n"); dfs2(1,0);//自上而下 for(int i=1;i&lt;=n;i++) printf("%d\n",p[i].val); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj5072】小A的树]]></title>
    <url>%2Fposts%2F8843.html</url>
    <content type="text"><![CDATA[来源和评测点Lydsy十月月赛Bzoj5072 题目【题目大意】给出一棵n个点的树，每个点有黑白两种颜色。q次询问，每次询问给出x和y，问能否选出一个x个点的联通子图，使得其中黑点数目为y。【输入格式】第一行一个正整数T 表示数据组数。对于每一组数据，第一行有两个用空格隔开的正整数，分别是n 和q，表示树的节点数和询问次数。接下来n-1 行，每行两个用空格隔开的正整数ui和vi，表示ui和vi间有一条边相连。接下来一行有n 个用空格隔开的整数b1,b2,…bn，其中若bi=0，则表示第i个点为白色，否则为黑色。接下来q 行，每行两个用空格隔开的整数和，意义如Problem Statement中描述的x和y。T&lt;=5,n&lt;=5000,q&lt;=10^51&lt;=ui,vi&lt;=n,1&lt;=xi&lt;=n,0&lt;=yi&lt;=n,yi&lt;=xi【输出格式】对于每一组数据，输出q行，每行为“YES”或者“NO”（不含双引号），表示对于给定的和，能否满足小A 的要求。每相邻两组数据的输出之间空一行。【输入样例】19 44 11 51 23 23 66 76 89 60 1 0 1 0 0 1 0 13 27 34 09 5【输出样例】YESYESNONO第一组数据中，可以取子图{6,7,9}。第一组数据中，可以取子图{1,2,3,4,5,6,7,8}。而在第三、四组数据中，不存在符合题意的子图。 刷题记录1h2WA1AC 分析首先，我不会算时间复杂度，别人说是N^2然后有一个结论，我也不会证明，但随便举了个栗子，自以为是比较坏的情况就是：给出一棵树，在某个固定大小的联通块中，如果可以有最少L,最大R个黑点，则之间的也一定可以实现。栗子：R=L+2,m=L+1然后减少2白，增加2黑（删除2白和1黑+添加3黑=减少2白，增加2黑）那么也可以减少1白，增加1黑（删除1白和1黑+添加2黑=减少1白，增加1黑）那我觉得应该结论是对的……然后DP的时候注意一下后效性就好了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=5100;//*******************全局定义*******************struct nod&#123; int hou; bool cl; int tot;&#125;p[MAXN];int l[MAXN][MAXN],r[MAXN][MAXN];struct edge&#123; int y,g;&#125;e[MAXN*2];int ln;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************void dfs(int x,int fa)&#123; p[x].tot=1;l[x][1]=r[x][1]=p[x].cl; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y==fa) continue; dfs(y,x); for(int i=p[x].tot;i&gt;=1;i--)//debug后效性 &#123; for(int j=p[y].tot;j&gt;=1;j--)//debug后效性 &#123; l[x][i+j]=mymin(l[x][i+j],l[x][i]+l[y][j]); r[x][i+j]=mymax(r[x][i+j],r[x][i]+r[y][j]); &#125; &#125; p[x].tot+=p[y].tot; &#125; for(int i=1;i&lt;=p[x].tot;i++) &#123; l[0][i]=mymin(l[0][i],l[x][i]); r[0][i]=mymax(r[0][i],r[x][i]); &#125;&#125;//*******************主函数*******************int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; memset(l,63,sizeof(l)); memset(r,-63,sizeof(r)); int n,q;scanf("%d%d",&amp;n,&amp;q); ln=0;for(int i=1;i&lt;=n;i++) p[i].hou=0; for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i].cl); dfs(1,0); while(q--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); if(l[0][x]&lt;=y and y&lt;=r[0][x]) printf("YES\n"); else printf("NO\n"); &#125; printf("\n"); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3226】校门外的区间]]></title>
    <url>%2Fposts%2Fef13.html</url>
    <content type="text"><![CDATA[来源和评测点Sdoi2008Bzoj3226 从小白的角度解释本题 题目【题目大意】5种运算维护集合S(S初始为空)并最终输出S5种运算如下：U T：S、T并集I T：S、T交集D T：S独有C T：T独有S T：S独有 交 T独有【输入格式】输入共M行。每行的格式为X T，用一个空格隔开，X表示运算的种类，T为一个区间123450≤a≤b≤65535，1≤M≤70000**【输出格式】**共一行，即集合S，每个区间后面带一个空格。若S为空则输出&quot;empty set&quot;。**【输入样例】** U [1,5]D [3,3]S [2,4]C (1,5)I (2,3]12345678910111213141516**【输出样例】**(2,3) &lt;/p&gt;## 刷题记录1h3WA1PE1AC## 分析挺考验逻辑关系能力的首先，区间都是连续的。然后先消除区间表达法的多样性，可以考虑用t表示t/2，这样把区间统一转化，例如(2,5)变成```[2.5,4.5]```也就是```[5,9] 然后各种操作逐个击破U 区间1I 独有0D 区间0C 区间取反，其余0S 区间取反 各种max，min乱搞线段树维护就好了 格式错误的话，是因为我以为打空格的同时换行，当时就想为什么这么奇怪，原来不用换行。 然后WA的话，就是【可能我的方式太古怪了】除了打修改的时候删掉翻转外，【因为我是用父亲c更新儿子c的】，所以如果翻转之前有修改标记而且是统一的（不是-1），那么就不用往下打标记了 然后我的答案统计方式好像很独特啊，网上那些方法我看不懂…… 最后最后就是，无数次忘记，翻转标记要用异或更新。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;//*******************全局常量*******************//*******************全局定义*******************struct seg&#123; int l,r; int lc,rc; int c;//-1,0,1 bool tg1,tg2;&#125;p[310000];//*******************实现*******************int ln=0;int build(int l,int r)&#123; int t=++ln; p[t].l=l;p[t].r=r;p[t].c=0; p[t].tg1=p[t].tg2=0; if(l&lt;r) &#123; int mid=(l+r)/2; p[t].lc=build(l,mid); p[t].rc=build(mid+1,r); &#125; else p[t].lc=p[t].rc=0; return t;&#125;void update(int x)&#123; int lc=p[x].lc,rc=p[x].rc; if(p[lc].c==p[rc].c) p[x].c=p[lc].c; else p[x].c=-1;&#125;void maketg1(int x,int c)&#123; p[x].c=c; p[x].tg1=1; p[x].tg2=0;&#125;void maketg2(int x)&#123; if(p[x].c&gt;=0) p[x].c=1-p[x].c; if( !(p[x].tg1==1 and p[x].c&gt;=0) ) p[x].tg2^=1;//debug&#125;void pushdown(int x)&#123; int lc=p[x].lc,rc=p[x].rc; if(p[x].tg1&gt;0) &#123; p[x].tg1=0; if(lc&gt;0) maketg1(lc,p[x].c); if(rc&gt;0) maketg1(rc,p[x].c); &#125; if(p[x].tg2&gt;0) &#123; p[x].tg2=0; if(lc&gt;0) maketg2(lc); if(rc&gt;0) maketg2(rc); &#125;&#125;void change1(int x,int l,int r,int c)&#123; if(x==0 or l&gt;r) return; if(p[x].l==l and p[x].r==r) &#123; maketg1(x,c); return; &#125; pushdown(x); int mid=(p[x].l+p[x].r)/2; int lc=p[x].lc,rc=p[x].rc; if(r&lt;=mid) change1(lc,l,r,c); else if(l&gt;mid) change1(rc,l,r,c); else change1(lc,l,mid,c),change1(rc,mid+1,r,c); update(x);&#125;void change2(int x,int l,int r)&#123; if(x==0 or l&gt;r) return; pushdown(x);//debug if(p[x].l==l and p[x].r==r) &#123; maketg2(x); return; &#125; int mid=(p[x].l+p[x].r)/2; int lc=p[x].lc,rc=p[x].rc; if(r&lt;=mid) change2(lc,l,r); else if(l&gt;mid) change2(rc,l,r); else change2(lc,l,mid),change2(rc,mid+1,r); update(x);&#125;bool bk=0;void output(int a,int b)&#123; bk=1; if(a%2==0) printf("[%d,",a/2); else printf("(%d,",a/2); if(b%2==0) printf("%d] ",b/2); else printf("%d) ",b/2+1);&#125;int ll=-2,rr=-2;void ask(int x)&#123; if(x==0) return; if(p[x].c==1) &#123; int a=p[x].l,b=p[x].r; if(a&gt;rr+1) &#123; if(ll&gt;=0) output(ll,rr); ll=a; &#125; rr=b; &#125; if(p[x].c==-1) &#123; pushdown(x); ask(p[x].lc); ask(p[x].rc); &#125;&#125;//*******************主函数*******************int main()&#123; build(0,140000); //build(0,10); char s[5],c1,c2;int a,b; while(scanf("%s %c%d,%d%c",s,&amp;c1,&amp;a,&amp;b,&amp;c2)!=EOF and s[0]!='e') &#123; a*=2;if(c1=='(') a++; b*=2;if(c2==')') b--; if(s[0]=='U') &#123; change1(1,a,b,1); &#125; if(s[0]=='I') &#123; change1(1,0,a-1,0); change1(1,b+1,140000,0); //change1(1,b+1,10,0); &#125; if(s[0]=='D') &#123; change1(1,a,b,0); &#125; if(s[0]=='C') &#123; change1(1,0,a-1,0); change2(1,a,b); change1(1,b+1,140000,0); //change1(1,b+1,10,0); &#125; if(s[0]=='S') &#123; change2(1,a,b); &#125; &#125; ask(1);if(ll&gt;=0) output(ll,rr); if(bk==0) printf("empty set");&#125;/*U 区间1I 其余0D 区间0C 区间取反，其余0S 区间取反*/]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2733】【Luogu3224】永无乡]]></title>
    <url>%2Fposts%2F6053.html</url>
    <content type="text"><![CDATA[来源和评测点HNOI2012Bzoj2733Luogu3224 题目【题目大意】永无乡包含n座岛，编号从1到n，每座岛都有自己的独一无二的重要度，按照重要度可以将这n座岛排名，名次用1到n来表示。某些岛之间由巨大的桥连接，通过桥可以从一个岛到达另一个岛。如果从岛a出发经过若干座（含0座）桥可以到达岛b，则称岛a和岛b是连通的。现在有两种操作：B x y 表示在岛x与岛y之间修建一座新桥。Q x k 表示询问当前与岛x连通的所有岛中第k重要的是哪座岛，即所有与岛x连通的岛中重要度排名第k小的岛是哪座，请你输出那个岛的编号。【输入格式】输入文件第一行是用空格隔开的两个正整数 n 和 m，分别 表示岛的个数以及一开始存在的桥数。接下来的一行是用空格隔开的 n 个数，依次描述从岛 1 到岛 n 的重要度排名。随后的 m 行每行是用空格隔开的两个正整数 ai 和 bi，表示一开始就存 在一座连接岛 ai 和岛 bi 的桥。后面剩下的部分描述操作，该部分的第一行是一个正整数 q，表示一共有 q 个操作，接下来的 q 行依次描述每个操作，操作的格式如上所述，以大写字母 Q 或B 开始，后面跟两个不超过 n 的正整数，字母与数字以及两个数字之间用空格隔开。对于 20%的数据 n≤1000,q≤1000对于 100%的数据 n≤100000,m≤n，q≤300000【输出格式】对于每个 Q x k 操作都要依次输出一行，其中包含一个整数，表示所询问岛屿的编号。如果该岛屿不存在，则输出-1。【输入样例】5 14 3 2 5 11 27Q 3 2Q 2 1B 2 3B 1 5Q 2 1Q 2 4Q 2 3【输出样例】-12512 刷题记录1h1AC 分析并查集维护连通性权值线段树维护数量来找大小注意类似主席树的合并跑得还是很快的，至于别的解法，不管了就算被卡，在考场上也是很优秀的算法，因为代码复杂度很低 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;//*******************全局常量*******************const int MAXN=110000;//*******************全局定义*******************struct nod&#123; int lc,rc; int c;&#125;p[21*MAXN];int rt[MAXN];//*******************线段树*******************int ln=0;void change(int &amp;x,int l,int r,int pos)&#123; if(x==0) &#123; x=++ln; p[x].c=0; p[x].lc=p[x].rc=0; &#125; p[x].c++; if(l==r) return; int mid=(l+r)/2; if(pos&lt;=mid) change(p[x].lc,l,mid,pos); else change(p[x].rc,mid+1,r,pos);&#125;void merg(int x,int &amp;y)&#123; if(x==0) return; if(y==0) &#123;y=x;return;&#125; p[y].c+=p[x].c; merg(p[x].lc,p[y].lc); merg(p[x].rc,p[y].rc);&#125;int find(int x,int l,int r,int k)&#123; if(k==0 or k&gt;p[x].c) return 0; if(l==r) return l; int mid=(l+r)/2,lc=p[x].lc; if(k&lt;=p[lc].c) return find(p[x].lc,l,mid,k); return find(p[x].rc,mid+1,r,k-p[lc].c);&#125;//*******************并查集*******************int fa[MAXN];int findfa(int x)&#123; if(fa[x]==x) return x; return fa[x]=findfa(fa[x]);&#125;void join(int x,int y)&#123; int fx=findfa(x),fy=findfa(y); if(fx!=fy) &#123; fa[fx]=fy; merg(rt[fx],rt[fy]); &#125;&#125;//*******************主函数*******************int id[MAXN],id2[MAXN];int main()&#123; memset(rt,0,sizeof(rt)); int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;id[i]); fa[i]=i;id2[id[i]]=i; change(rt[i],1,n,id[i]); &#125; id2[0]=-1; while(m--) &#123; int a,b; scanf("%d%d",&amp;a,&amp;b); join(a,b); &#125; int q;scanf("%d",&amp;q); while(q--) &#123; char s[20];int a,b; scanf("%s%d%d",s,&amp;a,&amp;b); if(s[0]=='B') join(a,b); else printf("%d\n",id2[ find(rt[ findfa(a) ],1,n,b) ]); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1500】【Luogu2042】维修数列]]></title>
    <url>%2Fposts%2Fd303.html</url>
    <content type="text"><![CDATA[来源和评测点NOI2005Bzoj1500Luogu2042Caioj1136 题目【题目大意】请写一个程序，要求维护一个数列，支持以下 6 种操作：请注意，格式栏 中的下划线‘_’表示实际输入文件中的空格【输入格式】输入的第1 行包含两个数N 和M(M ≤20000)，N 表示初始时数列中数的个数，M表示要进行的操作数目。第2行包含N个数字，描述初始时的数列。以下M行，每行一条命令，格式参见问题描述中的表格。任何时刻数列中最多含有500000个数，数列中任何一个数字均在[-1000,1000]内。插入的数字总数不超过4000000个，输入文件大小不超过20MBytes。【输出格式】对于输入数据中的GET-SUM和MAX-SUM操作，向输出文件依次打印结果，每个答案（数字）占一行。【输入样例】9 82 -6 3 5 1 -5 -3 6 3GET-SUM 5 4MAX-SUMINSERT 8 3 -5 7 2DELETE 12 1MAKE-SAME 3 3 2REVERSE 3 6GET-SUM 5 4MAX-SUM【输出样例】-110110 刷题记录9h12WA1AC 分析https://www.luogu.org/blog/IAmHellWord/solution-p2042 总结而言，这道题比序列操作相比多了添加、翻转和删除，于是也就从线段树变成了伸展树如果不会翻转的话可以看看文艺平衡树 这次依然是刚开始没有头绪，去膜了上面那个题解，但其实也不过如此，优化一下空间复杂度就好了。 或许是综合性强吧，然后年份也比较早，也是一道比较骚的数据结构题具体做法我就不造轮子了，上面那个真的不错，我重写也不过如此 代码1无语了答案正确但灰常慢的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=510000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int son[2],f; int d;//debug int lmx,rmx;//用于更新 int mx; int sum; int c; int tg1,tg1n; int tg2; nod() &#123; son[0]=son[1]=f=0; lmx=rmx=mx=0; sum=d=0;c=0; tg1=tg2=0; &#125;&#125;p[MAXN];void clear(int x)&#123; p[x].son[0]=p[x].son[1]=p[x].f=0; p[x].lmx=p[x].rmx=p[x].mx=0; p[x].sum=p[x].d=0; p[x].c=0; p[x].tg1=p[x].tg2=0;&#125;//*******************Splay*******************void pushdown(int x)&#123; if(x==0) return; int lc=p[x].son[0],rc=p[x].son[1]; if(p[x].tg1) &#123; p[x].tg1=0;p[x].tg2=0; p[x].d=p[x].tg1n; p[x].sum=p[x].c*p[x].tg1n; if(p[x].tg1n&lt;0) &#123; p[x].mx=p[x].tg1n; p[x].lmx=p[x].rmx=0;//debug &#125; else p[x].lmx=p[x].rmx=p[x].mx=p[x].sum; p[lc].tg1=p[rc].tg1=1; p[lc].tg1n=p[rc].tg1n=p[x].tg1n; p[lc].tg2=p[rc].tg2=0; &#125; if(p[x].tg2) &#123; p[x].tg2=0; swap(p[x].lmx,p[x].rmx); swap(p[x].son[0],p[x].son[1]); pushdown(lc);pushdown(rc); p[lc].tg2^=1;p[rc].tg2^=1;//debug &#125;&#125;void update(int x)//关键debug&#123; if(x==0) return; if(p[0].mx!=0 or p[0].sum!=0) printf("error!"); int lc=p[x].son[0],rc=p[x].son[1]; pushdown(lc);pushdown(rc); p[x].c=p[lc].c+1+p[rc].c; p[x].sum=p[lc].sum+p[x].d+p[rc].sum; p[x].lmx=mymax(p[lc].lmx,p[lc].sum+p[x].d); if(rc&gt;0) p[x].lmx=mymax(p[x].lmx,p[lc].sum+p[x].d+p[rc].lmx); p[x].rmx=mymax(p[rc].rmx,p[x].d+p[rc].sum); if(lc&gt;0) p[x].rmx=mymax(p[x].rmx,p[lc].rmx+p[x].d+p[rc].sum); p[x].mx=p[x].d; if(lc&gt;0) p[x].mx=mymax( mymax(p[x].mx,p[lc].mx),p[lc].rmx+p[x].d ); if(rc&gt;0) p[x].mx=mymax( mymax(p[x].mx,p[rc].mx),p[x].d+p[rc].lmx ); if(lc&gt;0 and rc&gt;0) p[x].mx=mymax( p[x].mx,p[lc].rmx+p[x].d+p[rc].lmx );&#125;void rotate(int x,int w)&#123; int f=p[x].f,ff=p[f].f; if(p[ff].son[0]==f) p[ff].son[0]=x; else p[ff].son[1]=x; p[x].f=ff; int xson=p[x].son[w]; p[f].son[1-w]=xson; if(xson&gt;0) p[xson].f=f; p[x].son[w]=f; p[f].f=x; update(f); update(x);&#125;int root;int lst[MAXN];void splay(int x,int rt)&#123; int t=0,i=x; while(p[i].f!=rt) lst[++t]=i,i=p[i].f; lst[++t]=rt; while(t&gt;0) pushdown(lst[t--]); while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(rt==ff) &#123; if(p[f].son[0]==x) rotate(x,1); else rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==0) root=x;&#125;int findbyrk(int rk)&#123; int x=root; while(1) &#123; pushdown(x);//!!! int lc=p[x].son[0]; if(rk&lt;=p[lc].c) x=lc; else if(rk&gt;p[lc].c+1) rk-=p[lc].c+1,x=p[x].son[1];//debug else break; &#125; splay(x,0); return x;&#125;//*******************动态分配*******************queue&lt;int&gt; q;int cnt;int getid()&#123; int t; if(!q.empty()) t=q.front(),q.pop(); else t=++cnt; return t;&#125;void del(int x)&#123; if(x==0) return; del(p[x].son[0]); del(p[x].son[1]); q.push(x);clear(x);&#125;//*******************建树*******************int nm[MAXN];int build(int l,int r,int f)//借鉴线段树&#123; if(l&gt;r) return 0; int t=getid(); p[t].f=f;p[t].tg1=p[t].tg2=0; if(l==r) &#123; p[t].son[0]=p[t].son[1]=0;p[t].c=1; p[t].d=p[t].lmx=p[t].rmx=p[t].mx=p[t].sum=nm[l];//debug &#125; else &#123; int mid=(l+r)/2; p[t].d=nm[mid];//debug p[t].son[0]=build(l,mid-1,t); p[t].son[1]=build(mid+1,r,t); update(t); &#125; return t;&#125;//*******************主函数*******************char s[20];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=2;i&lt;=n+1;i++) scanf("%d",&amp;nm[i]); nm[1]=0;nm[n+2]=0;//!!! p[0].lmx=p[0].rmx=-INF;//debug cnt=0;root=build(1,n+2,0); while(m--) &#123; scanf("%s",s); if(s[0]=='I')//INSERT &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1后 for(int i=1;i&lt;=ct;i++) scanf("%d",&amp;nm[i]); int l=findbyrk(k+1),r=findbyrk(k+2); splay(l,r);//debug p[l].son[1]=build(1,ct,l); update(l);update(r); &#125; if(s[0]=='D')//DELETE &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1~k+ct int l=findbyrk(k),r=findbyrk(k+ct+1); splay(l,r);//debug del(p[l].son[1]);//debug p[l].son[1]=0; update(l);update(r); &#125; if(s[2]=='K')//MAKE-SAME &#123; int k,ct,num;scanf("%d%d%d",&amp;k,&amp;ct,&amp;num);//k+1~k+ct int l=findbyrk(k),r=findbyrk(k+ct+1); splay(l,r);//debug p[p[l].son[1]].tg1=1;p[p[l].son[1]].tg1n=num; splay(p[l].son[1],0); &#125; if(s[0]=='R')//REVERSE &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1~k+ct int l=findbyrk(k),r=findbyrk(k+ct+1); splay(l,r);//debug if(p[p[l].son[1]].tg1==0) &#123; p[p[l].son[1]].tg2=1; splay(p[l].son[1],0); &#125; &#125; if(s[0]=='G')//GET-SUM &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1~k+ct if(ct==0) &#123;printf("0\n");continue;&#125; int l=findbyrk(k),r=findbyrk(k+ct+1);//debug splay(l,r);//debug pushdown(p[l].son[1]); printf("%d\n",p[p[l].son[1]].sum); &#125; if(s[2]=='X')//MAX-SUM &#123; int l=findbyrk(1),r=findbyrk(p[root].c);//debug splay(l,r);//debug pushdown(p[l].son[1]); printf("%d\n",p[ p[l].son[1] ].mx); &#125; &#125;&#125; 代码2AC代码，改了标记原本是自己也没有更新现在是自己已经更新其实也不是太快啦洛谷3896ms大视野7128 ms123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=510000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int son[2],f; int d;//debug int lmx,rmx;//用于更新 int mx; int sum; int c; bool tg1,tg2; nod() &#123; son[0]=son[1]=f=0; lmx=rmx=mx=0; sum=d=0;c=0; tg1=tg2=0; &#125;&#125;p[MAXN];void clear(int x)&#123; p[x].son[0]=p[x].son[1]=p[x].f=0; p[x].lmx=p[x].rmx=p[x].mx=0; p[x].sum=p[x].d=0; p[x].c=0; p[x].tg1=p[x].tg2=0;&#125;//*******************Splay*******************void maketg1(int x,int d)&#123; p[x].d=d;p[x].sum=p[x].c*d; if(p[x].d&lt;0) p[x].lmx=p[x].rmx=p[x].mx=d; else p[x].lmx=p[x].rmx=p[x].mx=p[x].sum; p[x].tg1=1;&#125;void maketg2(int x)//debug&#123; swap(p[x].lmx,p[x].rmx); swap(p[x].son[0],p[x].son[1]); p[x].tg2^=1;&#125;void pushdown(int x)&#123; if(x==0) return; int lc=p[x].son[0],rc=p[x].son[1]; if(p[x].tg1) &#123; p[x].tg1=0; if(lc&gt;0) maketg1(lc,p[x].d); if(rc&gt;0) maketg1(rc,p[x].d); &#125; if(p[x].tg2) &#123; p[x].tg2=0; if(lc&gt;0) maketg2(lc); if(rc&gt;0) maketg2(rc); &#125;&#125;void update(int x)//关键debug&#123; if(x==0) return; if(p[0].mx!=0 or p[0].sum!=0) printf("error!"); int lc=p[x].son[0],rc=p[x].son[1]; p[x].c=p[lc].c+1+p[rc].c; p[x].sum=p[lc].sum+p[x].d+p[rc].sum; p[x].lmx=mymax(p[lc].lmx,p[lc].sum+p[x].d); if(rc&gt;0) p[x].lmx=mymax(p[x].lmx,p[lc].sum+p[x].d+p[rc].lmx); p[x].rmx=mymax(p[rc].rmx,p[x].d+p[rc].sum); if(lc&gt;0) p[x].rmx=mymax(p[x].rmx,p[lc].rmx+p[x].d+p[rc].sum); p[x].mx=p[x].d; if(lc&gt;0) p[x].mx=mymax( mymax(p[x].mx,p[lc].mx),p[lc].rmx+p[x].d ); if(rc&gt;0) p[x].mx=mymax( mymax(p[x].mx,p[rc].mx),p[x].d+p[rc].lmx ); if(lc&gt;0 and rc&gt;0) p[x].mx=mymax( p[x].mx,p[lc].rmx+p[x].d+p[rc].lmx );&#125;void rotate(int x,int w)&#123; int f=p[x].f,ff=p[f].f; if(p[ff].son[0]==f) p[ff].son[0]=x; else p[ff].son[1]=x; p[x].f=ff; int xson=p[x].son[w]; p[f].son[1-w]=xson; if(xson&gt;0) p[xson].f=f; p[x].son[w]=f; p[f].f=x; update(f); update(x);&#125;int root;int lst[MAXN];void splay(int x,int rt)&#123; int t=0,i=x; while(p[i].f!=rt) lst[++t]=i,i=p[i].f; lst[++t]=rt; while(t&gt;0) pushdown(lst[t--]); while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(rt==ff) &#123; if(p[f].son[0]==x) rotate(x,1); else rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==0) root=x;&#125;int findbyrk(int rk)&#123; int x=root; while(1) &#123; pushdown(x);//!!! int lc=p[x].son[0]; if(rk&lt;=p[lc].c) x=lc; else if(rk&gt;p[lc].c+1) rk-=p[lc].c+1,x=p[x].son[1];//debug else break; &#125; splay(x,0); return x;&#125;//*******************动态分配*******************queue&lt;int&gt; q;int cnt;int getid()&#123; int t; if(!q.empty()) t=q.front(),q.pop(); else t=++cnt; return t;&#125;void del(int x)&#123; if(x==0) return; del(p[x].son[0]); del(p[x].son[1]); q.push(x);clear(x);&#125;//*******************建树*******************int nm[MAXN];int build(int l,int r,int f)//借鉴线段树&#123; if(l&gt;r) return 0; int t=getid(); p[t].f=f;p[t].tg1=p[t].tg2=0; if(l==r) &#123; p[t].son[0]=p[t].son[1]=0;p[t].c=1; p[t].d=p[t].lmx=p[t].rmx=p[t].mx=p[t].sum=nm[l];//debug &#125; else &#123; int mid=(l+r)/2; p[t].d=nm[mid];//debug p[t].son[0]=build(l,mid-1,t); p[t].son[1]=build(mid+1,r,t); update(t); &#125; return t;&#125;//*******************主函数*******************char s[20];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=2;i&lt;=n+1;i++) scanf("%d",&amp;nm[i]); nm[1]=0;nm[n+2]=0;//!!! p[0].lmx=p[0].rmx=-INF;//debug cnt=0;root=build(1,n+2,0); while(m--) &#123; scanf("%s",s); if(s[0]=='I')//INSERT &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1后 for(int i=1;i&lt;=ct;i++) scanf("%d",&amp;nm[i]); int l=findbyrk(k+1),r=findbyrk(k+2); splay(l,r);//debug p[l].son[1]=build(1,ct,l); update(l);update(r); &#125; if(s[0]=='D')//DELETE &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1~k+ct int l=findbyrk(k),r=findbyrk(k+ct+1); splay(l,r);//debug del(p[l].son[1]);//debug p[l].son[1]=0; update(l);update(r); &#125; if(s[2]=='K')//MAKE-SAME &#123; int k,ct,num;scanf("%d%d%d",&amp;k,&amp;ct,&amp;num);//k+1~k+ct int l=findbyrk(k),r=findbyrk(k+ct+1); splay(l,r);//debug maketg1(p[l].son[1],num); splay(p[l].son[1],0); &#125; if(s[0]=='R')//REVERSE &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1~k+ct int l=findbyrk(k),r=findbyrk(k+ct+1); splay(l,r);//debug maketg2(p[l].son[1]); splay(p[l].son[1],0); &#125; if(s[0]=='G')//GET-SUM &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1~k+ct if(ct==0) &#123;printf("0\n");continue;&#125; int l=findbyrk(k),r=findbyrk(k+ct+1); splay(l,r);//debug printf("%d\n",p[p[l].son[1]].sum); &#125; if(s[2]=='X')//MAX-SUM &#123; int l=findbyrk(1),r=findbyrk(p[root].c);//debug splay(l,r);//debug printf("%d\n",p[ p[l].son[1] ].mx); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1858】【Luogu2572】序列操作]]></title>
    <url>%2Fposts%2Fcf34.html</url>
    <content type="text"><![CDATA[来源和评测点SCOI2010Bzoj1858Luogu2572 题目【题目大意】lxhgww最近收到了一个01序列，序列里面包含了n个数，这些数要么是0，要么是1，现在对于这个序列有五种变换操作和询问操作：0 a b 把[a,b]区间内的所有数全变成01 a b 把[a,b]区间内的所有数全变成12 a b 把[a,b]区间内的所有数全部取反，也就是说把所有的0变成1，把所有的1变成03 a b 询问[a,b]区间内总共有多少个14 a b 询问[a,b]区间内最多有多少个连续的1对于每一种询问操作，lxhgww都需要给出回答，聪明的程序员们，你们能帮助他吗？【输入格式】输入数据第一行包括2个数，n和m，分别表示序列的长度和操作数目第二行包括n个数，表示序列的初始状态接下来m行，每行3个数，op, a, b，（0&lt;=op&lt;=4，0&lt;=a&lt;=b&lt;n）表示对于区间[a, b]执行标号为op的操作【输出格式】对于每一个询问操作，输出一行，包括1个数，表示其对应的答案【输入样例】10 100 0 0 1 1 0 1 0 1 11 0 23 0 52 2 24 0 40 3 62 3 74 2 81 0 50 5 63 3 9【输出样例】5265 分析本题最重要的只有一点，相通了这个，再注意一下细节就好了。这也是难点：如何解决最长连续的问题呢？考虑用线段树维护区间信息：lmx,rmx,mx,sumlmx和rmx用于在区间合并的时候更新mx，保证正确性。然后就是一些细节问题了，例如标记的传递与先后处理顺序。 最后提醒一句，因为本人老是忘记：反转标记是用xor来修改的还有就是我居然忘记要双倍空间了…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=210000;//debug//*******************全局定义*******************struct info&#123; int sum;//个数 int lmx,rmx;//边缘最长连续，合并用 int mx;//最长连续 int all;//长度 info() &#123; lmx=mx=rmx=0; sum=all=0; &#125;&#125;;struct seg&#123; int l,r,mid; int lc,rc; bool tg1,tg1n,tg2; info f[2];&#125;p[MAXN];//*******************info*******************info merg(info a,info b)&#123; info c; c.sum=a.sum+b.sum;c.all=a.all+b.all; c.lmx=a.lmx;if(c.lmx==a.all) c.lmx+=b.lmx; c.rmx=b.rmx;if(c.rmx==b.all) c.rmx+=a.rmx; c.mx=mymax(a.mx,b.mx);c.mx=mymax(c.mx,a.rmx+b.lmx); return c;&#125;void setall(info &amp;a)&#123; a.mx=a.lmx=a.rmx=a.sum=a.all;&#125;void setno(info &amp;a)&#123; a.mx=a.lmx=a.rmx=a.sum=0;&#125;//*******************接口*******************void update(int x)&#123; int lc=p[x].lc,rc=p[x].rc; if(p[x].tg1) &#123; p[x].tg1=0; bool b=p[x].tg1n; setall(p[x].f[b]); setno(p[x].f[!b]); p[lc].tg1=p[rc].tg1=1; p[lc].tg1n=p[rc].tg1n=b; p[lc].tg2=p[rc].tg2=0; &#125; if(p[x].tg2) &#123; p[x].tg2=0; swap(p[x].f[0],p[x].f[1]); update(lc);update(rc);//确保不冲突 p[lc].tg2^=1;p[rc].tg2^=1;//debug,总是忘记 &#125;&#125;int cnt;bool cl[MAXN];int build(int l,int r)&#123; int t=++cnt; p[t].l=l;p[t].r=r; if(l&lt;r) &#123; p[t].mid=(l+r)/2; p[t].lc=build(l,p[t].mid); p[t].rc=build(p[t].mid+1,r); p[t].f[0]=merg(p[p[t].lc].f[0],p[p[t].rc].f[0]); p[t].f[1]=merg(p[p[t].lc].f[1],p[p[t].rc].f[1]); &#125; else &#123; bool b=cl[l]; p[t].f[0].all=p[t].f[1].all=1; setall(p[t].f[b]);setno(p[t].f[!b]); &#125; p[t].tg1=p[t].tg2=0; return t;&#125;void change(int x,int l,int r,bool b)&#123; if(p[x].l==l and p[x].r==r) &#123; p[x].tg1=1; p[x].tg1n=b; p[x].tg2=0; return; &#125; update(x); int lc=p[x].lc,rc=p[x].rc,mid=(p[x].l+p[x].r)/2; if(r&lt;=mid) change(lc,l,r,b); else if(l&gt;mid) change(rc,l,r,b); else change(lc,l,mid,b),change(rc,mid+1,r,b); update(lc);update(rc);//debug p[x].f[0]=merg(p[lc].f[0],p[rc].f[0]); p[x].f[1]=merg(p[lc].f[1],p[rc].f[1]);&#125;void opposite(int x,int l,int r)&#123; update(x); if(p[x].l==l and p[x].r==r) &#123; p[x].tg2=1; return; &#125; int lc=p[x].lc,rc=p[x].rc,mid=(p[x].l+p[x].r)/2; if(r&lt;=mid) opposite(lc,l,r); else if(l&gt;mid) opposite(rc,l,r); else opposite(lc,l,mid),opposite(rc,mid+1,r); update(lc);update(rc);//debug p[x].f[0]=merg(p[lc].f[0],p[rc].f[0]); p[x].f[1]=merg(p[lc].f[1],p[rc].f[1]);&#125;info ask(int x,int l,int r)&#123; update(x); if(p[x].l==l and p[x].r==r) return p[x].f[1]; int lc=p[x].lc,rc=p[x].rc,mid=(p[x].l+p[x].r)/2; if(r&lt;=mid) return ask(lc,l,r); if(l&gt;mid) return ask(rc,l,r); return merg( ask(lc,l,mid),ask(rc,mid+1,r) );&#125;//*******************主函数*******************int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;cl[i]); cnt=0;build(1,n); while(m--) &#123; int op,a,b;scanf("%d%d%d",&amp;op,&amp;a,&amp;b); a++;b++; if(op==0) change(1,a,b,0); if(op==1) change(1,a,b,1); if(op==2) opposite(1,a,b); if(op==3) &#123; info t=ask(1,a,b); printf("%d\n",t.sum); &#125; if(op==4) &#123; info t=ask(1,a,b); printf("%d\n",t.mx); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1018】【Luogu4246】堵塞的交通]]></title>
    <url>%2Fposts%2F184e.html</url>
    <content type="text"><![CDATA[来源和评测点SHOI2008Bzoj1018Luogu4246 题目【题目大意】给定一张2*n的网格图，多次改变某条边是否可用，多次查询某两个点是否联通【输入格式】第一行只有一个整数C，表示网格的列数。接下来若干行，每行为一条交通信息，以单独的一行“Exit”作为结束。我们假设在一开始所有的道路都是堵塞的。我们保证 C小于等于100000，信息条数小于等于100000。【输出格式】对于每个查询，输出一个“Y”或“N”。【输入样例】2Open 1 1 1 2Open 1 2 2 2Ask 1 1 2 2Ask 2 1 2 2Exit【输出样例】YN 分析其实刚看到这题就觉得LCT然鹅，这并不是树，只好放弃看到行数是2，但一直想不到好办法于是背着良心膜了波题解 居然是线段树！首先假设询问的时候，只和两个点之间的边有关搞一个结构体，里面存有以下信息：h[2][2]表示四个端点的连通性（横、斜着）lb,rb表示上下节点的连通性（竖着）合并的话自己想，常数级别然后考虑两边，如果[1,L]两个右端点联通，等效于[L,R]两个左端点联通如果[R+1,c]两个左端点联通，等效于[L,R]两个右端点联通 目前见过最有意思的线段树题目。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************//*******************全局定义*******************struct nod//连通性信息&#123; bool lb,rb;//竖 bool h[2][2];//横、斜 nod() &#123; lb=rb=0; memset(h,0,sizeof(h)); &#125;&#125;;struct seg//线段树节点&#123; int l,r; int lc,rc; nod f; bool tp,bm;//mid和mid+1之间的信息&#125;p[410000];//*******************接口*******************nod merg(nod a,int tp,int bm,nod b)&#123; nod c; c.lb=a.lb or (a.h[0][0] and tp and b.lb and bm and a.h[1][1]); c.rb=b.rb or (b.h[0][0] and tp and a.rb and bm and b.h[1][1]); for(int i=0;i&lt;=1;i++) for(int j=0;j&lt;=1;j++) &#123; c.h[i][j] =a.h[i][0] and tp and b.h[0][j];//上面走 c.h[i][j]|=a.h[i][1] and bm and b.h[1][j];//下面走 &#125; return c;&#125;int cnt;int build(int l,int r)&#123; int t=++cnt; p[t].l=l;p[t].r=r; p[t].tp=p[t].bm=0; if(l&lt;r) &#123; int mid=(l+r)/2; p[t].lc=build(l,mid); p[t].rc=build(mid+1,r); &#125; else p[t].f.h[0][0]=p[t].f.h[1][1]=1;//单点横向必定可以 return t;&#125;void change(int x,int x1,int y1,int x2,int y2,bool b)&#123; int lc=p[x].lc,rc=p[x].rc,mid=(p[x].l+p[x].r)/2; if(x1==x2 and y1==mid)//横着，正好中间 &#123; if(x1==0) p[x].tp=b; else p[x].bm=b; p[x].f=merg(p[lc].f,p[x].tp,p[x].bm,p[rc].f); return; &#125; if(p[x].l==p[x].r)//其他单点 &#123; p[x].f.h[0][1]=p[x].f.h[1][0]=p[x].f.lb=p[x].f.rb=b; //tp、bm不需要，作为单点用不到 return; &#125; if(y1&lt;=mid) change(lc,x1,y1,x2,y2,b); else change(rc,x1,y1,x2,y2,b); p[x].f=merg(p[lc].f,p[x].tp,p[x].bm,p[rc].f);&#125;nod ask(int x,int L,int R)&#123; int lc=p[x].lc,rc=p[x].rc,mid=(p[x].l+p[x].r)/2; if(p[x].l==L and p[x].r==R) return p[x].f; if(R&lt;=mid) return ask(lc,L,R); if(L&gt;mid) return ask(rc,L,R); return merg(ask(lc,L,mid),p[x].tp,p[x].bm,ask(rc,mid+1,R));&#125;//*******************主函数*******************char s[20];int main()&#123; int n;scanf("%d",&amp;n); cnt=0;build(1,n); while(1) &#123; scanf("%s",s);if(s[0]=='E') break; int x1,y1,x2,y2;scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); if(y1&gt;y2) swap(x1,x2),swap(y1,y2);x1--;x2--; if(s[0]=='A') &#123; nod a,b,c; a=ask(1,1,y1);b=ask(1,y1,y2);c=ask(1,y2,n); if(a.rb) b.lb=1;if(c.lb) b.rb=1; bool bk=0; for(int i=0;i&lt;=1;i++) for(int j=0;j&lt;=1;j++) if(b.h[i][j]) if( (i==x1 or b.lb)and(j==x2 or b.rb) ) bk=1; if(bk) printf("Y\n"); else printf("N\n"); &#125; if(s[0]=='O') change(1,x1,y1,x2,y2,1); if(s[0]=='C') change(1,x1,y1,x2,y2,0); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>精品题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3343】教主的魔法]]></title>
    <url>%2Fposts%2Fc57c.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj3343 题目【题目大意】教主最近学会了一种神奇的魔法，能够使人长高。于是他准备演示给XMYZ信息组每个英雄看。于是N个英雄们又一次聚集在了一起，这次他们排成了一列，被编号为1、2、……、N。每个人的身高一开始都是不超过1000的正整数。教主的魔法每次可以把闭区间[L,R]（1≤L≤R≤N）内的英雄的身高全部加上一个整数W。（虽然L=R时并不符合区间的书写规范，但我们可以认为是单独增加第L（R）个英雄的身高）CYZ、光哥和ZJQ等人不信教主的邪，于是他们有时候会问WD闭区间 [L, R] 内有多少英雄身高大于等于C，以验证教主的魔法是否真的有效。WD巨懒，于是他把这个回答的任务交给了你。【输入格式】第1行为两个整数N、Q。Q为问题数与教主的施法数总和。第2行有N个正整数，第i个数代表第i个英雄的身高。第3到第Q+2行每行有一个操作：（1）若第一个字母为“M”，则紧接着有三个数字L、R、W。表示对闭区间 [L, R] 内所有英雄的身高加上W。（2）若第一个字母为“A”，则紧接着有三个数字L、R、C。询问闭区间 [L, R] 内有多少英雄的身高大于等于C。对30%的数据，N≤1000，Q≤1000。对100%的数据，N≤1000000，Q≤3000，1≤W≤1000，1≤C≤1,000,000,000。【输出格式】对每个“A”询问输出一行，仅含一个整数，表示闭区间 [L, R] 内身高大于等于C的英雄数。【输入样例】5 31 2 3 4 5A 1 5 4M 3 5 1A 1 5 4【输出样例】23【样例解释】原先5个英雄身高为1、2、3、4、5，此时[1, 5]间有2个英雄的身高大于等于4。教主施法后变为1、2、4、5、6，此时[1, 5]间有3个英雄的身高大于等于4。 分析普普通通的分块，该说的代码里面有。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;//*******************定义*******************int a[1100000],b[1100000],ad[1100000],bk[1100000];//a是原本，b是有序int bl[11000],br[11000];int n,m;//*******************实现*******************void reset(int x)&#123; int ll=bl[x],rr=br[x]; for(int i=ll;i&lt;=rr;i++) b[i]=a[i]; sort(b+ll,b+rr+1);&#125;int find(int x,int c)&#123; int l=bl[x],r=br[x],ans=bl[x]-1;//ans表示最后一个比w小的 while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(b[mid]&lt;c) l=mid+1,ans=mid; else r=mid-1; &#125; return br[x]-ans;&#125;void change(int x,int y,int c)&#123; int ex=bk[x],ey=bk[y]; if(ex==ey) &#123; for(int i=x;i&lt;=y;i++) a[i]+=c; reset(ex); return; &#125; for(int i=x;i&lt;=br[ex];i++) a[i]+=c;reset(ex); for(int i=bl[ey];i&lt;=y;i++) a[i]+=c;reset(ey); //修改完后立即重构，从而降低时间复杂度 //每次两个，即使很多次也胜过一次查询时更新 for(int i=ex+1;i&lt;=ey-1;i++) ad[i]+=c;&#125;int ask(int x,int y,int c)&#123; int ex=bk[x],ey=bk[y],ans=0; if(ex==ey) &#123; for(int i=x;i&lt;=y;i++) if(a[i]+ad[ex]&gt;=c) ans++; return ans; &#125; for(int i=x;i&lt;=br[ex];i++) if(a[i]+ad[ex]&gt;=c) ans++; for(int i=bl[ey];i&lt;=y;i++) if(a[i]+ad[ey]&gt;=c) ans++; for(int i=ex+1;i&lt;=ey-1;i++) ans+=find(i,c-ad[i]); return ans;&#125;//*******************主函数*******************char s[10];int main(int argc, char *argv[])&#123; int q;scanf("%d%d",&amp;n,&amp;q); m=sqrt(n)*2.0; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); bk[i]=(i-1)/m+1; &#125; int cnt=n/m; for(int i=1;i&lt;=cnt;i++) &#123; bl[i]=(i-1)*m+1; br[i]=i*m; reset(i); &#125; if(n%m&gt;0) &#123; cnt++; bl[cnt]=br[cnt-1]+1; br[cnt]=n; reset(cnt); &#125; while(q--) &#123; int a,b,c;scanf("%s%d%d%d",s,&amp;a,&amp;b,&amp;c); if(s[0]=='M') change(a,b,c); else printf("%d\n",ask(a,b,c)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>精品题</tag>
        <tag>难度3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3897】【Vijos1194】Domino]]></title>
    <url>%2Fposts%2F9f71.html</url>
    <content type="text"><![CDATA[来源和评测点Poj2663Vijos1194Caioj1487 题目【题目大意】问用1*2的多米诺骨牌填满m*n的矩阵有多少种方案，结果需要mod p。【输入格式】仅一行，有三个整数，m(m&lt;=5)，n(n&lt;2^31)，p(p&lt;=10^9+7)。【输出格式】输出方案数，结果需要mod p。【输入样例】3 2 5【输出样例】3 分析以下内容在参考网上题解后手打，补充了很多网上题解根本没有提及或者含糊不清的问题，有疑问可评论。 我们先从m=3入手，找到普遍解考虑用二进制表示一列的状态，然后从右往左填充，每次填充一列可以发现问题恰好转化为了：从111开始恰好n步回到111的方案数（显然考场上我是想不出来的，构思的时候细节很多）这时候只要找到方案间的边到底是怎么建立的，然后套上矩阵乘法即可，参考之前的多少条路呢 规则一：不能在第二列竖着放实现：前后方案的状态值，或操作的结果=111解释：因为假如有一个位置或结果是0，而又成功填充了一列，那么显然是竖着放了 规则二：能达到实现：前后方案的状态值，与操作的结果，不会有“连续奇数个”1解释：连续奇数个1意味着非法，因为原本状态值中连续奇数个1，不能添加竖着的domino，也没有其他办法，所以无法达到。 注意，我们构造边的时候其实有个原则（依然想不到）：如果面对某种局面只有一个地方能放置，也就是方案数不变，那么要将它压缩起来 至于为啥全都是双向边，逻辑上我讲不清，但从实现上看，两个状态的先后对得到可达矩阵结果没有影响，所以有对称性（m[i][j]==m[j][i]）不过因为状态太少，没有剪枝的必要 然后规则二的可行结果比较少，手工枚举后如下：00000 000011 300110 601100 1201111 1511000 2411011 2711110 30搞一个常量数组就好，就8个 然后，来个遗言：看到pascal用longint没问题，然后调试了一个小时……珍惜生命，请用longlong 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;//*******************全局常量*******************//*******************全局定义*******************struct martix&#123; ll m[40][40]; martix() &#123; memset(m,0,sizeof(m)); &#125;&#125;;//这次的矩阵从0开始int mx;ll MOD;//*******************接口*******************martix cheng(martix a,martix b)&#123; martix c; for(int i=0;i&lt;=mx;i++) for(int j=0;j&lt;=mx;j++) for(int k=0;k&lt;=mx;k++) c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]%MOD)%MOD; return c;&#125;martix power(martix a,int e)&#123; martix ans;for(int i=0;i&lt;=mx;i++) ans.m[i][i]=1; while(e&gt;0) &#123; if(e%2==1) ans=cheng(ans,a); a=cheng(a,a);e/=2; &#125; return ans;&#125;//*******************主函数*******************bool f[40];int main()&#123; f[0]=f[3]=f[6]=f[12]=f[15]=f[24]=f[27]=f[30]=1; int m,n;scanf("%d%d%lld",&amp;m,&amp;n,&amp;MOD);mx=(1&lt;&lt;m)-1; martix a; for(int i=0;i&lt;=mx;i++) for(int j=0;j&lt;=mx;j++) a.m[i][j]=( (i|j)==mx ) and f[i&amp;j]; printf("%lld",power(a,n).m[mx][mx]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>精品题</tag>
        <tag>难度3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打鼹鼠]]></title>
    <url>%2Fposts%2F554a.html</url>
    <content type="text"><![CDATA[来源和评测点毒瘤出题人不一定能用的luogu链接 题目【题目大意】鼹鼠一共在仓库中打了n个洞（用1至n编号），在这n个洞中，有些洞之间是连通的，你可以花费一定的时间从连通的一个洞口处跑到另一个洞口处，然鹅有些洞之间由于货物的堆放等原因并不是连通的，也就是你并不能直接从不连通的一个洞口处跑到另一个洞口处。（但所有的连通关系都是双向的）当你在某一时刻正好在某个洞旁时，如果正好这个洞中有一只出现在洞口处，你就可以用手中的武器（一把大锤）消灭这支鼹鼠，当你在某一时刻停留在某个洞穴处并使用大锤时，该洞当前出现的所有鼹鼠都将被消灭。你有t秒的时间来进行消灭鼹鼠的战斗，你也知道在这t秒内鼹鼠每次出现的时间和位置。那么，你最多能消灭多少只鼹鼠呢？为了尽可能多的消灭鼹鼠，dd_engi为你提供了一种超级武器：如果你在某个特定时刻在某个洞口处使用这个超级武器的话，那么这个洞以及与它直接有边相连的所有洞中此刻出现的鼹鼠都会被消灭掉。然鹅，这个超级武器只能使用一次。你需要编程求出的就是：用或者不用这个超级武器，你分别能消灭多少只鼹鼠？注意：你可以不用完你所给的时间，而且可以有一些时间你并没有来回跑动而是仅仅停在某个洞的旁边。一些题目没有将清楚的要点：1.注意是用超级武器杀死直接相连的，我看错然后从100=&gt;02.只要你某个时刻在那里，就可以杀死所有当时在那里的鼹鼠3.时间可能有0，坐标编号没有04.一开始在哪里任意【输入格式】第一行为三个用空格隔开的整数n、m、t，分别表示鼹鼠洞的个数和连通的边数以及你的时间t。以下m行，每行有三个用空格隔开的整数i、j、k，表示编号i、j的两个鼹鼠洞是双向连通的，从一个运动到另一个需要花费的时间为k。以下每行有三个用空格隔开的整数，第一个整数表示描述的这些鼹鼠将于第几秒末出现，第二个整数表示描述的这些鼹鼠出现的洞的编号，第三个整数表示这次将会出现的鼹鼠的数量。以三个整数0表示输入的结束。输入文件的结尾是一个回车/换行符。【输出格式】只需输出两个用空格隔开的整数，分别表示用和不用超级武器能消灭的最多鼹鼠数。最后以一个回车/换行符结尾。【输入样例】3 2 101 2 12 3 21 1 12 2 23 3 34 1 42 3 34 2 26 1 48 2 310 2 29 1 17 1 53 2 28 1 80 0 0【输出样例】32 29 分析其实是一道灰常简单的DP一开始写了个dfs，我不确定时间复杂度是否相同注意我上面说的要点就好了然后被第一条坑惨了，还用了并查集沾沾自喜…… 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************实现*******************struct pt&#123; int f[1100]; int hou; pt() &#123; memset(f,0,sizeof(f)); hou=0; &#125;&#125;p[110];struct rod&#123; int y,c,g;&#125;e[21000];int ln=0;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln;&#125;//*******************主函数*******************int f[1100][110][2];int ff[1100][110];int main()&#123; int n,m,T;scanf("%d%d%d",&amp;n,&amp;m,&amp;T); for(int i=1;i&lt;=n;i++) ins(i,i,1); while(m--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);ins(y,x,c); join(x,y); &#125; int a,b,c; while(scanf("%d%d%d",&amp;a,&amp;b,&amp;c)!=EOF) &#123; if(a==0 and b==0 and c==0) break; p[b].f[a]+=c; fal[fa[b]][a]+=c; &#125; int mx1=0,mx2=0; memset(f,0,sizeof(f)); memset(ff,0,sizeof(ff)); for(int t=1;t&lt;=T;t++) &#123; for(int x=1;x&lt;=n;x++) &#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) ff[t][x]+=p[e[k].y].f[t];//包括自己 for(int k=p[x].hou;k&gt;0;k=e[k].g)//包括自己 &#123; int y=e[k].y,c=e[k].c; if(t-c&lt;0) continue; f[t][x][0]=mymax(f[t][x][0],f[t-c][y][0]+p[x].f[t]); f[t][x][1]=mymax(f[t][x][1],f[t-c][y][1]+p[x].f[t]); //f[t][x][1]=mymax(f[t][x][1],f[t-c][y][0]+ff[t][x]); f[t][x][1]=mymax(f[t][x][1],f[t-c][y][0]+fal[fa[x]][t]); &#125; mx1=mymax(mx1,f[t][x][1]),mx2=mymax(mx2,f[t][x][0]); &#125; &#125; printf("%d %d\n",mx1,mx2);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3897】【Bzoj2709】迷宫花园]]></title>
    <url>%2Fposts%2Fab3c.html</url>
    <content type="text"><![CDATA[来源和评测点Poj3897Bzoj2709Bzoj的在分析1，Poj的在分析2 题目【题目大意】普通得甚至有些二逼的矮穷挫少年——Dios，不可避免地遇到了他生命中的劫数，白富美少女 Nyution。但是按照正常的校园故事的发展，Nyution 是无论如何不会喜欢上各方面条件都差到不行的 Dios 的。不过，Dios 还是面对 Nyution 颤抖着说出了那三个字。Nyution既不想过分地让 Dios 伤心，又不想接受她根本看不上的 Dios，于是决定让 Dios 走一个建在她家后院里的迷宫花园——如果 Dios 能很快地从起点走到终点，证明他的聪明才智，Nyution就答应他的表白。当然 Nyution 敢这么说肯定是有准备的。Nyution 的花园可以看做一个迷宫，在迷宫内部有起点和终点。Dios 要从起点走到终点，并且他只能选择前后左右四个方向行走，而且显然不能走到篱笆上，也不能走出迷宫的边界。Nyution 经过仔细的调查发现，Dios 移动到相邻格子的耗时肯定是 1。同时，Nyution 将在 Dios 的挑战开始前，通过进行适当的路面调整，使 Dios 在南北方向（数据中的上下方向）的移动时间由 1 变成实数v 。首先，Nyution不能让 Dios 过快地到达终点，这样她就得接受表白；其次，Nyution 也不想让 Dios 开了小宇宙之后还是过慢地到达终点，这样显得她在刁难 Dios。最后她确定了一个实数 L ——就是最坏情况（也就是 Dios 最神勇威武耗时最短的情况）下，Dios 将花费 L 的时间由起点到达终点。但是 Nyution 显然不会求此时的v 值，于是她找到了一向以算法达人著称的你。你当然不会拒绝白富美 Nyution 的请求，决定帮她算出此时的v 。由于 Nyution 不仅是白富美同时也是三好学生，所以她肯定不会给你一个无解的任务。并且，Nyution 的迷宫中一定没有水平的从起点到终点的通路。【输入格式】输入文件包含多个测试点。第一行包含一个整数，表示测试点的数目。每个测试点的第一行包含实数 L 和两个整数 R ,C 。 L 的含义如上， R 表示 Nyution 的花园南北方向的长度，C 表示花园东西方向的长度。之后 R 行为花园的描述，每行包含C 个字符。其中空格（ASCII 码为 32）代表空地，S 代表起点，E 代表终点，# 代表篱笆。显然，起点和终点都是空地。对于 20% 的数据，满足1&lt;=R,C&lt;=10对于另外 20% 的数据，保证答案v 的小数部分为 0对于 100% 的数据，满足1&lt;=R,C&lt;=100 ，保证0&lt;=v&lt;10【输出格式】对于每组测试数据，在单独的一行内输出v 的值，保留 5 位小数。【输入样例】22.5 4 5######S ## E######21 13 12#############S## #E## ## # # ## # # # #### # # # ## # # # ## ## # # ### # # # #### # # # ### # # # ## ## # ## # #############【输出样例】0.500000.21053 分析1被卡精度的菜鸡一只发现自己连二分都不会打了。。。以上就是难度2的原因 然后是精品题，这是因为这道题把最短路拓展了，希望大家和我一样，经过这个学会灵活变化，而不要太死脑筋因为这道题可以不去建边的，一开始我还想着把所有边dfs建好，边值自己变化，后来akc提醒才发现没必要 顺便说说，目前对稠密图的理解，通常m也就是边数至少n^2级别，这时才要用到Dijkstra 代码11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;//*******************全局常量*******************const double eps=1e-8;//*******************全局定义*******************struct nod&#123; int x,y; nod() &#123;&#125; nod(int xx,int yy) &#123;x=xx,y=yy;&#125;&#125;;//*******************接口*******************double midv;int n,m;int stx,sty;int edx,edy;bool mp[110][110];double d[110][110];queue&lt;nod&gt; q;bool b[110][110];double spfa()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) d[i][j]=0x3f3f3f3f,b[i][j]=0; while(!q.empty()) q.pop(); d[stx][sty]=0;b[stx][sty]=1;q.push( nod(stx,sty) ); while(!q.empty()) &#123; nod tp=q.front();int xx=tp.x,yy=tp.y; for(int i=0;i&lt;=3;i++) &#123; int tx,ty; if(i==0) tx=xx-1,ty=yy;if(i==1) tx=xx+1,ty=yy; if(i==2) tx=xx,ty=yy-1;if(i==3) tx=xx,ty=yy+1; if(tx&lt;1 or tx&gt;n or ty&lt;1 or ty&gt;m or !mp[tx][ty]) continue; double rc=(i&lt;2)?midv:1; if(d[tx][ty]&gt;d[xx][yy]+rc) &#123; d[tx][ty]=d[xx][yy]+rc; if(b[tx][ty]==0) &#123; b[tx][ty]=1; q.push( nod(tx,ty) ); &#125; &#125; &#125; q.pop();b[xx][yy]=0; &#125; return d[edx][edy];&#125;//*******************主函数*******************char s[110];int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; double L;scanf("%lf%d%d",&amp;L,&amp;n,&amp;m);gets(s+1);//debug for(int i=1;i&lt;=n;i++) &#123; gets(s+1);//debug for(int j=1;j&lt;=m;j++) &#123; if(s[j]=='#') mp[i][j]=0; else mp[i][j]=1; if(s[j]=='S') stx=i,sty=j; if(s[j]=='E') edx=i,edy=j; &#125; &#125; double l=0,r=10,ans=0;//debug -1 while(r-l&gt;eps)//最后l==r即r-l==0 &#123; midv=(l+r)/2; if(spfa()&lt;=L+eps) ans=midv,l=midv+eps;//spfa()&lt;=L else r=midv-eps; &#125; printf("%.5lf\n",ans); &#125;&#125; 分析2POJ也差不多。。已经用注释表明区别了 代码212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;//*******************全局常量*******************const double eps=1e-8;//*******************全局定义*******************struct nod&#123; int x,y; nod() &#123;&#125; nod(int xx,int yy) &#123;x=xx,y=yy;&#125;&#125;;//*******************接口*******************double midv;int n,m;int stx,sty;int edx,edy;bool mp[110][110];double d[110][110];queue&lt;nod&gt; q;bool b[110][110];double spfa()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) d[i][j]=0x3f3f3f3f,b[i][j]=0; while(!q.empty()) q.pop(); d[stx][sty]=0;b[stx][sty]=1;q.push( nod(stx,sty) ); while(!q.empty()) &#123; nod tp=q.front();int xx=tp.x,yy=tp.y; for(int i=0;i&lt;=3;i++) &#123; int tx,ty; if(i==0) tx=xx-1,ty=yy;if(i==1) tx=xx+1,ty=yy; if(i==2) tx=xx,ty=yy-1;if(i==3) tx=xx,ty=yy+1; if(tx&lt;1 or tx&gt;n or ty&lt;1 or ty&gt;m or !mp[tx][ty]) continue; double rc=(i&lt;2)?midv:1; if(d[tx][ty]&gt;d[xx][yy]+rc) &#123; d[tx][ty]=d[xx][yy]+rc; if(b[tx][ty]==0) &#123; b[tx][ty]=1; q.push( nod(tx,ty) ); &#125; &#125; &#125; q.pop();b[xx][yy]=0; &#125; return d[edx][edy];&#125;//*******************主函数*******************char s[110];int main()&#123; int T;scanf("%d",&amp;T); for(int tt=1;tt&lt;=T;tt++) &#123; double L; //scanf("%lf%d%d",&amp;L,&amp;n,&amp;m); scanf("%lf%d",&amp;L,&amp;n); gets(s+1);//debug for(int i=1;i&lt;=n;i++) &#123; gets(s+1);//debug m=strlen(s+1); for(int j=1;j&lt;=m;j++) &#123; if(s[j]=='#') mp[i][j]=0; else mp[i][j]=1; if(s[j]=='S') stx=i,sty=j; if(s[j]=='E') edx=i,edy=j; &#125; &#125; double l=0,r=10,ans=0;//debug -1 while(r-l&gt;eps)//最后l==r即r-l==0 &#123; midv=(l+r)/2.0; if(spfa()&lt;=L+eps) ans=midv,l=midv+eps;//spfa()&lt;=L else r=midv-eps; &#125; printf("Case #%d: %.3lf%%\n",tt,ans*100.0); //printf("%.5lf\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>难度2</tag>
        <tag>二分</tag>
        <tag>精品题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[花园]]></title>
    <url>%2Fposts%2Fb112.html</url>
    <content type="text"><![CDATA[来源和评测点某场比赛，没拿到数据意会吧 题目【题目大意】【输入格式】【输入样例】5 810 20 30 40 501 21 33 43 5Q 2 5 10C 2 21Q 3 4 21C 6 22Q 1 7 28C 5 20Q 2 5 20Q 2 0 9【输出样例】12031 分析1这是加密前的操作Q 2 5 10C 3 20Q 2 5 20C 4 20Q 3 5 30C 5 20Q 2 5 20Q 1 3 10咳咳先来个清新脱俗的暴力（50分）主要是因为T太大，想不到好方法 代码1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//Zory-2018//*******************头文件*******************#pragma once#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=110000,MAXM=210000;//*******************全局定义*******************struct pt&#123; int cl; int hou; int dep; int fa; pt() &#123; hou=0; &#125;&#125;p[MAXN];struct rod&#123; int y,g;&#125;e[MAXM];int ln=0;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************接口*******************void dfs(int x)&#123; p[x].dep=p[ p[x].fa ].dep+1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y!=p[x].fa) p[y].fa=x,dfs(y); &#125;&#125;//*******************主函数*******************char s[10];int main()&#123; int n,q;scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i].cl); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; dfs(1); int lans=0; while(q--) &#123; int x,y,t;scanf("%s%d",s,&amp;x);x=x^lans; if(s[0]=='C') &#123; scanf("%d",&amp;t); t=t^lans; p[x].cl=t; &#125; else &#123; scanf("%d%d",&amp;y,&amp;t); y=y^lans;t=t^lans; int ans=0; if(p[x].dep&lt;p[y].dep) swap(x,y); while(p[x].dep!=p[y].dep) &#123; if(p[x].cl==t) ans++; x=p[x].fa; &#125; while(x!=y) &#123; if(p[x].cl==t) ans++; if(p[y].cl==t) ans++; x=p[x].fa;y=p[y].fa; &#125; if(p[x].cl==t) ans++; lans=ans; printf("%d\n",ans); &#125; &#125;&#125; 分析2那么有请Rose大佬登场……对于离散化，我也想到了map，但之后就不会了他一语点醒了我，先%%% 先对颜色进行离散化，最坏情况下100000树链剖分维护结构，然后线段树动态开点，最坏情况下就一条链，然后不存在的节点点值就是0，修改操作的时候维护线段树，询问操作的时候就调用对应线段树查询，空间理论上最坏情况下100000*20，最好情况下也是100000*20但因为删除等，还是会有损耗 以上就是大致思路了嗯因为这道题算比较难的数据结构了，我加上了大量注释 代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;map&gt;using namespace std;//*******************全局常量*******************const int MAXN=110000,MAXM=210000;//*******************全局定义*******************struct pt&#123; int cl;//离散化后的值 int hou; int dep,tot; int fa,son,tp;&#125; p[MAXN];//逻辑上 很多棵线段树//实际上 为了动态开点 只有一个下标 用rt分配struct rod&#123; int y,g;&#125; e[MAXM];int ln=0;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************线段树*******************int rt[MAXN];//rt[经过离散化的值]=根节点struct mg&#123; int lc,rc; int c;&#125; sf[MAXN*30];int len=0;//类似于主席树，每次都是增加删除一条链void change(int &amp;x,int l,int r,int p,int z)&#123; if(x==0) x=++len;//新节点 sf[x].c+=z; if(l==r) return; int mid=(l+r)/2; if(p&lt;=mid) change(sf[x].lc,l,mid,p,z); else change(sf[x].rc,mid+1,r,p,z);&#125;int ask(int x,int l,int r,int fl,int fr)&#123; if(x==0) return 0;//减少空间支出 if(l==fl and r==fr) return sf[x].c; int mid=(l+r)/2; if(fr&lt;=mid) return ask(sf[x].lc,l,mid,fl,fr); if(fl&gt;mid) return ask(sf[x].rc,mid+1,r,fl,fr); return ask(sf[x].lc,l,mid,fl,mid)+ask(sf[x].rc,mid+1,r,mid+1,fr);&#125;//*******************树链剖分*******************void dfs(int x)&#123; p[x].tot=1;p[x].son=0; p[x].dep=p[ p[x].fa ].dep+1; for(int k=p[x].hou; k&gt;0; k=e[k].g) &#123; int y=e[k].y; if(y!=p[x].fa) &#123; p[y].fa=x; dfs(y); p[x].tot+=p[y].tot; if(p[y].tot&gt;p[p[x].son].tot) p[x].son=y; &#125; &#125;&#125;int nln=0;int nb[MAXN];void dfs2(int x,int tp)&#123; nb[x]=++nln;p[x].tp=tp; if(p[x].son&gt;0) dfs2(p[x].son,tp);//debug for(int k=p[x].hou; k&gt;0; k=e[k].g) &#123; int y=e[k].y; if(y!=p[x].fa and y!=p[x].son) dfs2(y,y);//debug &#125;&#125;//*******************接口*******************int n;map&lt;int,int&gt; mp;//key=大数字 元素=离散化后的值int cnt=0;int newcol(int col)&#123; if(mp[col]==0) return mp[col]=++cnt; return mp[col];&#125;//*******************主函数*******************char s[10];int main()&#123; int q;scanf("%d%d",&amp;n,&amp;q); for(int i=1; i&lt;=n; i++) &#123; int tc;scanf("%d",&amp;tc); p[i].cl=newcol(tc); &#125; for(int i=1; i&lt;=n-1; i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; p[1].fa=0;dfs(1); dfs2(1,1); for(int i=1;i&lt;=n;i++) change(rt[ p[i].cl ],1,n,nb[i],1); int lans=0; while(q--) &#123; int x,y,col; scanf("%s%d",s,&amp;x);x=x^lans; if(s[0]=='C') &#123; scanf("%d",&amp;col);col=col^lans; change(rt[ p[x].cl ],1,n,nb[x],-1); p[x].cl=newcol(col); change(rt[ p[x].cl ],1,n,nb[x],1); &#125; else &#123; scanf("%d%d",&amp;y,&amp;col); y=y^lans;col=mp[col^lans]; int ans=0; while(p[x].tp!=p[y].tp) &#123; if(p[p[x].tp].dep&lt;p[p[y].tp].dep) swap(x,y); ans+=ask(rt[col],1,n,nb[ p[x].tp ],nb[ x ]); x=p[p[x].tp].fa; &#125; if(p[x].dep&lt;p[y].dep) swap(x,y); lans=ans+ask(rt[col],1,n,nb[y],nb[x]); printf("%d\n",lans); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>线段树</tag>
        <tag>精品题</tag>
        <tag>难度3</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hdu2157】多少条路呢]]></title>
    <url>%2Fposts%2Fc65d.html</url>
    <content type="text"><![CDATA[来源和评测点小黑2008信息工程学院集训队——选拔赛Hdu2157Caioj1485 题目【题目大意】给定一个有向图，有n个点，m条边。求A点到B点恰好经过k条边的方案数（可走重复边）【输入格式】输入数据有多组，每组第一行有两个整数，n（1&lt;=n&lt;=20)，m(m&lt;=100)，表示有n个点，m条边，点的编号为0~n-1。接下来m行，每行有两个整数，x，y，表示x点能到y点。接下的一行有一个整数，t(1&lt;=t&lt;=100)，表示有t组询问。接着的t行，每行有三个整数，A，B，k(k&lt;20)，表示问你从A点到B点恰好经过k条边的方案数，由于可能方案数灰常大，所以只要计算方案数mod 1000.当n，m为0时，输入结束。【输出格式】输出每次询问的方案数(记得要对1000取模)【输入样例】4 40 10 21 32 320 3 20 3 33 60 11 00 22 01 22 121 2 10 1 30 0【输出样例】2013 分析这道题还是灰常有趣的考虑邻接矩阵的自乘因为有0的话必定无法对结果矩阵作出贡献，所以结果矩阵f[i,j]的值必定是f[i,k]后f[k,j]的总方案数（也就是k=2的情况）那么同理，k的其他情况就是邻接矩阵的k次幂 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;//*******************全局常量*******************const int MAXN=35;//*******************全局定义*******************struct matrix&#123; int row,col; int p[MAXN][MAXN]; matrix() &#123; memset(p,0,sizeof(p)); &#125;&#125;;//*******************全局变量*******************int mod=1000;//*******************实现*******************matrix cheng(matrix a,matrix b)&#123; matrix c; int n=a.row,m=a.col,p=b.col; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) c.p[i][j]=(c.p[i][j]+a.p[i][k]*b.p[k][j])%mod; c.row=n;c.col=p; return c;&#125;//*******************主函数*******************int main()&#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)!=EOF) &#123; if(n==0 and m==0) break; matrix f[20];f[1].row=f[1].col=n; for(int i=1;i&lt;=m;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); f[1].p[x+1][y+1]=1; &#125; for(int i=2;i&lt;=19;i++) f[i]=cheng(f[1],f[i-1]); for(int i=1;i&lt;=n;i++) f[0].p[i][i]=1;//debug int t;scanf("%d",&amp;t); while(t--) &#123; int x,y,k;scanf("%d%d%d",&amp;x,&amp;y,&amp;k); printf("%d\n",f[k].p[x+1][y+1]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Vijos1067】守望者的烦恼]]></title>
    <url>%2Fposts%2Fc439.html</url>
    <content type="text"><![CDATA[来源和评测点杜杜我爱你Vijos1067Caioj1485 题目【题目大意】有n个格子，从入口出发（注意，入口不是第一个格子，要另外计算),需要走到最后一个格子（即出口，第n个格子）。每走一步可选择走过1~k个格子，求能走到出口的方案数。【输入格式】仅一行，含有两个整数k(1&lt;=k&lt;=10)，n(1&lt;=n&lt;=2^31-1)【输出格式】输出方案数mod 7777777的值【输入样例】2 4【输出样例】5 分析首先想DP,f[i]=sigma(p=i-k~i-1)[f[p]]然后因为n太大，考虑加速列向量(k+1)/*1,表示近几个f的值，然后推导出一个操作矩阵表示把列向量往前推并计算出最后一个值，然后把这个操作矩阵快速幂n-k-1次即可 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=20;//*******************全局定义*******************typedef long long ll;struct matrix&#123; int row,col; ll p[MAXN][MAXN]; matrix() &#123; memset(p,0,sizeof(p)); &#125;&#125;;//*******************全局变量*******************ll mod=7777777;//*******************实现*******************matrix cheng(matrix a,matrix b)&#123; matrix c; int n=a.row,m=a.col,p=b.col; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) c.p[i][j]=(c.p[i][j]%mod+a.p[i][k]*b.p[k][j]%mod)%mod; c.row=n;c.col=p; return c;&#125;matrix pre(int fn)&#123; matrix c;c.row=c.col=fn; for(int i=1;i&lt;=fn;i++) c.p[i][i]=1; return c;&#125;matrix power(matrix a,int e)&#123; matrix c=pre(a.row); while(e&gt;0) &#123; if(e%2==1) --e,c=cheng(c,a);//a*c也行 a=cheng(a,a);e/=2; &#125; return c;&#125;//*******************主函数*******************int main()&#123; int k,n;scanf("%d%d",&amp;k,&amp;n); matrix f;f.row=k+1;f.col=k+1; for(int i=1;i&lt;=k;i++) f.p[i][i+1]=1; for(int i=2;i&lt;=k+1;i++) f.p[k+1][i]=1; matrix ans;ans.row=k+1;ans.col=1; for(int i=1;i&lt;=k+1;i++) &#123; if(i&lt;=k) ans.p[i][1]=1;//一步跳过来 for(int j=1;j&lt;=i-1;j++) ans.p[i][1]=(ans.p[i][1]+ans.p[j][1])%mod; &#125; if(n&lt;=k)//debug &#123; printf("%lld",ans.p[n][1]); return 0; &#125; ans=cheng(power(f,n-k-1),ans); printf("%lld",ans.p[k+1][1]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1962】Fibonacci数列]]></title>
    <url>%2Fposts%2F53d.html</url>
    <content type="text"><![CDATA[来源和评测点Luogu1962Caioj1484 题目【题目大意】给定n，求第n个Fibonacci数mod 10^9+7的值。注意第一个Fibonacci数为1【输入格式】仅一个整数n【输出格式】输出结果【输入样例】10【输出样例】5 分析一题比一题水 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;//*******************全局常量*******************const int MAXN=110;//*******************全局定义*******************typedef long long ll;struct matrix&#123; int row,col; ll p[MAXN][MAXN]; matrix() &#123; memset(p,0,sizeof(p)); &#125;&#125;;//*******************全局变量*******************ll mod=1000000007;//*******************实现*******************matrix cheng(matrix a,matrix b)&#123; matrix c; int n=a.row,m=a.col,p=b.col; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) c.p[i][j]=(c.p[i][j]+a.p[i][k]*b.p[k][j]%mod)%mod; c.row=n;c.col=p; return c;&#125;matrix jia(matrix a,matrix b)&#123; matrix c;c.row=a.row;c.col=a.col; for(int i=1;i&lt;=c.row;i++) for(int j=1;j&lt;=c.col;j++) c.p[i][j]=(a.p[i][j]+b.p[i][j])%mod; return c;&#125;matrix pre(int fn)&#123; matrix c; for(int i=1;i&lt;=fn;i++) c.p[i][i]=1; c.row=c.col=fn; return c;&#125;matrix power(matrix a,ll e)&#123; matrix c=pre(a.row); while(e&gt;0) &#123; if(e%2==1) --e,c=cheng(c,a);//a*c也行 a=cheng(a,a);e/=2; &#125; return c;&#125;//*******************主函数*******************int main()&#123; ll n;scanf("%lld",&amp;n); if(n==1) &#123; printf("1");return 0; &#125; if(n==2) &#123; printf("1");return 0; &#125; matrix f;f.row=2;f.col=2; f.p[1][2]=1;f.p[2][1]=1;f.p[2][2]=1; f=power(f,n-2); matrix ans;ans.row=2;ans.col=1; ans.p[1][1]=1;ans.p[2][1]=1; ans=cheng(f,ans); printf("%lld",ans.p[2][1]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1483】成群的细菌]]></title>
    <url>%2Fposts%2F34dd.html</url>
    <content type="text"><![CDATA[来源和评测点IPSC 2003 Problem H《算法艺术与信息学竞赛》207页（2.1代数方法和模型，[例题5]细菌，版次不同可能页码有偏差）Caioj1483 题目【题目大意】n个培养皿排成一个圈，每个里面都有一些细菌。培养皿逆时针编号为1,2,…,n，第i个培养皿里有许多个细菌。细菌不停地活动着，它们有可能会进行六种操作：d i 0，表示第i个培养皿的所有细菌都死亡。r i k，表示第i个培养皿的每个细菌分裂成k个。c i j，表示把第j个培养皿的所有细菌复制到第i个培养皿。t i j，表示把第j个培养皿的所有细菌转移到第i个培养皿。s i j，表示交换第i和第j两个培养皿的细菌。m 0 0，表示每个培养皿的细菌都同时转移到它逆时针的下一个培养皿。一旦某个培养皿里有超过s个细菌，每s个细菌会合在一起进化成一个高级组织而脱离培养皿，这些细菌重复的执行着m条命令（编号为0,1,…,m-1），即第X时刻执行第X mod m条命令。问在第t时刻执行命令后，每个培养皿各有多少个细菌？已知初始的时候每个培养皿恰好有一个细菌。【输入格式】第一行，有四个整数，n(n&lt;=100),m(m&lt;=20),t(t&lt;=10^9),s(s&lt;=10^9+7)。接下来m行，每行包括一个字符和两个整数，表示命令的详细信息。【输出格式】仅一行，输出第t时刻时，每个培养皿的细菌个数。末尾没有空格，但有回车。【输入样例】8 6 11 7r 3 5c 5 3d 2 0m 0 0t 6 4s 1 3【输出样例】1 0 0 0 0 4 4 1 分析和上一题差不多，没什么好说的 代码12]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Vijos1049】送给圣诞夜的礼品]]></title>
    <url>%2Fposts%2Fe353.html</url>
    <content type="text"><![CDATA[来源和评测点Vivian SnowVijos1049Caioj1482 题目【题目大意】有n个数，也就是说初始序列为1,2,3…nm种置换方式（有m行），每行有n个数字，这些数字互不相同而且每个数字都在1到n之间。置换操作方式为设这一行操作的第i个数字为a[i],那么就把原来序列中的第a[i]个数放到新的序列的第i的位置上，然后组成一个新的序列。从第一种置换方式开始操作，一直到最后一种操作，重复上面的操作方式。当最后一种操作结束后，组成了的序列又按照第一种来操作，一直循环下去，直到一共操作了k次为止【输入格式】第一行三个数，n（1&lt;=n&lt;=100)，m(1&lt;=m&lt;=10)和k(1&lt;=k&lt;=2^31-1)接下来m行，每行有n个数【输出格式】一行，一共有n个数，表示最终序列。n个数之间用一个空格隔开，行尾没有空格，需要回车。【输入样例】7 5 86 1 3 7 5 2 43 2 4 5 6 7 17 1 3 4 5 2 65 6 7 3 1 2 42 7 3 4 6 1 5【输出样例】2 4 6 3 5 1 7 分析真心简单把m个操作的每个操作变成一个操作矩阵这m个矩阵相乘，然后快速幂k次，与原始矩阵相乘即可 哦对了，记得因为不满足交换律，结合顺序必须依照原本的顺序如果是列向量的话，就是越左越晚 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;//*******************全局常量*******************const int MAXN=110;//*******************全局定义*******************struct matrix&#123; int row,col; int p[MAXN][MAXN]; matrix() &#123; memset(p,0,sizeof(p)); &#125;&#125;;//*******************全局变量*******************matrix c[20];//*******************实现*******************matrix cheng(matrix a,matrix b)&#123; matrix c; int n=a.row,m=a.col,p=b.col; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) c.p[i][j]+=a.p[i][k]*b.p[k][j]; c.row=n;c.col=p; return c;&#125;matrix jia(matrix a,matrix b)&#123; matrix c;c.row=a.row;c.col=a.col; for(int i=1;i&lt;=c.row;i++) for(int j=1;j&lt;=c.col;j++) c.p[i][j]=a.p[i][j]+b.p[i][j]; return c;&#125;matrix pre(int fn)&#123; matrix c; for(int i=1;i&lt;=fn;i++) c.p[i][i]=1; c.row=c.col=fn; return c;&#125;matrix power(matrix a,int e)&#123; matrix c=pre(a.row); while(e&gt;0) &#123; if(e%2==1) --e,c=cheng(c,a);//a*c也行 a=cheng(a,a);e/=2; &#125; return c;&#125;//*******************主函数*******************int main()&#123; int n,m,k;scanf("%d%d%d",&amp;n,&amp;m,&amp;k); matrix s;s.row=n;s.col=1;for(int i=1;i&lt;=n;i++) s.p[i][1]=i; matrix f=pre(n); for(int i=1;i&lt;=m;i++) &#123; c[i].row=c[i].col=n; for(int j=1;j&lt;=n;j++) &#123; int t; scanf("%d",&amp;t); c[i].p[j][t]=1; &#125; f=cheng(c[i],f); &#125; int a=k/m,b=k%m; matrix ans=power(f,a); for(int i=1;i&lt;=b;i++) ans=cheng(c[i],ans);//补上多余 ans=cheng(ans,s);//注意顺序 for(int i=1;i&lt;=n;i++) printf("%d ",ans.p[i][1]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3233】Matrix_Power_Series]]></title>
    <url>%2Fposts%2Ffb98.html</url>
    <content type="text"><![CDATA[来源和评测点POJ Monthly–2007.06.03, Huang, JinsongPoj3233Caioj1481 题目【题目大意】给定一个n行n列的矩阵A，求A+A^2+A^3+…+A^k的结果，并且输出的每个数都mod m【输入格式】第一行含有3个整数n(n≤30),k(k≤10^9) and m(m&lt;10^4)接下来n行表示输入的矩阵。【输出格式】输出结果矩阵【输入样例】2 2 40 11 1【输出样例】1 22 3 分析k灰常大，暴力显然会T设P(t)=A+A^2+….+A^t而P(t*2)=P(t)+A^t/*P(t)也就是说可以二分求解，一下变成O(logk)，灰常快 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct matrix&#123; int row,col; int p[40][40]; matrix() &#123; memset(p,0,sizeof(p)); &#125;&#125;;//*******************全局变量*******************int MOD;//*******************实现*******************matrix cheng(matrix a,matrix b)&#123; matrix c; int n=a.row,m=a.col,p=b.col; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) c.p[i][j]=(c.p[i][j]+(a.p[i][k]*b.p[k][j])%MOD)%MOD; c.row=n;c.col=p; return c;&#125;matrix jia(matrix a,matrix b)&#123; matrix c;c.row=a.row;c.col=a.col; for(int i=1;i&lt;=c.row;i++) for(int j=1;j&lt;=c.col;j++) c.p[i][j]=(a.p[i][j]+b.p[i][j])%MOD; return c;&#125;matrix pre(int fn)&#123; matrix c; for(int i=1;i&lt;=fn;i++) c.p[i][i]=1; c.row=c.col=fn; return c;&#125;matrix power(matrix a,int e)&#123; matrix c=pre(a.row); while(e&gt;0) &#123; if(e%2==1) --e,c=cheng(c,a);//a*c也行 a=cheng(a,a);e/=2; &#125; return c;&#125;matrix powsum(matrix a,int e)&#123; if(e==1) return a; if(e%2==1) return jia(powsum(a,e-1),power(a,e)); matrix t=powsum(a,e/2); return jia(t,cheng(power(a,e/2),t));&#125;//*******************主函数*******************int main()&#123; int n,k;scanf("%d%d%d",&amp;n,&amp;k,&amp;MOD); matrix s;s.row=s.col=n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;s.p[i][j]); matrix ans=powsum(s,k); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) printf("%d ",ans.p[i][j]); printf("\n"); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1480】矩阵无限方]]></title>
    <url>%2Fposts%2Fbfe0.html</url>
    <content type="text"><![CDATA[来源和评测点Caioj1480 题目【题目大意】给定一个n行n列的矩阵A，求出A^x的结果，输出的每个数都mod 10^9+7【输入格式】第一行含有两个整数n(1&lt;=n&lt;=10),x(x&lt;=2^31-1)。接下来n行表示这个矩阵。【输出格式】输出结果矩阵，每行n个数之间用一个空格隔开，行尾没有空格，需要回车【输入样例】2 31 35 2【输出样例】61 66110 83 分析显而易见的裸题 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;typedef long long ll;//*******************全局常量*******************const ll MOD=1000000007;//*******************全局定义*******************struct matrix&#123; int row,col; ll p[20][20]; matrix() &#123; memset(p,0,sizeof(p)); &#125;&#125;;//*******************实现*******************matrix cheng(matrix a,matrix b)&#123; matrix c; int n=a.row,m=a.col,p=b.col; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) c.p[i][j]=(c.p[i][j]+(a.p[i][k]*b.p[k][j])%MOD)%MOD; c.row=n;c.col=p; return c;&#125;matrix pre(int fn)&#123; matrix c; for(int i=1;i&lt;=fn;i++) c.p[i][i]=1; c.row=c.col=fn; return c;&#125;matrix power(matrix a,int e)&#123; matrix c=pre(a.row); while(e&gt;0) &#123; if(e%2==1) --e,c=cheng(c,a); //a*c也行，有的博客误导人啊 //因为快速幂中c其实只是好几个a，再多个a罢了 a=cheng(a,a);e/=2; &#125; return c;&#125;//*******************主函数*******************int main()&#123; int n,x;scanf("%d%d",&amp;n,&amp;x); matrix s;s.row=s.col=n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%lld",&amp;s.p[i][j]); matrix ans=power(s,x); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) printf("%lld ",ans.p[i][j]); printf("\n"); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Nyoj298】点的变换]]></title>
    <url>%2Fposts%2Fe629.html</url>
    <content type="text"><![CDATA[来源和评测点Nyoj298Caioj1479 题目【题目大意】平面上有不超过10000个点，坐标都是已知的现在可能对所有的点做以下几种操作：详见输入格式操作的次数不超过1000000次，求最终所有点的坐标。提示：如果程序中用到PI的值，可以用acos(-1.0)获得。【输入格式】测试数据的第一行是两个整数N,M，分别表示点的个数与操作的个数(N&lt;=10000,M&lt;=1000000)随后的一行有N对数对，每个数对的第一个数表示一个点的x坐标，第二个数表示y坐标，这些点初始坐标大小绝对值不超过100。随后的M行，每行代表一种操作，行首是一个字符：首字符如果是M,则表示平移操作，该行后面将跟两个数x,y，表示把所有点按向量(x,y)平移;首字符如果是X，则表示把所有点相对于X轴进行上下翻转;首字符如果是Y，则表示把所有点相对于Y轴进行左右翻转;首字符如果是S，则随后将跟一个数P,表示坐标放大P倍;首字符如果是R，则随后将跟一个数A,表示所有点相对坐标原点逆时针旋转一定的角度A(单位是度)【输出格式】每行输出两个数，表示一个点的坐标(对结果四舍五入到小数点后1位，输出一位小数位）点的输出顺序应与输入顺序保持一致【输入样例】2 51.0 2.0 2.0 3.0XYM 2.0 3.0S 2.0R 180【输出样例】-2.0 -2.00.0 0.0 分析首先，假如对每个点一个个进行操作的话，O(NM)显然会超时那怎么办呢？题目中每个操作都是对所有点而言的，也就是所有点都要经过各种操作那么考虑用矩阵乘法加速，把每个操作对应的矩阵推导出来就好了这样有什么好处呢？矩阵乘法不是更慢吗？答案：可以先将所有操作化为一个灰常复杂的操作O(M)，再每个点乘一次就好O(N)，共计O(M+N)提示：由于不满足交换律，所以顺序不能变 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;//*******************全局常量*******************const int MAXN=11000;const double PI=acos(-1.0);//*******************全局定义*******************struct matrix&#123; int row,col; double p[5][5]; matrix() &#123; memset(p,0,sizeof(p)); &#125;&#125;;//*******************全局变量*******************matrix pt[MAXN],c[5],ss;//*******************实现*******************matrix cheng(matrix a,matrix b)&#123; matrix c; int n=a.row,m=a.col,p=b.col; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) c.p[i][j]+=a.p[i][k]*b.p[k][j]; c.row=n;c.col=p; return c;&#125;matrix pre(int fn)&#123; matrix c; for(int i=1;i&lt;=fn;i++) c.p[i][i]=1; c.row=c.col=fn; return c;&#125;//*******************主函数*******************char s[5];int main()&#123; //横坐标加a，纵坐标加b c[0].p[1][1]=1;c[0].p[2][2]=1; c[0].p[3][3]=1;c[0].row=c[0].col=3; //把所有点相对于X轴进行上下翻转 c[1].p[1][1]=1;c[1].p[2][2]=-1; c[1].p[3][3]=1;c[1].row=c[1].col=3; //把所有点相对于Y轴进行左右翻转 c[2].p[1][1]=-1;c[2].p[2][2]=1; c[2].p[3][3]=1;c[2].row=c[2].col=3; //坐标放大P倍 c[3].p[3][3]=1;c[3].row=c[3].col=3; //所有点相对坐标原点逆时针旋转一定的角度A(单位是度) c[4].p[3][3]=1;c[4].row=c[4].col=3; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; pt[i].row=3;pt[i].col=1;pt[i].p[3][1]=1; scanf("%lf%lf",&amp;pt[i].p[1][1],&amp;pt[i].p[2][1]); &#125; ss=pre(3); while(m--) &#123; scanf("%s",s); if(s[0]=='M') &#123; double a,b;scanf("%lf%lf",&amp;a,&amp;b); c[0].p[1][3]=a;c[0].p[2][3]=b; ss=cheng(c[0],ss);//不可调换，操作越晚越左 &#125; if(s[0]=='X') ss=cheng(c[1],ss); if(s[0]=='Y') ss=cheng(c[2],ss); if(s[0]=='S') &#123; double p;scanf("%lf",&amp;p); c[3].p[1][1]=p;c[3].p[2][2]=p; ss=cheng(c[3],ss); &#125; if(s[0]=='R') &#123; double a;scanf("%lf",&amp;a); double rad=PI/180.0*a;//转弧度 c[4].p[1][1]=cos(rad);c[4].p[1][2]=-sin(rad); c[4].p[2][1]=sin(rad);c[4].p[2][2]=cos(rad); ss=cheng(c[4],ss); &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; pt[i]=cheng(ss,pt[i]); printf("%.1lf %.1lf\n",pt[i].p[1][1],pt[i].p[2][1]); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDKOI2018日志&游记]]></title>
    <url>%2Fposts%2F676d.html</url>
    <content type="text"><![CDATA[Zory at GDKOI2018 先讲讲我比赛之前的心情：以我现在的实力当然就是来打酱油的啦而且因为沉迷于升学毕业之类的乱七八糟的东西，尽管无比渴望有一天能回到像NOIP2017之前那样纯粹地沉浸在信息学竞赛中的日子，却不得不沉迷学习日渐憔悴，有点像一场豪赌吧，赌的就是我的OI生涯，希望我能实现目标，让高中的时候能有更高的效率弥补如今的损失。 比赛之前当然就是复习啦~其实这几天看我以前博客复习的时候还顺便修改 2018.01.24 Wednesday上午颓废于日了狗的主席树 下午颓废于日了狗的主席树 晚上复习主席树、Qtree、欧几里得 2018.01.25 Thursday day0上午复习匈牙利 下午出发……坐车，听了一小时的歌酒店依旧柏高，却没有当初激情 晚上复习KMP，十点半睡觉惯例： 2018.01.26 Friday day1上午早上六点半起床，其实还是有点困的，早餐人贼多为了避免上次NOIP的失误，仔细检查了要带的东西，而且这次居然允许试机，就赶快把文件夹完全弄好，并且打开记事本把密码保存下来，避免心态爆炸（忠告呀）。密码：DajiDali,chickenDinner!感觉这几次密码都很有趣 其实题目的难度不是一眼就能看出来的，毕竟都是原创题然鹅，每一道题都思考一遍之后，得出了一个可怕的结论：没有哪怕任何一道一眼题（解释一下，是指看不出做法而不是说无法AC）四小时暴力，犹如脱胎换骨，却也无可奈何感觉其实复习也没有用，自己实力不够做题少的话，知道也不会用，看不出倪端。所以就是去见见世面，了解难度的，事实上这个目的也的确达到了。 那么讲讲题目：第一题地铁，打Case，m=1，20分第二题取名，暴力，20分，手推一下KMP第三题中点，暴力，10分，不知为何错了20分第四题排列限制相邻两数差，暴力，10分总分：20+20+10+10=60正解：第一题：反向最长路（表示一脸懵逼哈）第二题：AC自动机，太久没用过完全忘记是什么了，别人提醒才想到第三题：（a*1000+b），二维转一维，化公式为卷积，FFT加速第四题：不知所云…… 总之也就丢了20分而已，忽然觉得初中组根本不是来拿分的，比谁暴力稳罢了，意义不大，也拉不开差距。很多实力超强的大佬因为各种失误居然和我分数差不多，可想而知分数的参考意义极低。 下午听讲课看到传说中的马耀华，袁无为，郭嵩山出题人好像是中大ACM队的吧,嗯严紫熙师兄也在其中咧马耀华大佬很活跃，急于展示自己的想法 晚上复习Manacher欢快的狼人杀，各种蛇皮操作，骚套路…… 2018.01.27 Saturday 讲课上午一下睡到了7:30，有点作讲课就是那本GDOI资料集里面的内容上午是数论入门和树上启发式合并感觉有用的东西然后发现自己被黄镇大佬感化了，决定等字符串复习完之后全力搞数论 下午中午吃完饭后去和lxj去万达吃牛杂和双皮奶然后被xgc感化决定翘课，因为感觉帮助不是太大 晚上和爸妈去家庭聚餐复习ExKMP 2018.01.28 Sunday day2上午嗯早餐人少多了，默默喝牛奶 T1是点阵匹配，跟曼哈顿距离有关系，题目的各种数据范围看起来可以打Case？我估了估大概能拿20分T2是最短路判断，我想了一个贪心算法，假如正确就有60分T3是推荐序列限制区间重复，dfs爆搜，复杂度上20分T4是给球涂色，数论题，我试图推公式，然后经过一番艰苦的计算，惊讶的发现可以O(N)！那就能AC了 这时候大概是9:30，考试是8:10到12:10，剩下两个半小时。这个时候做出的决定往往是关键 综合上述猜测，我决定打T4，因为T2太不确定了，于是先仔细检查了半个小时，更正了一个错误，心里想着AC的几率很大，当时心里满满的开心与感动，感觉很多人会没注意到第四题，望而生退，而我坚持下来，好歹拿个AC，一等就稳了……接着又码了一个小时，已经是11:00了。然鹅，忽然发现了一个可怕的事实，某个以为能O(1)计算的某部分的值，居然跟当前变量有关，硬生生变成了O(N^2)，当即无语……我试了试数据，发现灰常慢，很可能只有10分，可能是因为逆元常数大吧，因为我不会线性，只会用a^(mod-2)，虽然套了快速幂。 但我依旧是心怀希望的，或许可以用高中某个数学公式计算出那个部分？又或者这个东西满足某个玄学规律？于是我两管齐下，然鹅并没有什么卵用，怀恨而死，最后半小时抽空把第三题dfs打了，但样例2过不去，懒得调了，总觉得T4已经很接近正解了。 还是把这个问题共享出来吧，或许有人知道怎么算的可以评论走一波就是F[k]=给L个球涂且只涂k种颜色的方案数我当时的想法是：F[k]=k^L-sigma(p=1~k-1)[ F[p]*C(p,k) ] 出来以后，保守估计感觉只有10分…… 下午讲题的时候只是稍微听了听前面三题，看到了传说中的王之栋 然后就到了激动人心的第四题……BUT!10分做法，XXXXX，20分做法，XXXXX彻彻底底的懵逼，完全听不懂，心态爆炸好吧，所谓神仙打架 出分数的时候更加不爽，我居然没有成绩，跟着很多人去复评的计算机准备室，看到ACM队的大佬们然后发现是文件没有收取到，去原本的语音4室，还好文件不会还原，用U盘拷贝回来，然后上文说到的师兄用他的帅气macbook帮我测评，经过各种神奇的指令，大概是连接服务器什么的，然后看到第四题前面两个点居然TLE，无语了，我本来只是担心跑的慢而已，居然还错了，是我模太多次了吗？调出来看，我和答案仅仅是不同，还好并不是负数。然后最后测试T3时居然有个绿色的东西——暴力居然拿了10分，本来都快忘记了所以就没有爆0了哈哈 总结一下总分60+10=70=初中三等我这次真的缺少激情，因为已经一无所有，也就没有失去时候的痛苦。清楚自己没有多少实力，但也渴望着去改变。希望迈上高中后，我得以有质的飞跃吧……如果大家觉得索然无味，可以看看yzh大佬的风骚游记]]></content>
      <categories>
        <category>竞赛历程</category>
      </categories>
      <tags>
        <tag>赛事</tag>
        <tag>GDKOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj1325】Machine Schedule]]></title>
    <url>%2Fposts%2F7392.html</url>
    <content type="text"><![CDATA[来源和评测点Beijing 2002Poj1325 题目【题目大意】有两部机器A和B。A机器有n种工作模式0，1，2，3，……n-1，总共n种。B机器有m种工作模式0，1，2，3，……m-1，总共m种。有k个任务，每个任务可以在 A机器的某个模式 或者 B机器的某个模式中完成。A和B机器开始时都默认在0模式，要选择其他模式就要重启一次。求完成k个任务至少需要重启多少次机器。最后以0结束。输出最少重启机器的次数。【输入格式】第一行三个整数n,m,k(0&lt;n,m&lt;100,0&lt;k&lt;1000），下来k行，每行三个数p，x，y，第一个表示第p个任务，后面两个，表示该任务可以在A机器的x模式完成，或者可以选择B机器的y模式完成该任务。【输出格式】一个整数，为最少重启机器的次数。【输入样例】5 5 100 1 11 1 22 1 33 1 44 2 15 2 26 2 37 2 48 3 39 4 30【输出样例】3 分析请先仔细看题，然后思考。 其实数据的输入形式很多时候就给出了提示，例如这道题中，每个任务与A、B分别有两个可能，与点、边之间的关系灰常像。而要求最少的重启机器次数，显然最好能一个模式做多几个任务，使用过的模式数量之和就是答案。而机器只有两个，又可以联想到二分图匹配。 综上所述，构图如下：把A、B看作两个集合，模式看作点，任务看作边，每个任务连接两个点，最后通过匈牙利算法计算出最大匹配对数，根据定理得到最小点覆盖。 不过……这题目是卡邻接表的么？TLE了改成邻接矩阵就0ms了怀疑数据有超级多重边。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=100,MAXM=1000;//*******************全局定义*******************/*struct pt&#123; int hou;&#125;p[2*MAXN];struct rod&#123; int y,g;&#125;e[MAXM];*///*******************实现*******************/*int ln;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;*///*******************接口*******************int n,m,k;int ask[MAXN];int match[MAXN];bool mp[MAXN][MAXN];int t;bool findmuniu(int x)&#123; //for(int k=p[x].hou;k&gt;0;k=e[k].g) for(int i=1;i&lt;=m;i++) &#123; if(mp[x][i]==0) continue; //int i=e[k].y; if(ask[i]&lt;t) &#123; ask[i]=t; if(match[i]==0 or findmuniu(match[i])) //C++中的or逻辑关系，左边true则不会执行右边的语句 &#123; match[i]=x; return 1; &#125; &#125; &#125; return 0;&#125;//*******************主函数*******************int main()&#123; while(scanf("%d",&amp;n) and n!=0) &#123; memset(ask,0,sizeof(ask)); memset(match,0,sizeof(match)); //ln=0;for(int i=1;i&lt;=n+m;i++) p[i].hou=0; memset(mp,0,sizeof(mp)); scanf("%d%d",&amp;m,&amp;k); for(int i=1;i&lt;=k;i++) &#123; int t,a,b; scanf("%d%d%d",&amp;t,&amp;a,&amp;b); //ins(a,n+b); mp[a][b]=1; &#125; int ans=0; for(t=1;t&lt;=n;t++) ans+=findmuniu(t); printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>匈牙利</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1901】Dynamic Rankings]]></title>
    <url>%2Fposts%2F8705.html</url>
    <content type="text"><![CDATA[来源和评测点Author: XIN, TaoSource: Online Contest of Christopher’s AdventureBzoj1901Zju2112 多组数据Luogu2617Caioj1442 题目【题目大意】给n(1&lt;=n&lt;=50000)个数字，进行m(1&lt;=m&lt;=10000)次操作，有两种操作：Q l r k：询问l到r第k小的数。C x k：改变第x个数的值为k。【输入格式】第一行为n和m。接下来一行n个数。接下来m行为m个操作。【输出格式】遇到Q操作就输出。【输入样例】25 33 2 1 4 7Q 1 4 3C 2 6Q 2 5 35 33 2 1 4 7Q 1 4 3C 2 6Q 2 5 3【输出样例】3636 分析建议先阅读本文：【OI之路】06树-6主席树 可持续线段树（主席树）套树状数组 修改操作：原本的add是直接+1，现在考虑添加参数o，表示c要加上o然后先把原本数字删掉，添加新数字即可。但这样修改一个就要修改后面的全部，所以像许多其他题目一样，经典的带修改时用树状数组代替前缀和。 询问操作：也有些不同，因为统计左边部分时，用的只是某一层的值，所以用getsum时，引入函数turn来转向效果更佳~ 然鹅，Zoj死都SF，调了一整天，狂对拍，狂检查，都无济于事，又放弃了…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162//Zory-2018//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量*******************const int MAXN=51000,MAXM=11000;//*******************全局定义*******************int n;int ust[MAXN];int rx;//离散化后最大值//*******************主席树*******************struct nod&#123; int c; int lc,rc;&#125;p[MAXN*17];int rt[MAXN];int cnt;void add(int &amp;x,int l,int r,int pos,int c)&#123; if(x==0) x=++cnt; p[x].c+=c; if(l==r) return;//debug int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) add(p[x].lc,l,mid,pos,c); else add(p[x].rc,mid+1,r,pos,c);&#125;//*******************树状数组*******************int lowbit(int x) &#123;return x&amp;(-x);&#125;void change(int x,int p,int c)&#123; while(x&lt;=n) &#123; add(rt[x],1,rx,p,c); x+=lowbit(x); &#125;&#125;int lsum(int x)&#123; int sum=0; while(x&gt;=1) &#123; sum+=p[ p[ust[x]].lc ].c; x-=lowbit(x); &#125; return sum;&#125;//*******************实现******************int now[MAXN];void solve1(int x,int k)&#123; change(x,now[x],-1); now[x]=k; change(x,now[x],1);&#125;void turn(int x,int tn)&#123; while(x&gt;=1) &#123; if(tn==0) ust[x]=rt[x]; if(tn&lt;0) ust[x]=p[ ust[x] ].lc; if(tn&gt;0) ust[x]=p[ ust[x] ].rc; x-=lowbit(x); &#125;&#125;int ask(int x,int y,int l,int r,int k)//l、r锁定&#123; if(l==r) return l; int lm=lsum(y)-lsum(x); int mid=(l+r)/2; if(k&lt;=lm) &#123; turn(x,-1);turn(y,-1); return ask(x,y,l,mid,k); &#125; else &#123; turn(x,1);turn(y,1); return ask(x,y,mid+1,r,k-lm); &#125;&#125;int solve2(int x,int y,int k)&#123; turn(x-1,0);turn(y,0);//初始化 return ask(x-1,y,1,rx,k);&#125;//*******************离散化*******************struct Qes&#123; int op; int x,y,k;&#125;q[MAXM];int num[MAXN+MAXM];//原值struct Lsh&#123; int x,id,z;&#125;a[MAXN+MAXM];bool cmp(Lsh a,Lsh b) &#123;return a.x&lt;b.x;&#125;void lsh(int all)&#123; sort(a+1,a+all+1,cmp); rx=0;a[0].x=-666;//debug for(int i=1;i&lt;=all;i++) &#123; if(a[i-1].x!=a[i].x) num[++rx]=a[i].x; if(a[i].id&lt;=n) a[a[i].id].z=rx; else q[a[i].id-n].k=rx; &#125;&#125;//*******************主函数******************char s[5];int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; memset(rt,0,sizeof(rt)); int m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=cnt;i++) p[i].c=p[i].lc=p[i].rc=0; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i].x),a[i].id=i; int qs=0; for(int i=1;i&lt;=m;i++) &#123; scanf("%s",s); if(s[0]=='C') &#123; q[i].op=0; scanf("%d%d",&amp;q[i].x,&amp;q[i].k); qs++; a[n+qs].x=q[i].k; a[n+qs].id=n+i; &#125; else &#123; q[i].op=1; scanf("%d%d%d",&amp;q[i].x,&amp;q[i].y,&amp;q[i].k); &#125; &#125; lsh(n+qs); cnt=0; for(int i=1;i&lt;=n;i++) change(i,a[i].z,1),now[i]=a[i].z; for(int i=1;i&lt;=m;i++) &#123; if(q[i].op==0) solve1(q[i].x,q[i].k); else printf("%d\n",num[ solve2(q[i].x,q[i].y,q[i].k) ]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>树状数组</tag>
        <tag>莫队</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【置顶】码风与卡常技巧]]></title>
    <url>%2Fposts%2F3834.html</url>
    <content type="text"><![CDATA[我的码风与卡常技巧，以下内容基本贯穿全站。 注意事项！运算符的优先级参见运算符的优先级然后我个人经常被【三目运算符的超级低优先级】坑害而花大量时间调试…… 码风最大数的表示int下：memset(127)=0x7fffffff=2147483647memset(63)=0x3f3f3f3f=1061109567通常用0x3f3f3f3f表示INF，因为两个INF相加不会超过int极限，且正好与memset(63)相同 大括号以for为例1234for(int i=555;i&lt;=666;i++)&#123; ......&#125; 空格运算符周围没有任何空格i=a+b左圆（方）括号后、右圆（方）括号前，在书写长表达式时，为了便于阅读，可以加一个空格，如f[i][j]=f[ f[i][j-1] ][j-1] 0与1 通常情况下，数组、字符串、循环等都从1开始， 仅对与二进制性质、运用有关操作时，才从0开始。 表示逻辑值时，除非要输入用int（避免溢出），否则用bool 结构 在#include中，C标准库头文件必须使用c前缀，而不是.h后缀，并应该放置于C++ 标准库头文件前，如果有其它头文件应放置于最后。 所有的预编译指令（包括#ifdef等）不能缩进。 main函数应该放置于整个程序末尾。 多个意义独立的代码块之间应该用空行隔开。 通常情况下，除非有依赖关系，否则离主函数越近则越接口化，越远则越底层。 对于每个代码块，使用4空格或等长的Tab缩进。 变量名 局部变量必须在用时定义 所有常量命名为全大写 所有结构体命名为首字母大写，其他小写 其他所有需要命名的地方为全小写 避免危险的变量名如 next time x0(cmath) y0(cmath) hash （可以自己建立namespace规避） 技巧数组空间64MB 1kw128MB 2kw256MB 5kw512MB 10kw 【谨慎使用】 时间复杂度1s 10kw 读入应用范围：大量输入这个就灰常常用啦123456void read(int &amp;s)&#123; s=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') s=s*10+c-'0',c=getchar();&#125; 函数的定义inline应用范围：不递归的简单、频繁调用函数1inline int lowbit(int x) &#123;return x&amp;(-x);&#125; 计算平时多用点位运算啦123(a&amp;1)=(a%2==1)(a&lt;&lt;1)=(a\*2)(a&gt;&gt;1)=(a/2) sort的使用曾经天真地以为加上=可以少点交换，然鹅可能是具体实现方式吧，加上更慢……1bool cmp(Num a,Num b) &#123;return a.prime&lt;b.prime;&#125; memset全局变量默认是0，没必要再置零了 LCA我个人是比较稀饭倍增的但是如果会T，可以考虑变成ST表，常数÷6如果预处理log值，还可以常数÷5，加起来就超级快了条件：没有修改 取模素数19260817萌娘百科 字符串hash进制数13331或者131]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>原创精华</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3196】【Luogu3380】二逼平衡树]]></title>
    <url>%2Fposts%2Fd7e9.html</url>
    <content type="text"><![CDATA[来源和评测点Tyvj1730Bzoj3196Luogu3380Caioj1135 题目【题目大意】您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：1.查询k在区间内的排名2.查询区间内排名为k的值3.修改某一位值上的数值4.查询k在区间内的前驱(前驱定义为小于x，且最大的数)5.查询k在区间内的后继(后继定义为大于x，且最小的数)【输入格式】第一行两个数 n,m 表示长度为n的有序序列和m个操作第二行有n个数，表示有序序列下面有m行，opt表示操作标号若opt=1 则为操作1，之后有三个数l,r,k 表示查询k在区间[l,r]的排名若opt=2 则为操作2，之后有三个数l,r,k 表示查询区间[l,r]内排名为k的数若opt=3 则为操作3，之后有两个数pos,k 表示将pos位置的数修改为k若opt=4 则为操作4，之后有三个数l,r,k 表示查询区间[l,r]内k的前驱若opt=5 则为操作5，之后有三个数l,r,k 表示查询区间[l,r]内k的后继【输出格式】对于操作1,2,4,5各输出一行，表示查询结果【输入样例】9 64 2 2 1 9 4 0 1 12 1 4 33 4 102 1 4 31 2 5 94 3 9 55 2 8 5【输出样例】24349 分析1其他伸展树 第一次树套树，第一次代码行数300+ 线段树关键字：位置关系伸展树关键字：大小关系 n=m=50000，num=100000000logn=16，lognum=27建树2n颗，nlogn个节点，时间nlogn 接下来分析几个操作：1.查排名，(区间logn)*(前驱logn)=256，（每个完整子区间中k的排名-1）之和+12.找数字，(二分lognum)*(区间logn)*(后继logn)=6912，调用操作1，二分数字，验证3.改数字，2*(深度logn)*(伸展操作logn)=512，删除，添加4.5.前驱后继，(区间logn)*(前驱后继logn)=256，每个完整子区间中k的前驱后继的极值总时间：极限200000000即3s 从线段树的角度看：每个区间一个线段树从Splay的角度看：所有的Splay都挂在超级根节点Root上，注意我采取某些手段避免了Root向下认儿子 代码1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=50000+10;const int NUL=-1;const int Root=0;const int INF=0x7fffffff;//*******************Splay1-基础操作*******************struct pt&#123; int son[2],f; int d; int n,c; pt() &#123; son[0]=son[1]=f=NUL; &#125;&#125;p[30*MAXN];int ln=0;void update(int x)&#123; p[x].c=p[x].n; int lc=p[x].son[0],rc=p[x].son[1]; if(lc!=NUL) p[x].c+=p[lc].c; if(rc!=NUL) p[x].c+=p[rc].c;&#125;void rotate(int x,int w)&#123; int f=p[x].f,ff=p[f].f; if(ff!=Root) &#123; if(p[ff].son[0]==f) p[ff].son[0]=x; else p[ff].son[1]=x; &#125; p[x].f=ff; int xson=p[x].son[w]; if(xson!=NUL) p[xson].f=f; p[f].son[1-w]=xson; p[x].son[w]=f; p[f].f=x; update(f); update(x);&#125;void add(int d,int f)&#123; ln++; p[ln].d=d;p[ln].f=f; p[ln].n=p[ln].c=1; p[ln].son[0]=p[ln].son[1]=NUL; if(f!=Root) &#123; if(d&lt;p[f].d) p[f].son[0]=ln; else p[f].son[1]=ln; &#125;&#125;//*******************Splay2-与根有关*******************int root[2*MAXN];void splay(int r,int x,int rt)&#123; while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(ff==rt) &#123; if(p[f].son[0]==x) rotate(x,1); else rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==Root) root[r]=x;&#125;int findip(int r,int d)&#123; int x=root[r]; while(p[x].d!=d) &#123; int lc=p[x].son[0],rc=p[x].son[1]; if(d&lt;p[x].d) &#123; if(lc!=NUL) x=lc; else break; &#125; else &#123; if(rc!=NUL) x=rc; else break; &#125; &#125; return x;&#125;void ins(int r,int d)&#123; if(root[r]==NUL) &#123; add(d,Root); root[r]=ln; &#125; else &#123; int x=findip(r,d); if(p[x].d==d) &#123; p[x].n++; splay(r,x,Root); &#125; else &#123; add(d,x); splay(r,ln,Root); &#125; &#125;&#125;void del(int r,int d)&#123; int x=findip(r,d); if(p[x].d!=d) return; splay(r,x,Root); if(p[x].n&gt;1) &#123; p[x].n--; update(x); &#125; else &#123; int lc=p[x].son[0],rc=p[x].son[1]; if(lc==NUL and rc==NUL) &#123; root[r]=NUL; &#125; else if(lc!=NUL and rc==NUL) &#123; root[r]=lc; p[lc].f=Root; &#125; else if(lc==NUL and rc!=NUL) &#123; root[r]=rc; p[rc].f=Root; &#125; else &#123; int w=lc;while(p[w].son[1]&gt;0) w=p[w].son[1]; splay(r,w,x);root[r]=w;p[w].f=Root; p[w].son[1]=rc;p[rc].f=w; update(w); &#125; &#125;&#125;int findQ(int r,int d)&#123; int x=findip(r,d);splay(r,x,Root); if(p[x].d&gt;=d and p[x].son[0]!=NUL) &#123; x=p[x].son[0]; while(p[x].son[1]!=NUL) x=p[x].son[1]; &#125; if(p[x].d&lt;d) return p[x].d; return -INF;&#125;int findH(int r,int d)&#123; int x=findip(r,d);splay(r,x,Root); if(p[x].d&lt;=d and p[x].son[1]!=NUL) &#123; x=p[x].son[1]; while(p[x].son[0]!=NUL) x=p[x].son[0]; &#125; if(p[x].d&gt;d) return p[x].d; return INF;&#125;int findbf(int r,int d)//更小的&#123; int x=findip(r,d);splay(r,x,Root); int lc=p[x].son[0]; if(p[x].d==d) return p[ (lc==NUL)?0:lc ].c; if(p[x].d&gt;d and lc!=NUL) &#123; x=lc; while(p[x].son[1]!=NUL) x=p[x].son[1]; &#125; if(p[x].d&lt;d) &#123; splay(r,x,Root);lc=p[x].son[0]; return p[ (lc==NUL)?0:lc ].c+p[x].n; &#125; else return 0;&#125;//*******************线段树*******************int num[MAXN];struct mg&#123; int l,r; int lc,rc;&#125;s[2*MAXN];int len=0;int build(int l,int r)&#123; int t=++len;s[t].l=l;s[t].r=r; for(int i=l;i&lt;=r;i++) ins(t,num[i]); //把t作为根节点的下标 if(l==r) s[t].lc=s[t].rc=NUL; else &#123; int mid=(l+r)/2; s[t].lc=build(l,mid); s[t].rc=build(mid+1,r); &#125; return t;&#125;void change(int x,int pos,int yd,int d)//改数字&#123; del(x,yd);ins(x,d); if(s[x].l==s[x].r) return; int mid=(s[x].l+s[x].r)/2; if( pos&lt;=mid ) change(s[x].lc,pos,yd,d); else change(s[x].rc,pos,yd,d);&#125;//*******************接口*******************int solve1(int x,int l,int r,int d)//查排名&#123; if(s[x].l==l and s[x].r==r) return findbf(x,d); int lc=s[x].lc,rc=s[x].rc,mid=(s[x].l+s[x].r)/2; if(r&lt;=mid) return solve1(lc,l,r,d); if(l&gt;mid) return solve1(rc,l,r,d); return solve1(lc,l,mid,d)+solve1(rc,mid+1,r,d);&#125;int solve2(int l,int r,int k)//找数字&#123; int ll=0,rr=100000000,ans=-1; //满足运用二分的条件，因为数字与排名成正比 while(ll&lt;=rr) &#123; int mid=(ll+rr)/2,rk=solve1(1,l,r,mid)+1; if(rk&lt;=k) ans=mid,ll=mid+1; else rr=mid-1; &#125; return ans;&#125;int solve4(int x,int l,int r,int d)//前驱&#123; if(s[x].l==l and s[x].r==r) &#123; int t=findQ(x,d); return (t==NUL)?0:t; &#125; int lc=s[x].lc,rc=s[x].rc,mid=mid=(s[x].l+s[x].r)/2; if(r&lt;=mid) return solve4(lc,l,r,d); if(l&gt;mid) return solve4(rc,l,r,d); return mymax( solve4(lc,l,mid,d),solve4(rc,mid+1,r,d) );&#125;int solve5(int x,int l,int r,int d)//后继&#123; if(s[x].l==l and s[x].r==r) &#123; int t=findH(x,d); return (t==NUL)?0x3f3f3f3f:t; &#125; int lc=s[x].lc,rc=s[x].rc,mid=(s[x].l+s[x].r)/2; if(r&lt;=mid) return solve5(lc,l,r,d); if(l&gt;mid) return solve5(rc,l,r,d); return mymin( solve5(lc,l,mid,d),solve5(rc,mid+1,r,d) );&#125;//*******************主函数*******************int main()&#123; memset(root,NUL,sizeof(root)); int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;num[i]); build(1,n); while(m--) &#123; int op;scanf("%d",&amp;op); if(op==3) &#123; int pos,d;scanf("%d%d",&amp;pos,&amp;d); change(1,pos,num[pos],d);num[pos]=d; &#125; else &#123; int l,r,k;scanf("%d%d%d",&amp;l,&amp;r,&amp;k); if(op==1) printf("%d\n",solve1(1,l,r,k)+1); if(op==2) printf("%d\n",solve2(l,r,k)); if(op==4) printf("%d\n",solve4(1,l,r,k)); if(op==5) printf("%d\n",solve5(1,l,r,k)); &#125; &#125;&#125; 分析2然鹅Bzoj的评论里面有这样几句话：“用平衡树的都是二逼青年”“有智慧的长者都写主席树”so，依旧被D飞赶紧复习一波主席树 哦补充一下，我在打的时候突然想到一个问题：假如r的lowbit覆盖了l-1,那么它不就会turn两次了？后来经提醒发现，这种turn两次的情况理论上虽然是错的，但因为他们都是被覆盖两次的，所以求前缀和的时候刚好抵消了…… 优点就是少了一百行……，速度还快了三倍！ 代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207//Zory-2018//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量*******************const int MAXN=50010,MAXM=50010;const int INF=0x7fffffff;//*******************全局定义*******************int n;int rx;int num[MAXN+MAXM];int now[MAXN];//*******************主席树******************struct Nod&#123; int c; int lc,rc; Nod() &#123;c=lc=rc=0;&#125;&#125;p[MAXN*20*10];int rt[MAXN];int ust[MAXN];int cnt=0;void add(int &amp;x,int l,int r,int pos,int c)&#123; if(!x) x=++cnt; p[x].c+=c; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) add(p[x].lc,l,mid,pos,c); else add(p[x].rc,mid+1,r,pos,c);&#125;//*******************树状数组******************int lowbit(int x) &#123;return x&amp;(-x);&#125;void change(int x,int pos,int c)&#123; while(x&lt;=n) &#123; add(rt[x],1,rx,pos,c); x+=lowbit(x); &#125;&#125;int getlsum(int x)&#123; int s=0; while(x&gt;=1) &#123; s+=p[ p[ust[x]].lc ].c; x-=lowbit(x); &#125; return s;&#125;int getsum(int x)&#123; int s=0; while(x&gt;=1) &#123; s+=p[ust[x]].c; x-=lowbit(x); &#125; return s;&#125;int getrsum(int x)&#123; int s=0; while(x&gt;=1) &#123; s+=p[ p[ust[x]].rc ].c; x-=lowbit(x); &#125; return s;&#125;void turn(int x,int tn)&#123; while(x&gt;=1) &#123; if(tn==0) ust[x]=rt[x]; if(tn==-1) ust[x]=p[ ust[x] ].lc; if(tn==1) ust[x]=p[ ust[x] ].rc; x-=lowbit(x); &#125;&#125;//*******************实现******************struct Qes&#123; int op; int x,y,k;&#125;q[MAXM];int qian;int ask1(int x,int y,int l,int r,int k)&#123; if(l==r) return qian; int mid=(l+r)&gt;&gt;1; if(k&lt;=mid) &#123; turn(x-1,-1);turn(y,-1); return ask1(x,y,l,mid,k); &#125; else &#123; qian+=getlsum(y)-getlsum(x-1); turn(x-1,1);turn(y,1); return ask1(x,y,mid+1,r,k); &#125;&#125;int solve1(int l,int r,int k)//k在区间内的排名&#123; turn(l-1,0);turn(r,0); qian=0; return ask1(l,r,1,rx,k)+1;&#125;int ask2(int x,int y,int l,int r,int k)&#123; if(l==r) return num[l]; int ls=getlsum(y)-getlsum(x-1); int mid=(l+r)&gt;&gt;1; if(k&lt;=ls) &#123; turn(x-1,-1);turn(y,-1); return ask2(x,y,l,mid,k); &#125; else &#123; turn(x-1,1);turn(y,1); return ask2(x,y,mid+1,r,k-ls); &#125;&#125;int solve2(int l,int r,int k)//区间内排名为k的值&#123; turn(l-1,0);turn(r,0); return ask2(l,r,1,rx,k);&#125;void solve3(int pos,int k)//修改&#123; change(pos,now[pos],-1); now[pos]=k; change(pos,now[pos],1);&#125;int solve4(int l,int r,int k)//查询k在区间内的前驱，没有则-INF&#123; int t=solve1(l,r,k)-1; if(t==0) return -INF; return solve2(l,r,t);&#125;int solve5(int l,int r,int k)//查询k在区间内的后继，没有则INF&#123; int t=solve1(l,r,k+1)-1; if(t==(r-l+1)) return INF; return solve2(l,r,t+1);&#125;//*******************离散化******************struct Lsh&#123; int x,id,z;&#125;a[MAXN+MAXM];bool cmp(Lsh a,Lsh b) &#123;return a.x&lt;b.x;&#125;void lsh(int all)&#123; sort(a+1,a+all+1,cmp); rx=0;a[0].x=-INF; for(int i=1;i&lt;=all;i++) &#123; if(a[i-1].x!=a[i].x) num[++rx]=a[i].x;//debug if(a[i].id&lt;=n) a[a[i].id].z=rx; else q[a[i].id-n].k=rx; &#125;&#125;//*******************主函数******************int main()&#123; int m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i].x),a[i].id=i; int all=n; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;q[i].op,&amp;q[i].x); if(q[i].op==2) scanf("%d%d",&amp;q[i].y,&amp;q[i].k); else &#123; all++; if(q[i].op!=3) scanf("%d",&amp;q[i].y); scanf("%d",&amp;a[all].x); a[all].id=n+i; &#125; &#125; lsh(all); for(int i=1;i&lt;=n;i++) now[i]=a[i].z,change(i,now[i],1); for(int i=1;i&lt;=m;i++) &#123; if(q[i].op==1) printf("%d\n",solve1(q[i].x,q[i].y,q[i].k)); if(q[i].op==2) printf("%d\n",solve2(q[i].x,q[i].y,q[i].k)); if(q[i].op==3) solve3(q[i].x,q[i].k); if(q[i].op==4) printf("%d\n",solve4(q[i].x,q[i].y,q[i].k)); if(q[i].op==5) printf("%d\n",solve5(q[i].x,q[i].y,q[i].k)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>伸展树</tag>
        <tag>主席树</tag>
        <tag>莫队</tag>
        <tag>难度3</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WZK的减肥计划]]></title>
    <url>%2Fposts%2Ff8f3.html</url>
    <content type="text"><![CDATA[来源和评测点NOIP2009 赛前集训（CZYZ2009 暑假集训提高组 5） 题目【题目大意】有 n 种食品可供 WZK 选择，每种物品都有给定的价格，卡路里和拥有数量，选出一些食品使得总卡路里大于要求量且最小，如果有多种组合满足条件， 则取价格最小的。【输入格式】第一行为两个整数 n(0&lt;n&lt;=100)，k（0&lt;k&lt;=10^5）分别表示物品个数和一天消耗的最少卡路里。接下来n行每行 3 个整数，costi，mi，cali（0&lt; costi,1&lt;=mi&lt;=100,cali&lt;10^6）分别表示价格，数量和所含卡路里。输入数据保证合法、有解。【输出格式】满足条件的总卡路里和总价格，中间用一个空格隔开。注意：保证答案的总卡路里小于 10^5，总价格小于 10^8。【输入样例】5 1010 2 65 1 96 1 69 1 65 1 9【输出样例】12 15 分析话说今天生日耶，刷个卡~ 注意，逻辑上答案应该是可以何要求值（原题为WZK的需求量）一样的，但题目确实要求大于，机房许多大佬都错了，就是因为这个，暴0时间复杂度nk，应该这个才是正解，虽然数据水体现不出来注意现在更像多重背包了重点：c也就是使用量只跟物品有关，考试时以为实现不出来 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int mymin(int a,int b) &#123;return a&lt;b?a:b;&#125;int f[100010],c[100010];int main()&#123; freopen("plan.in","r",stdin); freopen("plan.out","w",stdout); memset(f,63,sizeof(f)); f[0]=0;int mi=100000; int n,k;scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++)//100 &#123; memset(c,0,sizeof(c));//c=在这个物品下，f对应的物品使用量 int cost,m,cal;scanf("%d%d%d",&amp;cost,&amp;m,&amp;cal); for(int j=0;j&lt;=k;j++)//100000 &#123; if(c[j]&lt;m) &#123; int ca=j+cal; if(ca&gt;k and ca&lt;mi) mi=ca; if(f[j]+cost&lt;f[ca]) &#123; c[ca]=c[j]+1; f[ca]=f[j]+cost; &#125; &#125; &#125; &#125; printf("%d %d\n",mi,f[mi]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3224】普通平衡树]]></title>
    <url>%2Fposts%2Fe070.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj3224Codevs4543Caioj1130 题目【题目大意】写一种数据结构来维护一些数，其中需要提供以下操作：1. 插入数字x2. 删除数字x(若有多个相同的数，应只删除一个)3. 查询数字x的排名(若有多个相同的数，因输出最小的排名)4. 查询排名为x的数5. 求数字x的前驱(前驱定义为小于x，且最大的数)6. 求数字x的后继(后继定义为大于x，且最小的数)【输入格式】第一行为n，表示操作的个数,下面n行每行有两个数opt和x，opt表示操作的序号1&lt;=opt&lt;=6 n&lt;=100000 所有数字均在-210^9到210^9内【输出格式】对于操作3,4,5,6每行输出一个数，表示对应答案【输入样例】81 101 201 303 204 22 105 256 -1【输出样例】2202020 分析【OI之路】06树-4伸展树的模版 核心思路在于：对于某节点，左子树是关键字（在这道题中是大小关系）比该节点大的，右子树比该节点小接着在保证这个平衡（中序遍历保持不变）的情况下，进行各种操作 旋转Rotate 旋转到某节点下Splay网上的一段话: 在实际情况中，90%的访问发生在10%的数据上。因此，我们可以重构树的结构，使得被经常访问的节点朝树根的方向移动。尽管这会引入额外的操作，但是经常被访问的节点被移动到了靠近根的位置，因此，对于这部分节点，我们可以很快的访问。这样，就能使得平摊复杂度为logN。伸展树就是基于这一原理。 很多细节可以考虑大量注释 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=100000;const int Nul=-1;//空节点const int Root=0;//超级根//**********************定义*************************struct pt&#123; int son[2],f; int d;//值 int c,n;//n是同值个数，c是管理节点数（包括自己） pt() &#123; son[0]=son[1]=f=Nul;//debug &#125;&#125;p[2*MAXN];//***********************基本操作***********************void update(int x)&#123; p[x].c=p[x].n; int lc=p[x].son[0],rc=p[x].son[1]; if(lc!=Nul) p[x].c+=p[lc].c; if(rc!=Nul) p[x].c+=p[rc].c;&#125;int ln=0;void add(int d,int f)&#123; ln++; p[ln].d=d;p[ln].f=f; p[ln].c=p[ln].n=1; p[ln].son[0]=p[ln].son[1]=Nul; if(f&gt;0)//debug &#123; if(d&lt;p[f].d) p[f].son[0]=ln; else p[f].son[1]=ln; &#125;&#125;int root=Nul;//真实根int findip(int d)&#123; int x=root; while(p[x].d!=d) &#123; int lc=p[x].son[0],rc=p[x].son[1]; if(d&lt;p[x].d) &#123; if(lc!=Nul) x=lc; else break; &#125; else &#123; if(rc!=Nul) x=rc; else break; &#125; &#125; return x;&#125;//有同值返回该点，否则某叶子节点void rotate(int x,int w)//w=0 x的父亲成为x的左孩子&#123; int f=p[x].f,ff=p[f].f; if(ff&gt;0)//debug &#123; if(p[ff].son[0]==f) p[ff].son[0]=x; else if(p[ff].son[1]==f) p[ff].son[1]=x; &#125; p[x].f=ff; int xson=p[x].son[w]; p[f].son[1-w]=xson; if(xson!=Nul) p[xson].f=f; p[x].son[w]=f; p[f].f=x; update(f); update(x);&#125;void splay(int x,int rt)//x成为rt的孩子&#123; while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(ff==rt) &#123; if(p[f].son[0]==x) rotate(x,1); else if(p[f].son[1]==x) rotate(x,0); &#125; else &#123; //x不能连续跳两次，灰常容易变成链（由树退化成链表） if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==Root) root=x;&#125;//***********************功能************************void inc(int d)&#123; if(root==Nul) &#123; add(d,Root); root=ln; &#125; else &#123; int x=findip(d); if(p[x].d==d) &#123; p[x].n++; splay(x,Root); //在里面自动进行了update //询问前n不重要 &#125; else &#123; add(d,x); splay(ln,Root); //据说：90%的访问发生在10%的数据上 &#125; &#125;&#125;void del(int d)&#123; int x=findip(d); if(p[x].d!=d) return; splay(x,Root); if(p[x].n&gt;1) &#123; p[x].n--; update(x); &#125; else &#123; int lc=p[x].son[0],rc=p[x].son[1]; if(lc==Nul and rc==Nul) &#123; ln=0;root=Nul; &#125; else if(lc==Nul and rc!=Nul) &#123; root=rc; p[root].f=Root; &#125; else if(lc!=Nul and rc==Nul) &#123; root=lc; p[root].f=Root; &#125; else &#123; int k=lc; while(p[k].son[1]!=Nul) k=p[k].son[1]; splay(k,x);root=k;p[k].f=Root; p[k].son[1]=rc;p[p[x].son[1]].f=k; update(k);//debug &#125; &#125;&#125;int askrank(int d)&#123; int x=findip(d); if(p[x].d!=d) return -1; splay(x,Root); int lc=p[x].son[0],lcc=(lc==Nul)?0:p[lc].c;//debug return lcc+1;&#125;int asknum(int rk)&#123; int x=root; while(1) &#123; if(rk&gt;p[x].c) return -1; int lc=p[x].son[0],lcc=(lc==Nul)?0:p[lc].c; if(rk&lt;=lcc) x=lc; else if(rk&gt;lcc+p[x].n) rk-=lcc+p[x].n,x=p[x].son[1]; else break; &#125; splay(x,Root); return p[x].d;&#125;int findQ(int d)&#123; int x=findip(d);splay(x,Root); if(p[x].d&gt;=d and p[x].son[0]!=Nul) &#123; x=p[x].son[0]; while(p[x].son[1]&gt;0) x=p[x].son[1]; &#125; if(p[x].d&lt;d) return p[x].d; return -1;&#125;int findH(int d)&#123; int x=findip(d);splay(x,Root); if(p[x].d&lt;=d and p[x].son[1]!=Nul) &#123; x=p[x].son[1]; while(p[x].son[0]&gt;0) x=p[x].son[0]; &#125; if(p[x].d&gt;d) return p[x].d; return -1;&#125;//***********************************************int main()&#123; int n;scanf("%d",&amp;n); while(n--) &#123; int opx,x;scanf("%d%d",&amp;opx,&amp;x); if(opx==1) inc(x); if(opx==2) del(x); if(opx==3) printf("%d\n",askrank(x)); if(opx==4) printf("%d\n",asknum(x)); if(opx==5) printf("%d\n",findQ(x)); if(opx==6) printf("%d\n",findH(x)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Ural1028】【Vijos1066】弱弱的战壕]]></title>
    <url>%2Fposts%2F5d1d.html</url>
    <content type="text"><![CDATA[来源和评测点Problem Author: Pavel ZaletskyProblem Source: Ural Collegiate Programming Contest ‘99Ural1028Vijos1066 题目【题目大意】永恒和mx正在玩一个即时战略游戏，名字嘛~~恕本人记性不好，忘了。mx在他的基地附近建立了n个战壕，每个战壕都是一个独立的作战单位，射程可以达到无限。但是，战壕有一个弱点，就是只能攻击它的左下方，说白了就是横纵坐标都不大于它的点（mx：“我的战壕为什么这么菜”ToT）。这样，永恒就可以从别的地方进攻摧毁战壕，从而消灭mx的部队。战壕都有一个保护范围，同它的攻击范围一样，它可以保护处在它左下方的战壕。所有处于它保护范围的战壕都叫做它的保护对象。这样，永恒就必须找到mx的战壕中保护对象最多的点，从而优先消灭它。现在，由于永恒没有时间来计算，所以拜托你来完成这个任务：给出这n个战壕的坐标xi、yi，要你求出保护对象个数为0，1，2……n-1的战壕的个数。【输入格式】第一行，一个正整数n（1&lt;=n&lt;=15000）接下来n行，每行两个数xi,yi，代表第i个点的坐标（1&lt;=xi,yi&lt;=32000）注意：可能包含多重战壕的情况（即有数个点在同一坐标）【输出格式】输出n行，分别代表保护对象为0，1，2……n-1的战壕的个数。【输入样例】51 15 17 13 35 5【输出样例】12110 分析做做难度不大但有所创新的题目还是挺好的先排序一遍确保形如这样123* - **** ****** ***** *** 按顺序处理就保证了y更小接着用树状数组维护x的前缀和即可 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//Zory-2017//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=15000;//*******************全局定义*******************struct pt&#123; int x,y;&#125;p[MAXN+10];//*******************接口*******************int lowbit(int x) &#123;return x&amp;-x;&#125;int s[32000+10];void add(int f)&#123; while(f&lt;=32001) &#123; s[f]+=1; f+=lowbit(f); &#125;&#125;int ask(int r)&#123; int sum=0; while(r&gt;0) &#123; sum+=s[r]; r-=lowbit(r); &#125; return sum;&#125;//*******************主函数*******************bool cmp(pt a,pt b)&#123; if(a.y==b.y) return a.x&lt;=b.x; return a.y&lt;=b.y; /* * - **** ***** * ***** *** */&#125;int ans[MAXN+10];int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].x,&amp;p[i].y); sort(p+1,p+1+n,cmp); for(int i=1;i&lt;=n;i++) &#123; ans[ask(p[i].x+1)]++; add(p[i].x+1); &#125; for(int i=0;i&lt;=n-1;i++) printf("%d\n",ans[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1012】最大数]]></title>
    <url>%2Fposts%2F5f48.html</url>
    <content type="text"><![CDATA[来源和评测点JSOI2008数据Bzoj1012 题目【题目大意】现在请求你维护一个数列，要求提供以下两种操作：1、 查询操作。语法：Q L 功能：查询当前数列中末尾L个数中的最大的数，并输出这个数的值。限制：L不超过当前数列的长度。2、 插入操作。语法：A n 功能：将n加上t，其中t是最近一次查询操作的答案（如果还未执行过查询操作，则t=0)，并将所得结果对一个固定的常数D取模，将所得答案插入到数列的末尾。限制：n是非负整数并且在长整范围内。注意：初始时数列是空的，没有一个数。【输入格式】第一行两个整数，M和D，其中M表示操作的个数(M &lt;= 200,000)，D如上文中所述，满足D在longint内。接下来M行，查询操作或者插入操作。【输出格式】对于每一个询问操作，输出一行。该行只有一个数，即序列中最后L个数的最大数。【输入样例】5 100A 96Q 1A 97Q 1Q 2【输出样例】969396 分析1看似插入是Splay，其实结构并没有变化。加上区间查询，考虑线段树，建树的时候保留空位就好了。 代码11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/************************************************************** Problem: 1012 User: Zory Language: C++ Result: Accepted Time:1076 ms Memory:10196 kb****************************************************************/ //Zory-2017//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=200000;//*******************全局定义*******************struct pt&#123; int l,r,mid; int lc,rc; int mx;&#125;p[MAXN*2+10];//*******************线段树*******************void change(int x,int pf,int c)&#123; if(p[x].l==p[x].r) &#123; p[x].mx=c; return; &#125; int lc=p[x].lc,rc=p[x].rc; if(pf&lt;=p[x].mid) change(lc,pf,c); else change(rc,pf,c); p[x].mx=mymax(p[lc].mx,p[rc].mx);&#125;int ask(int x,int l,int r)&#123; if(p[x].l==l and p[x].r==r) return p[x].mx; int lc=p[x].lc,rc=p[x].rc; int mid=p[x].mid; if(r&lt;=mid) return ask(lc,l,r); else if(l&gt;mid) return ask(rc,l,r); else return mymax( ask(lc,l,mid),ask(rc,mid+1,r) );&#125;//*******************接口*******************int ln=0;int build(int l,int r)&#123; int t=++ln; p[t].l=l;p[t].r=r;p[t].mid=(l+r)/2; p[t].mx=0; if(l==r) p[t].lc=p[t].rc=-1; else &#123; p[t].lc=build(l,p[t].mid); p[t].rc=build(p[t].mid+1,r); &#125; return t;&#125;//*******************主函数*******************char s[5];int main()&#123; int m,D;scanf("%d%d",&amp;m,&amp;D); build(1,m);int len=0,t=0; while(m--) &#123; int a;scanf("%s%d",s,&amp;a); if(s[0]=='Q') &#123; t=ask(1,len-a+1,len); printf("%d\n",t); &#125; else change(1,++len,(a+t)%D); &#125;&#125; 分析2然后看到了六个月前的代码，原来暴力还更快…… 代码21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/************************************************************** Problem: 1012 User: Zory Language: C++ Result: Accepted Time:468 ms Memory:2384 kb****************************************************************/ #include&lt;cstdio&gt;//#include&lt;cstdlib&gt;//#include&lt;cstring&gt;//#include&lt;cctype&gt;//#include&lt;cmath&gt;//#include&lt;ctime&gt;//#include&lt;queue&gt;//#include&lt;iostream&gt;//#include&lt;string&gt;//#include&lt;iomanip&gt;//#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int mymax(int a,int b)&#123; return a&gt;b?a:b;&#125;int mymin(int a,int b)&#123; return a&gt;b?b:a;&#125;//*******************实现*******************char s[5];int a[200010],mx[200010];int main(int argc, char *argv[])&#123; int m,p;scanf("%d%d",&amp;m,&amp;p); int len=0,k=0; for(int i=1;i&lt;=m;i++) &#123; int t; scanf("%s %d",s,&amp;t); if(s[0]=='A') &#123; a[++len]=(t+k)%p; for(int j=len;j;j--) if(mx[j]&lt;a[len]) mx[j]=a[len]; else break;//剪枝 &#125; else printf("%d\n",k=mx[len-t+1]); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CZYZ2009暑假集训提高组6】盟军敢死队]]></title>
    <url>%2Fposts%2F310b.html</url>
    <content type="text"><![CDATA[来源和评测点CZYZ2009暑假集训提高组6 题目【题目大意】仓库是一个 m*n的矩形区域， 每一格用一个字符来描述：“.” 代表空地; “#”代表墙或障碍物;“^”, “v”(小写), “&lt;”, “&gt;”四个字符分别表示正向 NSWE 四个方向看的敌人。敌人总是保持固定不动并朝着一个方向看，从这个方向一直延伸直到边界或障碍物的区域是他的视线范围，如果一个敌人没有在任何人的视线范围之内，敢死队员就可以消灭他。你不能消灭一个正在另一个活着的敌人视线范围内的敌人，否则你就会被发现，后果不堪设想。一个敌人不会成为遮挡视线的障碍物。【输入格式】输入数据的第一行是用空格分开的两个整数 n,m ，分别表示仓库的长和宽。接下来有 n行，每行 m个字符，是仓库的描述。100%的数据中，1&lt;=m, n&lt;=6090%的数据中，敌人数不超过 10100%的数据中，敌人数不超过 15【输出格式】如果能够成功消灭所有敌人，输出消灭所有敌人的不同顺序的数量，否则输出“Impossible” （不含引号）。【输入样例1】2 2&gt;^#^【输出样例1】2【输入样例2】1 3&gt;.&lt;【输出样例2】Impossible 分析挺好的状压题注释很详细“一看数据范围就知道是状压”话说有的人一看就觉得是暴力，其实也有道理事实上时间是压着过去的 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;//**********************************************struct pr&#123; int x,y; int tr;&#125;p[20];int pn;bool rd[20][20];//i能否看到j//**********************************************int mp[100][100];//**********************************************int f[1&lt;&lt;15];//状态方案数bool chw[20][1&lt;&lt;15];//j状态下能否杀i//状态用二进制表示，1就是死了//**********************************************char s[100];int bin[21];int main()&#123; pn=0;memset(rd,0,sizeof(rd));memset(chw,0,sizeof(chw)); bin[1]=1;for(int i=2;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; //稍微改了一下，不是2^i而是对应第i个敌人 int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",s+1); for(int j=1;j&lt;=m;j++) &#123; if(s[j]=='.') mp[i][j]=1; else if(s[j]=='#') mp[i][j]=0; else &#123; pn++;p[pn].x=i;p[pn].y=j; mp[i][j]=10+pn; if(s[j]=='^') p[pn].tr=2; if(s[j]=='v') p[pn].tr=3; if(s[j]=='&lt;') p[pn].tr=4; if(s[j]=='&gt;') p[pn].tr=5; &#125; &#125; &#125; for(int i=1;i&lt;=pn;i++) &#123; int x=p[i].x,y=p[i].y; while(1) &#123; if(p[i].tr==2) x--;if(p[i].tr==3) x++; if(p[i].tr==4) y--;if(p[i].tr==5) y++; if(mp[x][y]==0 or x&lt;=0 or y&lt;=0 or x&gt;n or y&gt;m) break; if(mp[x][y]&gt;10) rd[i][mp[x][y]-10]=1; &#125; &#125; int full=(1&lt;&lt;pn)-1;//圆满状态 for(int i=1;i&lt;=pn;i++)//被看者 &#123; for(int j=0;j&lt;=full;j++)//状态 &#123; if( (j&amp;bin[i])!=0 ) continue;//已经死了 bool bk=1; for(int k=1;k&lt;=pn;k++)//看者 &#123; if( (j&amp;bin[k])==0 and i!=k ) bk=!rd[k][i]; if(!bk) break; &#125; chw[i][j]=bk; &#125; if(chw[i][0]) f[bin[i]]++;//单杀 &#125; for(int i=0;i&lt;=full;i++) for(int j=1;j&lt;=pn;j++) if((i&amp;bin[j])!=0 and chw[j][i^bin[j]]==1)//任杀 f[i]+=f[i^bin[j]]; if(f[full]&gt;0) printf("%d",f[full]); else printf("Impossible");&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CZYZ2009暑假集训提高组6】魔兽争霸]]></title>
    <url>%2Fposts%2Fc201.html</url>
    <content type="text"><![CDATA[来源和评测点CZYZ2009暑假集训提高组6 题目【题目大意】小 x 正在销魂地玩魔兽他正控制着死亡骑士和 n个食尸鬼(编号 1～n)去打猎死亡骑士有个魔法，叫做“死亡缠绕” ，可以给食尸鬼补充 HP战斗过程中敌人会对食尸鬼实施攻击，食尸鬼的 HP 会减少小 x 希望随时知道自己部队的情况， 即 HP 值第 k 多的食尸鬼有多少 HP， 以便决定如何施放魔法请同学们帮助他:)小 x 向你发出 3种信号： （下划线在输入数据中表现为空格）A_i_a 表示敌军向第 i 个食尸鬼发出了攻击，并使第 i 个食尸鬼损失了 a 点 HP，如果它的 HP&lt;=0,那么这个食尸鬼就死了(Undead 也是要死的„„)。敌军不会攻击一个已死的食尸鬼。C_i_a 表示死亡骑士向第i 个食尸鬼放出了死亡缠绕，并使其增加了a点HP。 HP 值没有上限。死亡骑士不会向一个已死的食尸鬼发出死亡缠绕Q_k 表示小 x 向你发出询问【输入格式】第一行，一个正整数 n以后 n个整数 表示 n个食尸鬼的初始 HP 值接着一个正整数 m以下 m行 每行一个小 x 发出的信号40%的数据 n&lt;=3000 m&lt;=500070%的数据 n&lt;=8000 m&lt;=10000100%的数据 n&lt;=30000 m&lt;=5000090%的数据随机生成食尸鬼 HP 没有上限数据保证任意时刻食尸鬼的 HP 值在 longint范围内数据保证 A 和 C 命令中的食尸鬼是活着的输入数据中没有多余空格、换行【输出格式】对于小 x 的每个询问， 输出 HP 第 k 多的食尸鬼有多少 HP，如果食尸鬼总数不足 k 个，输出-1。每个一行数。最后一行输出一个数：战斗结束后剩余的食尸鬼数【输入样例】51 2 34 510Q 2A 4 6C 1 4Q 2A 2 1A 3 3A 1 3Q 4C 2 10Q 1【输出样例】45-1113 分析这道题还是挺有趣的利用了Splay的灵活性当时是比赛吧，写了200+行感觉思路完全是错的因为节点编号会换，差点心态爆炸想放弃冷静一想，毕竟是人发明的东西，那就可以改造我是用了一个数组存储对应的真实编号（后来看别人的代码，其实存着每个HP就好了……） 难度并不算太大，就不讲什么了，看代码吧 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=80000;int hh[MAXN+10];//**********************************************struct pt&#123; int son[2],f; int d,c,n; pt() &#123; son[0]=son[1]=-1; f=0; d=0; c=n=1; &#125;&#125;p[MAXN+10];//**********************************************void update(int x)&#123; p[x].c=p[x].n; int lc=p[x].son[0],rc=p[x].son[1]; if(lc&gt;0) p[x].c+=p[lc].c; if(rc&gt;0) p[x].c+=p[rc].c;&#125;void rotate(int x,int w)&#123; int f=p[x].f,ff=p[f].f; int xson=p[x].son[w]; if(xson&gt;0) p[xson].f=f; p[f].son[1-w]=xson; if(p[ff].son[0]==f) p[ff].son[0]=x; else if(p[ff].son[1]==f) p[ff].son[1]=x; p[x].f=ff; p[x].son[w]=f; p[f].f=x; update(f); update(x);&#125;int root;void splay(int x,int rt)&#123; while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(ff==rt) &#123; if(p[f].son[0]==x) rotate(x,1); else if(p[f].son[1]==x) rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==0) root=x;&#125;int findip(int d)&#123; int x=root; while(p[x].d!=d) &#123; if(d&gt;p[x].d) &#123; int lc=p[x].son[0]; if(lc&lt;0) return x; x=lc; &#125; else &#123; int rc=p[x].son[1]; if(rc&lt;0) return x; x=rc; &#125; &#125; return x;&#125;int len;void add(int f,int d)&#123; len++;p[len].f=f; p[len].son[0]=p[len].son[1]=-1; p[len].c=p[len].n=1;p[len].d=d; if(d&gt;p[f].d) p[f].son[0]=len; else p[f].son[1]=len;&#125;void addnum(int hk,int d)&#123; if(root==0) &#123; root=++len;p[len].f=0; p[len].son[0]=p[len].son[1]=-1; p[len].c=p[len].n=1;p[len].d=d; hh[hk]=len;// &#125; else &#123; int x=findip(d); if(p[x].d==d) &#123; p[x].n++; update(x); hh[hk]=x;// &#125; else &#123; add(x,d); update(x); hh[hk]=len;// &#125; splay(x,0); &#125;&#125;void del(int d)&#123; int x=findip(d); if(p[x].n&gt;1) &#123; p[x].n--; update(x); splay(x,0); &#125; else &#123; splay(x,0); if(p[x].son[0]==-1 and p[x].son[1]==-1) &#123; len=0;root=0; &#125; else if(p[x].son[0]&gt;0 and p[x].son[1]==-1) &#123; root=p[x].son[0]; p[root].f=0; &#125; else if(p[x].son[0]==-1 and p[x].son[1]&gt;0) &#123; root=p[x].son[1]; p[root].f=0; &#125; else &#123; int k=p[x].son[0]; while(p[k].son[1]&gt;0) k=p[k].son[1]; p[k].son[1]=p[x].son[1]; p[p[x].son[0]].f=0; p[p[x].son[1]].f=k; update(k);splay(k,0); &#125; &#125;&#125;//**********************************************int asknum(int k)&#123; int x=root; if(k&gt;p[x].c) return -1; while(x&gt;0) &#123; int lc=p[x].son[0]; int lcc=lc&gt;0?p[lc].c:0; if(k&lt;=lcc) x=lc; else if(k&gt;lcc+p[x].n) k-=lcc+p[x].n,x=p[x].son[1]; else &#123; splay(x,0); return p[x].d; &#125; &#125; return -2;&#125;void solve1(int k,int a)//-&#123; int d=p[ hh[k] ].d; del(d); if(d-a&gt;0) addnum(k,d-a);&#125;void solve2(int k,int a)//+&#123; int d=p[ hh[k] ].d; del(d); addnum(k,d+a);&#125;//**********************************************char s[10];int main()&#123; len=0;root=0; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int t; scanf("%d",&amp;t); addnum(i,t); &#125; int m;scanf("%d",&amp;m); while(m--) &#123; int a;scanf("%s%d",s,&amp;a); if(s[0]=='Q') printf("%d\n",asknum(a)); else &#123; int b;scanf("%d",&amp;b); if(s[0]=='A') solve1(a,b); else solve2(a,b); &#125; &#125; printf("%d",p[root].c);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3223】文艺平衡树]]></title>
    <url>%2Fposts%2F77a.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj3223Codevs3303Caioj1134 题目【题目大意】写一种数据结构，来维护一个有序数列，其中需要提供以下操作：翻转一个区间，例如原有序序列是5 4 3 2 1，翻转区间是[2,4]的话，结果是5 2 3 4 1【输入格式】第一行为n,mn表示初始序列有n个数，这个序列依次是(1,2……n-1,n)m表示翻转操作次数，接下来m行每行两个数[l,r]数据保证 1&lt;=l&lt;=r&lt;=n（n,m &lt; =100000）【输出格式】输出一行n个数字，表示原始序列经过m次变换后的结果【输入样例】5 31 31 31 4【输出样例】4 3 2 1 5 分析这道题建议自己多出几个小数据检验主要就是利用伸展树这种比较灵活的数据结构来维护数列中序遍历就是当前的状态通过标记实现翻转 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157//Zory-2017//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=100000;//*******************全局定义*******************struct pt&#123; int son[2],f; int c; bool fz; pt() &#123; c=0;fz=0; son[0]=son[1]=f=-1; &#125;&#125;p[MAXN+10];//*******************伸展树*******************void update(int x)&#123; p[x].c=1; int lc=p[x].son[0],rc=p[x].son[1]; if(lc&gt;0) p[x].c+=p[lc].c; if(rc&gt;0) p[x].c+=p[rc].c;&#125;void rev(int x)&#123; if(p[x].fz==0) return;p[x].fz=0; swap(p[x].son[0],p[x].son[1]); int lc=p[x].son[0],rc=p[x].son[1]; if(lc&gt;0) p[lc].fz^=1; if(rc&gt;0) p[rc].fz^=1;&#125;void rotate(int x,int w)&#123; int f=p[x].f,ff=p[f].f; int pson=p[x].son[w]; if(pson&gt;0) p[pson].f=f; p[f].son[1-w]=pson; if(p[ff].son[0]==f) p[ff].son[0]=x; else if(p[ff].son[1]==f) p[ff].son[1]=x; p[x].f=ff; p[x].son[w]=f; p[f].f=x; update(f); update(x);&#125;int root;int t[MAXN+10];void splay(int x,int rt)&#123; int s=0,i=x; while(p[i].f!=rt) t[++s]=i,i=p[i].f; t[++s]=rt; while(s&gt;0) rev(t[s--]); while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(p[f].f==rt) &#123; if(p[f].son[0]==x) rotate(x,1); else if(p[f].son[1]==x) rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==0) root=x;&#125;int findrank(int rk)&#123; int x=root; while(x&gt;0) &#123; rev(x); int lcc=p[x].son[0]&lt;0?0:p[p[x].son[0]].c; if(rk&lt;=lcc) x=p[x].son[0]; else if(rk==lcc+1) return x; else x=p[x].son[1],rk-=lcc+1; &#125;&#125;//*******************接口*******************int n;void buildtree()&#123; root=1; p[n].f=n-1;update(n); for(int i=n-1;i&gt;=1;i--) &#123; p[i].f=i-1; p[i].son[1]=i+1; update(i); &#125; p[0].son[1]=1;&#125;void solve(int l,int r)&#123; if(l==1 and r==n) &#123; p[root].fz^=1; &#125; else if(l==1 and r&lt;n) &#123; int y=findrank(r+1); splay(y,0); p[p[y].son[0]].fz^=1; &#125; else if(l&gt;1 and r==n) &#123; int x=findrank(l-1); splay(x,0); p[p[x].son[1]].fz^=1; &#125; else &#123; int x=findrank(l-1); int y=findrank(r+1); splay(x,0); splay(y,x); p[p[y].son[0]].fz^=1; &#125;&#125;void pf(int x)&#123; if(x&lt;0) return; rev(x); pf(p[x].son[0]); printf("%d ",x); pf(p[x].son[1]);&#125;//*******************主函数*******************int main()&#123; int m;scanf("%d%d",&amp;n,&amp;m); buildtree(); while(m--) &#123; int l,r;scanf("%d%d",&amp;l,&amp;r); if(l&gt;r) swap(l,r);solve(l,r); &#125; pf(root);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu2867】大广场Big Square]]></title>
    <url>%2Fposts%2F4b65.html</url>
    <content type="text"><![CDATA[来源和评测点USACO06 NOVLuogu2867 题目【题目大意】农民 John 的牛参加了一次和农民 Bob 的牛的竞赛。他们在区域中画了一个N乘N 的正方形点阵，两个农场的牛各自占据了一些点。当然不能有两头牛处于同一个点。农场的目标是用自己的牛作为4个顶点，形成一个面积最大的正方形(不必须和边界平行) 。除了 Bessie 以外，FJ其他的牛都已经放到点阵中去了，要确定bessie放在哪个位置，能使得农民约翰的农场得到一个最大的正方形(Bessie不是必须参与作为正方形的四个顶点之一)。【输入格式】第一行是N接下来是一个N乘N的矩阵，字符解释:‘J’ John 的牛,‘B’ Bob 的牛,‘*‘ 空点。数据保证至少一个空点【输出格式】面积，如果没有就输出0【输入样例】6J*J*********J***J*********B*********【输出样例】4 分析随便用暴力做，居然过了……难点就是已知对角线上两个点求出正方形另外两个点 膜师兄时大概用了高中向量的知识，但也挺好理解的，就是“固定方向固定距离”？ 假如有两个点$(a,b)和(c,d)$，把他们作为对角线先计算出中点$(mx=\frac{a+c}{2},my=\frac{b+d}{2})$计算出两点间向量$(fx=\frac{a-c}{2},fy=\frac{b-d}{2})$向量反转，另外两点分别为$(qx=mx+(-fy),qy=my+(fx))和(mx+(fy),my+(-fx))$面积则是$( \sqrt{ (a-qx)^2+(b-qy)^2 })^2=(a-qx)^2+(b-qy)^2$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;const int MAXN=150;struct nod&#123; int x,y;&#125;p[MAXN*MAXN];//已经使用的点int ptn=0;//数量int mp[MAXN][MAXN];int n;//判断x是不是整数y，我随便打的。。不是很严谨bool dint(double x,int y)&#123; double ty=y; return ty-0.001&lt;=x and x&lt;=ty+0.001;//在大致区间内&#125;int ans=0;void solve()&#123; for(int i=1;i&lt;=ptn;i++) &#123; for(int j=1;j&lt;=i-1;j++)//枚举互为对角线的点 &#123; double a=p[i].x,b=p[i].y;//点1 double c=p[j].x,d=p[j].y;//点2 double mx=(a+c)/2.0,my=(b+d)/2.0;//中点 double fx=(a-c)/2.0,fy=(b-d)/2.0;//向量 double qx=mx+(-fy),qy=my+(fx); if(qx&lt;1 or qx&gt;n) continue;if(qy&lt;1 or qy&gt;n) continue; double wx=mx+(fy),wy=my+(-fx); if(wx&lt;1 or wx&gt;n) continue;if(wy&lt;1 or wy&gt;n) continue; //理论做法：取中间向量，并应用在中点上 //由于初三还没正式学向量，不严谨 if(qx==wx and qy==wy) continue; int ax=int(qx+0.5),ay=int(qy+0.5);//注意四舍五入 int bx=int(wx+0.5),by=int(wy+0.5); if(!dint(qx,ax)) continue;//不是整点 if(!dint(qy,ay)) continue;//不是整点 if(!dint(wx,bx)) continue;//不是整点 if(!dint(wy,by)) continue;//不是整点 int qm=mp[ax][ay],wm=mp[bx][by];//状态 if(qm==1 or wm==1) continue;//被占用 if(qm==0 and wm==0) continue;//贝西只有一个…… double sq=(a-qx)*(a-qx)+(b-qy)*(b-qy);//面积 ans=mymax(sq,ans); &#125; &#125;&#125;char s[MAXN];int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",s+1); for(int j=1;j&lt;=n;j++) &#123; if(s[j]=='*') mp[i][j]=0; if(s[j]=='B') mp[i][j]=1; if(s[j]=='J') &#123; ptn++; p[ptn].x=i;p[ptn].y=j; mp[i][j]=2; &#125; &#125; &#125; solve(); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu3005】槽的游戏The Trough Game]]></title>
    <url>%2Fposts%2F1444.html</url>
    <content type="text"><![CDATA[来源和评测点USACO10 DECLuogu3005 题目【题目大意】农夫约翰在谷仓里藏起来了N（1&lt;=N&lt;=20）个槽，并且他已经把其中的一些装上了食物。贝西以“在这个表里（表由贝西提供）有多少个槽里有食物？”的形式问了M（1&lt;=M&lt;=100）个问题。现在，贝西想知道，哪几个槽里有食物？【输入格式】第一行是N、M后面M行，每行一个长度为N的01串，表示一个询问是否包含这个槽然后是一个数字，表示回答【输出格式】如果可行，输出长度为N的01串，表示槽的状态如果没有满足的方案，输出’IMPOSSIBLE’如果方案不唯一，输出’NOT UNIQUE’【输入样例】4 41000 10110 11001 10011 1【输出样例】1010 分析1这题一看数据输入输出就想到矩阵乘法提问（m×n）（只有0、1）真实（n×1）（只有0、1）回答（m×1）假如提问*真实=回答，则可行，然后暴力搜索枚举出真实状况，然鹅这只能拿60分 代码1这是TLE的，供参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;struct matrix&#123; int row,col; int a[120][120]; matrix() &#123; memset(a,0,sizeof(a)); &#125;&#125;;matrix cheng(matrix a,matrix b)&#123; matrix c; c.row=a.row;c.col=b.col; for(int i=1;i&lt;=c.row;i++) for(int j=1;j&lt;=c.col;j++) for(int k=1;k&lt;=a.col;k++) c.a[i][j]+=a.a[i][k]*b.a[k][j]; return c;&#125;bool same(matrix a,matrix b)&#123; if(a.row!=b.row) return 0; if(a.col!=b.col) return 0; for(int i=1;i&lt;=a.row;i++) for(int j=1;j&lt;=a.col;j++) if(a.a[i][j]!=b.a[i][j]) return 0; return 1;&#125;int n,m;matrix a,b,c,d,ans;bool ero;void dfs(int x)&#123; if(ero) return; if(x&gt;n) &#123; d=cheng(a,b); if(same(c,d)) &#123; if(ans.row&gt;0) ero=1; else ans=b; &#125; return; &#125; b.a[x][1]=0;dfs(x+1); b.a[x][1]=1;dfs(x+1);&#125;char s[30];int main()&#123; ero=0; scanf("%d%d",&amp;n,&amp;m); a.row=m;a.col=n; b.row=n;b.col=1; c.row=m;c.col=1; for(int i=1;i&lt;=m;i++) &#123; scanf("%s",s+1); for(int j=1;j&lt;=n;j++) a.a[i][j]=s[j]-'0'; scanf("%d",&amp;c.a[i][1]); &#125; dfs(1); if(ero) printf("NOT UNIQUE"); else if(ans.row==0) printf("IMPOSSIBLE"); else for(int i=1;i&lt;=n;i++) printf("%d",ans.a[i][1]);&#125; 分析2接下来考虑剪枝：根据提问中最后一个需要的槽状态排序（所以一旦决定了那个槽，就能验证是否满足这个提问），从而边枚举边乘，达到剪枝目的 注意因为排序内容比较多，我手写了一个二分排序 A了之后忽然想到可以预处理出每添加一个槽状态所能多判断的提问区间，每次判断哪些区间的提问就好了，这样时间复杂度会少灰常多。然鹅我懒得改了，所以代码里面是从1到最后的 至于什么高斯消元……并不会 代码212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int n,m;int a[110][30],b[30],c[110];int lt[110];//提问需要最末尾槽状态int ans[30];bool ha=0;bool ero;bool cheng(int x)//被我改良后的矩阵乘法，x是确定了的槽编号&#123; int i=1; while(lt[i]&lt;=x and i&lt;=m)//区间限制 &#123; int t=0; for(int k=1;k&lt;=x;k++) t+=a[i][k]*b[k]; if(t!=c[i]) return 0; i++; &#125; return 1;&#125;void dfs(int x)&#123; if(ero) return;//多个答案 if(x&gt;1 and !cheng(x-1)) return;//边做边判断 if(x&gt;n) &#123; if(ha&gt;0) ero=1; else &#123;memcpy(ans,b,sizeof(b));ha=1;&#125; return; &#125; b[x]=0;dfs(x+1); b[x]=1;dfs(x+1);&#125;void sort2(int l,int r)//手写二分排序&#123; int x=l,y=r,mid=lt[(l+r)&gt;&gt;1]; while(x&lt;=y) &#123; while(lt[x]&lt;mid and x&lt;m) x++; while(lt[y]&gt;mid and y&gt;1) y--; if(x&gt;y) break; swap(lt[x],lt[y]);//都要交换 swap(a[x],a[y]); swap(c[x],c[y]); x++;y--; &#125; if(l&lt;y) sort2(l,y); if(x&lt;r) sort2(x,r);&#125;char s[30];int main()&#123; ero=0; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; scanf("%s",s+1); for(int j=1;j&lt;=n;j++) &#123; a[i][j]=s[j]-'0'; if(a[i][j]==1) lt[i]=j;//记录 &#125; scanf("%d",&amp;c[i]); &#125; sort2(1,m); dfs(1); if(ero) printf("NOT UNIQUE"); else if(ha==0) printf("IMPOSSIBLE"); else for(int i=1;i&lt;=n;i++) printf("%d",ans[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度2</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1783】【Luogu2975】轮流Taking Turns]]></title>
    <url>%2Fposts%2F5323.html</url>
    <content type="text"><![CDATA[来源和评测点USACO10JANLuogu2975Bzoj1783 题目【题目大意】两头奶牛Bessi和Dessie走过一条路吃草，共n（n&lt;=700,000）个格子，第i个格子有重量为Wi（1&lt;=Wi&lt;=2,000,000,000）的草，两牛轮流走，一旦某头牛走过了一格，那么这格的草再也不可能被任一头奶牛吃，每格的草只能被吃一次，所以两头牛只能往后走。Bessi先走，每头牛每次都往最终自己能吃到最多草的格子走（若有多个格子则选择第一个能吃到最多草的格子），他们都知道对方也想吃到最多的草，问最后Bessi和Dessie各吃到的草的重量。【输入格式】第一行一个正整数n（n&lt;=700,000）接下来有n行，第i+1行是Wi（1&lt;=Wi&lt;=2,000,000,000）【输出格式】答案【输入样例】617591038【输出样例】27 17 分析类似博弈，倒退DPf[i]=从i到n最大收益id[i]=达到f[i]用了的干草堆最后编号 对于干草堆i，存在两种选择：1)用i，id[i]=i,f[i]=w[i]+f[id[i+1]+1] 即本堆干草+舍弃f[i+1]后最大收益2)不用i，id[i]=id[i+1],f[i]=f[i+1] 代码1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;ll w[710000],f[710000],id[710000];int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;w[i]); f[n]=w[n];id[n]=n;f[n+1]=0; for(int i=n-1;i&gt;=1;i--) &#123; if(w[i]+f[id[i+1]+1]&gt;=f[i+1]) &#123; f[i]=w[i]+f[id[i+1]+1]; id[i]=i; &#125; else &#123; f[i]=f[i+1]; id[i]=id[i+1]; &#125; &#125; printf("%lld %lld",f[1],f[id[1]+1]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>博弈</tag>
        <tag>DP</tag>
        <tag>难度1</tag>
        <tag>精品题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu3113】马拉松赛跑Marathon]]></title>
    <url>%2Fposts%2F134e.html</url>
    <content type="text"><![CDATA[来源和评测点USACO14DEC GoldLuogu3113 题目【题目大意】N个点的路线(1&lt;=N&lt;=100,000)，必须按顺序经过。询问特定的子路线需要多长时间才能跑完，其中的子路线是从完整路线的检查点中截取的的连续子序列。牛可能会选择在任何时候跳过一个检查点，但不允许在子路线中跳过第一个或最后一个点可能修改点的坐标由于该课程设置在市中心的街道网络中，两个点之间的距离(x1,y1)和(x2,y2)是由|x1-x2|+|y1-y2|得出的。【输入格式】第一行N和Q (1&lt;=Q&lt;=100,000).下面N行 每个点的坐标(x,y)，大小范围是-1000..1000下面Q行 每行一个操作“U I X Y” 修改 点I (1&lt;=I&lt;= N) 的坐标为(X, Y).“Q I J” 询问从I到J的最短距离（可以跳过除起点、终点外的其他点）(I &lt;= J)【输出格式】每个Q输出距离值【输入样例】5 5-4 4-5 -3-1 5-3 40 5Q 1 5U 4 0 1U 4 -1 1Q 2 4Q 1 4【输出样例】1188 分析使用线段树维护两个完全不同的信息。值1是每个节点到上一个节点的距离值2是每个节点被忽略后的收益（一般是负数）维护值1的和、值2的最小值 每次修改影响两个值1，三个值2 信息的维护用线段树达到log，树状数组则比较麻烦 玄学AC之本来线段树不忽略编号1，wa几个点都是个位数级别差异后来想着顺便加速（因为编号1从来不用），结果AC如果有人知道，可以在讨论区评论一下 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;ll myabs(ll x) &#123;return x&gt;0?x:-x;&#125;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;const int MAXN=110000;int n;struct nod&#123; int l,r,mid,lc,rc; ll s,mi;//分别维护值1的和、值2的最小值&#125;s[MAXN*2];int ln=0;int build(int l,int r)&#123; int t=++ln; s[t].l=l;s[t].r=r;s[t].mid=(l+r)&gt;&gt;1; if(l&lt;r) &#123; s[t].lc=build(l,s[t].mid); s[t].rc=build(s[t].mid+1,r); &#125; return t;&#125;void change1(int w,int x,ll c)&#123; if(s[w].l==s[w].r) &#123; s[w].s=c; return; &#125; int lc=s[w].lc,rc=s[w].rc; if(x&lt;=s[w].mid) change1(lc,x,c); else change1(rc,x,c); s[w].s=s[lc].s+s[rc].s;&#125;void change2(int w,int x,ll c)&#123; if(s[w].l==s[w].r) &#123; s[w].mi=c; return; &#125; int lc=s[w].lc,rc=s[w].rc; if(x&lt;=s[w].mid) change2(lc,x,c); else change2(rc,x,c); s[w].mi=mymin(s[lc].mi,s[rc].mi);&#125;ll ask1(int w,int l,int r)&#123; if(s[w].l==l and s[w].r==r) return s[w].s; int lc=s[w].lc,rc=s[w].rc; if(r&lt;=s[w].mid) return ask1(lc,l,r); if(l&gt;s[w].mid) return ask1(rc,l,r); return ask1(lc,l,s[w].mid)+ask1(rc,s[w].mid+1,r);&#125;ll ask2(int w,int l,int r)&#123; if(l&gt;r) return 0; if(s[w].l==l and s[w].r==r) return s[w].mi; int lc=s[w].lc,rc=s[w].rc; if(r&lt;=s[w].mid) return ask2(lc,l,r); if(l&gt;s[w].mid) return ask2(rc,l,r); return mymin(ask2(lc,l,s[w].mid),ask2(rc,s[w].mid+1,r));&#125;//值1是每个节点到上一个节点的距离//值2是每个节点被忽略后的收益（一般是负数）int xx[MAXN],yy[MAXN];ll get(int x,int sf)//与往前sf个节点的距离&#123; return myabs(xx[x]-xx[x-sf])+myabs(yy[x]-yy[x-sf]);&#125;ll p[MAXN];//顺便存储值char ss[10];int main()&#123; int q;scanf("%d%d",&amp;n,&amp;q); build(1,n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;xx[i],&amp;yy[i]); if(i==1) continue; change1(1,i-1,p[i]=get(i,1)); &#125; for(int i=2;i&lt;=n-1;i++) change2(1,i-1,get(i+1,2)-p[i]-p[i+1]); while(q--) &#123; scanf("%s",ss); if(ss[0]=='Q') &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); printf("%lld\n",ask1(1,x+1-1,y-1)+ask2(1,x+1-1,y-1-1)); &#125; else &#123; int a;scanf("%d",&amp;a); scanf("%d%d",&amp;xx[a],&amp;yy[a]); //修改值1两处 change1(1,a-1,p[a]=get(a,1)); change1(1,a+1-1,p[a+1]=get(a+1,1)); //对应值2三处 change2(1,a-1-1,get(a,2)-p[a-1]-p[a]); change2(1,a-1,get(a+1,2)-p[a]-p[a+1]); change2(1,a+1-1,get(a+2,2)-p[a+1]-p[a+2]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>精品题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3771】Triple]]></title>
    <url>%2Fposts%2Fdf74.html</url>
    <content type="text"><![CDATA[来源和评测点Zjoi2014Bzoj3771Caioj1451 题目【题目大意】我们讲一个悲伤的故事。从前有一个贫穷的樵夫在河边砍柴。这时候河里出现了一个水神，夺过了他的斧头，说：“这把斧头，是不是你的？”樵夫一看：“是啊是啊！”水神把斧头扔在一边，又拿起一个东西问：“这把斧头，是不是你的？”樵夫看不清楚，但又怕真的是自己的斧头，只好又答：“是啊是啊！”水神又把手上的东西扔在一边，拿起第三个东西问：“这把斧头，是不是你的？”樵夫还是看不清楚，但是他觉得再这样下去他就没法砍柴了。于是他又一次答：“是啊是啊！真的是！”水神看着他，哈哈大笑道：“你看看你现在的样子，真是丑陋！”之后就消失了。樵夫觉得很坑爹，他今天不仅没有砍到柴，还丢了一把斧头给那个水神。于是他准备回家换一把斧头。回家之后他才发现真正坑爹的事情才刚开始。水神拿着的的确是他的斧头。但是不一定是他拿出去的那把，还有可能是水神不知道怎么偷偷从他家里拿走的。换句话说，水神可能拿走了他的一把，两把或者三把斧头。樵夫觉得今天真是倒霉透了，但不管怎么样日子还得过。他想统计他的损失。樵夫的每一把斧头都有一个价值，不同斧头的价值不同。总损失就是丢掉的斧头价值和。他想对于每个可能的总损失，计算有几种可能的方案。注意：如果水神拿走了两把斧头a和b，(a,b)和(b,a)视为一种方案。拿走三把斧头时，(a,b,c),(b,c,a),(c,a,b),(c,b,a),(b,a,c),(a,c,b)视为一种方案。【输入格式】第一行是整数N，表示有N把斧头。接下来n行升序输入N个数字Ai，表示每把斧头的价值。所有数据满足：Ai&lt;=40000【输出格式】若干行，按升序对于所有可能的总损失输出一行x y，x为损失值，y为方案数。【输入样例】44 5 6 7【输出样例】4 15 16 18 19 110 111 212 113 114 115 117 118 119 1 分析莫比乌斯反演教程和题目分类参见：【OI之路】11更高级数论-3快速傅里叶变换其他快速傅里叶变换题目参见：Tag-快速傅里叶变换 Triple这道题的精华是容斥先推荐一下同学的博客，相当严谨科学他和我的思路不同，属于两种不同的角度我的思路可能有些乱啊，因为其实是在别人不停点醒才想到的，并不断完善 题意：给出价格各不相同（这很重要）的一些斧头，每次选一、二、三个，将所有方案统计起来，按价格输出，注意选的是组合不是排列。考虑分解成子问题。 选一个先解决选一个的情况。设$q_i$表示第i个斧头的价格。再设$A(q_i)=1$则$Ans[i]+=A(q_i)$原因就是每个斧头选自己，很好理解的 选两个答案是$A^2(q_i)$吗？先想想这个柿子怎么来的：将A想成多项式的系数系数（原本1）相乘就是方案数相乘指数（价格）相加就是花费相加 然鹅，仔细考虑，发现不完整，因为会有违法情况违法1：第i项和第i项相乘，应该被忽略的违法2：第i、j项乘积和第j、i项乘积重复对于违法1，设$B(2q_i)=1$，$A^2(q_i)-B(q_i)$对于违法2，解决违法一后除以2即可综上所述，$Ans[i]+=\frac { A^2(q_i)-B(q_i) }{2}$ 选三个依照选两个的思路，先计算出$A^3(q_i)$违法1：aab aba baa违法2：abc acb bac bca cab cba对于违法1，设$AB()=A() \times B()，C(q_i \times 3)=1$，答案就是$A^3(q_i)-3AB(q_i)+2C(i)$（因为B是相当于选了两个相同的，所有三个中两个相同情况都应去除）但假如b=a，也就是aaa，那就不能减3个而是一个，用C补回差值对于违法2，解决违法一后除以6即可综上所述，$Ans[i]+=\frac { A^3(q_i)-3AB(q_i)+2C(i) }{6}$ 总结与提醒0次项系数是0，所以$A^3(q_i)$必定是选了三个$Ans[i]=A(q_i)+\frac{A^2(q_i)-B(q_i)}{2}+\frac { A^3(q_i)-3AB(q_i)+2C(i) }{6}$ 对于多项式乘积，使用FFT计算，综合复杂度$\Theta(nlogn)$ 嗯我知道我的灰常不严谨啦~总而言之就是这样 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//Zory-2017//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const double PI=acos(-1.0);const int MAXN=300000;//*******************全局定义*******************struct complex&#123; double r,i;//real,imag complex() &#123;r=i=0;&#125; complex(double rr,double ii) &#123;r=rr;i=ii;&#125; complex operator + (complex b) &#123;return complex(r+b.r,i+b.i);&#125; complex operator - (complex b) &#123;return complex(r-b.r,i-b.i);&#125; complex operator * (complex b) &#123;return complex(r*b.r-i*b.i,r*b.i+i*b.r);&#125; //(a+bi)(c+di)=ac+adi+bci+bdi^2=(ac-bd)+(ad+bc)i //baike.baidu.com/item/复数运算法则&#125;;//*******************实现*******************complex omega[MAXN+10];void CalcOmega(int n,int op)&#123; double t=2*PI*op/n; omega[0]=complex(1,0); omega[1]=complex(cos(t),sin(t)); for(int k=2;k&lt;=n/2-1;k++) omega[k]=omega[k-1]*omega[1];&#125;int R[MAXN+10];void fft(complex *a,int n,int op)&#123; for(int i=0;i&lt;=n-1;i++) if(i&lt;R[i]) swap(a[i],a[R[i]]); //注意判断大小不然又换回来了 for(int L=1;L&lt;=n/2;L*=2)//合并前长度 &#123; CalcOmega(L*2,op); for(int j=0;j&lt;=n-1;j+=L*2)//开头,长度=L*2 &#123; for(int k=0;k&lt;=L-1;k++) &#123; complex x=a[j+k]; complex y=omega[k]*a[j+L+k]; a[j+k]=x+y; a[j+L+k]=x-y; //蝴蝶操作 &#125; &#125; &#125; if(op==-1) for(int i=0;i&lt;=n-1;i++) a[i].r=a[i].r/double(n);&#125;//*******************主函数*******************complex A[MAXN+10],B[MAXN+10],C[MAXN+10];complex A2[MAXN+10],AB[MAXN+10],A3[MAXN+10];double ans[MAXN+10];int main()&#123; //-------------读入------------- int n;scanf("%d",&amp;n); int mx=0; for(int i=0;i&lt;=n-1;i++) &#123; int t;scanf("%d",&amp;t);if(t&gt;mx) mx=t; A[t].r=1;B[2*t].r=1;C[3*t].r=1; &#125; //-------------准备------------- int sn=1,lg=0; while(sn&lt;mx*3+1) sn*=2,lg++; for(int i=0;i&lt;=sn-1;i++) R[i]=( R[i&gt;&gt;1]&gt;&gt;1 ) | ( (i&amp;1)&lt;&lt;(lg-1) ); //nlogn翻转二进制 //-------------计算------------- for(int i=0;i&lt;=sn-1;i++) ans[i]=(A[i].r)-(B[i].r/2.0)+(C[i].r/3.0);//先把A、B、C搞定 fft(A,sn,1);fft(B,sn,1); for(int i=0;i&lt;=sn-1;i++) A2[i]=A[i]*A[i],AB[i]=A[i]*B[i],A3[i]=A2[i]*A[i]; fft(A2,sn,-1);fft(AB,sn,-1);fft(A3,sn,-1); //-------------综合------------- for(int i=0;i&lt;=sn-1;i++) &#123; ans[i]+=(A2[i].r/2.0)+(A3[i].r/6.0)-(AB[i].r/2.0); int t2=ans[i]+0.5; if(t2&gt;0) printf("%d %d\n",i,t2); &#125; //ans[i]=A[i]+(A2[i]-B[i])/2+(A3[i]-3*AB[i]+2*C[i])/6&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>快速傅里叶变换</tag>
        <tag>精品题</tag>
        <tag>难度3</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3527】3-idiots]]></title>
    <url>%2Fposts%2Fb4ff.html</url>
    <content type="text"><![CDATA[来源和评测点2013 Multi-University Training Contest 1Hdu4609Caioj1454 题目【题目大意】有T组数据每组数据给出n条线段，问任意取三条，可以组成三角形的概率【输入格式】开头一行输入T（T&lt;=100）下来T组数据，每组数据第一行输入一个n（3&lt;=n&lt;=10^5）第二行输入n个数，表示n条线段线段长度（1&lt;=n&lt;=10^5）【输出格式】每组数据输出一个数p表示可以组成三角形的概率保留七位小数【输入样例】241 3 3 442 3 3 4【输出样例】0.50000001.0000000 分析莫比乌斯反演教程和题目分类参见：【OI之路】11更高级数论-3快速傅里叶变换其他快速傅里叶变换题目参见：Tag-快速傅里叶变换 大致思路：计算出两条边的和，枚举第三边表示能和它搭配的数量，经过去重后，除以总组合数就是概率 两边之和：FFT，参考另外几道简单点的题去重1：两边之和不能是来自同一条边去重2：两边有一条比第三边大，另一个小去重3：两边都比第三边大去重4：两边有任何一条=第三边（去重2、3、4后剩下的就是两边都比第三边小的情况） 输入的是q[i]，$A(q[i])=是q[i]的数量$NUM(i)表示两边之和=i的情况个数，用去重1$$NUM(i)=\frac{ A^2(i)-B(i) }{2}$$ 去重2、3、4利用排序，并用前缀和SUM获得区间和$ ANS(i)=SUM(rn-1)-SUM(q[i]) $$ 去重2：ANS(i)-=i\times (n-i-1) $$ 去重3：ANS(i)-=\frac{ (n-i-2)\times (n-i-1) }{2} $$ 去重4：ANS(i)-=n-1 $ $$tot=\frac{ n\times (n-1)\times (n-2) }{2}$$ 答案就是$$\frac{ \sum_{i=0}^{n-1} ANS(i) }{tot}$$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;struct complex&#123; double r,i; complex() &#123; r=i=0.0; &#125; complex(double rr,double ii) &#123; r=rr;i=ii; &#125; complex operator + (complex b) &#123; return complex(r+b.r,i+b.i); &#125; complex operator - (complex b) &#123; return complex(r-b.r,i-b.i); &#125; complex operator * (complex b) &#123; return complex(r*b.r-i*b.i,r*b.i+i*b.r); &#125;&#125;;const int MAXN=100000*4;const double PI=acos(-1.0);int R[MAXN+10];void FFT(complex *a,int n,int op)&#123; for(int i=0;i&lt;=n-1;i++) if(i&lt;R[i]) swap(a[i],a[R[i]]); for(int l=1;l&lt;=n/2;l*=2) &#123; complex w1( cos(op*PI/l),sin(op*PI/l) ); for(int j=0;j&lt;=n-1;j+=l*2) &#123; complex wk(1.0,0.0); for(int k=0;k&lt;=l-1;k++,wk=wk*w1) &#123; complex x=a[j+k],y=wk*a[j+l+k]; a[j+k]=x+y; a[j+l+k]=x-y; &#125; &#125; &#125; if(op==-1) for(int i=0;i&lt;=n-1;i++) a[i].r=a[i].r/double(n);&#125;//http://www.cnblogs.com/kuangbin/archive/2013/07/24/3210565.html//http://acm.hdu.edu.cn/showproblem.php?pid=4609//http://blog.csdn.net/rose_max/article/details/77370572complex A[MAXN+10],A2[MAXN+10],B[MAXN+10];int q[MAXN+10];double NUM[MAXN+10];double SUM[MAXN+10];int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; memset(A,0,sizeof(A)); memset(B,0,sizeof(B)); memset(SUM,0,sizeof(SUM)); int n;scanf("%d",&amp;n);int mx=0; for(int i=0;i&lt;=n-1;i++) &#123; scanf("%d",&amp;q[i]); A[q[i]].r++; B[q[i]*2].r++; if(q[i]&gt;mx) mx=q[i]; &#125; sort(q,q+n); int rn=1,rm=(mx)+(mx)+1,l=0; while(rn&lt;rm) rn*=2,l++; for(int i=0;i&lt;=rn-1;i++) R[i]=(R[i&gt;&gt;1]&gt;&gt;1) | ( (i&amp;1)&lt;&lt;(l-1) ); FFT(A,rn,1); for(int i=0;i&lt;=rn-1;i++) A2[i]=A[i]*A[i]; FFT(A2,rn,-1); for(int i=0;i&lt;=rn-1;i++) NUM[i]=(A2[i].r-B[i].r)/2.0; for(int i=0;i&lt;=rn-1;i++) SUM[i]=SUM[i-1]+NUM[i]; double ans=0; for(int i=0;i&lt;=n-1;i++)//第三边 &#123; ans+=SUM[rn-1]-SUM[q[i]]; ans-=double(i)*double(n-i-1);//一大一小 ans-=double(n-i-2)*double(n-i-1)/2;//两大 ans-=n-1;//某边=第三边 &#125; double tot=double(n)*double(n-1)*double(n-2)/6.0; printf("%.7lf\n",ans/tot); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>快速傅里叶变换</tag>
        <tag>精品题</tag>
        <tag>难度3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3527】力]]></title>
    <url>%2Fposts%2F1db5.html</url>
    <content type="text"><![CDATA[来源和评测点[Zjoi2014]Bzoj3527Caioj1451Caioj1451 题目【题目大意】给出n个数qi，给出Fj的定义如下：令Ei=Fi/qi，求Ei【输入格式】第一行一个整数n接下来n行每行输入一个数，第i行表示qin≤1000000&lt;qi&lt;1000000000【输出格式】n行，第i行输出Ei。与标准答案误差不超过1e-2即可。【输入样例1】3124.44513547.265135789.147852【输出样例1】-1994.552-5664.703578.376【输入样例2】54006373.88518415375036.4357591717456.4691448514941.0049121410681.345880【输出样例2】-16838672.6933439.7937509018.5664595686.88610903040.872 分析快速傅里叶变换教程和题目分类参见：【OI之路】11更高级数论-3快速傅里叶变换其他快速傅里叶变换题目参见：Tag-快速傅里叶变换 这道题还是挺有难度的基本思路：逐步化简公式转化为卷积的形式从而能用FFT解决下标统一从0开始，翻转时也会用到 $$题目要求：F_i=\sum_{i &lt; k} \frac{q_i q_k}{(i-k)^2}-\sum_{i &gt; k} \frac{q_i q_k}{(k-i)^2}$$ $$而E_i=\frac{F_i}{q_i}$$ $$显而易见E_i=\sum_{i &lt; k} \frac{q_k}{(i-k)^2}-\sum_{i &gt; k} \frac{q_k}{(k-i)^2}$$ $$明确界限E_i=\sum_{k=0}^{i-1} \frac{q_k}{(i-k)^2}-\sum_{k=i+1}^{n-1} \frac{q_k}{(k-i)^2}$$ $$设A_t=q_t,B_t=\frac{1}{t^2}(精髓1)$$ $$E_i=\sum_{k=0}^{i-1} A_k B_{i-k}-\sum_{k=i+1}^{n-1} A_k B_{k-i}$$ $$设B_0=0(小细节)，这样前面的柿子就和卷积一样了，重点放后面$$ $$E_i=\sum_{k=0}^{i} A_k B_{i-k}-\sum_{k=i}^{n-1} A_k B_{k-i}$$ 考虑$A’t=A{t+i}$,$B’_{(n-i-1)-k}=B_k$(精髓2，一个前移，一个翻转) $$E_i=\sum_{k=0}^{i} A_k B_{i-k}-\sum_{k=0}^{n-i-1} A’k B’{(n-i-1)-i}$$ $$E_i=FFT1(i)-FFT2(n-i-1)$$其中两个FFT只是A不同 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//Zory-2017//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const double PI=acos(-1.0);const int MAXN=4*100000;//*******************全局定义*******************struct complex&#123; double r,i;//real,imag complex() &#123;r=i=0;&#125; complex(double rr,double ii) &#123;r=rr;i=ii;&#125; complex operator + (complex b) &#123;return complex(r+b.r,i+b.i);&#125; complex operator - (complex b) &#123;return complex(r-b.r,i-b.i);&#125; complex operator * (complex b) &#123;return complex(r*b.r-i*b.i,r*b.i+i*b.r);&#125; //(a+bi)(c+di)=ac+adi+bci+bdi^2=(ac-bd)+(ad+bc)i //baike.baidu.com/item/复数运算法则&#125;;//*******************实现*******************complex omega[MAXN+10];void CalcOmega(int n,int op)&#123; double t=2*PI*op/n; omega[0]=complex(1,0); omega[1]=complex(cos(t),sin(t)); for(int k=2;k&lt;=n/2-1;k++) omega[k]=omega[k-1]*omega[1];&#125;int R[MAXN+10];void fft(complex *a,int n,int op)&#123; for(int i=0;i&lt;=n-1;i++) if(i&lt;R[i]) swap(a[i],a[R[i]]); //注意判断大小不然又换回来了 for(int L=1;L&lt;=n/2;L*=2)//合并前长度 &#123; CalcOmega(L*2,op); for(int j=0;j&lt;=n-1;j+=L*2)//开头,长度=L*2 &#123; for(int k=0;k&lt;=L-1;k++) &#123; complex x=a[j+k]; complex y=omega[k]*a[j+L+k]; a[j+k]=x+y; a[j+L+k]=x-y; //蝴蝶操作 &#125; &#125; &#125; if(op==-1) for(int i=0;i&lt;=n-1;i++) a[i].r=a[i].r/double(n);&#125;//*******************接口*******************void FFT(complex *a,complex *b,complex *c,int n)&#123; fft(a,n,1);fft(b,n,1);//求值 for(int i=0;i&lt;=n-1;i++) c[i]=a[i]*b[i];//点值乘法 fft(c,n,-1);//插值&#125;//*******************主函数*******************complex a[MAXN+10],b[MAXN+10];complex f1[MAXN+10],f2[MAXN+10];double q[MAXN+10];int main()&#123; int n;scanf("%d",&amp;n); for(int i=0;i&lt;=n-1;i++) scanf("%lf",&amp;q[i]); int fn=n-1,fm=n-1; int sn=1,lg=0; while(sn&lt;fn+fm+1) sn*=2,lg++; for(int i=0;i&lt;=sn-1;i++) R[i]=( R[i&gt;&gt;1]&gt;&gt;1 ) | ( (i&amp;1)&lt;&lt;(lg-1) ); //nlogn翻转二进制 for(int i=0;i&lt;=n-1;i++) a[i].r=q[i];b[0].r=0; for(int i=1;i&lt;=n-1;i++) b[i].r=1.0/double(i)/double(i); FFT(a,b,f1,sn); for(int i=0;i&lt;=sn-1;i++) a[i]=complex(),b[i]=complex(); for(int i=0;i&lt;=n-1;i++) a[i].r=q[n-i-1];b[0].r=0; for(int i=1;i&lt;=n-1;i++) b[i].r=1.0/double(i)/double(i); FFT(a,b,f2,sn); for(int i=0;i&lt;=n-1;i++) printf("%.3lf\n",f1[i].r-f2[n-i-1].r);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>快速傅里叶变换</tag>
        <tag>难度3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2194】快速傅立叶之二]]></title>
    <url>%2Fposts%2Ffb8e.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj2194Caioj1453 题目【题目大意】请计算$C[k]=\sum a[i]*b[i-k] $ 其中k&lt;=i&lt;n,并且有n&lt;=10^5。a,b中的元素均为小于等于100的非负整数。【输入格式】第一行一个整数N,接下来N行，第i+2..i+N-1行，每行两个数，依次表示a[i],bi【输出格式】输出N行，每行一个整数，第i行输出C[i-1]【输入样例】53 12 41 12 41 4【输出样例】24121061 分析莫比乌斯反演教程和题目分类参见：【OI之路】11更高级数论-3快速傅里叶变换其他快速傅里叶变换题目参见：Tag-快速傅里叶变换 按通常的卷积形式应该是$c[k]=\sum_{i=0}^k a[i]*b[k-i]$但是本题要求的是$c[k]=\sum_{i=k}^{n-1} a[i]*b[i-k]$于是将b上下反转即可另外，将序号看作指数，反转后对于某个c的乘积和，指数和其实是相同的 自己推一推就好了…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//Zory-2017//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const double PI=acos(-1.0);const int MAXN=4*100000;//*******************全局定义*******************struct complex&#123; double r,i;//real,imag complex() &#123;r=i=0;&#125; complex(double rr,double ii) &#123;r=rr;i=ii;&#125; complex operator + (complex b) &#123;return complex(r+b.r,i+b.i);&#125; complex operator - (complex b) &#123;return complex(r-b.r,i-b.i);&#125; complex operator * (complex b) &#123;return complex(r*b.r-i*b.i,r*b.i+i*b.r);&#125; //(a+bi)(c+di)=ac+adi+bci+bdi^2=(ac-bd)+(ad+bc)i //baike.baidu.com/item/复数运算法则&#125;;//*******************实现*******************int R[MAXN+10];complex omega[MAXN+10];void CalcOmega(int n,int op)&#123; double t=2*PI*op/n; omega[0]=complex(1,0); omega[1]=complex(cos(t),sin(t)); for(int k=2;k&lt;=n/2-1;k++) omega[k]=omega[k-1]*omega[1];&#125;void FFT(complex *a,int n,int op)&#123; for(int i=0;i&lt;=n-1;i++) if(i&lt;R[i]) swap(a[i],a[R[i]]); //注意判断大小不然又换回来了 for(int L=1;L&lt;=n/2;L*=2)//合并前长度 &#123; CalcOmega(L*2,op); for(int j=0;j&lt;=n-1;j+=L*2)//开头,长度=L*2 &#123; for(int k=0;k&lt;=L-1;k++) &#123; complex x=a[j+k]; complex y=omega[k]*a[j+L+k]; a[j+k]=x+y; a[j+L+k]=x-y; //蝴蝶操作 &#125; &#125; &#125; if(op==-1) for(int i=0;i&lt;=n-1;i++) a[i].r=a[i].r/double(n);&#125;//*******************主函数*******************complex a[MAXN+10],b[MAXN+10];char s[MAXN+10];int ans[MAXN+10];int main()&#123; int n;scanf("%d",&amp;n);int tn=n; int m=n-1;n=n-1; for(int i=0;i&lt;=n;i++) scanf("%lf%lf",&amp;a[i].r,&amp;b[m-i].r); m=n+m+1;int log=0;n=1; while(n&lt;m) n*=2,log++; for(int i=0;i&lt;=n-1;i++) R[i]=( R[i&gt;&gt;1]&gt;&gt;1 ) | ( (i&amp;1)&lt;&lt;(log-1) ); //nlogn翻转二进制 FFT(a,n,1);FFT(b,n,1);//求值 for(int i=0;i&lt;=n-1;i++) a[i]=a[i]*b[i];//点值乘法 FFT(a,n,-1);//插值 for(int i=0;i&lt;=m-1;i++) &#123; ans[i]+=int(a[i].r+0.5); if(ans[i]&gt;=10) &#123; ans[i+1]+=ans[i]/10; ans[i]%=10; if(i==m-1) m++; &#125; &#125; for(int i=tn-1;i&lt;=2*tn-2;i++) printf("%d\n",int(a[i].r+0.5));&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>快速傅里叶变换</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2179】超大整数乘法]]></title>
    <url>%2Fposts%2F9654.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj2179Luogu1919Caioj1450Codevs3123 题目【题目大意】给出两个正整数A和B，计算A*B的值。保证A和B的位数不超过100000位。【输入格式】读入两个用空格隔开的正整数【输出格式】输出A*B的值【输入样例1】49【输出样例1】36【输入样例2】5612【输出样例2】672【输入样例3】9999【输出样例3】9801 分析快速傅里叶变换教程和题目分类参见：【OI之路】11更高级数论-4快速傅里叶变换其他快速傅里叶变换题目参见：Tag-快速傅里叶变换 将10看作x就好了注意进位 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=210000;const double PI=acos(-1.0);//*******************全局定义*******************struct Cmplex&#123; double r,i; Cmplex(double a=0,double b=0) &#123;r=a,i=b;&#125; Cmplex operator +(Cmplex a) &#123;return Cmplex(r+a.r,i+a.i);&#125; Cmplex operator -(Cmplex a) &#123;return Cmplex(r-a.r,i-a.i);&#125; Cmplex operator *(Cmplex a) &#123;return Cmplex(r*a.r-i*a.i,r*a.i+i*a.r);&#125;&#125;;//*******************实现*******************Cmplex omega[MAXN];void calc_omega(int n,int op)&#123; omega[0]=Cmplex(1,0); omega[1]=Cmplex( cos(PI*2*op/n),sin(PI*2*op/n) ); for(int i=2;i&lt;=n/2-1;i++) omega[i]=omega[i-1]*omega[1];&#125;int n;int R[MAXN];void FFT(Cmplex *a,int op)&#123; for(int i=0;i&lt;=n-1;i++) if(i&lt;R[i]) swap(a[i],a[R[i]]); for(int L=1;L&lt;n;L&lt;&lt;=1)//合并前长度 &#123; calc_omega(L*2,op); for(int st=0;st&lt;=n-1;st+=L*2) &#123; for(int i=0;i&lt;=L-1;i++) &#123; Cmplex x=a[st+i]; Cmplex y=omega[i]*a[st+i+L]; a[st+i]=x+y; a[st+i+L]=x-y; &#125; &#125; &#125; if(op==-1) for(int i=0;i&lt;=n-1;i++) a[i].r/=double(n);&#125;//*******************主函数*******************char s[MAXN];Cmplex a[MAXN],b[MAXN];int ans[MAXN];int main()&#123; int ln;scanf("%d",&amp;ln); scanf("%s",s+1);for(int i=ln;i&gt;=1;i--) a[ln-i].r=s[i]-'0'; scanf("%s",s+1);for(int i=ln;i&gt;=1;i--) b[ln-i].r=s[i]-'0'; int m=(ln-1)+(ln-1)+1; n=1;int tmp=0; while(n&lt;m) tmp++,n*=2; for(int i=1;i&lt;=n-1;i++) R[i]= (R[i&gt;&gt;1]&gt;&gt;1) | ( (i&amp;1)&lt;&lt;(tmp-1) );//debug //nlogn二进制翻转 FFT(a,1);FFT(b,1);//求值 for(int i=0;i&lt;=n-1;i++) a[i]=a[i]*b[i];//点值乘法 FFT(a,-1);//插值 for(int i=0;i&lt;=m-1;i++) &#123; ans[i]+=round(a[i].r); if(ans[i]&gt;9) &#123; ans[i+1]+=ans[i]/10; ans[i]%=10; if(i==m-1) m++; &#125; &#125; for(int i=m-1;i&gt;=0;i--) putchar('0'+ans[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>快速傅里叶变换</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2820】YY的GCD]]></title>
    <url>%2Fposts%2F5aa0.html</url>
    <content type="text"><![CDATA[来源和评测点一模一样的题目但数据弱化版：Bzoj2818 GCD-莫比乌斯2Bzoj2820 题目【题目大意】神犇YY虐完数论后给傻kAc出了一题给定N,M,求1≤x≤N, 1≤y≤M且gcd(x,y)为质数的(x,y)有多少对kAc这种傻kAc必然不会了，于是向你来请教……【输入格式】多组输入第一行一个整数T 表述数据组数接下来T行，每行两个正整数，表示N, M【输出格式】T行，每行一个整数表示第i组数据的结果【输入样例】210 10100 100【输出样例】302791 分析1莫比乌斯反演教程和题目分类参见：【OI之路】11更高级数论-2莫比乌斯反演其他莫比乌斯反演题目参见：Tag-莫比乌斯反演 即使分块也会T！需要优化了，主要是针对素数： 转载并修改自Hzwer $ 假定n&lt;m $$$\sum_{isprime(p)} \sum_{a=1}^n \sum_{b=1}^m gcd(a,b)==p$$ 简化为： $$\sum_{isprime(p)} \sum_{a=1}^{\left \lfloor \frac{n}{p} \right \rfloor} \sum_{b=1}^{\left \lfloor \frac{m}{p} \right \rfloor}gcd(a,b)==1$$ ————在我之前的教程中，下面直接被忽略————$$\sum_{isprime(p)}\sum_{a=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\sum_{b=1}^{\left \lfloor \frac{m}{p} \right \rfloor}\sum_{d|gcd(a,b)}\mu(d)$$ $$\sum_{isprime(p)}\sum_{a=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\sum_{b=1}^{\left \lfloor \frac{m}{p} \right \rfloor}\sum_{d|a \space and \space d|b}\mu(d)$$因为：$$\sum_{d|a \space and \space d|b}1 是等于后边的{\left \lfloor \frac{n}{pd} \right \rfloor}{\left \lfloor \frac{m}{pd} \right \rfloor}的$$所以之前就直接得出了。 ————-在我之前的教程中，上面直接被忽略—————额不妨设n&lt;=m，则可以变成：$$\sum_{isprime(p)}\sum_{d=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\mu(d){\left \lfloor \frac{n}{pd} \right \rfloor}{\left \lfloor \frac{m}{pd} \right \rfloor}$$ 上面的柿子已经很好用了，但可以考虑加速： 将pd设为k $$\sum_{k=1}^{n}\sum_{isprime(p) \space and \space p|k}\mu(\frac{k}{p}){\left \lfloor \frac{n}{k} \right \rfloor}{\left \lfloor \frac{m}{k} \right \rfloor}$$ $$\sum_{k=1}^{n} G(k){\left \lfloor \frac{n}{k} \right \rfloor}{\left \lfloor \frac{m}{k} \right \rfloor}$$ $$G(k)就是\sum_{isprime(p) \space and \space p|k}\mu(\frac{k}{p})$$ $$也就是k的所有质因数的\mu(\frac{k}{质因数})之和$$于是就优化到了可怕的O(N)~ 那么接下来就是要解决G(k)的预处理了简单粗暴的，使用暴力枚举素数来更新 代码14332 ms1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;typedef long long ll;const int MAXNUM=10000000,MAXPR=1000000;int prime[MAXPR],pr;ll mu[MAXNUM+10];bool v[MAXNUM+10];int G[MAXNUM+10];void getmu()&#123; mu[1]=1;pr=0; memset(v,1,sizeof(v)); for(int i=2;i&lt;=MAXNUM;i++) &#123; if(v[i]==1) prime[++pr]=i,mu[i]=-1; for(int j=1;j&lt;=pr;j++) &#123; ll tt=ll(i)*ll(prime[j]); if(tt&gt;ll(MAXNUM)) break; v[tt]=0; if(i%prime[j]==0) &#123; mu[tt]=0; break; &#125; else mu[tt]=-mu[i]; &#125; &#125; for(int i=1;i&lt;=pr;i++) &#123; int p=prime[i]; for(int j=1;ll(j)*ll(p)&lt;=ll(MAXNUM);j++) G[j*p]+=mu[j]; &#125; for(int i=1;i&lt;=MAXNUM;i++) G[i]+=G[i-1];&#125;ll calc(int n,int m)&#123; ll ans=0; if(n&gt;m) swap(n,m); int t=1; int last; for(int k=1;k&lt;=n;k=last+1) &#123; last=mymin(n/(n/k),m/(m/k)); ans+=(G[last]-G[k-1])*ll(n/k)*ll(m/k); &#125; return ans;&#125;int main()&#123; getmu(); int T;scanf("%d",&amp;T); while(T--) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); printf("%lld\n",calc(n,m)); &#125;&#125; 分析2然鹅，利用莫比乌斯函数的性质和G(k)的性质，可以得到这样的规律(用了足足一节数学课)：if(i%prime[j]==0) G[tt]=mu[i];else G[tt]=-G[i]+mu[i]; 代码23476 ms12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;typedef long long ll;const int MAXNUM=10000000,MAXPR=1000000;int prime[MAXPR],pr;ll mu[MAXNUM+10];bool v[MAXNUM+10];int G[MAXNUM+10];void getmu()&#123; mu[1]=1;pr=0; memset(v,1,sizeof(v)); for(int i=2;i&lt;=MAXNUM;i++) &#123; if(v[i]==1) prime[++pr]=i,mu[i]=-1,G[i]=1; for(int j=1;j&lt;=pr;j++) &#123; ll tt=ll(i)*ll(prime[j]); if(tt&gt;ll(MAXNUM)) break; v[tt]=0; if(i%prime[j]==0) &#123; mu[tt]=0; G[tt]=mu[i]; break; &#125; else &#123; mu[tt]=-mu[i]; G[tt]=-G[i]+mu[i]; &#125; &#125; &#125; for(int i=1;i&lt;=MAXNUM;i++) G[i]+=G[i-1];&#125;ll calc(int n,int m)&#123; ll ans=0; if(n&gt;m) swap(n,m); int t=1; int last; for(int k=1;k&lt;=n;k=last+1) &#123; last=mymin(n/(n/k),m/(m/k)); ans+=(G[last]-G[k-1])*ll(n/k)*ll(m/k); &#125; return ans;&#125;int main()&#123; getmu(); int T;scanf("%d",&amp;T); while(T--) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); printf("%lld\n",calc(n,m)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>难度3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Zoj3435】Ideal Puzzle Bobble]]></title>
    <url>%2Fposts%2Fea1.html</url>
    <content type="text"><![CDATA[来源和评测点Author: ZHU, YukeContest: ZOJ Monthly, November 2010Zoj3435Caioj1283 题目【题目大意】给定点(x,y,z)与(1,1,1)确定一个长方体，长方体边上及内部总共有x*y*z个点，问从(1,1,1)总共能看到多少个点【输入格式】多组数据一行三个整数，x,y,z 1&lt;=a,b,c&lt;=1000000【输出格式】共1行，一个整数从(1,1,1)总共能看到多少个点【输入样例】2 2 23 3 3【输出样例】719 分析莫比乌斯反演教程和题目分类参见：【OI之路】11更高级数论-2莫比乌斯反演其他莫比乌斯反演题目参见：Tag-莫比乌斯反演 建议先看二维版：仪仗队 用了分块讲(x,y,z)与(1,1,1)变成(x-1,y-1,z-1)与(0,0,0)三个数的gcd是一样的，注意0答案就是：（都不是0）+（一个0）+（两个0也就是3）分别反演结果之和 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;typedef long long ll;//******************定义******************const int MAXNUM=1000000,MAXPR=100000;int mu[MAXNUM+10];//******************莫比乌斯函数******************int prime[MAXPR+10],pr;bool prv[MAXNUM+10];void getmu()&#123; pr=0;memset(prv,1,sizeof(prv)); mu[1]=1; for(int i=2;i&lt;=MAXNUM;i++) &#123; if(prv[i]==1) &#123; prime[++pr]=i; mu[i]=-1; &#125; for(int j=1;j&lt;=pr;j++) &#123; int t=i*prime[j]; if(t&gt;MAXNUM) break; prv[t]=0; if(i%prime[j]==0) &#123; mu[t]=0; break; &#125; else mu[t]=-mu[i]; &#125; mu[i]+=mu[i-1]; &#125;&#125;//******************莫比乌斯反演******************ll calc1(int a,int b,int c)&#123; //已经不必强调大小了，找到最小值就好了 //其实也就模板题需要去重所以才要交换罢了 int mi=mymin(a,mymin(b,c)); ll ans=0; int last; int t=1; for(int i=1;i&lt;=mi;i=last+1)//d/t &#123; int d=i*t; last=mymin( a/(a/d), mymin( b/(b/d),c/(c/d) ) ); ans+=ll(mu[last]-mu[i-1])*( ll(a/d)*ll(b/d)*ll(c/d) ); &#125; return ans;&#125;ll calc2(int a,int b)&#123; int mi=mymin(a,b); ll ans=0; int last; int t=1; for(int i=1;i&lt;=mi;i=last+1)//d/t &#123; int d=i*t; last=mymin( a/(a/d),b/(b/d) ); ans+=ll(mu[last]-mu[i-1])*( ll(a/d)*ll(b/d) ); &#125; return ans;&#125;//******************主函数******************int main()&#123; getmu(); int x,y,z; while(scanf("%d%d%d",&amp;x,&amp;y,&amp;z)!=EOF) &#123; //都不是0+一个0+两个0 printf("%lld\n",calc1(x-1,y-1,z-1)+calc2(x-1,y-1)+calc2(y-1,z-1)+calc2(x-1,z-1)+3); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>难度2</tag>
        <tag>精品题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2190】仪仗队]]></title>
    <url>%2Fposts%2F24f8.html</url>
    <content type="text"><![CDATA[来源和评测点SDOI2008Bzoj2190 题目【题目大意】 作为体育委员，C君负责这次运动会仪仗队的训练。仪仗队是由学生组成的N*N的方阵，为了保证队伍在行进中整齐划一，C君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐(如下图)。现在，C君希望你告诉他队伍整齐时能看到的学生人数。【输入格式】共一个数N，1≤N≤40000【输出格式】共一个数，即C君应看到的学生人数。【输入样例】4【输出样例】9 分析莫比乌斯反演教程和题目分类参见：【OI之路】11更高级数论-2莫比乌斯反演其他莫比乌斯反演题目参见：Tag-莫比乌斯反演 我代码里面用了分块，其实可能不用也可以重点是题目的转换，经别人提醒才想到和点的坐标有关假设C君在(0,0)，那么他能看到的点必须互质（注意0和任何数互质所以+2）原因：假如有点A(ak,bk)的坐标不互质,那么他必定被B(a,b)遮挡 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//************************定义************************typedef long long ll;const int MAXNUM=100000,MAXPR=10000;int mu[MAXNUM+10];//************************线性筛************************bool prv[MAXNUM+10];int prime[MAXPR+10],pr;void getmu()&#123; pr=0;memset(prv,1,sizeof(prv)); mu[1]=1; for(int i=2;i&lt;=MAXNUM;i++) &#123; if(prv[i]==1) &#123; prime[++pr]=i; mu[i]=-1; &#125; for(int j=1;j&lt;=pr;j++) &#123; ll t=ll(i)*ll(prime[j]); if(t&gt;ll(MAXNUM)) break; prv[t]=0; if(i%prime[j]==0) &#123; mu[t]=0; break; &#125; else mu[t]=-mu[i]; &#125; mu[i]+=mu[i-1]; &#125;&#125;//************************主函数************************ll calc(int n,int m)&#123; if(n&gt;m) swap(n,m); ll ans=0; int t=1; //F[d]=sigma[ f(t) ] d|t //f(t)=sigma[ mu(d/t)*F[d] ] t|d int last=0; for(int i=1;i&lt;=n;i=last+1)//d/t &#123; int d=i*t; last=mymin( n/(n/d) , m/(m/d) ); ans+=ll(mu[last]-mu[i-1])*ll(n/d)*ll(m/d); &#125; return ans;&#125;int main()&#123; getmu(); int n;scanf("%d",&amp;n); printf("%lld\n",calc(n-1,n-1)+2);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2301】【Luogu2522】Problem_b]]></title>
    <url>%2Fposts%2F12b6.html</url>
    <content type="text"><![CDATA[来源和评测点HAOI2011Bzoj2301Luogu2522Caioj1282 题目【题目大意】对于给出的n个询问，每次求有多少个数对(x,y)，满足a≤x≤b，c≤y≤d，且gcd(x,y)=k，gcd(x,y)函数为x和y的最大公约数。【输入格式】第一行一个整数n，接下来n行每行五个整数，分别表示a、b、c、d、k100%的数据满足：1≤n≤50000，1≤a≤b≤50000，1≤c≤d≤50000，1≤k≤50000【输出格式】共n行，每行一个整数表示满足要求的数对(x,y)的个数【输入样例】22 5 1 5 11 5 1 5 2【输出样例】143 分析莫比乌斯反演教程和题目分类参见：【OI之路】11更高级数论-2莫比乌斯反演其他莫比乌斯反演题目参见：Tag-莫比乌斯反演 嗯这次就不能硬搞了，会超时哒（bzoj上51000+到11000ms），所以要分块了而且还要用到容斥，因为下界也是变量了，画张图就灰常好理解了 至于分块，如下：采用前缀和优化+分块思想因为(n/d)*(m/d)有连续的一段是相等的，所以对莫比乌斯函数计算前缀和 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//************************定义************************typedef long long ll;const int MAXNUM=100000,MAXPR=10000;int mu[MAXNUM+10];//************************线性筛************************bool prv[MAXNUM+10];int prime[MAXPR+10],pr;void getmu()&#123; pr=0;memset(prv,1,sizeof(prv)); mu[1]=1; for(int i=2;i&lt;=MAXNUM;i++) &#123; if(prv[i]==1) &#123; prime[++pr]=i; mu[i]=-1; &#125; for(int j=1;j&lt;=pr;j++) &#123; ll t=ll(i)*ll(prime[j]); if(t&gt;ll(MAXNUM)) break; prv[t]=0; if(i%prime[j]==0) &#123; mu[t]=0; break; &#125; else mu[t]=-mu[i]; &#125; mu[i]+=mu[i-1]; &#125;&#125;//************************主函数************************ll calc(int n,int m)&#123; if(n&gt;m) swap(n,m); ll ans=0; int t=1; //F[d]=sigma[ f(t) ] d|t //f(t)=sigma[ mu(d/t)*F[d] ] t|d int last=0; for(int i=1;i&lt;=n;i=last+1)//i=d/t &#123; int d=i*t; last=mymin( n/(n/d) , m/(m/d) ); ans+=ll(mu[last]-mu[i-1])*ll(n/d)*ll(m/d); &#125; return ans;&#125;int main()&#123; getmu(); int n;scanf("%d",&amp;n); for(int tk=1;tk&lt;=n;tk++) &#123; int a,b,c,d,k;scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d,&amp;k); if(k==0) &#123; printf("0\n"); continue; &#125; a=(a-1)/k,b=b/k,c=(c-1)/k,d=d/k; printf("%lld\n",calc(b,d)-calc(b,c)-calc(a,d)+calc(a,c)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2818】GCD-莫比乌斯2]]></title>
    <url>%2Fposts%2F9151.html</url>
    <content type="text"><![CDATA[来源和评测点湖北省队互测Bzoj2818Caioj1281 一模一样的题目但数据强化版：Bzoj2820 YY的GCD 题目【题目大意】给定整数N，求1&lt;=x,y&lt;=N且Gcd(x,y)为素数的数对(x,y)有多少对【输入格式】一个整数N【输出格式】对数【输入样例】4【输出样例】4 分析1莫比乌斯反演教程和题目分类参见：【OI之路】11更高级数论-2莫比乌斯反演其他莫比乌斯反演题目参见：Tag-莫比乌斯反演 数据水到直接硬搞就好就是枚举每个素数p，然后n/p当作m就好了，还不用去重 代码1340 5584 ms123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;typedef long long ll;int prime[1000000],pr;ll mu[11000000];bool v[11000000];void getmu()&#123; mu[1]=1;pr=0; memset(v,1,sizeof(v)); for(int i=2;i&lt;=10000000;i++) &#123; if(v[i]==1) prime[++pr]=i,mu[i]=-1; for(int j=1;j&lt;=pr and ll(i)*ll(prime[j])&lt;=ll(10000000);j++) &#123; v[ i*prime[j] ]=0; if(i%prime[j]==0) &#123; mu[i*prime[j]]=0; break; &#125; mu[i*prime[j]]=-mu[i]; &#125; &#125;&#125;//ll F[10000000],f[11000000];int main()&#123; getmu(); int n;scanf("%d",&amp;n); ll ans=0; for(int pi=1;pi&lt;=pr;pi++) &#123; int p=prime[pi];if(p&gt;n) break; int m=n/p; int t=1; for(int i=1;i&lt;=m;i++)//d/t &#123; int d=i*t; //F[d]=ll( m/d )*ll( m/d ); //ans1+=mu[i]*F[i]; ans+=mu[i]*ll( m/d )*ll( m/d ); &#125; &#125; printf("%lld\n",ans);&#125; 分析2可以采用前缀和优化+分块思想因为（m/d）有连续的一段是相等的，所以对莫比乌斯函数计算前缀和 代码2256 5276 ms123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;typedef long long ll;int prime[1000000],pr;ll mu[11000000];bool v[11000000];void getmu()&#123; mu[1]=1;pr=0; memset(v,1,sizeof(v)); for(int i=2;i&lt;=10000000;i++) &#123; if(v[i]==1) prime[++pr]=i,mu[i]=-1; for(int j=1;j&lt;=pr and ll(i)*ll(prime[j])&lt;=ll(10000000);j++) &#123; v[ i*prime[j] ]=0; if(i%prime[j]==0) &#123; mu[i*prime[j]]=0; break; &#125; else mu[i*prime[j]]=-mu[i]; &#125; mu[i]+=mu[i-1]; &#125;&#125;//ll F[10000000],f[11000000];int main()&#123; getmu(); int n;scanf("%d",&amp;n); ll ans=0; for(int pi=1;pi&lt;=pr;pi++) &#123; int p=prime[pi];if(p&gt;n) break; int m=n/p; int t=1;int last=0; for(int i=1;i&lt;=m;i=last+1)//d/t &#123; int d=i*t; last=mymin(m,m/(m/d)); ans+=(mu[last]-mu[i-1])*ll( m/d )*ll( m/d ); &#125; &#125; printf("%lld\n",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hdu1695】GCD(莫比乌斯1)]]></title>
    <url>%2Fposts%2Fd395.html</url>
    <content type="text"><![CDATA[来源和评测点2008 “Sunline Cup” National Invitational ContestHdu1695Caioj1280 题目【题目大意】对于给出的n个询问，每次求有多少个数对(x,y)，满足a≤x≤b，c≤y≤d，且gcd(x,y) = k，gcd(x,y)函数为x和y的最大公约数，保证所有数据中a和c一定等于1。 注意：2，3和3，2是一种情况【输入格式】第一行一个整数n，接下来n行每行五个整数，分别表示a、b、c、d、k【输出格式】共n行，每行一个整数表示满足要求的数对(x,y)的个数【输入样例】21 3 1 5 11 11014 1 14409 9【输出样例】9736427 分析莫比乌斯反演教程和题目分类参见：【OI之路】11更高级数论-2莫比乌斯反演其他莫比乌斯反演题目参见：Tag-莫比乌斯反演 这道题分析在教程，因为是模版题我的代码尽量贴合教程了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;typedef long long ll;const int MAXN=1000000;ll mu[MAXN+100000];bool v[MAXN+100000];int prime[MAXN+100000],pr;void getmu()&#123; mu[1]=1;pr=0; memset(v,1,sizeof(v)); for(int i=2;i&lt;=MAXN;i++) &#123; if(v[i]==1) prime[++pr]=i,mu[i]=-1; for(int j=1;j&lt;=pr and ll(i)*ll(prime[j])&lt;ll(MAXN);j++) &#123; v[ i*prime[j] ]=0; if(i%prime[j]==0) &#123; mu[i*prime[j]]=0; break; &#125; mu[i*prime[j]]=-mu[i]; &#125; &#125;&#125;ll F[MAXN],f[MAXN];int main()&#123; getmu(); int n;scanf("%d",&amp;n); for(int fs=1;fs&lt;=n;fs++) &#123; int a,b,c,d,k;scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d,&amp;k); printf("Case %d: ",fs); if(k==0) &#123; printf("0\n"); continue; &#125; int n=b/k,m=d/k; if(n&gt;m) swap(n,m); ll ans1=0,ans2=0; int t=1; for(int i=1;i&lt;=n;i++)//d/t &#123; int d=i*t; F[d]=ll( n/d )*ll( m/d ); ans1+=mu[i]*F[i]; &#125; for(int i=1;i&lt;=n;i++)//d/t &#123; int d=i*t; F[d]=ll( n/d )*ll( n/d ); ans2+=mu[i]*F[i]; &#125; printf("%lld\n",ans1-ans2/2); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1001】狼抓兔子]]></title>
    <url>%2Fposts%2F9c9f.html</url>
    <content type="text"><![CDATA[来源和评测点BeiJing2006Bzoj1001 题目【题目大意】现在小朋友们最喜欢的”喜羊羊与灰太狼”,话说灰太狼抓羊不到，但抓兔子还是比较在行的，而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对下面这样一个网格的地形：左上角点为(1,1),右下角点为(N,M)(上图中N=3,M=4)。有以下三种类型的道路：1:(x,y)&lt;==&gt;(x+1,y)2:(x,y)&lt;==&gt;(x,y+1)3:(x,y)&lt;==&gt;(x+1,y+1)道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的。左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角(1,1)的窝里，现在它们要跑到右下解(N,M)的窝中去，狼王开始伏击这些兔子。当然为了保险起见，如果一条道路上最多通过的兔子数为K，狼王需要安排同样数量的K只狼，才能完全封锁这条道路。你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦。【输入格式】第一行为N,M.表示网格的大小，N,M均小于等于1000.接下来分三部分第一部分共N行，每行M-1个数，表示横向道路的权值.第二部分共N-1行，每行M个数，表示纵向道路的权值.第三部分共N-1行，每行M-1个数，表示斜向道路的权值.输入文件保证不超过10M【输出格式】输出一个整数，表示参与伏击的狼的最小数量.【输入样例】3 45 6 44 3 17 5 35 6 7 88 7 6 55 5 56 6 6【输出样例】14 分析1网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他最小割题目参见：Tag-最小割 一看就是最小割 代码1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131/************************************************************** Problem: 1001 User: Zory Language: C++ Result: Accepted Time:1256 ms Memory:85196 kb****************************************************************/ //最小割#include&lt;cstdio&gt;//#include&lt;cstdlib&gt;#include&lt;cstring&gt;//#include&lt;cctype&gt;#include&lt;cmath&gt;//#include&lt;ctime&gt;//#include&lt;queue&gt;#include&lt;set&gt;//#include&lt;stack&gt;//#include&lt;iostream&gt;//#include&lt;string&gt;//#include&lt;iomanip&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int mymax(int a,int b)&#123; return a&gt;b?a:b;&#125;int mymin(int a,int b)&#123; return a&gt;b?b:a;&#125;/*int myabs(int a)&#123; return a&gt;0?a:-a;&#125;void myswap(int &amp;x,int &amp;y)&#123; int t=x;x=y;y=t;&#125;*/int read()&#123; int s=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') s=s*10+c-'0',c=getchar(); return s;&#125;//*******************定义*******************const int Maxn=1100000,Maxm=6100000;int st,ed;int hou[Maxn],h[Maxn];struct nod&#123; int y,c;int gg;&#125;e[Maxm];//*******************实现*******************int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].gg=hou[x];hou[x]=ln;&#125;int getoth(int x) &#123; return (x%2==0)?x-1:x+1; &#125;int q[Maxn];bool bfs()&#123; memset(h,0,sizeof(h)); q[1]=st;h[st]=1; int tou=1,wei=1; while(tou&lt;=wei) &#123; int x=q[tou]; for(int k=hou[x];k&gt;0;k=e[k].gg) &#123; int y=e[k].y; if(h[y]==0 and e[k].c&gt;0 ) &#123; h[y]=h[x]+1; q[++wei]=y; if(y==ed) return 1; &#125; &#125; tou++; &#125; return 0;&#125;int dfs(int x,int s)&#123; if(x==ed) return s; int t=0; for(int k=hou[x];k&gt;0;k=e[k].gg ) &#123; int y=e[k].y; if(h[y]==h[x]+1 and e[k].c&gt;0 and t&lt;s ) &#123; int b=dfs(y,mymin(e[k].c,s-t)); e[k].c-=b;e[getoth(k)].c+=b;t+=b; if(s==t) return s; &#125; &#125; if(t==0) h[x]=0; return t;&#125;//*******************接口*******************int n,m;int pt(int x,int y)&#123; return (x-1)*m+y;&#125;//*******************主函数*******************int tx[3]=&#123;0,1,1&#125;;int ty[3]=&#123;1,0,1&#125;;int main(int argc, char *argv[])&#123; scanf("%d%d",&amp;n,&amp;m); ln=0; for(int k=0;k&lt;=2;k++) for(int i=1;i&lt;=((k==0)?n:n-1);i++) for(int j=1;j&lt;=((k==1)?m:m-1);j++) &#123; int x=pt(i,j),y=pt(i+tx[k],j+ty[k]),c=read(); ins(x,y,c);ins(y,x,c); &#125; st=1;ed=pt(n,m); int ans=0; while(bfs()) ans+=dfs(st,INF); printf("%d\n",ans);&#125; 分析2可以将网格图转化为对偶图可以参考论文：https://wenku.baidu.com/view/8f1fde586edb6f1aff001f7d 代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159/************************************************************** Problem: 1001 User: Zory Language: C++ Result: Accepted Time:1536 ms Memory:126332 kb****************************************************************/ //Dijkstra#include&lt;cstdio&gt;//#include&lt;cstdlib&gt;#include&lt;cstring&gt;//#include&lt;cctype&gt;#include&lt;cmath&gt;//#include&lt;ctime&gt;#include&lt;queue&gt;//#include&lt;set&gt;//#include&lt;stack&gt;//#include&lt;iostream&gt;//#include&lt;string&gt;//#include&lt;iomanip&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int mymax(int a,int b)&#123; return a&gt;b?a:b;&#125;int mymin(int a,int b)&#123; return a&gt;b?b:a;&#125;/*int myabs(int a)&#123; return a&gt;0?a:-a;&#125;void myswap(int &amp;x,int &amp;y)&#123; int t=x;x=y;y=t;&#125;*/int read()&#123; int s=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') s=s*10+c-'0',c=getchar(); return s;&#125;//*******************定义*******************const int Maxn=2100000,Maxm=8100000;struct nod1&#123; int hou,ans;&#125;p[Maxn];struct nod2&#123; int y,c;int gg;&#125;e[Maxm];int st,ed;//*******************实现*******************int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].gg=p[x].hou; p[x].hou=ln; ln++; e[ln].y=x;e[ln].c=c; e[ln].gg=p[y].hou; p[y].hou=ln;&#125;typedef pair&lt;int,int&gt; P;priority_queue&lt; P,vector&lt;P&gt;,greater&lt;P&gt; &gt; q;void Dijkstra()&#123; while(!q.empty()) q.pop(); p[st].ans=0; q.push(make_pair(0,st)); while(!q.empty()) &#123; P s=q.top();q.pop(); int x=s.second; if(s.first&gt;p[x].ans) continue; for(int k=p[x].hou;k&gt;0;k=e[k].gg) &#123; int y=e[k].y; if(p[y].ans&gt;p[x].ans+e[k].c) &#123; p[y].ans=p[x].ans+e[k].c; q.push(make_pair(p[y].ans,y)); &#125; &#125; &#125;&#125;//*******************接口*******************int a,b;int pt(int x,int y)&#123; return (x-1)*b+y;&#125;//*******************主函数*******************int t[3][1100][1100];int main(int argc, char *argv[])&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); if(n==1 or m==1) &#123; if(n&gt;m) swap(n,m); int ans=INF; for(int i=1,a;i&lt;m;i++) &#123; scanf("%d",&amp;a); ans=mymin(ans,a); &#125; printf("%d",ans==INF?0:ans); return 0; &#125; for(int k=0;k&lt;=2;k++) for(int i=1;i&lt;=(k==0?n:n-1);i++) for(int j=1;j&lt;=(k==1?m:m-1);j++) t[k][i][j]=read(); ln=0; a=(n-1)*2,b=m-1; int cnt=a*b; for(int i=1;i&lt;=cnt+2;i++) &#123; p[i].ans=INF; p[i].hou=0; &#125; for(int i=1;i&lt;=a;i++) for(int j=1;j&lt;=b;j++) if(i%2==0) &#123; ins(pt(i,j),pt(i-1,j),t[2][i/2][j]); &#125; else &#123; if(i&gt;1) ins(pt(i,j),pt(i-1,j),t[0][(i+1)/2][j]); if(j&lt;b) ins(pt(i,j),pt(i+1,j+1),t[1][(i+1)/2][j+1]); &#125; st=cnt+1;ed=cnt+2; for(int i=2;i&lt;=a;i+=2) ins(st,pt(i,1),t[1][i/2][1]),//左 ins(pt(i-1,b),ed,t[1][i/2][m]);//右 for(int j=1;j&lt;=b;j++) ins(st,pt(a,j),t[0][n][j]),//下 ins(pt(1,j),ed,t[0][1][j]);//上 Dijkstra(); printf("%d",p[ed].ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>Dijkstra</tag>
        <tag>网络流</tag>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>最小割</tag>
        <tag>对偶图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1645】City Horizon城市地平线]]></title>
    <url>%2Fposts%2Feed1.html</url>
    <content type="text"><![CDATA[来源和评测点USACO 2007 Open SilverBzoj1645 题目【题目大意】约翰带着奶牛去都市观光。在落日的余晖里，他们看到了一幢接一幢的摩天高楼的轮廓在地平线上形成美丽的图案。以地平线为 X 轴，每幢高楼的轮廓是一个位于地平线上的矩形，彼此间可能有重叠的部分。奶牛一共看到了N幢高楼，第i幢楼的高度是Hi，两条边界轮廓在地平线上的坐标是Ai到Bi。请帮助奶牛们计算一下，所有摩天高楼的轮廓覆盖的总面积是多少。【输入格式】第一行：单个整数N，1≤N≤40000第二行到第N+1行：第i+1行有三个整数Ai，Bi和Hi，1≤Ai&lt;Bi≤10^9, 1≤Hi≤10^9【输出格式】单个整数：表示摩天高楼轮廓所覆盖的总面积【输入样例】42 5 19 10 46 8 24 6 3【输出样例】16【样例解释】只有第一幢楼和最后一幢楼有1个单位的重叠面积 分析线段树教程和题目分类参见：【OI之路】06树-1线段树其他线段树题目参见：Tag-线段树 我看到网上有说“扫描线”，并不知道是什么……反正我的做法就是离散化信息，然后使用线段树，区间修改，维护单点最值最后求和即可 具体可参考注释 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;typedef long long ll;struct seg&#123; int l,r,mid; int lc,rc; int mx,lz;&#125;p[200000];int ln;int build(int l,int r)&#123; int t=++ln; p[t].l=l;p[t].r=r;p[t].mid=(l+r)&gt;&gt;1; if(l&lt;r) &#123; p[t].lc=build(l,p[t].mid); p[t].rc=build(p[t].mid+1,r); &#125; return t;&#125;//lz是lazy优化（区间修改一般都有）//定义为某尚未尝试更新的值，且必须下传void pushdown(int x)&#123; if(!p[x].lz) return; p[x].mx=mymax(p[x].mx,p[x].lz); int lc=p[x].lc,rc=p[x].rc; p[lc].lz=mymax(p[lc].lz,p[x].lz); p[rc].lz=mymax(p[rc].lz,p[x].lz); p[x].lz=0;&#125;void change(int x,int l,int r,int c)&#123; if(p[x].l==l and p[x].r==r) &#123; p[x].lz=mymax(p[x].lz,c); return; &#125; pushdown(x); int lc=p[x].lc,rc=p[x].rc; if(r&lt;=p[x].mid) change(lc,l,r,c); else if(l&gt;p[x].mid) change(rc,l,r,c); else change(lc,l,p[x].mid,c),change(rc,p[x].mid+1,r,c);&#125;int ask(int w,int x)&#123; pushdown(w); if(p[w].l==p[w].r) return p[w].mx; if(x&lt;=p[w].mid) return ask(p[w].lc,x); return ask(p[w].rc,x);&#125;int n;int a[81000];int l[41000],r[41000],h[41000];int find(int x)&#123; int l=1,r=2*n; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(a[mid]&lt;x) l=mid+1; else if(a[mid]==x) return mid; else r=mid-1; &#125;&#125;//由于是函数，保证了相同x返回相同的值，具体是什么不重要int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d%d",&amp;l[i],&amp;r[i],&amp;h[i]); if(l[i]==r[i])//特判，防止空信息 &#123; i--;n--; continue; &#125; a[2*i-1]=l[i];a[2*i]=r[i]; &#125; sort(a+1,a+1+2*n); int rx=2*n; //改点区间为段区间，便于维护 ln=0;build(1,rx); for(int i=1;i&lt;=n;i++) change(1,find(l[i])+1,find(r[i]),h[i]); //二分离散化 //为了能够实现同值的结果依然同值并且获得损失的区间信息量 ll s=0; for(int i=2;i&lt;=2*n;i++) s+=ll(ask(1,i))*ll(a[i]-a[i-1]); //记得还原信息 printf("%lld",s);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1934】【Bzoj2768】善意的投票&冠军调查]]></title>
    <url>%2Fposts%2Fa1fb.html</url>
    <content type="text"><![CDATA[来源和评测点这两道题连样例都是一模一样的……下文以1934来分析Bzoj1934Bzoj2768 注意！Bzoj2768冠军调查数据可能和题面不同，网络流边数应开到40万而不是10万 题目【题目大意】幼儿园里有n个小朋友打算通过投票来决定睡不睡午觉。对他们来说，这个问题并不是很重要，于是他们决定发扬谦让精神。虽然每个人都有自己的主见，但是为了照顾一下自己朋友的想法，他们也可以投和自己本来意愿相反的票。我们定义一次投票的冲突数为好朋友之间发生冲突的总数加上和所有和自己本来意愿发生冲突的人数。 我们的问题就是，每位小朋友应该怎样投票，才能使冲突数最小？【输入格式】第一行只有两个整数n，m，保证有2≤n≤300，1≤m≤n(n-1)/2。其中n代表总人数，m代表好朋友的对数。文件第二行有n个整数，第i个整数代表第i个小朋友的意愿，当它为1时表示同意睡觉，当它为0时表示反对睡觉。接下来文件还有m行，每行有两个整数i，j。表示i，j是一对好朋友，我们保证任何两对i，j不会重复。【输出格式】只需要输出一个整数，即可能的最小冲突数。【输入样例】3 31 0 01 21 33 2【输出样例】1【样例解释】所有小朋友都投赞成票就能得到最优解 分析网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他最小割题目参见：Tag-最小割 考验模型转化能力，难度2吧想了十多分钟？当然，已经知道是最小割了 “分配方案”、“强制站队”是我自己的理解方式，因人而异吧 一开始想着“分配方案”最大流，每个人与1、0连接，然后后面朋友间的边权依赖于前面，所以不可行 由于只有睡和不睡两种选择，考虑最小割“强制站队”，源点是睡觉的，汇点是不睡觉的每个人只能选择其中一个，形成了最小割构图：依然要拆点源点到左人、右人到汇点，边权都根据个人意愿决定，是自己意愿就是1，因为拆了就违反意愿，否则为0同理，好朋友之间边权是1 想想特例:1、所有人都不想睡觉，最大流是0好朋友之间也不会有违背，确实是0，没问题2、没有好朋友，最大流是0直接每个人依照自己意愿，确实是0，也没问题 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;const int MAXN=1000,MAXM=410000;struct pt&#123; int h; int hou;&#125;p[MAXN];struct rod&#123; int y,c,g; int oth;&#125;e[MAXM];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; ln++; e[ln].y=x;e[ln].c=0; e[ln].g=p[y].hou;p[y].hou=ln; e[ln].oth=ln-1;e[ln-1].oth=ln;&#125;int st,ed;int lst[MAXN];bool bfs()&#123; for(int i=1;i&lt;=ed;i++) p[i].h=0; lst[1]=st;p[st].h=1; int tou=1,wei=1; while(tou&lt;=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==0 and e[k].c&gt;0) &#123; p[y].h=p[x].h+1; lst[++wei]=y; &#125; &#125; tou++; &#125; return p[ed].h&gt;0;&#125;int dfs(int x,int f)&#123; if(x==ed) return f; int t=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==p[x].h+1 and t&lt;f and e[k].c&gt;0) &#123; int tt=dfs(y,mymin(f-t,e[k].c)); t+=tt;e[k].c-=tt;e[e[k].oth].c+=tt; &#125; &#125; if(t==0) p[x].h=0; return t;&#125;int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); st=n+n+1,ed=n+n+2;ln=0; for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); if(t) ins(st,i,1); else ins(n+i,ed,1); &#125; for(int i=1;i&lt;=m;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,n+y,1);ins(y,n+x,1); &#125; int ans=0; while(bfs()) ans+=dfs(st,INF); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>难度2</tag>
        <tag>精品题</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3189】Steady Cow Assignment]]></title>
    <url>%2Fposts%2Fb6a3.html</url>
    <content type="text"><![CDATA[来源和评测点USACO 2006 February GoldPoj3189Caioj1120 题目【题目大意】有N(1&lt;=N&lt;=1000)头牛，B(1&lt;=B&lt;=20)个牛圈每头牛对于牛圈都有不同的喜好程度排名，牛圈有一定的容量对于某种分配方案，假如牛1去了牛圈3，是它的第五志愿，记满意程度=5输出（所有牛的满意程度 最大值到最小值的区间）的最小值相当于 （MAX牛的满意程度）-（MIN牛的满意程度）+1重点句：Your job is to find an assignment of cows to barns such that no barn’s capacity is exceeded and the size of the range (i.e., one more than the positive difference between the the highest-ranked barn chosen and that lowest-ranked barn chosen) of barn rankings the cows give their assigned barns is as small as possible.【输入格式】第一行N和B接下来N行，每行B个数，表示喜欢的牛圈的序号，按喜欢的程度（递减）给出，（比如第一个给出的牛圈的就是最喜欢，最后一个就是最不喜欢的）接下来B个数，每个数表示牛圈最多容纳的牛的数目【输出格式】最小的“满意程度区间”【输入样例】6 41 2 3 42 3 1 44 2 3 13 1 2 41 3 4 21 4 2 32 1 3 2【输出样例】2【样例解释】牛圈1：牛1 牛5牛圈2：牛2牛圈3：牛4牛圈4：牛3 牛6满意程度 1 1 1 1 1 2答案就是 2 分析网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他网络流题目参见：Tag-网络流 其实可以尝试着看看英文题题意我翻译好了，caioj不完整也不好理解，poj全英文 对于区间，枚举下界，在此基础上二分答案O( B*logB*(n^3) )这做法真的狗血，好久没用过枚举了 构图：源点到牛连权值为1的边牛到牛圈连权值为1的边牛圈到汇点连权值为 该牛圈容量 的边 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;const int MAXN=1100,MAXM=61000;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;struct pt&#123; int h; int hou;&#125;p[MAXN];struct rod&#123; int y,c,g; int oth;&#125;e[MAXM];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; ln++; e[ln].y=x;e[ln].c=0; e[ln].g=p[y].hou;p[y].hou=ln; e[ln].oth=ln-1;e[ln-1].oth=ln;&#125;int st,ed;int lst[MAXN];bool bfs()&#123; for(int i=1;i&lt;=ed;i++) p[i].h=0; int tou=1,wei=1; lst[1]=st;p[st].h=1; while(tou&lt;=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==0 and e[k].c&gt;0) &#123; p[y].h=p[x].h+1; lst[++wei]=y; &#125; &#125; tou++; &#125; return p[ed].h&gt;0;&#125;int dfs(int x,int f)&#123; if(x==ed) return f; int t=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==p[x].h+1 and e[k].c&gt;0 and t&lt;f) &#123; int tt=dfs(y,mymin(f-t,e[k].c)); t+=tt;e[k].c-=tt;e[e[k].oth].c+=tt; &#125; &#125; if(t==0) p[x].h=0; return t;&#125;int n,b;int lv[MAXN][30];int ct[30];bool check(int ll,int rr)&#123; ln=0;for(int i=1;i&lt;=ed;i++) p[i].hou=0; for(int i=1;i&lt;=n;i++) &#123; ins(st,i,1); for(int j=ll;j&lt;=rr;j++) ins(i, n+lv[i][j] ,1); &#125; for(int i=1;i&lt;=b;i++) ins(n+i,ed,ct[i]); int ans=0; while( bfs() ) ans+=dfs(st,INF); //printf("-----ll=%d rr=%d ans=%d n=%d\n",ll,rr,ans,n); return ans==n;&#125;int getans(int low)&#123; int l=1,r=b-low+1,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(low,low+mid-1)) ans=mid,r=mid-1; else l=mid+1; &#125; //printf("low=%d ans=%d\n",low,ans); return ans&lt;0?INF:ans;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;b); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=b;j++) scanf("%d",&amp;lv[i][j]); for(int i=1;i&lt;=b;i++) scanf("%d",&amp;ct[i]); st=n+b+1,ed=n+b+2; int mi=INF; for(int i=1;i&lt;=b;i++) mi=mymin(mi, getans(i) ); printf("%d",mi);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>难度2</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj2112】Optimal Milking]]></title>
    <url>%2Fposts%2F41bc.html</url>
    <content type="text"><![CDATA[来源和评测点USACO 2003 US OpenPoj2112Caioj1119 题目【题目大意】FJ把K个挤奶机搬进了住着C头奶牛的牧场。挤奶机的编号为1~K，奶牛的编号为K+1~K+C。每头奶牛到每台挤奶机距离不同，每台挤奶机每天最多服务M头奶牛。求一种分配方案, 使得走得最远的奶牛走过的距离最小化，输出此距离重点句：Cows can traverse several paths on the way to their milking machine. 路径the distance the furthest-walking cow travels is minimized 走最多的牛的路程最小【输入格式】数据第1行是3个整数K，C，M（1≤K≤30）（1≤C≤200）（1≤M≤15）接下来是一个（K+C）×（K+C）的距离矩阵。矩阵元素为正并不超200。距离为0表示两个点之间无边存在。【输出格式】输出一个整数，即走得最远的奶牛走过的距离的最小化值。【输入样例】2 3 20 3 2 1 13 0 3 2 02 3 0 1 01 2 1 0 21 0 0 2 0【输出样例】2 分析网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他网络流题目参见：Tag-网络流 其实可以尝试着看看英文题 依旧是folyd，然后二分答案(反正最终还是要到达挤奶机的) 构图：从源点到牛建权值为1的边牛到挤奶机建权值为1的边（当满足二分条件时）挤奶机到汇点建权值为m的边 相比上一题Ombrophobic Bovines相当无聊，秒AC 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;const int MAXN=310,MAXM=91000;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;struct pt&#123; int h; int hou;&#125;p[MAXN];struct rod&#123; int y,c,g; int oth;&#125;e[MAXM];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; ln++; e[ln].y=x;e[ln].c=0; e[ln].g=p[y].hou;p[y].hou=ln; e[ln].oth=ln-1;e[ln-1].oth=ln;&#125;int st,ed;int lst[MAXN];bool bfs()&#123; for(int i=1;i&lt;=ed;i++) p[i].h=0; int tou=1,wei=1; lst[1]=st;p[st].h=1; while(tou&lt;=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==0 and e[k].c&gt;0) &#123; p[y].h=p[x].h+1; lst[++wei]=y; &#125; &#125; tou++; &#125; return p[ed].h&gt;0;&#125;int dfs(int x,int f)&#123; if(x==ed) return f; int t=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==p[x].h+1 and e[k].c&gt;0 and t&lt;f) &#123; int tt=dfs(y,mymin(f-t,e[k].c)); t+=tt;e[k].c-=tt;e[e[k].oth].c+=tt; &#125; &#125; if(t==0) p[x].h=0; return t;&#125;//挤奶机的编号为1~K，奶牛的编号为K+1~K+Cint cst[MAXN][MAXN];int nk,nc,m;bool check(int mid)&#123; ln=0;for(int i=1;i&lt;=ed;i++) p[i].hou=0; for(int i=1;i&lt;=nc;i++) ins(st,i,1); for(int i=1;i&lt;=nc;i++) for(int j=1;j&lt;=nk;j++) if(cst[j][nk+i]&lt;=mid) ins(i,nc+j,1); for(int j=1;j&lt;=nk;j++) ins(nc+j,ed,m); int ans=0; while(bfs()) ans+=dfs(st,INF); return ans==nc;&#125;int main()&#123; scanf("%d%d%d",&amp;nk,&amp;nc,&amp;m); st=nc+nk+1,ed=nc+nk+2; int n=nk+nc; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; int c;scanf("%d",&amp;c); cst[i][j]=(c==0)?INF:c; &#125; int l=0,r=0; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; int tt=cst[i][k]+cst[k][j]; if(tt&lt;cst[i][j]) cst[i][j]=tt; if(cst[i][j]!=INF and r&lt;cst[i][j]) r=cst[i][j]; &#125; int ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf("%d",ans);&#125; 分析2然鹅通过改进匈牙利算法实现多重二分图匹配能大幅度加快速度，从而取代网络流思路来自http://blog.csdn.net/leolin_/article/details/7195205 代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;const int INF=0x3f3f3f3f;const int MAXGN=300,MAXMN=50,MAXM=15000;int hou[MAXGN];struct rod&#123; int y,g;&#125;e[MAXM];int ln;void ins(int x,int y)&#123; ln++;e[ln].y=y; e[ln].g=hou[x];hou[x]=ln;&#125;int gn,mn;int mnum[MAXMN];int match[MAXMN][20];int ask[MAXMN];int tnow;int kk,cc,mm;bool find_muniu(int x)&#123; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(ask[y]&lt;tnow) &#123; ask[y]=tnow; if(mnum[y]&lt;mm) &#123; match[y][++mnum[y]]=x; return 1; &#125; else &#123; for(int z=1;z&lt;=mnum[y];z++) &#123; if(find_muniu( match[y][z] )) &#123; match[y][z]=x; return 1; &#125; &#125; &#125; &#125; &#125; return 0;&#125;int cst[MAXGN+MAXMN][MAXGN+MAXMN];bool check(int mid)&#123; ln=0; for(int i=1;i&lt;=gn;i++) &#123; hou[i]=0; for(int j=1;j&lt;=mn;j++) if(cst[kk+i][j]&lt;=mid) ins(i,j); &#125; memset(ask,0,sizeof(ask));//debug memset(mnum,0,sizeof(mnum));//debug for(tnow=1;tnow&lt;=gn;tnow++) if(find_muniu(tnow)==0) return 0; return 1;&#125;int mx;void folyd(int n)&#123; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) cst[i][j]=mymin(cst[i][k]+cst[k][j],cst[i][j]); mx=0; for(int i=1;i&lt;=kk;i++) for(int j=1;j&lt;=cc;j++) if(cst[i][j]&gt;mx and cst[i][j]&lt;INF) mx=cst[i][j];&#125;int main()&#123; scanf("%d%d%d",&amp;kk,&amp;cc,&amp;mm); for(int i=1;i&lt;=kk+cc;i++) for(int j=1;j&lt;=kk+cc;j++) &#123; int t;scanf("%d",&amp;t); cst[i][j]=(t==0)?INF:t; &#125; folyd(kk+cc); gn=cc,mn=kk; int l=0,r=mx,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>匈牙利</tag>
        <tag>网络流</tag>
        <tag>Floyd</tag>
        <tag>最大流</tag>
        <tag>难度2</tag>
        <tag>二分</tag>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Usaco05Mar】Ombrophobic Bovines]]></title>
    <url>%2Fposts%2F44a6.html</url>
    <content type="text"><![CDATA[来源和评测点USACO 2005 March GoldBzoj1738Poj2391Caioj1118 题目【题目大意】下雨了，有F(1&lt;=F&lt;=200)个牛棚，这F个牛棚之间有P(1&lt;=P&lt;=1500)条无向边（有耗时）每个牛棚有两个值A和B（A表示一开始这个牛棚有A头牛，B表示下雨时该牛棚最多可以容纳B头牛躲雨）。问最少需要提前多少时间响“下雨警告”才能让所有牛在下雨前都能够找到可以遮雨的地方。 重点句：The paths are wide,so that any number of cows can traverse a path in either direction. 无向边Fields are small compared to the paths and require no time for cows to traverse. 将牛棚看作点【输入格式】两个整数: F 和 P接下来F行，第i行两个整数A和B（A、B的范围都是:0..1000）描述第i个牛棚接下来P行，每行三个整数。X Y L，表示牛棚X和牛棚Y之间有一条边，耗时是L（1&lt;=L&lt;=1,000,000,000）【输出格式】输出一行，即为最短的时间，如果无法使得所有牛都能够有地方避雨，那么输出 “-1”【输入样例】3 47 20 42 61 2 403 2 702 3 901 3 120【输出样例】110【样例解释】牛棚1安排4头牛到牛棚2，牛棚1再安排1头牛走到牛棚2，再走到牛棚3避雨。 分析网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他网络流题目参见：Tag-网络流本题入选了精品题：Tag-精品题 这道题建议大家像我一样仔细想想，别急着看题解，虽然你到我这个页面很可能是来膜题解的 由于边比较复杂，但又是无向图考虑Floyd获得两点之间最短耗时然后两点之间只存在一条边了 原问题转化成：选一些边来满足条件并且最长边最小条件为牛跑来跑去后每个牛棚能容纳下 考虑二分答案，从而得到满足的边，跑一遍网络流验证解的可行性 构图：从汇点到各个左牛棚，容量是每个牛棚原本的牛数量拆点，从左牛棚连到右牛棚，表示可以通过去，容量是无限从右牛棚到汇点，容量是牛棚最后的最大容纳 假如最大流=牛的数量F 表示可行 记得自己可以连自己 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;const int MAXN=510,MAXM=110000;struct pt&#123; int h; int hou;&#125;p[MAXN];struct rod&#123; int y,c,g; int oth;&#125;e[MAXM];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; ln++; e[ln].y=x;e[ln].c=0; e[ln].g=p[y].hou;p[y].hou=ln; e[ln-1].oth=ln;e[ln].oth=ln-1;&#125;int st,ed;int lst[MAXN];bool bfs()&#123; for(int i=1;i&lt;=ed;i++) p[i].h=0; int tou=1,wei=1; lst[1]=st;p[st].h=1; while(tou&lt;=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==0 and e[k].c&gt;0) &#123; p[y].h=p[x].h+1; lst[++wei]=y; &#125; &#125; tou++; &#125; return p[ed].h&gt;0;&#125;int dfs(int x,int f)&#123; if(x==ed) return f; int t=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==p[x].h+1 and e[k].c&gt;0 and t&lt;f) &#123; int tt=dfs(y,mymin(f-t,e[k].c)); t+=tt;e[k].c-=tt;e[e[k].oth].c+=tt; &#125; &#125; if(t==0) p[x].h=0; return t;&#125;/*1~n 左牛棚n+1~n+n 右牛棚n+n+1 源点n+n+2 汇点*/int n;int alc;int aa[MAXN],bb[MAXN];ll cst[MAXN][MAXN];bool check(ll mid)&#123; ln=0;for(int i=1;i&lt;=ed;i++) p[i].hou=0; for(int i=1;i&lt;=n;i++) &#123; ins(st,i,aa[i]);ins(i,n+i,INF);ins(n+i,ed,bb[i]); for(int j=1;j&lt;=n;j++) if(cst[i][j]&lt;=mid) ins(i,n+j,INF); &#125; int ans=0; while(bfs()) ans+=dfs(st,INF); //printf("mid=%d ans=%d alc=%d\n",mid,ans,alc); return ans==alc;&#125;int main()&#123; memset(cst,63,sizeof(cst)); int m;scanf("%d%d",&amp;n,&amp;m); st=n+n+1,ed=n+n+2; for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;aa[i],&amp;bb[i]),alc+=aa[i]; for(int i=1;i&lt;=m;i++) &#123; int x,y;ll c;scanf("%d%d%lld",&amp;x,&amp;y,&amp;c); if(c&lt;cst[x][y]) cst[x][y]=cst[y][x]=c; &#125; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; ll nt=cst[i][k]+cst[k][j]; if(nt&lt;cst[i][j]) cst[i][j]=nt; &#125; ll l=0,r=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=i-1;j++) if(cst[i][j]!=cst[0][0] and cst[i][j]&gt;r) r=cst[i][j]; ll ans=-1; while(l&lt;=r) &#123; ll mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>Floyd</tag>
        <tag>最大流</tag>
        <tag>难度2</tag>
        <tag>二分</tag>
        <tag>精品题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj2455】【Bzoj1733】Secret Milking Machine]]></title>
    <url>%2Fposts%2F7731.html</url>
    <content type="text"><![CDATA[来源和评测点USACO 2005 February GoldPoj2455Bzoj1733Caioj1117 题目【题目大意】给出N(2&lt;=N&lt;=200)个点和P(1&lt;=P&lt;=40000)条双向边，每条边的长度为（0~1000000）现在要求选出T(1&lt;=T&lt;=200)条“1至N”的路径，任意两条路径上的边不能重复并且要求这些路径中的最长边的长度最小注意：两个点之间有可能多条边，出发点是1，终点是N【输入格式】第一行三个整数: N,P,T下来P行,每行三个整数x,y,L,描述一条边：从点x到y的双向边，长度为Li【输出格式】求这T条路径中的的最长边的最小值【输入样例】7 9 21 2 22 3 53 7 51 4 14 3 14 5 75 7 11 6 36 7 3【输出样例】5提示：样例最后选择了两条路径 1-2-3-7 和 1-6-7 最长的路是5. 分析网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他网络流题目参见：Tag-网络流 注意两个概念：边 和 路径（路径是由多条边组成，当然可以是一条边）这题需要建立模型重点是二分，在同学的提醒下想到这个，然后就想通了就是二分最长边长度，满足结果（可行性）有序性因为每条边只能去一次，边权为1即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;const int MAXN=210,MAXM=81000;struct pt&#123; int hou; int h;&#125;p[MAXN];struct rod&#123; int y,c,g; int oth;&#125;e[MAXM];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; ln++; e[ln].y=x;e[ln].c=c; e[ln].g=p[y].hou;p[y].hou=ln; e[ln-1].oth=ln;e[ln].oth=ln-1;&#125;int m,T;int st,ed;int lst[MAXN];bool bfs()&#123; for(int i=st;i&lt;=ed;i++) p[i].h=0; int tou=1,wei=1; lst[1]=st;p[st].h=1; while(tou&lt;=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==0 and e[k].c&gt;0) &#123; p[y].h=p[x].h+1; lst[++wei]=y; &#125; &#125; tou++; &#125; return p[ed].h&gt;0;&#125;int dfs(int x,int f)&#123; //printf("---x=%d f=%d\n",x,f); if(x==ed) return f; int t=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(t&lt;f and e[k].c&gt;0 and p[y].h==p[x].h+1) &#123; int fs=dfs(y,mymin(e[k].c,f-t)); t+=fs;e[k].c-=fs;e[e[k].oth].c+=fs; &#125; &#125; if(t==0) p[x].h=0; return t;&#125;int xx[MAXM],yy[MAXM],cc[MAXM];bool check(int mid)&#123; for(int i=st;i&lt;=ed;i++) p[i].hou=0; ln=0; for(int i=1;i&lt;=m;i++) if(cc[i]&lt;=mid) ins(xx[i],yy[i],1); int ans=0; while(bfs()) ans+=dfs(st,INF); return ans&gt;=T;&#125;int main()&#123; int n;scanf("%d%d%d",&amp;n,&amp;m,&amp;T); int l=INF,r=-INF; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;xx[i],&amp;yy[i],&amp;cc[i]); l=mymin(l,cc[i]);r=mymax(r,cc[i]); &#125; st=1,ed=n; int ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3281】Dining]]></title>
    <url>%2Fposts%2F6d11.html</url>
    <content type="text"><![CDATA[来源和评测点USACO 2007 Open GoldPoj3281Caioj1116 题目【题目大意】有F(1≤F≤1000)块不同的肉（编号1~F）和D(1≤D≤1000)罐不同的饮料（编号1~D），N(1≤N≤1000)头（编号1~N）。每头牛有自己喜欢的肉和饮料。每块肉和每罐饮料只能供给一头牛使用。求最多能满足多少头牛能同时享用到自己喜欢的肉和饮料。（注意某头牛得到满足，不要求享用自己所有喜欢的肉和饮料，只要喜欢的肉的其中一块和自己喜欢的饮料其中一罐就可以算满足）【输入格式】第一行：三个整数N,F,D接下来N行。每行描述一头牛。每行开头两个整数Fi和Di，Fi表示该牛喜欢的肉的数目，Di表示它喜欢的饮料的数目。接下来Fi个数，各表示它喜欢的肉的编号，再来Di个数，表示它喜欢的饮料的编号。（注意Fi和Di有可能为0）【输出格式】一个整数，最大满足的牛的数目【输入样例】4 3 32 2 1 2 3 12 2 2 3 1 22 2 1 3 1 22 1 1 3 3【输出样例】3 分析网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他网络流题目参见：Tag-网络流 类似模板题终极起点连接肉肉连接牛牛连接饮料饮料连接终极终点 但还要拆点，为了让一头牛只能选一种，把一头牛分成两个，自己连自己 所有边权都是1，这样的最大流就是方案数 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; const int MAXN=5000,MAXM=1000000;struct pt&#123; int h; int hou;&#125;p[MAXN];struct edge&#123; int y,c,g; int oth;&#125;e[2*MAXM];int ln;void ins(int x,int y,int c)&#123; e[++ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; e[++ln].y=x;e[ln].c=0; e[ln].g=p[y].hou;p[y].hou=ln; e[ln-1].oth=ln;e[ln].oth=ln-1;&#125;int st,ed;int lst[MAXN];bool bfs()&#123; for(int i=1;i&lt;=ed;i++) p[i].h=0; lst[1]=st;p[st].h=1; int tou=1,wei=1; while(tou&lt;=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==0 and e[k].c&gt;0) &#123; p[y].h=p[x].h+1; lst[++wei]=y; &#125; &#125; tou++; &#125; return p[ed].h&gt;0;&#125;int dfs(int x,int f)&#123; if(x==ed) return f;//debug int t=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[x].h+1==p[y].h and e[k].c&gt;0 and t&lt;f) &#123; int s=dfs(y,mymin(f-t,e[k].c)); t+=s;e[k].c-=s;e[e[k].oth].c+=s; &#125; &#125; if(t==0) p[x].h=0;//debug return t;&#125;/*1~ff+1~f+nf+n+1~f+n+nf+n+n+1~f+n+n+d*/int main()&#123; int n,f,d;scanf("%d%d%d",&amp;n,&amp;f,&amp;d); int cw1=f,cw2=f+n,dk=f+n+n; st=f+n+n+d+1,ed=f+n+n+d+2; ln=0; for(int i=1;i&lt;=n;i++) &#123; int fi,di;scanf("%d%d",&amp;fi,&amp;di); for(int j=1;j&lt;=fi;j++) &#123; int t;scanf("%d",&amp;t); ins(t,cw1+i,1); &#125; for(int j=1;j&lt;=di;j++) &#123; int t;scanf("%d",&amp;t); ins(cw2+i,dk+t,1); &#125; ins(cw1+i,cw2+i,1); &#125; for(int i=1;i&lt;=f;i++) ins(st,i,1); for(int i=1;i&lt;=d;i++) ins(dk+i,ed,1); int ans=0; while(bfs()) ans+=dfs(st,INF); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj1273】网络流模版题Drainage Ditches]]></title>
    <url>%2Fposts%2F9eca.html</url>
    <content type="text"><![CDATA[来源和评测点USACO 1993Poj1273Syzoj11772Hdu1532Caioj1115 题目【题目大意】有N条水渠,及M个池塘给出M条水渠所连接的池塘和所能流过的水量（有向）求水渠1到水渠M中所能流过的水的最大容量 （Caioj上先池塘后水渠）（Hdu上多组数据）【输入格式】第1行:2个整数N(0&lt;=N&lt;=200)和M(2&lt;=M&lt;=200)接下来M行: 每行有三个整数：x,y,c表示一条从点x到点y的有向边，流量为c(0&lt;=c&lt;=10,000,000)【输出格式】输出一个整数，即最大流量。【输入样例1】5 41 2 401 4 202 4 202 3 303 4 10【输出样例1】50 理论上可以卡最短路的数据【输入样例2】4 41 2 102 4 52 3 203 4 10【输出样例2】10 分析网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他网络流题目参见：Tag-网络流 模板题 代码我的代码n是点数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; const int MAXN=210;const int INF=0x3f3f3f3f; struct pt&#123; int h; int hou;&#125;p[MAXN];struct nod&#123; int y,c,g;&#125;e[MAXN*2];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln;&#125; int n;int lst[MAXN];int st,ed;bool bfs()&#123; for(int i=1;i&lt;=n;i++) p[i].h=0; int tou=1,wei=1; lst[1]=st;p[1].h=1; while(tou&lt;=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==0 and e[k].c&gt;0) &#123; p[y].h=p[x].h+1; lst[++wei]=y; &#125; &#125; tou++; &#125; return p[ed].h&gt;0;&#125; int getoth(int k)&#123; return k%2==0?k-1:k+1;&#125; int dfs(int x,int f)&#123; if(x==ed) return f; int t=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==p[x].h+1 and e[k].c&gt;0 and t&lt;f) &#123; int tt=dfs(y,mymin(e[k].c,f-t)); t+=tt;e[k].c-=tt;e[getoth(k)].c+=tt; &#125; &#125; return t;&#125; int main()&#123; int m;scanf("%d%d",&amp;m,&amp;n);ln=0; for(int i=1;i&lt;=m;i++) &#123; int x,y,c; scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);ins(y,x,0);//反向弧 &#125; st=1;ed=n; int ans=0; while(bfs()) ans+=dfs(st,INF); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2017游记]]></title>
    <url>%2Fposts%2Fd1a6.html</url>
    <content type="text"><![CDATA[Zory at NOIP2017 2017.11.10 Friday下午在车上浪（与lhp打农药） 晚上到酒店后去万达广场晚饭在毛家饭店吃，有的人吃不了辣，点得有点多了然后在离开时在电梯处抢拍了众多神犇：接着初三小队逛一逛，买瓶饮料，等我妈送电脑来酒店一个房一个wifi，还算流畅萌萌哒lhp（右）晚上开会也就说说保管好准考证、身份证什么的复习一下同余方程组，caioj和poj一遍AC做了一道单调队列，scy说他押这两个其实还有很虚，晚上十一点睡觉 2017.11.11 Saturday啦啦啦光棍节 上午六点半起床，在酒店吃早餐走十多分钟到二中科学城校区和zzz、zxr同一间电脑室哦好像还有个二中的zjt大佬？之前电脑室听师兄提到过发现忘记带眼镜了特别尴尬，输密码的时候因为看不清借旁边的眼睛死都输错，请监考过来看，原来是一直开着大写ps 赛后才发现是buwangchuxin不忘初心，好密码呀因为输错没心情了或许D1心态不爆炸能做第三题？眼镜这种事…… 第一题 小凯的疑惑大概是数论？因为这些天搞数论搞多了一下想到拓展欧几里德，60分以上好像会超时试着推公式，找规律硬是找不到，感觉这题会比后面两题简单然后就做了一两个小时？可能70分吧 第二题 时间复杂度O(n)模拟吧没多少时间了随便打打然后过了大小样例没有自己出数据，有点虚 第三题 逛公园判0环什么的主要是不会怎么求方案数加上没时间，直接没做 出来以后在升旗台集合，和众大佬讨论第一题正解是O(1) a*b-a-b 有的大佬五分钟想到，无语了我第三题可能是改spfa？听不懂yzh的做法 估分60+60+0=120最坏80，最好180 下午受不了了网络真的不行手机电脑主要用流量了本来想看斜率优化的，很快又去颓废了其实本来没有打游戏的打算的，所以没有带ipad手机玩真的难受，经常借lhp的iphone喉咙特别痛 晚上初三小分队继续万达，吃鸡，因为派了优惠卷开会时因为scy不在，代理人栋老师叫大家过去，五分钟“记住scy说的话”就散了于是在308玩狼人杀到十一点，特别high 2017.11.12 Sunday上午早上起来稍微有点困这次戴好眼镜了密码一遍过 第一题 奶酪N^2建边深搜跑一遍就好过了大小样例，自己也出了几组数据，找回自信100分应该没问题 第二题 宝藏看起来像最小生成树N^4枚举起点跑最小生成树枚举树里面的点和外面的点找最小的加进去样例可以过，但没有出数据或许又可以AC 第三题 列队暴力30分先到手数据范围应该不能开数组，应该有规律找不到以后试图搞20分的部分分就是x=1的情况比如每个位置记录这里的数的编号原位置与这个位置的偏移量然后用差分修改，树状数组维护？反正不会做弃疗了 估分100+100+30=230 出来以后听hz说第二题最小生成树是错的，应该是状压DP有点虚啊现在想来应该打对拍的，检测算法正确性哎自己说的自己却没有做到，其实模拟赛也一直没有这么干 下午车上浪，玩狼人杀回到学校后在竞赛室写退役日记其他人都回家了，就我无家可回喉咙稍微好点了 D2T2 chan老板正好也回来就找他讲讲为什么不能用最小生成树然后就D飞了我：5 51 2 5000002 3 102 4 1003 4 14 5 10000画张图一看，果然错了，安心退役 晚上滚回去文化课了…… 总结一下估分70+50+0+100+30+30=280话说好像scy押的题一个没中以后记得多几种解法，能用对拍检验的不只贪心 出代码以后2017.11.15洛谷自测第一题90，最后一个点TLE第二题幸运地AC了第四题AC第五题幸运地80了，虽然算法是错的第六题列队的暴力分3090+100+0+100+80+30=400 出成绩以后2017.11.21 math complexity park cheese treasure phalanx 65 100 0 100 45 30 treasure那题错误算法果然不稳定，不可寄予希望啊其他就比较贴合我的预估分数了]]></content>
      <categories>
        <category>竞赛历程</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2017训练日记]]></title>
    <url>%2Fposts%2Ff969.html</url>
    <content type="text"><![CDATA[尽管走不了最短路,图仍是连通图 2017.10.22-2017.11.10 2017.10.22及以前统测二前申请停课了一个星期，然后目测统测二太浪了，但值得，嘻嘻不过忘记写日记了，大概是 归并排序、逆序对、分块、最小割转最短路 2017.10.23 Monday搞定了caioj主席树的第二、四题其中第二题带修改，我想到了第二种做法，各有所长吧第四题 分块加速+树状数组预处理+主席树维护区间信息，利用权值树特性找大于或小于自己数字的个数，统计即为逆序对数 2017.10.24 Tuesday上午主席树第五题，求区间种类，大概看了看主席树做法，没什么特别的就懒得打了，听Rose大佬说可以用莫队，之前只学了分块，于是找嘎爷爷学，然后做了道“小Z的袜子”顺便回顾了一下概率，回来看这道题，发现要维护的公式更简单，就水过去了，哪天无聊再用主席树做吧 下午回归USACO，搞定了之前的“分治法-破坏阴谋”，然后做了“堆-锯栅栏”（原来合并果子和石子合并完全不同。。）“堆-奶牛探险”就拖到明天了，虽然下午搞了一半，因为晚上要研究矩阵乘法去了 晚上学习Caioj矩阵乘法的第一二题，复习矩阵的乘法方式，研究结合律与交换律之类 2017.10.25 Wednesday保底：USACO“堆” 上午一直在琢磨“堆-奶牛探险”，想了好几种解法，最后被灏爷爷D了（2^n =&gt; n*m从后往前TLE =&gt; n*n从后往前错误 =&gt; 从前往后错误 =&gt; 半途而废）正解：回头贪心 下午有点心态爆炸，搞了矩阵乘法第三四题（还是这个容易点）感觉这个保底有点遥远 晚上矩阵乘法五六题 2017.10.26 Thursday保底：USACO“堆-赞助学费” 上午依旧被灏爷爷D，勉强完成保底 下午一直研究矩阵乘法话说全竞赛室除了初三都去帮scy搭网站去了，什么ceoi、noi之类 晚上做“堆-奶牛优惠卷”(另一个翻译是牛卷)发现我的贪心是真的菜，膜题解去了 2017.10.27 Friday保底：USACO“堆” 上午嗯给昨天晚上收尾，接下来是USACO“堆-城市地平线” 下午根本没有人用堆做，我也完全想不到可以维护什么，于是用hzwer的做法，通过线段树优化延迟更新最后单点查询（离散化也搞了挺久） 晚上有的人做bzoj月赛，但我感觉后期再打比赛比较好，现在先补补基础什么的简而言之就是做USACO 2017.10.28 Saturday上午学习状态压缩，切了Caioj一到五题 下午打洛谷比赛，第三题好像是LCT，然后就不想做前面了，觉得后面分比较好拿结果模版没打好，随后用三个小时推出，自以为是~ 晚上嗯外面吃饭用手机查无脑爆零 2017.10.29 Sunday上午周末上课 下午然后我成了机房第一个AC了第三题的，发现最后一个点十分玄学，于是找向出题人要数据什么的做了USACO“数值计算-数的幂次” 晚上插头DP入门 2017.10.30 Monday上午上午学校搞事情，回去上文化课浪费一上午 下午做USACO“排序”和“排序2” 晚上学习插头DP（基于连通性状态压缩的动态规划问题） 2017.10.31 Tuesday上午做插头DP第一题，USACO想转战洛谷 下午在洛谷做USACO2920、3184、2960、2212 晚上洛谷2867洛谷好处在于不知道做法概率DP第一、二题 2017.11.1 Wednesday上午洛谷3005洛谷2912 下午树链剖分：Caioj1162、Caioj1163 晚上概率DP第三题 2017.11.2 Thursday保底：3题 上午概率DP第四题洛谷2975再学莫队 下午教别人莫队和分块洛谷3113下周要八连测~可怕了 晚上概率DP完结，但我并不想做 2017.11.3 Friday保底：复习模版 上午复习康托展开、线段树、树形DP 下午发现caioj第四，因为大家都去刷USACO、洛谷、bzoj什么的了，就我这菜逼刷水题复习网络流 晚上都去打比赛、学对拍了……默默复习模版 2017.11.4 Saturday上午Splay、单调队列 下午差分约束2-sat 晚上周末 2017.11.5 Sunday上午周末 下午单调队列 晚上比赛https://oj.hsefz.info/contest/1330+70+28=128图判断-TLE其实可以不用并查集概率DP-TLE好像是前缀和优化主席树-TLE堆优化主席树？ 2017.11.6 Monday上午100+50+30第一题O(n)找山峰或盆地-AC第二题暴力优化-TLE维护1、2的位置，话说ch大佬自带小常数多水了四个点第三题暴力-TLE可以找规律（三角形），出题人栋老师原意灰常复杂，什么方案数奇偶性Lucas优化 下午碌碌无为看看数论 晚上70+20+0=90第一题类似博弈，反正我找规律-WA正解每个点看作一条从x到y的边，跑完美匹配，有则Bob赢第二题我打了表-WA灏哥的暴力几分钟跑完，我死都打不出12膜膜膜，好像是利用分解乘法原理什么的第三题不会-TLE或者WA，为了消除可以在城市打水的影响，将城市放入队列跑BFS，扩张视野范围，边缘之间建边后最小生成树 2017.11.7 Tuesday上午100+0+0=100第一题强联通缩点第二题不会-N^2是最长上升子序列DP（a[i]），nlogn维护最长不下降子序列（sum[i]），前驱后继二分查找，可能覆盖第三题打表 20=&gt;表中找规律DP 50=&gt;高精度100但高精度写不完……改DP输出文件后缀名错 教训：多练码力，多打模版，注意变量初始化，特别是结构体 下午总结今天早上和昨晚的比赛膜完斜率优化看看拓展欧几里得 晚上hzwer的神模拟题做到一半很多人都不做了，太可怕我一开始还以为第三题可做，但其实hhn立刻想到反例2235正解是暴力拿出来，假如超过50个直接可以，否则排序，取相邻尝试50的原理：好像是最坏情况为斐波那契数列并且都不相等，超过50个就超过int 这套题全是神题，都以为是计算几何什么的，结果代码都超级短，思维题，当然我只看懂了第三题 2017.11.8 Wednesday上午30+30+0=60有点爆炸第一题博弈倒推DP，打算赶快去学学博弈，和别人倒推式不一样。。第二题只打了暴力，正解超级简单而且显而易见……分解质因数后统计约数出现个数，大于k就输出……太可怕了第三题贪心就好了，维护每个位置到没确定的开头要多少次交换但有两个细节：一个是longlong，然后直接暴力修改后面会超时两个点，正解是用树状数组维护差分的前缀和（因为每次都是直接修改后面的一大段） 下午总结今天早上和昨晚的比赛 晚上100+30+40=170两小时稳打T1，后两题纯骗分，数据太水 2017.11.9 Thursday上午100+90+100=290信心赛？第一题水题第二题DP，好像没搞好边界第三题DFS序+线段树维护乘积 下午开心到颓废继续数论 晚上0+20+0佛山市选？？！！狗来的就第二题打了个表 2017.11.10 Friday上午最后一天有点慌复习模版网络流、DP 下午踏上退役的征程了 晚上]]></content>
      <categories>
        <category>竞赛历程</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AC自动机】地图匹配]]></title>
    <url>%2Fposts%2F4c6e.html</url>
    <content type="text"><![CDATA[评测点Caioj1465 分析这道题数据的话。。好像直接来自hdu，有谁知道原题请留言然后数据中一个单词只会有一次机会，就不用考虑什么“第一个出现”之类了 从边框开始（尽量不重复）地一遍遍做AC自动机，为了方便求起始点，可以考虑倒着搜索（注意add也要倒着建）为了记录答案，s记录的是“假如是单词的开头，就表示单词编号”。因为是倒着的，c也要转向 【话说这道题应该是没有被覆盖的字符串的】 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//*******************定义*******************struct Trie&#123; int s,c[27],fail; bool b;&#125;a[200010];struct tans&#123; int x,y,c;&#125;ans[200010];//*******************实现*******************void clean(int x)&#123; a[x].s=a[x].fail=a[x].b=0; for(int f=1;f&lt;=26;f++) a[x].c[f]=-1;&#125;char s[2010];int len;int k;void add(int id)&#123; len=strlen(s+1); int x=0; for(int i=len;i&gt;=1;i--) &#123; int f=s[i]-'A'+1; if(a[x].c[f]&lt;0) &#123; a[x].c[f]=++k; clean(k); &#125; x=a[x].c[f]; &#125; a[x].s=id;&#125;int list[50010];void getfail()&#123; int tou=1,wei=2;list[1]=0; while(tou!=wei) &#123; int x=list[tou]; for(int f=1;f&lt;=26;f++) &#123; int son=a[x].c[f]; if(son&lt;0) continue; if(x==0) a[son].fail=0; else &#123; int p=a[x].fail; while(p&gt;0 and a[p].c[f]&lt;0) p=a[p].fail;//类似KMP的思想 a[son].fail=mymax(a[p].c[f],0); //可能没有一个匹配，最后出来的c[i]==-1 &#125; list[wei++]=son;if(wei&gt;50000) wei=1; &#125; tou++;if(tou&gt;50000) tou=1; &#125;&#125;int n,m;bool check(int x,int y)&#123; return x&gt;=1 and y&gt;=1 and x&lt;=n and y&lt;=m;&#125;const int tx[8]=&#123;-1,-1,0,1,1, 1, 0,-1&#125;;const int ty[8]=&#123; 0, 1,1,1,0,-1,-1,-1&#125;;char map[1010][1010];int solve(int x,int y,int c)&#123; int p=0; while(check(x,y)) &#123; int f=map[x][y]-'A'+1; while(p&gt;0 and a[p].c[f]&lt;0) p=a[p].fail; if(a[p].c[f]!=-1) p=a[p].c[f]; int k=p; while(k!=0 and a[k].b==0) &#123; if(a[k].s)//到了结尾 &#123; int o=a[k].s; ans[o].x=x; ans[o].y=y; ans[o].c=(c+4)%8;//因为倒着找，要倒过来 &#125; a[k].b=1;//经过 k=a[k].fail; &#125; x+=tx[c];y+=ty[c]; &#125;&#125;//*******************主函数*******************int main(int argc, char *argv[])&#123; int w;scanf("%d%d%d",&amp;n,&amp;m,&amp;w); for(int i=1;i&lt;=n;i++) scanf("%s",map[i]+1); clean(0);k=0; for(int i=1;i&lt;=w;i++) &#123; scanf("%s",s+1); add(i); &#125; //计算fail getfail(); //从边框开始（尽量不重复） for(int i=1;i&lt;=n;i++) &#123; solve(i,1,1);solve(i,1,2);solve(i,1,3);//左边 solve(i,m,5);solve(i,m,6);solve(i,m,7);//右边 &#125; for(int j=1;j&lt;=m;j++) &#123; solve(1,j,3);solve(1,j,4);solve(1,j,5);//上边 solve(n,j,7);solve(n,j,0);solve(n,j,1);//下边 &#125; for(int i=1;i&lt;=w;i++) printf("%d %d %c\n",ans[i].x-1,ans[i].y-1,ans[i].c+'A');&#125; 另外，如果你更喜欢正着搜索，就要正着add，s也放到结尾，c就不用转向了。给出不同的部分:add函数：12345678910111213141516void add(int id)&#123; ans[id].len=strlen(s+1); int x=0; for(int i=1;i&lt;=ans[id].len;i++) &#123; int f=s[i]-'A'+1; if(a[x].c[f]&lt;0) &#123; a[x].c[f]=++k; clean(k); &#125; x=a[x].c[f]; &#125; a[x].s=id;&#125; solve函数：12345678if(a[k].s)//到了结尾 &#123; int o=a[k].s; ans[o].x=x-(ans[o].len-1)*tx[c]; ans[o].y=y-(ans[o].len-1)*ty[c]; ans[o].c=c; //ans[o].c=(c+4)%8;//因为倒着找，要倒过来 &#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>难度2</tag>
        <tag>精品题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qtree3]]></title>
    <url>%2Fposts%2Fa8dd.html</url>
    <content type="text"><![CDATA[评测点Caioj1432Spoj2789 分析第三题终于修改线段树部分了，并且运用到将新编号转换回去那个yzz数组了。 2018.01.24 UP:其实蛮简单的……各位珍惜这种做较简单的中型数据结构的时光吧…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//*******************线段树*******************struct nod1&#123; int lz,rz,l,r,c; //c=0 没有 否则是第一个编号&#125;e[400010];int qq;int build(int l,int r)&#123; int t=++qq; e[t].l=l;e[t].r=r; e[t].lz=e[t].rz=-1; if(l!=r) &#123; int mid=(l+r)&gt;&gt;1; e[t].lz=build(l,mid); e[t].rz=build(mid+1,r); &#125; return t;&#125;void change(int x,int p)&#123; if(e[x].l==e[x].r) &#123; if(e[x].l!=p) printf("error1\n"); e[x].c=(e[x].c&gt;0)?0:e[x].l; return; &#125; int mid=(e[x].l+e[x].r)&gt;&gt;1; int lc=e[x].lz,rc=e[x].rz; if(p&lt;=mid) change(lc,p); else change(rc,p); e[x].c=(e[lc].c&gt;0)?e[lc].c:e[rc].c; //注意，因为树链的编号在线段树中从上往下 //所以编号越小离根节点越近&#125;int ask(int x,int l,int r)&#123; if(e[x].l==l and e[x].r==r) return e[x].c; int mid=(e[x].l+e[x].r)&gt;&gt;1; int lc=e[x].lz,rc=e[x].rz; if(r&lt;=mid) return ask(lc,l,r); if(l&gt;mid) return ask(rc,l,r); int t=ask(lc,l,mid); if(t&gt;0) return t;//同理 return ask(rc,mid+1,r);&#125;//*******************定义*******************struct nod2&#123; int dep,tot,son,fa,tp; int hou;&#125;a[100010];struct nod3&#123; int y,gg;&#125;b[200010];//*******************实现*******************int pp;void ins(int x,int y)&#123; pp++; b[pp].y=y; b[pp].gg=a[x].hou; a[x].hou=pp;&#125;void dfs1(int x)&#123; a[x].tot=1;a[x].son=0; for(int k=a[x].hou;k;k=b[k].gg) &#123; int y=b[k].y; if(y==a[x].fa) continue; a[y].fa=x; //a[y].dep=a[x].dep+1; dfs1(y); a[x].tot+=a[y].tot; if(a[a[x].son].tot&lt;a[y].tot) a[x].son=y; &#125;&#125;int z,yz[100010],yzz[100010];void dfs2(int x,int tp)&#123; yz[x]=++z;yzz[z]=x; a[x].tp=tp; if(a[x].son) dfs2(a[x].son,tp); for(int k=a[x].hou;k;k=b[k].gg) &#123; int y=b[k].y; if(y!=a[x].fa and y!=a[x].son) dfs2(y,y); &#125;&#125;int solve(int x)&#123; int ans=-1; while(a[x].tp!=1)//更简单的跳法 &#123; int t=ask(1,yz[ a[x].tp ],yz[x]); if(t&gt;0) ans=t;//最近的 x=a[ a[x].tp ].fa; &#125; int t=ask(1,yz[1],yz[x]);if(t&gt;0) ans=t; if(ans&gt;0) return yzz[ans];//记得还原 return -1;&#125;//*******************主函数*******************int main(int argc, char *argv[])&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); //for(int i=1;i&lt;=n;i++) a[i].hou=0; for(int i=1;i&lt;n;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; pp=0;a[1].dep=1;a[1].fa=0;dfs1(1); qq=0;dfs2(1,1); z=0;build(1,n); while(m--) &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); if(a==0) change(1,yz[b]); else printf("%d\n",solve(b)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>Qtree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qtree2]]></title>
    <url>%2Fposts%2F681c.html</url>
    <content type="text"><![CDATA[评测点Caioj1431Spoj913 分析第二题没有修改，所以预处理后通过LCA最近公共祖先求解，相对简单如果不熟LCA可以看看这篇文章：【OI之路】06树-5最近公共祖先求距离：dis[i]=第i个点到根的距离求第k个点：很巧妙地利用了dep即深度来获得节点数量 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879int bin[31];void InitBin(void)&#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1;&#125;//*******************定义*******************int hou[100010],dep[100010];int yy[200010],gg[200010],cc[200010];//*******************实现*******************int ln;void ins(int x,int y,int c)&#123; ln++; yy[ln]=y;gg[ln]=hou[x];cc[ln]=c; hou[x]=ln;&#125;int f[100010][30],dis[100010];void dfs(int x,int fa)&#123; dep[x]=dep[fa]+1;f[x][0]=fa; for(int i=1;bin[i]&lt;=dep[x];i++) f[x][i]=f[f[x][i-1]][i-1]; for(int k=hou[x];k;k=gg[k]) &#123; int y=yy[k]; if(y!=fa) &#123; dis[y]=dis[x]+cc[k]; dfs(y,x); &#125; &#125;&#125;int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=30;i&gt;=0;i--) if(dep[x]-dep[y]&gt;=bin[i]) x=f[x][i]; if(x==y) return x; for(int i=30;i&gt;=0;i--) if(dep[x]&gt;=bin[i] and f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0];&#125;int findk(int x,int k)//找x向上（包括自己）的第k个&#123; for(int i=30;i&gt;=0;i--) if(k&gt;bin[i]) k-=bin[i],x=f[x][i]; return x;&#125;//*******************主函数*******************char ss[10];int main(int argc, char *argv[])&#123; InitBin(); int T;scanf("%d",&amp;T); while(T--) &#123; int n;scanf("%d",&amp;n); memset(hou,0,sizeof(hou));ln=0; for(int i=1;i&lt;n;i++) &#123; int a,b,c;scanf("%d%d%d",&amp;a,&amp;b,&amp;c); ins(a,b,c);ins(b,a,c); &#125; dfs(1,0); while(scanf("%s",ss) and ss[1]!='O') &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); if(ss[1]=='I') printf("%d\n",dis[a]+dis[b]-dis[LCA(a,b)]*2); else &#123; int k,t=LCA(a,b);scanf("%d",&amp;k); int dx=dep[a]-dep[t]+1,dy=dep[b]-dep[t]+1; printf("%d\n",(k&lt;=dx)?findk(a,k):findk( b,dy-(k-dx+1)+1 )); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>难度1</tag>
        <tag>Qtree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qtree1]]></title>
    <url>%2Fposts%2F695c.html</url>
    <content type="text"><![CDATA[评测点Caioj1430Spoj375 分析树链剖分（还没写相关文章，自行理解吧哈哈），但与Caioj1162不同的是由点权变成边权，所以稍微有难度（因为太菜），挺适合作为引子。 其实这一点如果想通了，就不难了：把每条边的权值转移为那条边下面的点的权值，这样刚好剩下根节点没有值。接下来就是赤裸裸的树链剖分了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138//*******************线段树*******************struct nod1&#123; int lz,rz,l,r,mx;&#125;e[400010];int qq;int build(int l,int r)&#123; int t=++qq; e[t].l=l;e[t].r=r; e[t].lz=e[t].rz=-1; if(l!=r) &#123; int mid=(l+r)&gt;&gt;1; e[t].lz=build(l,mid); e[t].rz=build(mid+1,r); &#125; return t;&#125;void change(int x,int p,int z)&#123; if(e[x].l==e[x].r) &#123; if(e[x].l!=p) printf("error1\n"); e[x].mx=z; return; &#125; int mid=(e[x].l+e[x].r)&gt;&gt;1; int lc=e[x].lz,rc=e[x].rz; if(p&lt;=mid) change(lc,p,z); else change(rc,p,z); e[x].mx=mymax(e[lc].mx,e[rc].mx);&#125;int ask(int x,int l,int r)&#123; if(e[x].l==l and e[x].r==r) return e[x].mx; int mid=(e[x].l+e[x].r)&gt;&gt;1; int lc=e[x].lz,rc=e[x].rz; if(r&lt;=mid) return ask(lc,l,r); if(l&gt;mid) return ask(rc,l,r); else return mymax(ask(lc,l,mid),ask(rc,mid+1,r));&#125;//*******************定义*******************struct nod2&#123; int dep,tot,son,fa,tp; int hou;&#125;a[10010];struct nod3&#123; int y,gg;&#125;b[20010];struct nod4&#123; int x,y,c;&#125;c[10010];//*******************实现*******************int pp;void ins(int x,int y)&#123; pp++; b[pp].y=y; b[pp].gg=a[x].hou; a[x].hou=pp;&#125;void dfs1(int x)&#123; a[x].tot=1;a[x].son=0; for(int k=a[x].hou;k;k=b[k].gg) &#123; int y=b[k].y; if(y==a[x].fa) continue; a[y].fa=x; a[y].dep=a[x].dep+1; dfs1(y); a[x].tot+=a[y].tot; if(a[a[x].son].tot&lt;a[y].tot) a[x].son=y; &#125;&#125;int z,yz[10010];//,yzz[10010]void dfs2(int x,int tp)&#123; yz[x]=++z;//yzz[z]=x; a[x].tp=tp; if(a[x].son) dfs2(a[x].son,tp); for(int k=a[x].hou;k;k=b[k].gg) &#123; int y=b[k].y; if(y!=a[x].fa and y!=a[x].son) dfs2(y,y); &#125;&#125;int solve(int x,int y)&#123; int tx=a[x].tp,ty=a[y].tp,ans=0; while(tx!=ty) &#123; tx=a[x].tp;ty=a[y].tp; if(a[tx].dep&lt;a[ty].dep) swap(tx,ty),swap(x,y); ans=mymax(ans,ask(1,yz[tx],yz[x])); x=a[tx].fa;tx=a[x].tp; &#125; if(x==y) return ans; if(a[x].dep&lt;a[y].dep) swap(x,y); return mymax(ans,ask(1,yz[a[y].son],yz[x]));&#125;//*******************主函数*******************char ss[10];int main(int argc, char *argv[])&#123; int T;scanf("%d",&amp;T); while(T--) &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) a[i].hou=0; for(int i=1;i&lt;n;i++) &#123; scanf("%d%d%d",&amp;c[i].x,&amp;c[i].y,&amp;c[i].c); ins(c[i].x,c[i].y);ins(c[i].y,c[i].x); &#125; pp=0;a[1].dep=1;a[1].fa=0;dfs1(1); qq=0;dfs2(1,1); z=0;build(1,n); for(int i=1;i&lt;n;i++) if(a[c[i].x].dep&gt;a[c[i].y].dep) swap(c[i].x,c[i].y); for(int i=1;i&lt;n;i++) change(1,yz[c[i].y],c[i].c); while(scanf("%s",ss) and ss[0]!='D') &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); if(ss[0]=='C') change(1,yz[c[a].y],b); else printf("%d\n",solve(a,b)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>Qtree</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1080】乘电梯]]></title>
    <url>%2Fposts%2F2666.html</url>
    <content type="text"><![CDATA[评测点Caioj1080 题目 【输入】第一行是电梯的数量和大楼层数。然后每行是一个电梯服务的最低层和最高层。最多有200个电梯，大楼不超过10000层。显然问题是有解的。不然你是怎么上去的呢？【输出】最短时间，精确到5位小数。【输入样例】6 154 810 141 57 1113 151 13【输出样例】20.32308 分析题解视频推荐（老师的理念是成功的，令人没有翻录的欲望）http://url.cn/5fzRGrj密码：QM2K9q微云找1080 f[i]表示到达第i层的时间 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;using namespace std;const int INF=0x3f3f3f3f;double mymax(double a,double b)&#123; return a&gt;b?a:b;&#125;double mymin(double a,double b)&#123; return a&gt;b?b:a;&#125;//*******************定义*******************struct nod&#123; double jl; int x,y;&#125;p[210];double f[10010];//*******************实现******************double dd(int s,int k)//电梯编号、楼层&#123; int a=p[s].y-k,b=k-p[s].x;//a是上面的层数 return (a*(a+1)+b*(b+1))/2.0/(a+b+1);&#125;//*******************主函数*******************int main(int argc, char *argv[])&#123; int n,h;scanf("%d%d",&amp;n,&amp;h); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].x,&amp;p[i].y),p[i].jl=INF; for(int i=1;i&lt;h;i++) f[i]=INF; f[h]=0; for(int j=h;j&gt;=1;j--) &#123; for(int i=1;i&lt;=n;i++) if(p[i].x&lt;=j and j&lt;=p[i].y)//第j层在第i个电梯的服务范围内 f[j]=mymin(f[j],p[i].jl+double(p[i].y-j));//计算f[j] for(int i=1;i&lt;=n;i++) if(p[i].x&lt;=j and j&lt;=p[i].y)//第j层在第i个电梯的服务范围内 p[i].jl=mymin(p[i].jl,f[j]-double(p[i].y-j)+dd(i,j)); //保证f[j]最小的前提下，更新p[i].jl &#125; printf("%.5lf",f[1]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度2</tag>
        <tag>精品题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1086】进攻策略]]></title>
    <url>%2Fposts%2F4a23.html</url>
    <content type="text"><![CDATA[评测点Caioj1086 题目【题意】植物大战僵尸这款游戏中，还有一个特别的玩法；玩家操纵僵尸进攻植物。首先，僵尸有m种（每种僵尸都是无限多的），玩家可以选择何时的僵尸来进攻。使用第i种僵尸需要花费wi资源，可以得到pi的攻击效果。在这里，我们认为多个僵尸总的进攻效果就是他们每个攻击效果的代数和。地图共有n行，对于第i行，最左端有若干植物，这些植物需要至少qi的攻击才能被全部消灭。若一行上的植物全部被消灭，我们认为这一行被攻破。由于资源紧张，你只有总量为k 的资源，不一定能够攻破所有行。但僵尸博士希望攻破相邻的t行，并希望t尽量的大。你能帮他算出t的值吗？【输入】第一行三个非负整数：m n k第二行m 个正整数 第i个数表示wi第三行m个正整数 第i个数表示pi第四行n个非负整数 第i个数表示qi【输出】一个正整数t【输入样例】3 11 395 2 113 1 75 3 6 10 3 2 4 200 1 1 1【输出样例】4【提示】样例说明：打掉 10 3 2 4 这相邻的4行，需要的最小代价是16+5+4+7=32，不超过39数据规模：对于70%的数据 n&lt;=1000对于100%的数据 n&lt;=200000，m&lt;=100，k&lt;=1000，所有pi ,qi&lt;=100000000(lzg PS:pi,qi固然大,可k是小于1000的啊!) 分析先DP计算出i的资源能造成总共f[i]的伤害再计算出攻下第i行的资源花费剩下的就简单了 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;using namespace std;const int INF=0x3f3f3f3f;int mymax(int a,int b)&#123; return a&gt;b?a:b;&#125;//*******************定义*******************int w[110],p[110],q[200010];int f[1010],a[200010];//*******************主函数*******************int main()&#123; int n,m,k;scanf("%d%d%d",&amp;m,&amp;n,&amp;k); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;w[i]); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;p[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;q[i]); for(int i=1;i&lt;=m;i++) for(int j=w[i];j&lt;=k;j++) f[j]=mymax(f[j],f[j-w[i]]+p[i]); f[k+1]=INF; int tou=1,ans=0,s=0; for(int i=1;i&lt;=n;i++) &#123; int l=0,r=k,tans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(f[mid]&gt;=q[i]) tans=mid,r=mid-1; else l=mid+1; &#125; a[i]=tans;//攻下这一行的资源花费 s+=a[i]; while(s&gt;k and tou&lt;=i) s-=a[tou],tou++; ans=mymax(ans,i-tou+1); &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度2</tag>
        <tag>精品题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[俄罗斯轮盘]]></title>
    <url>%2Fposts%2Fd3b3.html</url>
    <content type="text"><![CDATA[有人知道来源在评论说一声 题目【背景】游戏需要的器材灰常简单：一支左轮手枪和一颗子弹。通常游戏人数为两人。玩法也灰常简单：把一发子弹填入左轮手枪的弹仓，将枪轮拨转一下，这样就猜不着子弹是否上膛。接着，把枪交给一个玩家，该玩家对准自己的太阳穴扣枪机。规定如果子弹没上膛而打空的话，就换另一个玩家打，再打空就再换第一个玩家打，直到打中为止。【问题描述】小I和小强是一对灰常要好的朋友，他们经常在一起玩俄罗斯轮盘。可是有一天小I有事不能陪小强玩，这令小强很郁闷，于是他决定自己一个人玩。小强拿了一支有N个弹仓的左轮手枪，随机填入了M发子弹，然后对准自己的太阳穴连续打了K枪。他这样玩了几次之后，突然想知道打不中的概率是多少。你能帮他算算吗？ 【输入格式】输入三个整数：N,M,K(1&lt;=N&lt;=1000,1&lt;=M&lt;=N,1&lt;=K&lt;=1000)。【输出格式】输出N个弹仓的左轮手枪，随机填入M发子弹，对准自己的太阳穴打K枪都打不中的概率，保留六位小数。【输入样例1】62 2【输出样例1】0.400000【输入样例2】153 7【输出样例2】0.123077 分析1234等价于M个球放入N个箱子，前K个箱子没有球的概率P=C(N-K,M)/C(N,M)c(n,m)= p(n,m)/m! = n! / ( (n-m)!*m! )[ (N-K)!/( (N-K-M)!*M! ) ] / [ N!/(N-M)!/M! ] 代码12345678910int n,m,k;scanf("%d%d%d",&amp;n,&amp;m,&amp;k);if(n==m or n&lt;m+k) printf("%.6lf",1);else&#123; double s=1; for(int i=0;i&lt;=m-1;i++) s=s*(n-i-k)/(n-i); printf("%.6lf",s);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1159最长公共子序列LCS]]></title>
    <url>%2Fposts%2Fddc4.html</url>
    <content type="text"><![CDATA[评测点HDU1159 题目【题意】求两个字符串最长公共子序列的长度,最长公共子序列强调位置的前后关系不变，但不在乎是否连续,不唯一【输入样例】abbccdss aeebfcaadb【输出样例】4 某解释 代码1234567891011121314char s[1010],s1[1010];int f[1010][1010];int main(int argc, char *argv[])&#123; scanf("%s %s",s+1,s1+1); int l1=strlen(s+1),l2=strlen(s1+1); for(int i=1;i&lt;=l1;i++) for(int j=1;j&lt;=l2;j++) &#123; if(s[i]==s1[j]) f[i][j]=f[i-1][j-1]+1; else f[i][j]=mymax(f[i-1][j],f[i][j-1]); &#125; printf("%d",f[l1][l2]);&#125; 分析：a=abcb=1abcn=3m=4i=2 4//字符串2的位置j=2 3//字符串1的位置s=0 0 0 01 1 1 10 2 2 20 0 3 3]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2528市长的海报Posters]]></title>
    <url>%2Fposts%2F96fc.html</url>
    <content type="text"><![CDATA[来历POJ2528 题目【题意】n（n&lt;=10000)个人依次贴海报,给出每张海报所贴的范围li，ri（1&lt;=li&lt;=ri&lt;=10000000)。求出最后还能看见多少张海报。（注意：没多组数据）【输入样例】51 42 68 103 47 10【输出样例】4 分析关于离散化，可以参考这里 推荐一个好的算法，但我没有这么做：如果更新次数太多的话，可以考虑从后往前更新即如果更新时发现之前已经有一张海报完全覆盖他了就可以不用更新（因为没有必要）这样的算法时间会减少很多 代码不完整，通用部分可以参考这里1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071struct DisNod&#123; int x,p,z;&#125;a[20010],b[20010];void Discretization(int n)//离散化&#123; for(int i=1;i&lt;=n;i+=2) &#123; scanf("%d %d",&amp;a[i].x,&amp;a[i+1].x);a[i+1].x++; a[i].p=i;a[i+1].p=i+1; b[i]=a[i];b[i+1]=a[i+1]; //拷贝 &#125; sort2(1,n);//排序 b[1].z=1; for(int i=2;i&lt;=n;i++) &#123; if(b[i].x==b[i-1].x) b[i].z=b[i-1].z; else b[i].z=b[i-1].z+1; a[b[i].p].z=b[i].z; &#125;&#125;struct Manager&#123; int l,r,tl,tr,c; bool lazy;&#125;f[40010];void update(int x)&#123; f[x].lazy=false; if(f[x].tl&gt;0 and f[x].tr&gt;0) &#123; int tl=f[x].tl,tr=f[x].tr; f[tl].lazy=f[tr].lazy=true; f[tl].c=f[tr].c=f[x].c; &#125;&#125;void change(int now,int l,int r,int c)&#123; if(l==f[now].l and r==f[now].r) &#123; f[now].c=c; f[now].lazy=true; return; &#125; if(f[now].lazy) update(now); ……&#125;int num=0;int build(int l,int r)&#123; …… f[x].lazy=false; ……&#125;char ch[5];bool v[20010]=&#123;0&#125;;int main()&#123; scanf("%d",&amp;n);n*=2; Discretization(n); build(1,b[n].z); for(int i=1;i&lt;=n;i+=2) change(1,a[i].z,a[i+1].z,i); int s=0; for(int i=1;i&lt;=num;i++) &#123; if(f[i].lazy) update(i); if(!f[i].tl and !v[f[i].c]) v[f[i].c]=1,s++; &#125; printf("%d",s);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[糖果自动管理系统]]></title>
    <url>%2Fposts%2F739e.html</url>
    <content type="text"><![CDATA[来历建议这里备用 题目【题意】糖果自动管理系统能管理N堆糖果。初始时，所有堆糖果数目为0。（1）I a b c(1≤a≤b≤N,0 &lt; c≤100)，ACM将在堆a至堆b之间（包含a和b）每堆糖果加c个。（2）C a b(1≤a≤b≤N)，将会选择a到b堆之间糖果数最多的清空。选择编号小的。给出一系列的操作，对于每个C操作，输出堆的糖果数。【输入】第一行为两个整数N，M（0&lt; N，M≤10^5），N表示糖果堆的数目，M表示操作的次数。【输出】对于每个C操作，输出小朋友能得到的糖果的数目。【输入样例】5 4I 1 5 1C 2 3I 2 2 4C 2 3【输出样例】14 代码不完整，通用部分可以参考这里12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576void update(int x)&#123; f[f[x].tl].c+=f[x].lazy; f[f[x].tr].c+=f[x].lazy; f[f[x].tl].lazy+=f[x].lazy; f[f[x].tr].lazy+=f[x].lazy; f[x].lazy=0;&#125;void make(int x,int l,int r,int k)&#123; if(f[x].l==l and r==f[x].r) &#123; f[x].c+=k; f[x].lazy+=k; return; &#125; …… if(r&lt;=mid) make(fl,l,r,k); else if(l&gt;mid) make(fr,l,r,k); else &#123; make(fl,l,mid,k); make(fr,mid+1,r,k); &#125; if(f[fl].c&gt;=f[fr].c) &#123; f[x].mc=f[fl].mc; f[x].c=f[fl].c; &#125; else &#123; f[x].mc=f[fr].mc; f[x].c=f[fr].c; &#125;&#125;int fc,fmc;void qesc(int x,int l,int r)&#123; if(f[x].l==l and f[x].r==r) &#123; fc=f[x].c; fmc=f[x].mc; return; &#125; if(r&lt;=mid) qesc(fl,l,r); else if(l&gt;mid) qesc(fr,l,r); else &#123; qesc(fl,l,mid); int ac=fc,amc=fmc; qesc(fr,mid+1,r); if(ac&gt;=fc) &#123; fc=ac; fmc=amc; &#125; &#125;&#125;int main()&#123; num=0;br(1,n); for(int i=1;i&lt;=m;i++) &#123; scanf("%s%d%d",ch,&amp;a,&amp;b); if(ch[0]=='C') &#123; qesc(1,a,b); printf("%d\n",fc); make(1,fmc,fmc,-fc); &#125; else &#123; scanf("%d",&amp;d);make(1,a,b,d); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016魔法阵]]></title>
    <url>%2Fposts%2F141d.html</url>
    <content type="text"><![CDATA[评测点和题目洛谷2119 分析遇到这种有条件的题，通常把图形画出来比较直观。 如图所示，若把d点确定，设c-d距离为i，则a,b的距离就是2i，则b,c的距离&gt;2×(a-b)也就是&gt;6i，总距离大于9i，那么我们的外层循环就枚举i，再枚举d的位置，d的方案数就等于(前面所有a的方案)×(前面所有b的方案)×(当前c的方案数)，c的方案数=(前面所有a的方案)×(前面所有b的方案)×(当前d的方案数)，同理，枚举a的位置，也可以得到a与b的方案数。 什么意思呢？这可能有点绕。 我们将d不断往后枚举，而在现在的a之前所扫过的ab都符合条件，故而累加在一个变量中，a亦复如是。 注意，同样魔法值的物品，作为abcd物品的次数其实是一样的。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int rn(void)&#123; char c=getchar();int s=0; while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') &#123; s=s*10+c-'0'; c=getchar(); &#125; return s;&#125;struct nod1&#123; int w,a,b,c,d; nod1() &#123;w=a=b=c=d=0;&#125;&#125;f[15010];int h[40010];//第i个物品的魔法值需要保留，输出时要用到int main()&#123; int n,m; n=rn();m=rn(); for(int i=1;i&lt;=m;i++) &#123; h[i]=rn(); f[h[i]].w++;//表示这个值的数增加了一个 &#125; //[d&gt;9*i&lt;=n]==&gt;[9*i&lt;n],边界一定要考虑无误 for(int i=1;9*i&lt;n;i++)//cd &#123; int ab=2*i,bd=7*i+1; int ad=ab+bd;//9*i+1 int ac=ad-i; int s=0;//累加和 for(int j=n-ad;j&gt;=1;j--)//j-&gt;a //注意循环不能顺序，因为s的累加和会改变,a[j]会加上后面的c,d //而不是前面的 &#123; s+=f[j+ac].w*f[j+ad].w;//c*d元素的个数 f[j].a+=s*f[j+ab].w;//b*[c*d]==a(乘在一起，就是可能量) f[j+ab].b+=s*f[j].w;//a*[c*d]==b &#125; s=0; for(int j=ad+1;j&lt;=n;j++)//j-&gt;d &#123; s+=f[j-ad].w*f[j-bd].w;//a*b元素的个数 f[j-i].c+=s*f[j].w;//d*[a*b]==c f[j].d+=s*f[j-i].w;//c*[a*b]==d &#125; //上下两循环可以调换顺序，因为a,b,c,d只与i和w有关 //和a[],b[],c[],d[]无关 &#125; for(int i=1;i&lt;=m;i++) printf("%d %d %d %d\n",f[h[i]].a,f[h[i]].b,f[h[i]].c,f[h[i]].d);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016海港]]></title>
    <url>%2Fposts%2Fafb6.html</url>
    <content type="text"><![CDATA[评测点和题目洛谷2058 分析这道题主要收获是将总量不大的数组降维储存，从而大大减少空间 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445int rn(void)//正整数输入&#123; char c=getchar();int s=0; while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') &#123; s=s*10+c-'0'; c=getchar(); &#125; return s;&#125;int t[100010],k[100010],q[500010],w[500010];//t:每艘船时间 k:每艘船第一个人(类似指针)//q:每个国家人数 w:每人国家int main(int argc,char *argv[])&#123; int n=rn(); int tou=1;//当前状态指针 int ans=0;//当前状态答案 k[1]=1; for(int i=1;i&lt;=n;i++) &#123; t[i]=rn();int rs=rn(); k[i+1]=k[i]+rs; for(int j=0;j&lt;rs;j++) &#123; int p=rn(); w[j+k[i]]=p; if(q[p]==0) ans++;//如果此国家原来没人，ans+1 q[p]++;//输入每个人，并在他的国家处+1 &#125; while(t[tou]+86400&lt;=t[i]) //如果第tou艘船不符合条件，就去掉 &#123; for(int j=k[tou];j&lt;k[tou+1];j++)//枚举每一个人 &#123; q[w[j]]--; if(q[w[j]]==0) ans--; //要是此国家去掉这个人就没了，答案减一 &#125; tou++; &#125; printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016总结]]></title>
    <url>%2Fposts%2Fda68.html</url>
    <content type="text"><![CDATA[NOIP2016总结 2016.11.18【考前篇】明天早9点，我将与学校众多大神们一起去广州，进军NOIP2016普及组。内心还是很忐忑的（呵呵，正是心上下跳动），如能暴力骗分已是极好。 第一次参加比赛，其实初赛能过已经是出乎意料，当然，今年题目水也是原因之一。本来，我们全员要停课一周的，初一的年级主任同意了，初三的也同意了，就只有我们初二的蒋芳周红差点没同意，周二时竟然还要求仅能有十几人停课，其他的只能中午和晚修来，大大扰乱了兴致。【嗯嗯，如果她们真的敢来捉人，就跟她们火拼嘛！】 这周足足进行了五次模拟考试，每一次都有它的特色。题解（怒插广告）：俄罗斯轮盘约瑟夫问题终极装备密室逃脱智捅马蜂窝最后的战犯 这周总体的收获还是极大的，巩固了许多知识，还学习了很多技巧，最重要的是能和大家一起开心地打游戏、一起努力，更是体验了停课的酸爽，故即使这次比赛成绩不好，我亦无悔。 提高组的今天下午三点就已经出发了，加油！ 2016.11.19【Day1】广州一日游结束了，这绝对是一次宝贵的经历。 九点半从一中出发，伴随着大巴上的【第一次用流量玩王者】【互祝爆零】，十一点到了在六中附近的一家中餐厅吃饭（我也不知道为什么会和纪念中学那位差不多），多贵倒是不知道，反正每人交张红色毛爷爷，有多的回去统计后再归还。味道还不算太坏，吃完后一起去六中拍了几张合照，大概是一点钟左右。反正还有时间，和几个朋友出去浪，买了杯贡茶【抹茶奶盖绿茶】，顺便无聊地在手机上看模板。。 到了两点，就上了四楼，找到自己的位置，花半小时搞定了电脑的一切配置。两点半正式开始，密码很长而复杂，呵呵。花十分钟看完了题目。这次竟然没有我擅长的图论，全是模拟、暴力和剪枝什么的，一二题水题，大约一个半小时搞定。在三四题中选了第四题，纯粹排序+暴力，有想过去重，但不知道怎么还原，只好放弃（其实现在也不知道），顶多优化一下常数和公式，不知道能不能拿一半分，最后半小时选择了检查一二四题而第三题只打一个骗分。【好像第三题记录一下最后值就好了，不难，但当时硬是想不到】比赛结束，还是在那家餐厅吃饭，又去买了杯贡茶【金色年华】，回来看到大家都在高举手机，甚是怪异————原来在争信号抢红包。然鹅那个微信群我却硬是没加，听说错过了HY的一个大红包。 归途中继续开嘿，九点回到中山市第一少年看守所。。。 2016.12.1初评成绩公布篇成绩出来了，200分，也还好吧:100,100,0,0,呵呵。 照片：初一:初二:提高组:普及组:hz与akc【镇楼！】: 两个题解：海港魔法阵]]></content>
      <categories>
        <category>竞赛历程</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[星球大战]]></title>
    <url>%2Fposts%2F4cfd.html</url>
    <content type="text"><![CDATA[来源bzoj1015JSOI2008 分析：有一个同学做了PPT，里面的数据演示做得不错，详细做法建议看代码，更清晰下载链接 题目【问题描述】很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治者整个星系。某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通快的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。【问题大意】给你一些点和边，有K次毁灭，每次删掉一条边，输出没毁灭时的连通数以及每次操作后剩余的联通数量【输入格式】第一行包含两个整数，N(1&lt;=N&lt;=2M)和M(1&lt;=M&lt;= 200,000)，分别表示星球的数目和以太隧道的数目。星球用0~N-1的整数编号。接下来的M行，每行包括两个整数X, Y，其中（0&lt;=X&lt;&gt;Y【输出格式】输出文件的第一行是开始时星球的连通块个数。接下来的N行，每行一个整数，表示经过该次打击后现存星球的连通块个数。【输入样例】8 130 11 66 55 00 61 22 33 44 57 17 27 63 65 1 6 3 5 7【输出样例】1 1 1 2 3 3 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899struct nod1&#123; int hou;//最小儿子 int fa;//父亲 bool b;//是否会被炸毁 bool v;//是否存在 nod1() &#123; hou=0;b=false;v=false; &#125;&#125;point[400010];struct nod2&#123; int x; int g;//哥哥&#125;road[400010];/*注意：因为是双向路，所以要开200000*2*/void bulid(int,int);int findfa(int);int add(int);int f[400001];//这些点将被攻击int ans[400001];//答案记录//两个序列↑int roadnum;int sum;//联通块int main(int argc, char *argv[])&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) point[i].fa=i;//初始化每个点的父亲为自己 roadnum=0; for(int i=1;i&lt;=m;i++) &#123; int x,y; cin&gt;&gt;x&gt;&gt;y; bulid(x,y); bulid(y,x);//建边 &#125; int k; cin&gt;&gt;k; for(int i=1;i&lt;=k;i++) &#123; cin&gt;&gt;f[i]; point[f[i]].b=true;//如果不会被炸毁的先标记下来下边可以用上 &#125; //倒推大法↓ sum=0; for(int i=0;i&lt;n;i++)//是0到n-1 &#123; if(point[i].b==false)//没被炸毁的先建边 &#123; sum++; add(i); point[i].v=true;//建了边代表存在的 &#125; &#125; ans[k+1]=sum;//k+1代表最后炸毁的状态 for(int i=k;i&gt;0;i--)//模拟，一个一个把点加上去 &#123; sum++; add(f[i]);//加点 point[f[i]].v=true;//这条边存在 ans[i]=sum;//记录值 &#125; for(int i=1;i&lt;=k+1;i++) printf("%d\n",ans[i]);&#125;int add(int n)&#123; int xf=findfa(n); for(int k=point[n].hou;k&gt;0;k=road[k].g)//这个点应该加在哪里 &#123; int x=road[k].x; if(point[x].v==true)//存在 &#123; int yf=findfa(x); if(xf!=yf) &#123; point[yf].fa=n; sum--;//如果祖先不一样的话，统一祖先，联通块-1 &#125; &#125; &#125;&#125;void bulid(int x,int y)&#123; roadnum++; road[roadnum].x=y; road[roadnum].g=point[x].hou; point[x].hou=roadnum;&#125;int findfa(int x)&#123; if(x!=point[x].fa) point[x].fa=findfa(point[x].fa) return point[x].fa;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>难度1</tag>
        <tag>宽度优先搜索BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codevs1082线段树练习3]]></title>
    <url>%2Fposts%2F9bea.html</url>
    <content type="text"><![CDATA[Codevs1082线段树练习3 评测Codevs1082 题目【问题大意】给你N个数，有两种操作：1：给区间[a,b]的所有数增加X2：询问区间[a,b]的数的和。【输入】第一行一个正整数n，接下来n行n个整数，再接下来一个正整数Q，每行表示操作的个数，如果第一个数是1，后接3个正整数，表示在区间[a,b]内每个数增加X,如果是2，表示操作2询问区间[a,b]的和是多少。pascal选手请不要使用readln读入【输出】对于每个询问输出一行一个答案【样例输入】312321 2 3 22 2 3【样例输出】9【数据范围】(其实这个贴出来没什么用)1&lt;=n&lt;=2000001&lt;=q&lt;=200000 分析用线段树做自然是灰常简单的假如你想学习如何用树状数组实现可以参考这篇文章 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394typedef long long lld; using namespace std; struct Segment &#123; int l,r; int s1,s2; lld c; lld lazy; &#125;a[400001]; int num=0; void build(int l,int r) &#123; num++; int t=num;// a[t].c=0; a[t].l=l; a[t].r=r; a[t].lazy=0; if(l==r) &#123; a[t].s1=-1; a[t].s2=-1; return; &#125; int mid=(l+r)/2; a[t].s1=num+1;build(l,mid); a[t].s2=num+1;build(mid+1,r); &#125; void make(int x,int l,int r,int k) &#123; a[x].c=a[x].c+k*(r-l+1); if(a[x].l==l and a[x].r==r) &#123; a[x].lazy+=k; return; &#125; int mid=(a[x].r+a[x].l)/2; if(r&lt;=mid) make(a[x].s1,l,r,k); else if(l&gt;mid) make(a[x].s2,l,r,k); else &#123; make(a[x].s1,l,mid,k); make(a[x].s2,mid+1,r,k); &#125; &#125; lld qes(int x,int l,int r) &#123; if(a[x].l==l and a[x].r==r) return a[x].c; int mid=(a[x].r+a[x].l)/2; int s1=a[x].s1,s2=a[x].s2; if(a[x].lazy!=0) &#123; a[s1].c=a[s1].c+a[x].lazy*(a[s1].r-a[s1].l+1); a[s2].c=a[s2].c+a[x].lazy*(a[s2].r-a[s2].l+1); a[s1].lazy+=a[x].lazy; a[s2].lazy+=a[x].lazy; a[x].lazy=0; &#125; if(r&lt;=mid) return qes(a[x].s1,l,r); else if(l&gt;mid) return qes(a[x].s2,l,r); else return qes(a[x].s1,l,mid)+qes(a[x].s2,mid+1,r); &#125; int main(int argc, char *argv[]) &#123; int n,m; cin&gt;&gt;n; build(1,n); for(int i=1;i&lt;=n;i++) &#123; int a; scanf("%d",&amp;a); make(1,i,i,a); &#125; cin&gt;&gt;m; for(int i=1;i&lt;=m;i++) &#123; int x,a,b,c; scanf("%d %d %d",&amp;x,&amp;a,&amp;b); if(x==1) &#123; scanf("%d",&amp;c); if(a&gt;b) make(1,b,a,c); else make(1,a,b,c); &#125; else &#123; if(a&gt;b) printf("%lld\n",qes(1,b,a)); else printf("%lld\n",qes(1,a,b)); &#125; &#125; &#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魏总数星星]]></title>
    <url>%2Fposts%2F4672.html</url>
    <content type="text"><![CDATA[声明好像是别人的原创题，感觉不错：来源另外，学习并查集可以参考这个：生动的故事，透彻的分析我的并查集总结 题目【问题大意】魏总，也就是DP魏，灰常喜欢星星，有一天他躺在草坪上数星星。天上共有i颗星星，魏总把天空分成了K个扇形，绕着天空的中心——月亮排布。月亮看见魏总喜欢星星，灰常不爽，她就想考一下魏总。月亮给出n队星星的相互关系，形如a b p表示b星星在a星星所在扇形区域的顺时针方向第p个扇形内（0&lt;=p&lt;=k）（p==0时表示在同一个扇形内）。最后月亮要询问m次，形如a b表示询问a b两星是否在一个扇形内，是则输出“Yes”，不是则输出“No”，不知道则输出“Unknown”。由于月亮看魏总喜欢星星变得心情急躁，可能有一些关系与前面的关系矛盾，则这些关系无效。月亮说如果不能把她的所有询问答对就要发出强光，让魏总看不到星星，而本来是大神的魏总因为想见到星星不能编程，只有把这个艰巨的任务交给你了。【输入格式】第一行四个整数i，k，n，m表示i颗星星，k个扇形，n个关系，m次询问。接下来n行，每行三个整数a b p 表示表示b星星在a星星所在扇形区域的顺时针方向第p个扇形内。接下来m行，每行两个整数a b表示询问a，b是否在同一个扇形内。【输出格式】共m行，每行为“Yes”或“No”或“Unknown”对应每一个询问【输入样例】5 5 3 31 2 12 4 24 5 21 23 41 5【输出样例】NoUnknownYes【数据范围】20%，魏总数不超过100个星星，月亮询问不超过100次，天空被分成不超过10个区域。50%，魏总数不超过4000个星星，月亮询问不超过4000次，天空被分成不超过1000个区域。100%，魏总数不超过100000个星星，月亮询问不超过100000次，天空被分成不超过10000个区域，关系数少于200000。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct star&#123; int fa,len; star() &#123; fa=len=0; &#125;;&#125;st[100010];int mod;int findfa(int now)&#123; if(st[now].fa==now) return now; int f=findfa(st[now].fa); st[now].len=(st[now].len+st[st[now].fa].len)%mod; if (st[now].len==0) st[now].len=mod; st[now].father=f; return f;&#125;void join(int a,int b,int l)&#123; int af=findfa(a),bf=findfa(b); int len=(st[a].len+l)%mod; st[bf].fa=a; if (l&gt;=st[b].len) st[bf].len=l-st[b].len; else st[bf].len=mod+l-st[b].len;&#125;int main()&#123; int n,m,k; cin&gt;&gt;n&gt;&gt;mod&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;=n;i++) st[i].fa=i; for(int i=1;i&lt;=m;i++) &#123; int a,b,p; cin&gt;&gt;a&gt;&gt;b&gt;&gt;p; if(findfa(a)!=findfa(b)) join(a,b,p); &#125; for(int i=1;i&lt;=k;i++) &#123; int a,b; scanf("%d%d",&amp;a,&amp;b); if (findfa(a)!=findfa(b)) printf("Unknown\n"); else &#123; if (st[a].len%mod==st[b].len%mod) printf("Yes\n"); else printf("No\n"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[智捅马蜂窝]]></title>
    <url>%2Fposts%2F76b3.html</url>
    <content type="text"><![CDATA[评测rqnoj86 题目【问题大意】给出一个 N 个节点的无向图，每个节点用坐标（Xi，Yi）来表示，平平要从第1个点爬到第N个点。如果出现两线相交的情况，我们不认为它们是相通的。除了从一个节点爬向另一个相邻的节点以外，他还有一种移动方法，就是从一个节点跳下，到达正下方的某个节点（之间可隔着若干个点和边），下落所用时间满足自由落体公式t=sqrt((Yj-Yi)×2/g) （g取10）。【输入格式】两个整数N,V，N表示节点个数，V表示平平爬树的速度。接下来N行，每行包含3个整数X,Y,F，X,Y是这个点的坐标，F是他的父节点（F一定小于这个点的标号，第一行的F为0）。（1&lt;=N&lt;=100,1&lt;=V&lt;=10,0&lt;=X,Y&lt;=100）【输出格式】输出仅包括一行，从1到N所用的最少所需时间T，保留两位小数。【输入样例】9 15 0 05 5 16 5 27 6 26 9 23 6 24 5 23 2 77 2 3【输出样例】8.13 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879void build(int,int,double);double calc(int,int);struct point&#123; double ans; int hou,x,y; bool v;&#125;a[110];struct road&#123; int x,y,g; double c;&#125;b[310];int n,v,k=0,l[110];int main()&#123; scanf("%d %d",&amp;n,&amp;v); for(int i=1;i&lt;=n;i++) &#123; int x,y,f; scanf("%d %d %d",&amp;x,&amp;y,&amp;f); a[i].x=x;a[i].y=y;a[i].hou=0; a[i].ans=999999;a[i].v=false; double c=calc(f,i)/v; build(i,f,c);build(f,i,c); &#125; for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) if(a[i].x==a[j].x) //能垂直下落就建边 &#123; double c=sqrt(abs(a[i].y-a[j].y)/5.0);//不是5 if(a[i].y&gt;a[j].y) build(i,j,c); else build(j,i,c); &#125; l[1]=1; a[1].v=true; a[1].ans=0; int tou=1,wei=2; while(tou!=wei) &#123; int x=l[tou]; for(int i=a[x].hou;i&gt;0;i=b[i].g) &#123; int y=b[i].y; if(a[y].ans&gt;a[x].ans+b[i].c) &#123; a[y].ans=a[x].ans+b[i].c; if(a[y].v==false) &#123; a[y].v=true; l[wei]=y; wei++; if(wei==n+1) wei=1; &#125; &#125; &#125; a[x].v=false; tou++; if(tou==n+1) tou=1; &#125; printf("%.2lf",a[n].ans);&#125;void build(int x,int y,double t)&#123; k++; b[k].x=x;b[k].y=y;b[k].c=t; b[k].g=a[x].hou;a[x].hou=k;&#125;double calc(int x,int y)&#123; double q=a[x].x-a[y].x,w=a[x].y-a[y].y; return sqrt(q*q+w*w);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>SPFA</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最后的战犯]]></title>
    <url>%2Fposts%2F47fc.html</url>
    <content type="text"><![CDATA[题目【问题描述】Feli来到岩洞入口，发现岩洞其实是一个巨大的迷宫。迷宫地形极为复杂，为一个正方形，其中布满了障碍物。迷宫可以分为N乘N（2≤N≤100）个区域，每个区域或者是空地，或者是不可逾越的障碍物。小犬就躲藏在其中某一个区域内。由于小犬已经忍受了几天的饥饿，Feli进入迷宫时他已经失去思维处于迷乱状态。小犬每秒钟只会沿着他的方向直线前进，如果遇到障碍物或者迷宫边界，他会立刻向右转90度（不会花去时间），继续沿直线前进（初始方向向北）。Feli每秒钟可以自主决定往哪个方向走。如果同一时刻Feli与小犬位于同一个区域，或者相邻的区域（非对角线相邻），Feli可以立刻将小犬抓住。Feli本来打算先确定小犬的位置，然后沿最短路线抓住他，但是Feli前进时小犬同时也在移动，就不能采取这种方法了。请你帮助Feli确定一种方案，使Feli抓获小犬所用的时间最短。【输入格式】输入数据第一行是一个整数N。以下N行每行N个字符，星号表示岩洞中的障碍物，“.”表示空地，“J”表示小犬（一开始他会向北走），“F”表示Feli。上北下南左西右东。【输出格式】输出数据仅一行，如果Feli能抓到小犬，那么输出所需的最短时间，如果Feli抓不到小犬，那么这个最后的日本战犯将在岩洞中饿死（因为Feli将在离开的时候封闭岩洞的所有出口），此时输出“No solution.”，不要输出引号。1234567【输入样例】3F*J.*....【输出样例】3 声明找不到来源，保留原题目对不起啦贴着代码先 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586struct pointnode&#123;int x,y,f;&#125;;bool m[110][110],v[110][110];int stx,sty,edx,edy,n,jat=0;int tx[4]=&#123;-1,0,1,0&#125;,ty[4]=&#123;0,1,0,-1&#125;;pointnode q[10010];bool qs(void)//直接被困住&#123; for(int i=0;i&lt;=3;i++) if(m[edx+tx[i]][edy+ty[i]]) return false; return true;&#125;bool check(int x,int y)&#123; if((x==edx and abs(y-edy)&lt;=1)or(y==edy and abs(x-edx)&lt;=1)) return true; return false;&#125;void solve()//走一步&#123; while(1) &#123; int txx=edx+tx[jat],tyy=edy+ty[jat]; if(m[txx][tyy]) &#123; edx=txx; edy=tyy; return; &#125; jat++; jat%=4; &#125;&#125;void bfs(void)&#123; memset(v,0,sizeof(v)); int tou=1,wei=2; q[1].x=stx;q[1].y=sty;q[1].f=0; q[0].f=-1; v[stx][sty]=true; while(tou!=wei) &#123; int nowx=q[tou].x,nowy=q[tou].y; if(q[tou].f&gt;q[tou-1].f) solve(); //进入新的一层 for(int i=0;i&lt;=3;i++) &#123; int fx=nowx+tx[i],fy=nowy+ty[i]; if(m[fx][fy] and !v[fx][fy]) &#123; v[fx][fy]=true; q[wei].x=fx;q[wei].y=fy; q[wei].f=q[tou].f+1; if(check(fx,fy)) &#123; printf("%d",q[wei].f); return; &#125; wei++; &#125; &#125; tou++; &#125; printf("No solution.");&#125;int main()&#123; memset(m,0,sizeof(m)); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; char s[110];scanf("%s",s+1); for(int j=1;j&lt;=n;j++) &#123; m[i][j]=(s[j]!='*'); if(s[j]=='J') &#123;edx=i;edy=j;&#125; if(s[j]=='F') &#123;stx=i;sty=j;&#125; &#125; &#125; if(qs()) printf("No solution."); else if(check(stx,sty)) printf("0"); else bfs();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>宽度优先搜索BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密室逃脱]]></title>
    <url>%2Fposts%2F5ade.html</url>
    <content type="text"><![CDATA[题目来自于某NOIP模拟赛 【问题描述】即使czhou没有派出最强篮球阵容，机房篮球队还是暴虐了校篮球队。为了不打击校篮球队信心，czhou决定改变训练后的活动。近来，江大掌门的徒弟徒孙们纷纷事业有成，回到母校为机房捐钱捐物。财大气粗的机房组收回了五层六层的所有教室。Czhou决定将六层的教室改造为智能密室逃脱活动室。每天傍晚，神牛们可以依次逐个进入游玩。我们简单的将教室分割为n乘n个房间，K是你初始所在房间，T是你最终逃脱的房间。如果你想要逃脱房间，你必须依次找到m把钥匙。我们假定你从一个房间进入另一个房间需要花费1的时间。当然某些房间有些特殊的问题(地图上S表示)需要回答才能通过，对于机智的众牛们来说，这些问题根本不是问题。我们假定众牛们花费1的时间解决问题。（主要是出题的人表述不清，导致众牛理解困难；当然问题只需要回答一次，下次再次进入房间不需要回答了）【问题大意】有一个密室，分割为N乘N个房间，K是初始房间，T是最终逃脱的房间，并且在逃脱前要找齐M把钥匙（要按顺序取，可以经过而不取，地图上可能有多个同一种钥匙，走），“#”为墙壁（一个关闭的房间）即不可走，假定从一个到另一个房间需要1个单位时间，当然某些房间有些特殊的问题(地图上S表示)需要回答才能通过，假定要花费1的时间解决问题（当然每个问题只需要回答一次），问最少时间花费。【输入格式】第一行两个数字n,m，接下来n乘n描述地图【输出格式】逃脱密室需要的最少时间，若无解输出impossible123456789101112131415161718192021【输入样例1】31K.S##11#T【输出样例1】5【输入样例2】3 1K#T.S#1#.【输出样例2】impossible【输入样例3】32K#T.S.21.【输出样例3】8 代码对不起啦贴着代码先123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263struct pos&#123;int x,y,k;&#125;;char map[101][101];int n,m,ans=inf,qesn=0;int f[101][101][10],tx[4]=&#123;0,-1,0,1&#125;,ty[4]=&#123;1,0,-1,0&#125;;pos st,ed,qes[9];int mymin(int a,int b)&#123;return a&gt;b?b:a;&#125;void bfs(void)&#123; memset(f,-1,sizeof(f)); f[st.x][st.y][0]=0; queue&lt;pos&gt; q;//用滚动数组更快 q.push(st); while(q.empty()==false) &#123; pos fr=q.front(); for(int i=0;i&lt;=3;i++) &#123; pos ne; ne.x=fr.x+tx[i]; ne.y=fr.y+ty[i]; ne.k=fr.k; if(map[ne.x][ne.y]==ne.k+1) ne.k++; if(map[ne.x][ne.y]==0 or f[ne.x][ne.y][ne.k]!=-1) continue; f[ne.x][ne.y][ne.k]=f[fr.x][fr.y][fr.k]+1; q.push(ne); &#125; q.pop(); &#125;&#125;void dfs(int k,int l)//枚举每一个S&#123; if(k==qesn+1) &#123; bfs(); if(f[ed.x][ed.y][m]!=-1) ans=mymin(ans,l+f[ed.x][ed.y][m]); return; &#125; map[qes[k].x][qes[k].y]=11; dfs(k+1,l+1); map[qes[k].x][qes[k].y]=0; dfs(k+1,l);&#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; char s[110];scanf("%s",s+1); for(int j=1;j&lt;=n;j++) &#123; map[i][j]=s[j]!='#'?11:0; if(s[j]=='K') &#123;st.x=i;st.y=j;&#125; if(s[j]=='T') &#123;ed.x=i;ed.y=j;&#125; if(s[j]=='S') &#123;qesn++;qes[qesn].x=i;qes[qesn].y=j;&#125; if(s[j]&gt;='0' and s[j]&lt;='9') map[i][j]=s[j]-'0'; &#125; &#125; dfs(1,0); if(ans==inf) printf("impossible"); else printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>bfs</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终极装备]]></title>
    <url>%2Fposts%2F35a8.html</url>
    <content type="text"><![CDATA[题目【问题大意】小明玩游戏时，获得了一些终极装备，但在这之前，他已经获得了一批能和终极装备媲美的装备，并且前后的数量是一致的，但人物的最大负重为M，每个装备可提升人物V[i]力量值，自身重量为W[i]（我们把这两个值称为该装备的属性），现在的目的是让人物更强大【输入】第一行3个数：M，N，T。分别为最大负重、装备数量、人物不带任何装备的能量值。接下来N行，一行4个数，V1[i],W1[i],V2[i],W2[i]（前后两组装备视为同种）【输出】人物能够达到的最大力量值，并且同种装备只能选一个。【样例输入】50 3 2012 18 23 1917 10 30 2420 20 17 20【样例输出】80【数据范围】(其实这个贴出来没什么用)1&lt;=M,T&lt;=10000,1&lt;=N&lt;=2001&lt;=W[i],V[i]&lt;=10000 代码123456789101112131415161718192021int f[10010];//f[I]=当使用I重量时，可以达到的能量int main(int argc,char *argv[])&#123; int m,n,t; scanf("%d %d %d",&amp;m,&amp;n,&amp;t); for(int i=1;i&lt;=n;i++) &#123; int a,b,c,d; scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d); if(b&gt;d) &#123; int t=a;a=c;c=t;t=b;b=d;d=t; &#125; v1[i]=a;v2[i]=c;w1[i]=b;w2[i]=d; &#125; memset(f,0,sizeof(f)); for(int i=1;i&lt;=n;i++) &#123; for(int j=m;j&gt;=w1[i];j--) if(j&gt;=w2[i]) f[j]=max3(f[j],f[j-w1[i]]+v1[i],f[j-w2[i]]+v2[i]); else f[j]=max2(f[j],f[j-w1[i]]+v1[i]); &#125; printf("%d",f[m]+t);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【置顶】个人简介About me]]></title>
    <url>%2Fposts%2F367.html</url>
    <content type="text"><![CDATA[I am Zory, an OIer in GD.Welcome to my blog. 现高一狗一枚 然后关于本站……（这不是借口） OI界，如果什么都要证明，那就不是OI了毕竟咱不是搞学术的 然后内容方面，教程应该会比较少主要是一些精华内容，网上很少的东西会点拨一下然后分享一些经验总结之类的如果你要学什么东西，先大概学会了再来这里提高吧 顺便说一句，其实如果是有意义的内容，多点评论吧！如果是灌水、乱膜拜、发广告的就免了，否则直接删除。欢迎问题指出和修正、提意见、补充内容。 有急事的话……邮箱：zorysoftware@qq.com（推荐）QQ：1134430323当然文章下评论也是可以的（不赶时间的纠正类） 最后，可能文章在写的时候，贪图一时方便，直接引用了他人的图片而忘记标明来源如果有任何侵权，请联系我，一定会第一时间纠正。 还有一些以前的网站，不会更新了： Delphi专博：zory.cnblogs.com C++专博：blog.csdn.net/zory_programmer 软件发布网站：zory.icoc.cc]]></content>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】07其他-5哈希]]></title>
    <url>%2Fposts%2F9bde.html</url>
    <content type="text"><![CDATA[哈希Hash 前言这东西主要用来验重而且在字符串领域比较常用但其思想的应用才是其精髓所以没有放在字符串分类 正文123456789101112typedef unsigned long long ull;ull gethash(char *s)&#123; int len=strlen(s+1); ull ans=0,p=1; for(int i=1;i&lt;=len;i++) &#123; ans=ans*p+s[i]; p*=13331; &#125; return ans;&#125; 其他应用1. 字符串匹配-kmp例题：poj3461 Oulipo 2. 字符串匹配-ac自动机等价于用kmp搞ac机，不推荐 3. 字符串匹配-manacherO(nlogn)求最大回文子串其实就是枚举中心点，分情况讨论，然后二分长度 4. 字符串匹配-后缀数组O(n log^2⁡ n )在排序的比较函数中，套一个二分，得到最长公共前缀，比较其下一个字符，就能够比较出大小得出排名后，相邻的再同样地二分一次就好了 练习题Tag-哈希]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】07其他-4哈夫曼树]]></title>
    <url>%2Fposts%2Ff6c6.html</url>
    <content type="text"><![CDATA[哈夫曼树 定义定义树的带权路径长度（wpl）是每个叶子节点，其【权值×节点到根的带权距离】之和 定义“满足国际定义的满k叉树”是每个节点，其孩子个数不是0就是k 相关介绍：百度百科-满二叉树（借鉴一下）这里稍微有提到，省略了“国际”：百度百科-哈夫曼树 因为没有时间，不详细介绍有兴趣的童鞋可以去wiki看看专业文献 哈夫曼树（霍夫曼树）1.给出n个叶子节点，求一个k叉树结构，使得这棵树的带权路径长度和最小 2.先考虑k=2的二叉树情况由定义，可以想到一个贪心：每次取出最小的a和b，累计答案a+b，并构造父亲节点，权值为a+b（其实很多算法都是从贪心开始的，虽然不一定以此结束）必要性证明：不会充分性证明：把（a+b）×深度，拆分成父亲（深度-1）和答案里面的a+b 然后，由于带权路径长度的特殊性如果我们已经限定了k=2，生成的树一定是满足国际定义的满k叉树必要性证明：假设某个非底层位置还剩个“槽”，把某个比这里深的节点（这意味着它比这几个叶子节点小）移到这里，一定能让答案更小 例题：noip2004 合并果子把参与合并次数作为深度就好了 3.当k&gt;2呢？我们能不能改成一次拿出k个？有一个要考虑的细节：再刚才，k=2，总能取到这么多然鹅现在，有可能最后剩下&lt;k个由于上面的证明，我们需要生成满足国际定义的满k叉树，才能确保正确性其实解决办法很简单：补0，直到能生成满足国际定义的满k叉树这样就把本来应该放在顶层（其实就是非顶层里面最大的那些）放到顶层 但是怎么判断能不能生成完全k叉树呢？换句话说，生成满足国际定义的满k叉树对叶子节点数量有什么要求？结论：(n-1)%(k-1)=0充分性证明：假设有n个叶子节点，它们能生成满足国际定义的满k叉树先看根节点，隐去剩下的n-1个节点，倒过来考虑每一次，我们给它k个孩子节点，但同时它自己不再是叶子节点所以每一次，那n-1个节点，按照一次k-1个来出现所以n-1应当是k-1的倍数 哈夫曼Huffman编码哈夫曼有个特性，就是能够解决编码问题把每个字母、单词的出现次数统计起来，给其新的编码，总长度总是最小的（可以把次数看作权值，长度看作深度）而且，这个编码的优秀在于不会有歧义换句话说，一个编码不会是另外一个编码的前缀 做法：生成哈夫曼树，如果编码是k进制的，也就是0~k-1的那么可以理解为是k叉的，然后按照0~k-1给同一个父亲到它孩子的边赋权然后上面说的前缀，原因在于我们把字母、单词看作叶子节点从根节点到达它，经过的权，其排列是独一无二的（后缀就不一定了，但没有关系，因为解码的时候是从前往后的，先入为主） 例题：noi2015 荷马史诗 其他经典Tag-哈夫曼]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>原创精华</tag>
        <tag>经典问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】07其他-3启发式搜索]]></title>
    <url>%2Fposts%2F5f25.html</url>
    <content type="text"><![CDATA[启发式搜索，又称A*算法 基本原则$估价f(x)&lt;=实际代价g(x)$作用：假设有两个状态非最优A，在堆内是$s(A)+f(A)$最优B，在堆内是$s(B)+f(B)$即使A先出来，会拓展出$s(C)+f(C)$也就是$s(A)+g(A)-g(C)+f(C)$既然A不是最优的，那么我们的B一定能出来 但如果违反了基本原则呢？因为$s(A)+f(A)&lt;s(B)+f(B)$所以 有可能 $s(A)+g(A)+f(C)-g(C)&lt;s(B)+f(B)$所以这个状态又要再出来一次（这里的ed不一定是最终状态） 练习题Tag-启发式搜索]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>启发式搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】07其他-2-01分数规划]]></title>
    <url>%2Fposts%2F7705.html</url>
    <content type="text"><![CDATA[01分数规划问题 问题给出数组a和b，求一组解x（只由01组成），使下面的柿子最大化$\frac{ \sum a_i \times x_i }{ \sum b_i \times x_i }$ 二分法二分答案L，转化为判定性问题判定：$\frac{ \sum a_i \times x_i }{ \sum b_i \times x_i } \geq L$$\sum (a_i-L \times b_i) \times x_i \geq 0$而这个问题的判定灰常简单，因为相互之间不影响，只要括号内是正数就是1即可判定 好文章推荐显然他们真的写得比我好、也更详细张天翔PerSeAwe]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>01分数规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】07其他-1约瑟夫问题]]></title>
    <url>%2Fposts%2F6fd3.html</url>
    <content type="text"><![CDATA[不会证明…… 来历（丢个链接就跑）：百科 题目【问题描述】做了上面那题“俄罗斯轮盘”之后，大家肯定很想亲自玩一玩了。不过当人多的时候，俄罗斯轮盘就不怎么好玩了。试想一下，十几个人，一支枪，一颗子弹……那是多么不过瘾啊。因此，我为大家准备了一个更刺激的游戏：约瑟夫轮盘。玩法是这样：N个人站成一圈，按顺时针方向编号1到N。裁判站在圈的中间，手持一把填满了N-1颗子弹的左轮手枪，从1号开始，每顺时针数到第M个人就把他干掉（当然，死了的人就不算人了，且裁判枪法如神，枪枪爆头），最后剩下的一个人就是赢家。比如，N=6,M=5时，依次被干掉的是5号，4号，6号，2号，3号，而1号是赢家。现在假设你也参与了这个游戏（当然不是做裁判），你想知道站在第几号的位置才能赢，请自己编个程序算算吧，你的命运就掌握在自己手里了！ 【输入格式】输入两个整数：N和M (1&lt;=N,M&lt;=10000)。【输出格式】输出一个整数——第几号赢。【输入样例】65【输出样例】1 代码12345int n,m;scanf("%d %d",&amp;n,&amp;m);int s=0;for(int i=2;i&lt;=n;i++) s=(s+m)%i;printf("%d",s+1); 更新如今回头看，感觉这东西没什么应用？？ 有兴趣的可以去这里研究研究]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>经典问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-7后缀自动机]]></title>
    <url>%2Fposts%2Fd6cf.html</url>
    <content type="text"><![CDATA[尚未完成]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-6后缀数组]]></title>
    <url>%2Fposts%2Fcc01.html</url>
    <content type="text"><![CDATA[更详细地解释：Manacher、莫队、fft、后缀数组、exkmp等各种算法，本质上都是尽量地利用子信息、残留信息 8.1 定义sa[i]=j 排第i的是原字符串中（假设他是s[]）s[j]为开头的后缀rk[i]=j 在原字符串中s[i]排第jy[i]=j 因为后面要补0（跟sa数组的记录方式一样，都是记录开头）wr[i]=j 对第二关键字排序后的rank值rsort[i]=j 基数排序中要用到的数组，表示数字i出现了j次 基数排序构建后缀数组过程如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//*******************定义*******************const int MAXN=210000,MAXM=210000;int wr[MAXN],rk[MAXN],sa[MAXN],y[MAXN],rsort[MAXM];int s[MAXN];//*******************实现*******************void getsa(int n,int m)&#123; //基数排序 for(int i=0;i&lt;=m;i++) rsort[i]=0; for(int i=1;i&lt;=n;i++) rsort[rk[i]=s[i]]++; for(int i=1;i&lt;=m;i++) rsort[i]+=rsort[i-1]; for(int i=n;i&gt;=1;i--) sa[rsort[rk[i]]--]=i; int p=0,ln=1;//不同子串量；当前子串大小 while(p&lt;n) &#123; //先按照第二关键字排序 //y[第二关键字排名]=第一关键字位置 int k=0; for(int i=n-ln+1;i&lt;=n;i++) y[++k]=i; //优先第二关键字为空的情况，排名定靠前 for(int i=1;i&lt;=n;i++) if(sa[i]&gt;ln) y[++k]=sa[i]-ln; //确保是第二关键字 //再使用稳定排序对第二关键字所对应的第一关键字排序 //wr[第二关键字排名]=第一关键字排名 for(int i=0;i&lt;=m;i++) rsort[i]=0; for(int i=1;i&lt;=n;i++) rsort[wr[i]=rk[y[i]]]++; for(int i=1;i&lt;=m;i++) rsort[i]+=rsort[i-1]; for(int i=n;i&gt;=1;i--) sa[rsort[wr[i]]--]=y[i]; //可以这样理解：既然rk[i]对应i，则rk[y[i]]对应y[i] //既然刚才对第二关键字排序，就用这个顺序来循环 swap(wr,rk);//wr数组保存旧rank值 p=1;rk[sa[1]]=1; for(int i=2;i&lt;=n;i++) &#123; if(wr[sa[i]]!=wr[sa[i-1]] or wr[sa[i]+ln]!=wr[sa[i-1]+ln]) p++; rk[sa[i]]=p; &#125; m=p;ln*=2; &#125; for(int i=1;i&lt;=n;i++) rk[sa[i]]=i;&#125;int hei[MAXN];void gethei(int n)&#123; int ht=0; for(int i=1;i&lt;=n;i++) &#123; if(ht) ht--; int k2=sa[rk[i]-1];//h[i-1]-1 while(s[k2+ht]==s[i+ht]) ht++; hei[rk[i]]=ht; &#125;&#125; 参考文档同学的：CSDN专业论文(已不存在：http://pan.baidu.com/s/1hs8yjac)网络上：博客园]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>后缀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-5AC自动机]]></title>
    <url>%2Fposts%2Fab16.html</url>
    <content type="text"><![CDATA[更详细地解释：Manacher、莫队、fft、后缀数组、exkmp等各种算法，本质上都是尽量地利用子信息、残留信息 一、定义 这东西就是KMP思想和字典树的结合。 首先，对于多模问题，也就是对一个母串判断多个字符串是否是它的子串时， （对于判断多个字符串是否是它的母串，kmp灰常优秀） 每个都做一次KMP显然是不合理的，同时为了减小空间，采用字典树 二、KMP思想我主要用fail“指针”实现在字典树中，假设现在有节点i，保证从【root到fail】路径上的字符串是从【root到i】的最长后缀这样，当我们失配时，退而求其次，尝试匹配它的后缀其实有种【树上kmp】的感觉 三、有关字典树在每个节点中有一个变量s，我们对于字典树模板的修改和利用主要体现在这上面，可能还有一个布尔保证不再来。 四、从例题开始Caioj1464我采用clean是为了应对多组数据的情况，并且比全部直接初始化更灵活和更快负责专题那家伙说求fail时放入队列的顺序并不重要，然后我就跟着用了bfs，至于dfs我没试过注意solve中曾经有个BUG，就是应该每次都尝试引导k到fail那里，即使还没到字符串尾（这样才不会忽略掉包含的情况，例如abcd和bc，在abcd中计算），caioj的数据已经改进了~123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=1100000;//*******************全局定义*******************char s[MAXN];//*******************实现*******************struct Trie&#123; int s; int ch[26]; int fail;&#125;a[510000];int cnt;void clear(int x)&#123; a[x].s=a[x].fail=0; memset(a[x].ch,0,sizeof(a[x].ch));&#125;void add()&#123; int ln=strlen(s+1); int now=0; for(int i=1;i&lt;=ln;i++) &#123; int t=s[i]-'a'; if(!a[now].ch[t]) &#123; clear(++cnt); a[now].ch[t]=cnt; &#125; now=a[now].ch[t]; &#125; a[now].s++;&#125;int lst[MAXN];void getfail()&#123; int tou=1,wei=2;lst[1]=0; while(tou!=wei) &#123; int x=lst[tou++];if(tou==MAXN) tou=1; for(int i=0;i&lt;26;i++) &#123; int son=a[x].ch[i]; if(!son) continue; if(x&gt;0)//debug &#123; int j=a[x].fail; while(j&gt;0 and !a[j].ch[i]) j=a[j].fail; a[son].fail=a[j].ch[i]; &#125; lst[wei++]=son;if(wei==MAXN) wei=1; &#125; &#125;&#125;int solve()&#123; int ln=strlen(s+1); int ans=0; int now=0; for(int i=1;i&lt;=ln;i++) &#123; int t=s[i]-'a'; while(now&gt;0 and !a[now].ch[t]) now=a[now].fail; now=a[now].ch[t]; if(now&gt;0) &#123; int tmp=now;//匹配了现在这个等同于匹配了其所有后缀 while(a[tmp].s&gt;=0) &#123; ans+=a[tmp].s; a[tmp].s=-1;//阻断 tmp=a[tmp].fail; &#125; &#125; &#125; return ans;&#125;//*******************主函数*******************int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; int n;scanf("%d",&amp;n); clear(0);cnt=0; while(n--) &#123; scanf("%s",s+1); add(); &#125; getfail(); scanf("%s",s+1); printf("%d\n",solve()); &#125;&#125; 五、练习地图匹配更全面的：Tag-AC自动机]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-4字典树]]></title>
    <url>%2Fposts%2F7385.html</url>
    <content type="text"><![CDATA[更详细地解释：Manacher、莫队、fft、后缀数组、exkmp等各种算法，本质上都是尽量地利用子信息、残留信息 这东西属于数据结构，还是很有趣的……这个的话我就不解释太多了，根据代码理解完全足够 简单的例题：统计前缀Caioj1463HDU1251 【题意】给出很多个字符串(只有小写字母组成)和很多个提问串，统计出以某个提问串为前缀的字符串数量(单词本身也是自己的前缀).【输入格式】输入n,表示有n个字符串(n&lt;=10000)接下来n行,每行一个字符串,字符串度不超过10输入m,表示有m个提问(m&lt;=100)第二部分是一连串的提问,每行一个提问,每个提问都是一个字符串.【输出格式】对于每个提问,给出以该提问为前缀的字符串的数量.【样例输入】5bananabandbeeabsoluteacm4babbandabc【样例输出】2310 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//*******************定义*******************struct Trie&#123; int s,c[27];&#125;a[500010];//*******************实现*******************void clean(int x)&#123; a[x].s=0; for(int i=1;i&lt;=26;i++) a[x].c[i]=-1;&#125;char s[20];int len,k;void add()&#123; len=strlen(s+1); int x=0; for(int i=1;i&lt;=len;i++) &#123; int t=s[i]-'a'+1; if(a[x].c[t]&lt;0) &#123; a[x].c[t]=++k; clean(k); &#125; x=a[x].c[t]; a[x].s++; &#125;&#125;int solve()&#123; len=strlen(s+1); int x=0; for(int i=1;i&lt;=len;i++) &#123; int t=s[i]-'a'+1; if(a[x].c[t]&lt;0) return 0; x=a[x].c[t]; &#125; return a[x].s;&#125;//*******************主函数*******************int main(int argc, char *argv[])&#123; clean(0);k=0; int n;scanf("%d",&amp;n); while(n--) &#123; scanf("%s",s+1); add(); &#125; int m;scanf("%d",&amp;m); while(m--) &#123; scanf("%s",s+1); printf("%d\n",solve()); &#125;&#125; 字典树练习：HDU1075HDU1800]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-3ExKMP]]></title>
    <url>%2Fposts%2F4360.html</url>
    <content type="text"><![CDATA[更详细地解释：Manacher、莫队、fft、后缀数组、exkmp等各种算法，本质上都是尽量地利用子信息、残留信息本文思路和图片大致来自于师兄cys大佬的论文本文会用相同颜色分别表示图片中某段的相等性 一、定义KMP：$str(1,nxt[i])=str(i-nxt[i]+1,i)$exKMP：$str(1,ext[i])=str(i,i+ext[i]-1)$然后接下来的过程中，思路和manacher是灰常类似的，各种分类讨论继承 二、求ext数组$ext[1]=lenb$（显而易见）因为ext[1]这个是具有一定性，所以我们基本把这东西废掉……那么我们就直接从ext[2]开始求。 A. k表示在当前搜索过的范围以内,rx=k+ext[k]-1最远（与manacher很像）故str(1,ext[k])=str(k,rx)因为$rx=k+ext[k]-1$，又得：$ext[k]=rx-k+1$代换变成：str(1,rx-k+1)=str(k,rx)因为现在要求ext[i]，截取str(i-k+1,rx-k+1)=str(i,rx) B. 设$L=ext[i-k+1]$，又得：str(1,L)=str(i-k+1,i-k+L)接下来尝试合并。因为L的不定性，需要考虑$i-k+L$和$rx-k+1$的大小 （1）i-k+L&lt;rx-k+1因为str(1,L)=str(i-k+1,i-k+L)，str(i-k+1,rx-k+1)=str(i,rx)所以在str(i,rx)中str(i,i+L-1)=str(1,L)因为str(i-k+1,rx-k+1)=str(i,rx)，得：str[i-k+L+1]=str[i+L]而因为ext[i-k+1]的定义，所以str[L+1]!=str[i-k+L+1]，得：str[i+L]!=str[L+1]，那么$ext[i]=L$小总结：主要利用【$i-k+L+1$已经扫描过】 （2）i-k+L&gt;=rx-k+1str(1,L)=str(i-k+1,i-k+L)所以str(1,rx-i+1)=str(i-k+1,rx-k+1)因为ext[k]的意义，所以str[rx+1]!=str[rx-k+2]又有可能str[rx-i+2]!=str[rx-k+2]（与rx-i+1与L的大小关系有关），那么就会得到：str[rx-i+2]!=str[rx+1]，所以$ext[i]\geq rx-i+1\geq ext[i-k+1]$ 总结：当$i-k+L&lt;rx-k+1$，$ext[i]=L$当$i-k+L\geq rx-k+1$，$ext[i]\geq ext[i-k+1]$ 三、用ext数组好啦我们要开始匹配A串（母串）和B串了定义ex数组，$B(1,ex[i])=A(i,i+ex[i]-1)$即A中每个后缀与B的最长公共前缀长度某种理解：将i-k+1看作i的对应点，将串B和串A放在同一条线上，前面用ext，后面用ex，则L为ext[i的对应点] 四、总结让我们再次对比一下kmp与exkmpKMP：$str(1,nxt[i])=str(i-nxt[i]+1,i)$exKMP：$str(1,ext[i])=str(i,i+ext[i]-1)$对于kmp，当i向后时，利用前面的信息是灰常简单的，一个比较即可；而对于exkmp，前后的i之间并没有较紧密的联系，需要较复杂地分情况讨论 那么这个“牺牲”为我们带来了什么呢？如ex一样的字符串局部信息，并且能够有从i开始的信息。 五、例题最长共同前缀长度回文串字符串的相似度 六、练习题Tag-exkmp 七、一张图快速复习exkmp]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>ExKMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-2Manacher]]></title>
    <url>%2Fposts%2F1c35.html</url>
    <content type="text"><![CDATA[更详细地解释：Manacher、莫队、fft、后缀数组、exkmp等各种算法，本质上都是尽量地利用子信息、残留信息 一、定义应用：求最长回文子串。暴力复杂度：O(n^3)Manacher复杂度：O(n)是不是特别优越？ 二、过渡算法考虑枚举每一个中间点，向两边拓展，此时即O(n^2)这种做法已经比暴力好很多了，但是让我们思考一些缺陷来提升效率。 1. 中间点的多样性目前的做法，中间点有可能是字符（回文串长度为奇数）也可能是字符间的空隙（回文串长度为偶数），比较麻烦。考虑将空隙变成‘#’等绝对不出现字符，复杂度不变，但便于我们处理。此时空隙数为字符数+1 2. 求解过程没有利用残留信息（这从来都是算法设计的关键） 通常我们要求的或者做题需要的辅助只是长度，与具体字符串无关，或许可以从这里入手。 所谓长度，而且还是回文的，我们可以定义【回文半径】，即回文串长度的一半，此后只需要考虑半径就等同于考虑长度。而且因为之前我们把空隙变成了字符，现在算出来的最大【回文半径-1】就是原来的回文串长度（因为空隙数必然是字符数+1）举例：123char: # a # b # b # a # RL : 1 2 1 2 5 2 1 2 1RL-1: 0 1 0 1 4 1 0 1 0 然后定义：rx：当前所有回文子串最右触及位置ma：回文半径数组 二、具体操作接下来就是分类讨论i与rx的位置关系啦，因为这关系到状态的继承 （pos是rx的对应中介点，lx是对于左端点） 1. i&lt;=rx那么找到i关于pos对称的j①ma[i]=ma[j]②ma[i]=rx-i+1 2. i&gt;rxma[i]=1 当然，这些继承只是基础，接下来还是要暴力拓展这些主要是缩短了前面无意义的继承。 三、例题代码2009 Multi-University Training Contest 16 - Host by NITHdu3068Caioj1179123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=110000;const char SPC='#';//*******************全局定义*******************char s2[MAXN*2];//*******************实现*******************char s[MAXN*2];int ma[MAXN*2];int manacher()&#123; int ln=strlen(s2+1); for(int i=1;i&lt;=ln;i++) s[2*i-1]=SPC,s[2*i]=s2[i]; ln=ln*2+1;s[ln]=SPC; int md,rx=0,ans=0; for(int i=1;i&lt;=ln;i++) &#123; if(i&lt;=rx) &#123; int j=2*md-i; if(i+ma[j]-1&lt;=rx) ma[i]=ma[j]; else ma[i]=rx-i+1; &#125; else ma[i]=1; while(i-ma[i]&gt;=1 and i+ma[i]&lt;=ln and s[i-ma[i]]==s[i+ma[i]]) ma[i]++; if(rx&lt;i+ma[i]-1) rx=i+ma[i]-1,md=i; chmax(ans,ma[i]-1); &#125; return ans;&#125;//*******************主函数*******************int main()&#123; //freopen("tmp.in","r",stdin); while(scanf("%s",s2+1)!=EOF) printf("%d\n",manacher());&#125; 参考文献：segmentfault-曾会玩刘毅]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-1KMP]]></title>
    <url>%2Fposts%2Fc111.html</url>
    <content type="text"><![CDATA[更详细地解释：Manacher、莫队、fft、后缀数组、exkmp等各种算法，本质上都是尽量地利用子信息、残留信息 一、说在正文前的小声明网络上有关KMP的文章灰常多，本文旨在给初学者一个大致理解，尽量以最简单最直观的方式实现kmp，而不考虑太多有关性能的问题。 参考文献（或者说建议你看看的东西）：1(并不是他原创，但原文找不到了。。)，用了个图片和栗子2 栗子比较完整，大家有兴趣可以看看，对本文无用3 阮一峰，挺好的，用了图片和前后缀角度的看法4 v_july_v，太强了，堪称完美，建议理解本文后去这里提高，目前我持膜拜状态5 matrix67，绝对经典 二、定义Knuth-Morris-Pratt字符串查找算法，简称为”KMP算法”，常用于在一个文本串S(母串)内查找一个模式串P(子串)的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H.Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。KMP算法的主要作用在于，计算出字符串B是否为字符串A的子串及其系列问题。它比简单的暴力算法更优秀的地方在于，当部分匹配失败时，暴力算法一个个字符向前回溯，KMP则通过预先根据字符串B所计算出的”假如我的下一个字符失配，我的新对应位置”（通常用Next数组表示）。由于此预处理过程只是与字符串B有关，所以很适合处理”某个字符串B验证多个字符串A是否是其母串”一类问题。 三、利用Next数组求解KMPNext的性质（你要是想成定义也行）（在实现中，通常把Next用其他更简短的单词表示，本文用p）B[1..p[i]]=B[i-p[i]+1..i]并且要求p[i]最大，从而让移动距离最小，成功可能性更大并且没有漏网之鱼，类似贪心思想 假设现在字符串A[i-1]匹配成功，字符串B[j]匹配成功伪代码：1234567891011j=0;for i=1 to lenA&#123; while(j&gt;0 and a[i]!=b[j+1]) j=p[j]; //将匹配成功的j的p[j]重新尝试对齐i-1 //此举意味着失配时，字符串B相对于字符串A向右移动了j-Next[j]位 if(a[i]==b[j+1]) j++; //此时j成功匹配 如果(j==lenb) ans++; //这句话看情况，目前表示统计的答案数+1（如果想搜出来的不重叠就加上j=0）&#125; 三、Next数组 对称不是中心对称，而是中心字符块对称，比如不是abba，而是abab这种对称 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合 “后缀”指除了最前一个字符以外，一个字符串的全部尾部组合 那么Next数组究竟怎么求？这也是网络上有关KMP最大的争议。首先，Next数组有几种定义（这也是为何初学者很容易混淆）。不过殊途同归，next本质上是相同的~ 四、Next的角度1“最大长度值”是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例。 (个人认为这个也适合作为性质去记忆而非求法，虽然听老师讲了一遍后开始折服于此) 序号 1 2 3 4 5 6 7 字符 A B C D A B D 最大长度 0 0 0 0 1 2 0 “A”的前缀和后缀都为空集，共有元素的长度为0；“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；“ABC”的前缀为[A,AB]，后缀为[BC,C]，共有元素的长度0；“ABCD”的前缀为[A,AB,ABC]，后缀为[BCD,CD,D]，共有元素的长度为0；“ABCDA”的前缀为[A,AB,ABC,ABCD]，后缀为[BCDA,CDA,DA,A]，共有元素为”A”，长度为1；“ABCDAB”的前缀为[A,AB,ABC,ABCD,ABCDA]，后缀为[BCDAB,CDAB,DAB,AB,B]，共有元素为”AB”，长度为2；“ABCDABD”的前缀为[A,AB,ABC,ABCD,ABCDA,ABCDAB]，后缀为[BCDABD,CDABD,DABD,ABD,BD,D]，共有元素的长度为0。 所以，p[i]可以说是从1到i形成的字符串中的最大长度值。其实与前面说的“s(1,p[i])=s(i-p[i]+1,i)”是一样的 1234567for(int i=2;i&lt;=lenb;i++)//X2，后缀头不变尾延长&#123; while(j&gt;0 and b[j+1]!=b[i]) j=p[j];//让前缀和后缀同时增长 //j是前缀的尾同时也是最大长度值，必然比i小所以其p已经计算出了 //失败的时候找更小一点的对称，也就从蓝色转变为红色来延长 if(b[i]==b[j+1]) p[i]=++j; else p[i]=0;&#125; 同样的代码，不同的理解方式。 另一个更贴合本理解的代码123456for(int i=2;i&lt;=lenb;i++)//图片中的X2，后缀头不变尾延长&#123; int j=p[i-1];//图片中的x1-1，因此蓝色相等 while(j&gt;0 and sb[i]!=sb[j+1]) j=p[j]; if(sb[i]==sb[j+1]) p[i]=j+1; else p[i]=0;&#125; 这两份代码可以结合图片理解，i就是x2，j是x1-1 五、Next的角度2Next数组相当于“最大长度值”整体向右移动一位，然后初始值赋为-1 序号 1 2 3 4 5 6 7 字符 A B C D A B D 最大长度 0 0 0 0 1 2 0 Next -1 0 0 0 0 1 2 其实这个角度本质上和上一个一样，只不过这样就能”在j失配时直接对j跳转“而不是”在j+1失配时对j跳转“《最大长度值》字符串B向右移动的位数[已匹配字符位置-失配字符的上一位字符的最大长度值]《Next数组》字符串B向右移动的位数[失配字符的位置-失配字符对应的Next值]上述两个值相等 六、Next的角度3用一个长长的字符串来解释 序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 符 A G C T A G C A G C T A G C T G Ne 0 0 0 0 1 2 3 1 2 3 4 5 6 7 4 0 假设当前字符位置i，子串位置j(1)递推比较把i与j+1进行比较，如果相等，直接继承为上个Next再+1，因为对称程度增加了。如果不相等，跳到(2)，很好理解 (2)回头来找对称性 t如果要存在对称性，那么对称程度肯定比前面这个c的对称程度小。要找更小的对称，必然在对称内部还存在子对称，而且这个t必须紧接着在子对称之后。 可以通过循环j=Next[j]不断找更小对称性个人感觉类似自己匹配自己 七、代码123456789101112131415161718192021222324252627282930313233343536373839//*******************定义*******************int p[11100],lenb;char b[11000];//*******************实现*******************void calcb(void)&#123; lenb=strlen(b+1); int j=0;p[1]=0; for(int i=2;i&lt;=lenb;i++) &#123; while(j&gt;0 and b[j+1!=b[i]]) j=p[j]; if(b[i]==b[j+1]) p[i]=++j; else p[i]=0; &#125;&#125;int KMP(char a[])&#123; int lena=strlen(a+1); int j=0;int ans=0; for(int i=1;i&lt;=lena;i++) &#123; while(j&gt;0 and a[i]!=b[j+1]) j=p[j]; if(a[i]==b[j+1]) j++; if(j==lenb) ans++,j=0; &#125; return ans;&#125;//*******************主函数*******************char a[11000];int main(int argc, char *argv[])&#123; int n;scanf("%d",&amp;n); while(n--) &#123; scanf("%s",b+1); calcb(); scanf("%s",a+1); printf("%d\n",KMP(a)); &#125;&#125; 检验数据：Inputalkdfjhaljhdgelqigljafiehiqhrougsgssgsgijosgsjeswsgjjiigj Output02 八、练习陶陶的名字（可以重叠的最小覆盖） 九、kmp与最小覆盖参考文献：FarmerJohn 定义：对于一个字符串，一个长度最小的满足【复制自己多次（不重叠，与陶陶的名字不同）后可以覆盖原串】的子串 结论：长度=n-next[n] 证明：先证明它是覆盖子串①next[n]&lt;=n-next[n]显而易见覆盖 ②next[n]&gt;n-next[n] 然后它也是最小的这里用反证法，假设存在一个比n-next[n]更小的C，然后截取掉这样的话，黄色部分比next[n]更长，不满足next[n]是最长这个定义 Q.E.D.]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>原创精华</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】05动态规划-4数位DP]]></title>
    <url>%2Fposts%2F8ba0.html</url>
    <content type="text"><![CDATA[数位DP 很好资料zbtrs 感觉这东西也没什么好说的了等碰到什么不套路，有特色的题目再加上来吧 练习题Tag-数位DP]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】05动态规划-5概率与期望]]></title>
    <url>%2Fposts%2F7366.html</url>
    <content type="text"><![CDATA[概率与期望 概率应该不难？ 期望通俗地讲，就是【所有结果状态的权值乘以概率】的和相当于，尝试无限次后，得到的平均数通常是倒推的，因为这样，当前状态的概率总是1，灰常方便 例题：3801 Rainbow的信号 然后讲讲期望的线性性结合例题：3802 绿豆蛙的归宿对于一个状态x，如果按照定义来计算期望枚举它的所有能产生的结果状态，然后累计权值乘以概率 然鹅事实上可以直接枚举k个后继状态y$f[x]=\sum_{i=1}^k (f[y_i]+c)\times \frac{1}{k}$这是为什么？其实就是把c按照后面发生的概率，等比例划分后更新到权值里面（因为权值也就是距离在变大） 有空再慢慢研究的资料练习题Tag-概率与期望]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-3最近公共祖先]]></title>
    <url>%2Fposts%2Fdc4.html</url>
    <content type="text"><![CDATA[最近公共祖先的四种求法 倍增lca时间复杂度 预处理nlogn+询问logn其实也没什么好说的，结合代码注释吧1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//Zory-2017//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=100000,MAXM=200000;//*******************全局定义*******************struct pt&#123; int dep,hou;&#125;p[MAXN+10];struct rod&#123; int y,g;&#125;e[MAXM+10];int bin[31];//*******************实现*******************int ln=0;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;int f[MAXN+10][31];void dfs(int x,int fa)&#123; f[x][0]=fa;p[x].dep=p[fa].dep+1;//dep=bin[i]时只有f[x][i] for(int i=1;bin[i]&lt;=p[x].dep;i++) f[x][i]=f[f[x][i-1]][i-1]; for(int k=p[x].hou;k&gt;0;k=e[k].g) if(e[k].y!=fa) dfs(e[k].y,x);&#125;int LCA(int x,int y)&#123; if(p[x].dep&lt;p[y].dep) swap(x,y); for(int i=30;i&gt;=0;i--) if(p[x].dep-p[y].dep&gt;=bin[i]) x=f[x][i];//从高向低消除差距 if(x==y) return x;//y是x祖先 for(int i=30;i&gt;=0;i--) if(p[x].dep&gt;=bin[i] and f[x][i]!=f[y][i])//防止跳过头 x=f[x][i],y=f[y][i];//一起向上跳 return f[x][0];&#125;//*******************主函数*******************int main()&#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; int n,m;scanf("%d%d",&amp;n,&amp;m);ln=0; for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; dfs(1,0); while(m--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); printf("%d\n",LCA(x,y)); &#125;&#125; 树剖lca时间复杂度 预处理n+询问logn就是树剖跳tp的fa实现不太常用，适用于已经打了树剖的情况 ps：其实树剖是在线算法中最快的因为log是最坏情况下的复杂度 tarjan+并查集 lca时间复杂度 预处理n+询问1这属于离线算法 对于每个点，三种标记，0表示没访问过，1表示访问过但没有回溯（x和x的祖先）2表示访问且回溯过那么对于x的每个询问（可以建立链表去枚举），如果y是1，则lca=y如果y是2，则y向上的第一个【标记1】的节点就是lca 然后每次回溯的时候，把自己的块合并到父亲的块中这就相当于把第一个【标记1】的节点指向父亲那么每个询问的答案即findfa(y) st表lca用st表存储编号，预处理后即可O(1) 练习Caioj1236模版Caioj1237树上任意两点的距离]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】05动态规划-2-1d1d动态规划]]></title>
    <url>%2Fposts%2F4bab.html</url>
    <content type="text"><![CDATA[1D/1D动态规划状态为n，转移为n的dp方程动态规划的优化-周尚彦.pdf 单调队列主要步骤： 移除无效元素 计算队首的最优g，得到f(i)的最优结果 计算新的g，放入队列中，并维护单调性 有一道比较变态的变形题：Cut the Sequence 斜率优化这个东西学了n次，前面n-1次都没学扎实（教练水平有限）随着实力的提升，这次细细研究周尚彦的论文，终于彻底搞明白了所以我也尽力讲清楚，但开始研究之前请确保有扎实的基础（如提高一等水平） 斜率优化主要可以从数学和图形的角度去理解，数学方面的话可以看我玩具装箱的题解，本文以图形为主（更有助于后期的提升） dp方程的基本形式(不能有二维数组)：$f(i)=f(j)+w(j,i),w(j,i)=a_i+b_j+c_i \times d_j$如果j在i之前已经计算出来了，显然可以化一下柿子$f(i)=(d_j) \cdot (c_i) +a_i+b_j+f(j)$不难看出这是一个一次函数，i是带入的未知元，这个可以用李超树轻松解决看到别人说要化成一次函数的形式，这是我最先想到的做法，然而这样的复杂度下限是nlogn的然而有些题，使用斜率优化可以线性解决 换一种思路，考虑将j本身的东西所谓x和y，也就是变成点那么对于i，它的决策也可以是这种形式：$f(j)+b_j=(-c_i) \cdot (d_j) +f(i)-a_i$截距：直线与y轴的交点的纵坐标那么我们的目的就是最小化截距 据说这是一个线性规划问题，但我不清楚这是什么……但这和我们要讲的无关总之就是一个直线，其斜率和i有关，从下往上移直到碰到第一个点，就是最优决策点显然只有某个凸壳上的点是有用的（min则下凸壳） 然后下面的内容就要结合题目的具体性质了A. 点的x坐标是单调的 提供的直线的斜率是单调递增的这种情况的话，显然这个凸壳内部相邻点的斜率是单调递增的，否则不会有贡献而且决策点具有单调性，左边的部分无需保留，通常用单调队列实现 提供的直线的斜率是不单调的此时决策点不单调，不过因为维护好了凸壳，可以在上面二分（某个左右都更差的位置） B. 点的x坐标是不单调的平衡树动态插入来维护或者用cdq分治处理 练习详细地讲讲这个入门好题(仅从数学的角度)：玩具装箱好文章推荐：MashiroSky 四边形不等式如果转移满足该不等式，则称满足决策单调性形式1：对于 $a \leq b \leq c \leq d,w(a,d)+w(b,c) \geq w(a,c)+w(b,d)$（简单记为：交叉小于包含）形式2： $w(a,b+1)+w(a+1,b) \geq w(a,b)+w(a+1,b+1)$考场上可以考虑暴力打出决策点的表，验证单调性 一维：$f(i)=min f(j)+w(j,i)$一维状态例题：诗人小G这个套路还是很好用的 二维（虽然这个不属于1d1d，但是也顺便讲讲）：$f(l,r)=min f(l,k)+f(k+1,r)+w(l,r)$如果w满足四边形不等式，则f也满足四边形不等式如果f满足四边形不等式，则 $fm(l,r-1) \leq fm(l,r) \leq fm(l+1,r)$即f的决策，在同一行、同一列上单调递增 例题：合并石子显然其w满足四边形不等式（取等），则f也满足，那么决策的区间是确定了的然后你考虑每种ln$l=1，fm(1,ln-1) -&gt; fm(2,ln)$$l=2，fm(2,ln) -&gt; fm(3,ln+1)$……也就是枚举范围连起来只有一个n（感觉这种东西谁会想到啊……）l推荐文章：https://www.cnblogs.com/mlystdcall/p/6525962.htmlhttps://blog.csdn.net/noiau/article/details/72514812]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】05动态规划-1入门]]></title>
    <url>%2Fposts%2Fb119.html</url>
    <content type="text"><![CDATA[动态规划DP基础 7.1 采药的升级版终极装备 7.2 中链式（二维）乘积最大 7.3 最长升降序子序列合唱队形 7.4 最长公共子序列最长公共子序列 7.5 练习动态规划思想+二分优化：进攻策略难度较大 思维风暴~：乘电梯 7.6 多重背包二进制拆分法：每个物品有ci次使用机会可以把每个物品拆成log个主要是利用二进制的表示法记得把余数加上就好了还是很好理解的 7.7 环形dp对于没有产生环形依赖的情况，可以把自身复制一遍到后面但如果有环形依赖，但转移简单的时候，可以用高斯消元否则有一种精妙的办法，适用于那种收尾相接情况简单的时候，就是通过多次dp，第一次不相连，第二次强行相连（通过赋初始值）]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-9二分图]]></title>
    <url>%2Fposts%2F250b.html</url>
    <content type="text"><![CDATA[博大精深的二分图 二分图顶点可以分类两个集合X和Y，所有的边关联的两个顶点，恰好一个属于集合X，另一个属于集合Y。 最大二分匹配（下文为早期所写，不保证正确性）例题Caioj1122 匈牙利算法：ask[i]==true，表示这一轮中母牛i有匹配成功的可能性（每到一只新公牛t就要重置） 我们每次尽量让公牛x（不一定是t）配对，那么当询问到母牛i时 ask[i]==true情况一、match[i]==0，直接成功情况二、match[i]&gt;0，之前有一只公牛y=match[i]， 尝试让y找其他母牛去匹配，从而调整搭配 在这过程中，这个公牛y以及之后为了搞定公牛y所需要调整的其他公牛y2、y3 都不能占用母牛i（先宣告主权，ask[i]=false），从而避免死循环，这是一个潜在的贪心， 递归回来之后假如一切顺利，则x也成功假如情况任意一个成功，匹配match[i]=x但无论如何，ask[i]=false（别急着问为什么，看下去先） ask[i]==false（看文字前再明确一遍，配对公牛t时曾经询问过i）情况一、之前匹配成功了，然鹅，仔细想想，我们的递归结构中，只要有一次成功， 就全部成功了，那么x的配对就不会找到母牛i了，所里本情况不存在。情况二、之前匹配也就是调整失败，那么在同样情况下（ask没变也就是公牛t没变） 这一次必然也会失败，所以这时应当退出，达到剪枝省时的目的总而言之，当ask[i]==false时，退出即可 决策单调性（好像语言组织得不是特别好）：为什么当情况二调整公牛y后成功则母牛i属于x，而不是x自己去再往后尝试？好吧严格而言这并不是一个证明：目前先凑合着，假如以后发生状况需要调整x时再调整疑点：“现在调整”和“满足现状”面对的状况可能不一样？解答：这应该是可行最大二分图匹配方案不唯一的一种体现吧，反正目前而言我们的目的是求出最大匹配数，所以具体方案没有关系 加速：可以考虑运用邻接表（这条边通往的地方）和时间戳（这样就不用每次初始化ask数组）邻接表：话说这可是我们学最短路后立刻就学了的东西，适用于稀疏图时间戳：ask用int存储，如果比“当前匹配公牛编号t”小就是过时的，相当于false 改造：解决多重二分图匹配问题Optimal Milking 练习：【Poj1325】Machine Schedule 二分图提高篇二分图增广路的另一种理解：建立一个有向图，非匹配边看做从左向右，匹配边看做从右向左那么左边的x到右边的y存在增广路，相当于存在一条路径 二分图最大匹配的必经边和可行边先从特殊的完备匹配开始考虑可以先任意找到一组匹配方案 必经边：【当前是匹配边】并且【删除后不存在从x到y的路径】因为匹配边意味着从y到x，现在又存在从x到y的路径那么就以为着 x和y属于同一个强连通分量所以必经边的判定条件可以改为：【当前是匹配边】并且【不同强连通分量中】 可行边：【当前是匹配边】或者【把x到y看做可行边后，存在连接原本另外两个匹配点的路径】因为我们刚才的建边方式，也就是另外两个原本的点之间有路径，同时原本就有匹配边把他们和x、y连接所以说条件可以改成：【当前是匹配边】或者【同一个强连通分量中】 不过，如果没有完备匹配呢？对于两种边的第二个条件，不一定非要增广x到y，而可以是到z所以就会出问题（还傻傻地以为没有问题） 怎么解决呢？接下来的内容很好懂但是我认为是神仙想出来的东西……太nb了，我也只有帮忙吹水的份 分情况去解决问题对于必经边的判定，不能只是x到y了，而是不能有任何新增广路所以我们要判断，删除之后是否存在其他增广路不过，这个增广路一定是连接x和y中某一个的，否则与此次操作无关，影响了最大匹配的“最大” 如果我们考虑用网络流解决二分图最大匹配问题，剩下的残余网络能够很清晰地得出具体的有向图方案因为对于匹配边，流量过去了，那么有效边是其反向弧，非匹配边则不变，恰好与我们提出的有向图表示法相一致 加入源点和汇点，那么匹配点也能很清晰地表示出来了然后我们可以用这个图去考虑完善判断条件 图示：a和b是非匹配点，u和v是匹配边蓝色是匹配边，红色是非匹配边然后绿色是在强连通分量中的部分 先解决必经边的判定，也就是断开原本的边，分为x和y去找两种情况 对于可行边的判定，原本是非匹配边可能x和y中只有一个匹配点，分为x和y去找两种情况也可能两个都是匹配点 综上所述，可以把原本的方案，判断强连通部分不变，对象从简单有向图变为网络流的残余网络（忽略流量为0的边） 例题：舞动的夜晚]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>匈牙利</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-8-2-SAT]]></title>
    <url>%2Fposts%2Fef65.html</url>
    <content type="text"><![CDATA[差分约束题目直观版：Tag-2-SAT经典论文：由对称性解2-SAT问题 不错的入门教程：csdn-jarjingx（不得不说，超级良心！） 话说2-sat问题好像是有很多种解法的，但我比较喜欢tarjan 正经说细节 如果要固定，某一个变量必须取某个值可以用一条单向边连接，表示如果选择了非法值，会导致矛盾 如果题目要求输出方案在scc缩点以后，不难发现，因为是个dag任意时刻一定会有出度为0的点 明确：缩点以后，边的关系就是，如果选择则必须传递选择如果我每次选择一个之前没选择而且出度为0的节点，那么一定是无害的（不选择它就不一定了）此时把对立的节点（由原本的逻辑关系产生，一定只有唯一一个，否则应合并，因为只有二元）定为不选择那么因为搞的是出度=0，可以在反图上跑拓扑 不过还有一个性质，能省去代码复杂度，不需要建立反图因为tarjan求scc的时候，编号是自下而上的（不了解的请博客中搜索“简单连通性问题”）不难发现，对于两个上下的scc之间，下面那个编号小，恰好拓扑序也是在上面之前所以可以根据两个对立scc的编号，直接确定选择与否（编号小，就选择）相当优美简洁 练习Caioj1405聚会Poj3207Panda’s TrickBzoj1997PlanarPoj3683Priest John’s Busiest Day]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-7-最小生成树]]></title>
    <url>%2Fposts%2Fb399.html</url>
    <content type="text"><![CDATA[最小生成树 kruskal其实也没什么好说的，正确性自行百度并查集维护连通性，每次取最小的，连接两个森林的一条边时间复杂度$O(m log_2 m)$ prim维护一个树，开始只有一个节点1加入n-1次，每次选择【加入这棵树的代价】最小的那个点时间复杂度如果直接暴力是 $O(n^2)$ 的，如果加入二叉堆可以变成 $O(m log_2 n)$如果logm和logn相差不大的话，写kruskal所以说prim只要适用于稠密图 练习自行搜索tag 有意思的变形CH6201 走廊泼水节]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-6差分约束]]></title>
    <url>%2Fposts%2F62.html</url>
    <content type="text"><![CDATA[差分约束，就是要满足一定条件(形如ax-ay&lt;=c)求最值的问题。可以应用于求解不等式。 其实就是把数形结合起来入门教程自行搜索差分约束题目直观版：Tag-差分约束 入门练习Caioj1400差分约束1区间Caioj1401差分约束2国王Caioj1402差分约束3消息可靠吗Caioj1403差分约束4整数区间Vijos1094关系运算图Bzoj2330糖果]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-5网络流]]></title>
    <url>%2Fposts%2F5c7c.html</url>
    <content type="text"><![CDATA[网络流类似流水问题难点就是构图也有各种变例决策类问题的法宝之一（还有贪心等） 有个不错的入门教程网络流-纳米黑客PDF 最大流解决方案Edmond-Karp 理论上界是 $nm^2$ ，但通常可以解决$10^3$ ~ $10^4$ 的规模 EK的缺点主要是，每次只找出一条增广路Dinic算法试图改进这一点 通过bfs得出残余网络中的分层图（显然是一个dag） 通过dfs得出增广路，回溯时更新流量3.理论上界是 $n^2m$ ，但通常可以解决$10^4$ ~ $10^5$ 的规模 特别地，对于二分图匹配，时间复杂度可以达到$O(m \sqrt n)$ 最大流练习题目直观版：Tag-网络流 最大流：Caioj1115 Poj1273Drainage DitchesCaioj1116 Poj3281DiningCaioj1117 Poj2455 Bzoj1733Secret Milking MachineCaioj1118 Poj2112Optimal MilkingCaioj1119 Poj2391Ombrophobic BovinesCaioj1120 Poj3189Steady Cow Assignment 最小（割的容量）=最大流很规范的PPT最小割：Bzoj1934 Bzoj2768善意的投票&amp;冠军调查Bzoj1001狼抓兔子 51nod-1299师兄刚好给我看这题，但这道题我就不做了，好像正解不是最小割，会超时一半，我就说说最小割部分分的思路：原图中每个点拆为左点和右点，原图的边边权为无限，左点和右点之间的边边权为1从源点到犯人的左点连条边，从出口点的右点到汇点连条边，跑一遍最大流就是答案 费用流 最小费用最大流是指满足源点流出的流量最大时，总费用最小的一个网络，模板都是基于此。最大费用最大流则是将所有的费用取负，然后再跑一遍最小费用最大流，将最终的最小费用取负就是最大流量下的最大费用了。最大费用可行流关注的是费用而非流量是否最大，暂时不会最小费用可行流没有意义 资料：窝嘞割草本质上其实就是把EK中bfs换成能处理边权的spfa（因为dinic无法处理，所以只有EK的衍生版） 题目：Tag-费用流 至于zkw费用流……jzq233jzqzkw 最大权闭合子图闭合子图：只进不出的子图，可用于处理依赖关系很容易贪心地想到，最优情况是所有正权点，但为了闭合要有所割舍 考虑有网络流决策，将点分成选和不选两种，用割的模型，以是否和S联通来标识则S向所有正权点连边，边权为点权，所有负权点向T连边，边权为点权的绝对值割后，设选的点集为A，不选为B，根据点权正负细分，如图所示：如果x依赖y，则选x就要选y，此时从x到y连接一条INF的边，标识不可【选x不选y】注意一个细节（因为我这菜逼一开始忽略了）：这条边是允许选y不选x的，因为那种情况没有造成联通 此时只要是个合法的割，A一定是一个闭合子图，现在要最大化它显然割=B1-A0，而A=A1+A0故A+割=A1+A2=正权和，让割最小化即可]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-4简单连通性问题]]></title>
    <url>%2Fposts%2F293.html</url>
    <content type="text"><![CDATA[简单连通性问题tarjan算法无向图与有向图致敬：维基百科Robert_Tarjan 无向图连通图割点：删去该点和相关的边后，分裂为两个或以上子图桥或割边：删去该边后，分裂为两个或以上子图 tarjan算法dfn表示时间戳low表示所有【子树内节点，能通过一条非搜索树边到达子树内的节点】的最小dfn 割点和割边的判定无向边x-&gt;y是割边，当且仅当搜索树上存在x和y，满足 $dfn_x &lt; low_y$含义就是，y无法通过其他方式到达比x更早的点显然割边一定是搜索树上面的为了也能兼容有重边的情况，可以考虑通过记录来到这里那条边的编号来判断是否是搜索树边 对于割点，当x不是根节点时，仅当搜索树上存在x的子节点y，满足 $dfn_x \leq low_y$但当x是根节点的时候，则更简单，即x要有至少两个儿子节点 双联通分量点双联通分量（v-DDC，又有一个经常被误用的名字：块）：无向图中，极大无割点联通子图显然任意两个点，都同时在至少一个简单环中求法和缩点：并不是去掉所有割点！割点可能同时存在多个v-DCC中维护一个栈（仅第一次访问才放入），当x和y满足割点判定条件（不管x是不是根节点），将顶部到y间的元素弹出，再强行加入一个x，作为v-DDC（不难发现x还在里面，以后可能会被取出）另外，孤立点也是v-DDC缩点的时候，要新建割点个数（分配新编号，指向所有包含自己的v-DDC）的点，是一棵树（或森林）原理：因为满足条件，去掉x无法导致y内分裂，而一定不存在内部有割点的情况，否则在前面就弹出了 边双联通分量（e-DDC）：无向图中，极大无割边联通子图显然任意一条边，都同时在至少一个简单环中求法和缩点：去掉所有割边，剩下的就是边双联通图把每个边双联通图缩成一个点，用割边连起来，就形成一棵树（或森林） 欧拉通路从s到t，经过每条边恰好一次判定：联通图无向图：【度数=奇】=0时，其实是欧拉回路；【度数=奇】=2时，一个起点一个终点有向图：【入度!=出度】=0时，其实是欧拉回路；【入度!=出度】=2时，【入度=出度-1】是起点，【入度=出度+1】是终点 欧拉回路欧拉回路：从s出发，回到s的欧拉通路 性质：如果原本是欧拉回路，拿走一个小欧拉回路（包括一个点），依然是欧拉回路 判定：联通图无向图：每个点度数=偶有向图：每个点入度=出度 无向图输出方案：从任意点出发，前往没有去过的边最后停止的时候一定会回到原本的点但可能漏了一些环，所以要在回溯的时候向其他分支走，然后作为一个插入但是直接插入会非常不方便，所以回溯的时候才把x（或者边）入栈，得出倒过来的路径 这样的时间复杂度较高，因为会多次尝试询问每一条边一种优化是，每次邻接表把用过的剔除掉，因为不可逆，时间降到n+m但此时空间搜索深度复杂度为m，即使linux也会爆（详见理论知识-概要），建议手写栈 模板题：uoj117123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=110000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int op; int hou[MAX_N],dg1[MAX_N],dg2[MAX_N]; struct Edge &#123; int y,g; &#125;e[MAX_N*4]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; bool v[MAX_N*2]; vector&lt;int&gt; ans; void euler(int x)//n+m &#123; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int tmp=(op==1?(k+1)/2:k); if(v[tmp]) hou[x]=e[k].g; else &#123; v[tmp]=1;euler(e[k].y); if(op==1) ans.push_back(k&amp;1?(k+1)/2:-k/2); else ans.push_back(k); k=hou[x];//被极限自环卡…… &#125; &#125; &#125; int sz; void col(int x)//n+m &#123; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int tmp=(op==1?(k+1)/2:k); if(!v[tmp]) &#123; v[tmp]=1,sz++; col(e[k].y);k=hou[x]; &#125; else hou[x]=e[k].g; &#125; &#125; int xx[MAX_N*2],yy[MAX_N*2]; void main() &#123; scanf("%d",&amp;op); int n,m;scanf("%d%d",&amp;n,&amp;m); if(m==0) &#123;puts("YES");return;&#125; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;xx[i],&amp;yy[i]); ins(yy[i],xx[i]); if(op==1) ins(xx[i],yy[i]); dg1[xx[i]]++;dg2[yy[i]]++; &#125; int cc=0,st=1; for(int i=1;i&lt;=n;i++) &#123; sz=0;col(i); if(sz&gt;0) cc++,st=i; &#125; if(cc&gt;1) &#123;puts("NO");return;&#125; for(int i=1;i&lt;=n;i++) &#123; if(op==1 and (dg1[i]+dg2[i])%2==1) &#123;puts("NO");return;&#125; if(op==2 and dg1[i]!=dg2[i]) &#123;puts("NO");return;&#125; &#125; memset(v,0,sizeof v); ln=0;memset(hou,0,sizeof hou); for(int i=1;i&lt;=m;i++) &#123;ins(yy[i],xx[i]);if(op==1) ins(xx[i],yy[i]);&#125; euler(st); puts("YES");for(int i=0;i&lt;=(int)ans.size()-1;i++) printf("%d ",ans[i]); &#125;&#125;;int main()&#123; mine::main();&#125; 有向图流图只要有任意起点满足能到达每个节点该点被称为源点 有四种类型的边： 搜索树边 前向边，搜索树中x是y的祖先 后向边，搜索树中y是x的祖先 横向边，搜索树中，谁也不是谁的祖先，因为不是树边，一定满足$dfn_y &lt; dfn_x$ 强连通强连通图：其中任意两点都能互相到达的图强连通分量(SCC)：有向图极大强连通子图 tarjan算法找scc：首先，前向边没有贡献，后向边有贡献，而横向边看其能否贡献出一条路径，从y能回到x的祖先为了利用后向边和横向边，需要维护一个栈，保存【x的祖先】和【子树内能前往x的祖先的的点】追溯值low：【在栈中，而且能够从x的子树内出发被到达的节点】的最小dfn 那么具体实现的时候 加入栈中 遍历所有边，如果没访问过就是子树内节点，递归；否则判断是不是栈中的节点，有两种可能【祖先】或者【在子树内并且能前往祖先的】这两个的dfn恰好是我们想要的（为什么这么恰好待会解释） 判断是否 $low_x = dfn_x$ ，若是，意味着没有节点能访问祖先，则弹出栈中节点直到x被弹出 之所以在栈中没有【在子树内而不能前往祖先的】，是因为这些节点已经出栈，作为其他scc的一部分了 对于能到祖先的点，显然不会满足等于自己这个条件，应该交给那个祖先去处理，所以在栈中保留 那么，对所有scc缩点后，就会得到一个dag（有向无环图） 必经点、必经边从s到t，所有路径上都存在的点必经边也类似 在普通有向图上求据说要使用支配树不过在一个有向无环图上，可以用拓扑统计到这里的路径数量，再跑一次反图那么枚举每个点，或者边，根据乘法原理检验即可但是数字可能太大，可以考虑搞点模数来校验 至于无向图就比较简单了，可以用相应的dcc去缩点 无向图的独立集和团独立集：任意两点间没有边相连团：任意两点都有一条边相连 定理1：最大团大小=补图（对于边集的补集）的最大独立集大小定理2：见套路集锦中二分图项目 有向无环图的最小路径点覆盖简称最小路径覆盖，就是用最少数量的简单路径，覆盖每个点恰好一次解决方法：分析题意，因为点只能覆盖一次，对于路径上面的点，入度和出度不能超过1，而且至少一个是1把每个点，拆分成入度点和出度点，那么就形成了一个二分图，按照原图的边来构图即可 【最少路径数量】=【最少的终点】=【最少的出度=0】=【最少的出度点失配】所以数量就是n-最大匹配当然，用起点也可以，入度为0也就是右边的无匹配，不影响柿子 那么如果允许多次覆盖相同的点呢？这就是最小路径可重复点覆盖问题整个问题可以说变复杂了，也变简单了对于联通的两个点x和y，其实是可以直接添加一条边的，对答案没有影响这个可以用传递闭包实现 练习自行搜索tag]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-2并查集]]></title>
    <url>%2Fposts%2Fa89d.html</url>
    <content type="text"><![CDATA[3.3.1定义并查集，顾名思义就是有“合并集合”和“查找集合”两种操作的关于数据结构的一种算法。 用途1、维护无向图的连通性。支持判断两个点是否在同一连通块内，和判断增加一条边是否会产生环。2、用在求解最小生成树的Kruskal算法里。 初始化自己是自己的老大 3.3.2 代码1234567891011121314151617181920找老大：int findfa(int x)0&#123; if(fa[x]==x) return x; return fa[x]=findfa(fa[x]);&#125;合并：void join(int x,int y)&#123; int fx=findfa(x),fy=findfa(y); if(fx!=fy) fa[fx]=fy;&#125;检测环：for(int i=1;i&lt;=边数;i++)&#123; int q=findfa(b[i].x); int w=findfa(b[i].y); if(q==w) return 1;//如果在一个集合，就找到了环 join(q,w);&#125; 3.3.3 进阶练习魏总数星星星球大战 3.3.4 所有题目Tag-并查集 拓展进阶上文用到的合并方法叫做路径压缩，均摊log另外有种优化方法叫“按秩合并”，也是启发式合并的一种应用就是每次把小的合并到大的里面，在这里可以用大小来表示那么均摊也是log 然后如果两者合并，根据tarjan的论文证明，总是小于5的]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-1最短路]]></title>
    <url>%2Fposts%2F8720.html</url>
    <content type="text"><![CDATA[最短路 定义松弛：常听人说松弛，一直不懂，后来明白其实就是更新某点到源点最短距离。邻接表：表示与一个点联通的所有路。负权回路：从一个点沿着某条路径出发，又回到了自己，而且所经过的边上的权和小于0,该回路将导致算法不停循环以更小。零环：边权都是0，理论上最短路将有无数种方案。 回归正题，SPFA是bellman-ford的一种改进算法，由1994年西安交通大学段凡丁提出。它无法处理带有负环的图（其实应该没有能处理负环的算法），判断方法：如果某个点进入队列的次数超过N次则存在负环。SPFA的两种写法，bfs和dfs，bfs判别负环不稳定，相当于限深度搜索，但是设置得好的话还是没问题的，dfs的话判断负环很快（看不懂，喜欢宽搜）。 DFS版123456789101112131415161718int n; //表示n个点，从1到n标号int s,t; //s为源点，t为终点int d[N]; //d[i]表示源点s到点i的最短路bool vis[N];//vis[i]=1表示点i在队列中int spfa_dfs(int x)&#123; v[x]=true; for(int k=hou[x];k!=0;k=e[k].next) &#123; int y=e[k].y,c=e[k].c; if(d[y]&gt;d[x]+c) &#123; d[y]=d[x]+c; if(v[y] or spfa_dfs(y)) return true; &#125; &#125; v[x]=false;&#125; 3.1.3 BFS版结合题目来看看：【题目描述】给出一个有N个节点，M条边的带权有向图.判断这个有向图中是否存在负权回路.如果存在负权回路, 只输出一行-1;如果不存在负权回路,求出一个点S到每个点的最短路的长度.约定:S到S的距离为0,如果S与这个点不连通,则输出NoPath.点数N,边数M,源点S;以下M行,每行三个整数a,b,c表示点a,b之间连有一条边,权值为c如果存在负权环,只输出一行-1,否则按以下格式输出共N行,第i行描述S点到点i的最短路:如果S与i不连通,输出NoPath;如果i=S,输出0;其他情况输出S到i的最短路的长度【样例输入】6 8 11 3 41 2 63 4 -76 4 22 4 53 6 34 5 13 5 4【样例输出】0 6 4 -3 -2 7 3.1.4 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485struct point&#123; int ans; //距离源点的最短距离 int hou; //最后的儿子 int p; //被放进序列(list)的次数统计 int v; //是否在序列(list)中&#125;a[99999];struct road&#123; int x,y,c,g;//起点、终点、长度和哥哥&#125;b[99999];void BuildRoad(void);void ShortRoad(int);int list[99999],n,m,s,k;//路的数量bool bo;int main()&#123; scanf("%d %d %d",&amp;n,&amp;m,&amp;s); k=0; for(int i=1;i&lt;=n;i++) a[i].hou=0;//放在建路之前 for(int i=1;i&lt;=m;i++) BuildRoad(); bo=true; for(int i=1;i&lt;=n;i++) &#123; ShortRoad(i);//寻找负权回路 if(bo==false) &#123; printf("-1"); return 0; &#125; &#125; ShortRoad(s); for(int i=1;i&lt;=n;i++) if(a[i].ans==99999999) printf("NoPath\n"); else printf("%d\n",a[i].ans);&#125;void BuildRoad(void)&#123; int x,y,c; scanf("%d %d %d",&amp;x,&amp;y,&amp;c); k++; b[k].x=x; b[k].y=y; b[k].c=c; b[k].g=a[x].hou; a[x].hou=k;&#125;void ShortRoad(int st)&#123; for(int i=1;i&lt;=n;i++) &#123; a[i].ans=99999999; a[i].p=0;a[i].v=0; &#125; a[st].ans=0;a[st].p=1; a[st].v=true;list[1]=st; //放入序列中 int tou=1,wei=2; if(wei&gt;n) wei=1;//循环数组 while(tou!=wei) &#123; int x=list[tou]; for(int i=a[x].hou;i&gt;0;i=b[i].g) &#123; int y=b[i].y; if(a[y].ans&gt;a[x].ans+b[i].c) &#123; a[y].ans=a[x].ans+b[i].c;//松弛 if(a[y].v==false)//如果还没有放入 &#123; a[y].p++; if(a[y].p&gt;n) &#123; bo=false; return; &#125; a[y].v=0;list[wei++]=y; if(wei==n+1) wei=1; &#125; &#125; &#125; a[x].v=false;tou++; if(tou==n+1) tou=1; &#125;&#125; 3.1.5 一些补充以下内容更新于2018.8.29spfa的时间复杂度为 $O(km)$在稀疏图上，k很小，但在稠密图上，有可能被卡成 $O(nm)$ 介绍两个优化策略，通常来说能稍微提高效率SLF（Small Label First）优化（本机房俗称酸辣粉优化）：基于双端队列（deque）的思想，更新完disy后，如果它比队头小，就放在前面，否则放在后面然后如果没有负权边，可以用个堆取最小值，即堆优化spfa，但这个是没有任何意义的，spfa的唯一一点点优势就是负权边，现在这样搞，那不如写dijkstra堆优化（其实单纯写法上只是标记是否清空而已） LLL（Large Label Last）优化（本机房俗称啦啦啦优化）：维护队列的平均值，如果队首比平均值小，就丢到后面去 总的来说，这两个优化策略的基本思路就是不用堆，保持能处理负权边的特性，但是又能尽量取出小的节点去拓展 最后，对于判断负权回路，还有第二种方式：记录每个节点当前最短路径的边数，超过cnt则跳出，通常会更快一些 3.1.6 练习智捅马蜂窝(变化不大) Dijkstra在无负权的图中，找最短路可防止被卡边（spfa容易被卡）时间复杂度相对没那么玄学，比较稳定（如果慢，那就真的慢） 简单讲讲dijkstra算法基于贪心思想，每次找最小的dist来更新这是因为，当边长都是非负数的时候，全局最小的那个dist显然不会再被更新，所以已经是最短路径堆优化就是在找最小的dist的时候，用堆维护，时间复杂度从 $O(n^2)$ 变成 $O(mlogn)$ 总结参考：Here floyd这个算法用于求所有点对的最短距离，时间复杂度为O(n^3)。【无法判断、计算含有负环的图】 依次扫描每一点(k)，并以该点作为中介点，计算出通过k点的其他任意两点(i,j)的最短距离，这就是floyd算法的精髓！同时也解释了为什么k点这个中介点要放在最外层循环。 其实就是运用动态规划的思想。 代码12345678910void floyd()&#123; memset(dis,127,sizeof(dis)); for(int i=1;i&lt;=n;i++) dis[i][i]=0; for(int k=1;k&lt;=n;k++)//中介点 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);&#125; up 2018.8.29floyd的正确性证明：设$dis[k][i][j]$表示只经过编号小于k的点，从i到j的最小距离那么对于任意一条最短路径，可以想象为分割的，然后以k为阶段，长度递增，逐渐合并具体实现的时候，只要把k放在外面，就可以通过滚动数组，省去第一维 找无向图最小环：加入一句1ans=min(dis[i][j]+dis[i][k]+dis[k][j]); 即可韵味自行理解其实就是假设这个环，编号最大那个为k不过要注意一点，就是要针对实际需求，看要不要打上i!=j等三个条件例题：poj1734 Sightseeing trip 然后无向图的话，因为两个点也能组成（甚至一个点）所以不需要对环的大小作限制，可以直接扫一次dis[i][i]例题：vijos1423123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=210; const int INF=0x3f3f3f3f; int w[MAX_N]; int dis[MAX_N][MAX_N]; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]); memset(dis,63,sizeof dis); while(m--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c);c+=w[x]; if(c&lt;dis[x][y]) dis[x][y]=c; &#125; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(dis[i][j]&gt;dis[i][k]+dis[k][j]) dis[i][j]=dis[i][k]+dis[k][j]; printf("%d ",dis[1][1]==INF?-1:dis[1][1]); &#125;&#125;;int main()&#123; mine::main();&#125; 当然如果跑dijkstra+heap把起点更新后，d[st]=正无穷，下一次取出也是最小环长度]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-16博弈]]></title>
    <url>%2Fposts%2Fc7bb.html</url>
    <content type="text"><![CDATA[博弈 有向图游戏在一个DAG中，只由一个起点，上面有一个棋子，两个玩家轮流沿着有向边推动棋子，不能走的玩家判负 NIM博弈n堆物品，每堆有ai个，两个玩家轮流任选一堆来取物品，但不能不取，取走最后一个物品者获胜（不能取的玩家判负）不难发现NIM博弈是由n个有向图游戏组成的 定理：先手必胜，当且仅当异或和 $\neq 0$证明可用数学归纳法，从游戏结束开始分析，每次给对面一个平衡状态（异或和=0） 公平组合游戏ICG 两个玩家交替行动 能执行的操作与具体玩家无关 不能行动的玩家判负 mex运算与SG函数定义mex为，非负整数集合S中，最小的不属于集合S的非负整数 对于状态x，有k个后继状态y$SG(x)=mex( { SG(y_1),SG(y_2)…SG(y_k) } )$ 而对于多个有向图游戏，定义有向图游戏的和为，它们sg(起点)的异或和 定理：有向图游戏的某个局面必胜，当且仅当其对应节点，sg函数值大于0（能到达必败终点） 例题：数学 斐波那契博弈好神奇啊……有一堆石子共有N个。A B两个人轮流拿，A先拿。每次拿的数量最少1个，最多不超过对手上一次拿的数量的2倍（A第1次拿时要求不能全拿走）。拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。 结论：先手必胜，当且仅当 原本的石子数量为斐波那契数]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-15-Lucas及其拓展]]></title>
    <url>%2Fposts%2Fbb31.html</url>
    <content type="text"><![CDATA[Lucas及其拓展 Lucas条件：Mod是素数公式：$C_n^m=C_{n/Mod}^{m/Mod} \times C_{n \mod Mod}^{m \mod Mod} (\mod Mod)$证明 拓展Lucas 一阶条件：Mod是素数的次幂，即$Mod=p^k$ 做法： 根据组合数公式，如果能求出$n! \mod p^k$，那么就能计算出其值 因为是阶乘，把它表示出来$1 2 … Mod … Mod^2 … Mod^3 … Mod^t … n$然后，因为我们要求逆元，必须保证与Mod互质，所以要先把p的倍数全部提出 $$(1=&gt;Mod-1) \\(Mod+1=&gt;2 \times Mod-1) \\… \\((t-1) \times Mod+1 =&gt;t \times Mod-1) \\t \times Mod+1 =&gt; n 【暴力处理，跳过p的倍数】$$以及$p^t \times (1=&gt;t)$ 那么每个括号在模意义下，值是一样的，所以递归下去就好了，后面那个括号也是递归下去就好了唯一要在里面处理的就是暴力枚举从$t \times Mod+1到n$，看做是Mod的复杂度总之，这个复杂度是$O(Mod log_{Mod} n)$ 等阶乘和逆元处理完后，处理p的倍数那么因为一定能整除，可以用logn分别求出上和下次数，然后相减得出次数，最后带模快速幂一下就好了求次数的做法在阶乘分解中提到过 拓展Lucas 二阶条件：无对于一个更为一般的Mod，将其分解因式$Mod=p_1^{k_1} \times p_2^{k_2} … \times p_t^{k_t}$ 然后我们要用到中国剩余定理CRT你可能会问，这东西不是能被exgcd完美替代吗？我们其实是要用一下它的形式，而不是仅仅是解方程 把其答案和方程组对调，发现变成了【左边都一样，右边从一个大模数A拆分成多个小模数A’】我们现在想要求出组合数x在大模数下的值，把大模数拆分为多个互质的小模数这样子就得到了多个线性同余方程组，而在小的方程中，因为模数小，许多操作（如预处理逆元等）都便利许多 回归正题，对于每个小的同余方程，调用【拓展Lucas 一阶】即可 例题：礼物]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>Lucas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-14快速傅里叶变换]]></title>
    <url>%2Fposts%2F4db.html</url>
    <content type="text"><![CDATA[简介快速傅里叶变换(Fast Fourier Transform),简称FFTOI中主要要来加速多项式乘法 声明预备知识：实数，虚数定义n=第一个多项式最高次+1，m=第二个多项式最高次+1以$(4x^3+5)\times (x^2-6x+\sqrt3)$为例n=4，m=3 转化对于x的多项式可以转化为对于x的函数f(x)函数f(x)有两种表达方式：系数表达法和点值表达法 系数表达法最常见的表达方式$f(x)=a_0x^0+a_1x^1+…+a_{n-1}x^{n-1}=\sum_{j=0}^{n-1}a_j x^j$ 点值表达法原理：假设f(x)的最高次数为n−1，那么我们只要知道了n个不相同的x及f(x)值，就能确定出f(x)的多项式。例如确定一个二次函数需要三个不同的点，因为有三个变量那么要得到多项式乘积对应的函数，需要$(n-1)+(m-1)+1=n+m-1$个点 函数的加法运算对于系数表达法，各项系数对应相加对于点值表达法，x相同的点y值相加 例如：$A(x)=x^2+2x-1$可以被表达为$(0,-1),(1,2),(2,7)$$B(x)=x^2-x+2$可以被表达为$(0,2),(1,2),(2,4)$$C(x)=A(x)+B(x)=2x^2+x+1$可以被表达为$(0,1),(1,4),(2,11)$ 两者势均力敌嗯这个并不会用到，毕竟我们要解决的是多项式乘法 函数的乘法运算对于系数表达法，将前面的每个项依次与后面的每个项乘机之和，时间复杂度$\Theta(n\times m)$对于点值表达法，x相同的点y值相乘，时间复杂度$\Theta(n+m-1)$ 例如：$A(x)=x^2+2x-1$可以被表达为$(0,-1),(1,2),(2,7),(3,14),(4,23)$$B(x)=x^2-x+2$可以被表达为$(0,2),(1,2),(2,4),(3,8),(4,14)$$C(x)=A(x)\times B(x)=x^4+x^3-x^2+5x-2$可以被表达为$(0,-2),(1,4),(2,28),(3,112),(4,322)$可以发现A(x)和B(x)一定要取足够多（即n+m-1个）点 这就是快速傅里叶变换的精髓：利用点值表达法比系数表达法在乘法中更快 思路引入新定义：求值：通过多项式的系数表示法求其点值表示法。插值：通过多项式的点值表示法求其系数表示法。显然上面两个定义是互逆的关系。 方法：引用别人的一幅图，灰常清晰（如果图没了就算了） FFTFFT就是用来解决求值的过程的，可以在$\Theta(nlogn)$的时间里完成DFT分析一下如何得到最终的多项式吧。 求A的n+m-1个单位根的点值，求B的n+m-1个单位根的点值。 点值相乘，得到C的点值。 计算C的多项式。步骤2可以直接$\Theta(n+m-1)$得出，重点是步骤1和3 单位根中途插叙这个数学上的概念，有点难，要挺过去。复数，就是实数+虚数，两者只能和同类型的运算，符号$i$表示是一个虚数，$i\times i=-1$n次单位复数根，就是满足$\omega^n=1$的复数值$\omega$(念omega)在实数范围下，满足所有n的有1，对于偶数n还有-1，然鹅在复数范围下$\omega$将更加广泛。下文的n和这道题的n暂时无关。 单位根性质-简单 n次单位复数根恰好有n个，标号k从0到n-1 预备知识$e^t=cos(t)+sin(t)i$，注意cos是实数sin是虚数 $\omega_n^k=e^{ \frac{k}{n}2\pi } i$，是值的定义，用于推性质 $\omega_n^k=cos(\frac{k}{n}2\pi)+sin(\frac{k}{n}2\pi)i$，是值的具体体现，用于代码实现 递推式：$ \omega_n^k=\omega_n^{k-1}\times \omega_n^1 $ 单位根性质-复杂消去引理：$\omega_{dn}^{dk} = \omega_n^k$这是利用定义得出的（因为指数是个分数，所以一样）推论：$\omega_{n/2}^{n} = \omega_2^1 = -1和1中的第一个=-1$，等下会用到。 折半引理：$(\omega_n^{k+n/2})^2=(\omega_n^k)^2 $ 证明：$$\omega_n^{k+n/2} )^2=\omega_n^{2k+n}=\omega_n^{2k}\times \omega_n^n=\omega_n^{2k}\times 1=\omega_n^{2k}=(\omega_n^k)^2$$至于其他定理和性质，因为本文不需要就不讲了，有兴趣的自行百度就好。 离散傅里叶变换DFT离散傅里叶变换(Discrete Fourier Transform)，简称DFT。为了方便，暂时将n设为需要带入的点数，不同于声明中的的n 我们的目的就是从系数得到点值表示法，已知需要代入n个点DFT的实质就是对一个多项式在n次单位根上求值，利用单位根的性质加速。 $$ f(x)=\sum_{j=0}^{n-1}a_jx^j $$求出x在$\omega_n^0, \omega_n^1, \omega_n^2…\omega_n^{n-1}$(即n个n次单位复数根)的y值，时间复杂度$\Theta(n^2)$。$$DFT(k)=y_k=f(\omega_n^k)=\sum_{j=0}^{n-1}a_j(\omega_n^k)^j=\sum_{j=0}^{n-1}a_j \omega_n^{jk}$$ 回到FFT-求值经典的分治又来了，也终于到正文了……它的神奇之处在于利用了n 次单位根的一些玄学性质，然后利用分治大大加速计算。 首先假设n是偶数，然后将偶数奇数下标分离$Q(k)=a_0+a_2\times k+a_4\times k^2+…+a_n\times k^{n/2-1}$$W(k)=a_1+a_3\times k+a_5\times k^2+…+a_{n-1}\times k^{n/2-1}$易得$A(k)= Q(k^2)+k\times W(k^2)$ 所以，求$A(k)在k=\omega_n^0, \omega_n^1, \omega_n^2…\omega_n^{n-1}$处的值就转换成为求$Q(k)和W(k)在k=(\omega_n^0)^2,(\omega_n^1)^2,(\omega_n^2)^2…(\omega_n^{n-1} )^2$处的值 当然这样只是相当于展开，是时候利用单位根的性质了。 $对于k&lt; n/2，A(\omega_n^{k})=Q((\omega_n^{k})^2)+\omega_n^k\times W((\omega_n^{k})^2)$$对于k\geq n/2，A(\omega_n^{k+n/2})=Q((\omega_n^{k+n/2})^2)+\omega_n^{k+n/2}\times W((\omega_n^{k+n/2})^2)$根据折半引理$(\omega_n^{k+n/2})^2=(\omega_n^k)^2$再次简化（主要是减少了带入次数）$(\omega_n^{k+n/2})^2=(\omega_n^k)^2$$Q(\omega_n^{k+n/2})=Q(\omega_n^k)$$W(\omega_n^{k+n/2})=W(\omega_n^k)$$\omega_n^{k+n/2}=\omega_n^k \times \omega_n^{n/2}=\omega_n^k \times -1=-\omega_n^k$$对于k\geq n/2，A(\omega_n^{k+n/2})=Q((\omega_n^{k})^2)-\omega_n^k\times W((\omega_n^{k})^2)$ 边界：$\omega_1^0=1$ 对了，有木有一种熟悉感？没错，等比数列二分求和的快速也是靠这个分治减少带入计算量！ 回到FFT-插值从x、y得到系数也就是插值又要怎么搞呢？丢个结论（额证明我也不会）：用$\omega_n^{-1}$的值代替$\omega_n^1$，根据递推式从而让所有的$\omega$都不同最后再将答案除以n，得到的便是逆DFT的结果。 再理理思路如果n是2的幂，一路分治下去，时间复杂度$\Theta(nlogn)$……如果n不是2的幂怎么办？很简单，强制取更多的点（并且是2的幂个），多项式前面的系数补0。综上所述，找到比n+m-1更大或相等的2的幂作为n 讲一个重要的细节：$A(k)= Q(k^2)+k\times W(k^2)$这个公式在代码里的体现是将平方拆开也就是n/2传给所谓Q、W（FFT）的，所以看起来没有平方 讲一道模版题FFT基本上就讲完了，但都是理论做法，下面结合例题来看。Caioj1449多项式乘法其实本文一直在解决这个问题。 递归版代码因为是递归，分治时n一直在变首先确定：当op=1也就是求值时进入函数时f[i]表示将被带入的多项式的系数（n个）结束函数时f[i]表示代入n次单位负数根第i个得到的值（n个）当op=-1则相反 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=410000;const double PI=acos(-1.0);struct cmplex&#123; double real,imag; cmplex() &#123;real=imag=0;&#125; cmplex(double r,double i) &#123;real=r;imag=i;&#125; cmplex operator + (const cmplex &amp;b) &#123; return cmplex(real+b.real,imag+b.imag); &#125; cmplex operator - (const cmplex &amp;b) &#123; return cmplex(real-b.real,imag-b.imag); &#125; cmplex operator * (const cmplex &amp;b) &#123; return cmplex(real*b.real-imag*b.imag,real*b.imag+imag*b.real); //(a+bi)(c+di)=ac+adi+bci+bdi^2=(ac-bd)+(ad+bc)i &#125; //baike.baidu.com/item/复数运算法则/2568041&#125;;void FFT(cmplex *a,int op,int n)&#123; if(n==1) return; cmplex q[n/2],w[n/2]; for(int i=0;i&lt;=n/2-1;i++) &#123; q[i]=a[i*2];//偶数 w[i]=a[i*2+1];//奇数 &#125; FFT(q,op,n/2);FFT(w,op,n/2);//分治 cmplex wk(1,0),w1( cos(2*PI*op/n) ,sin(2*PI*op/n) ); for(int k=0;k&lt;=n/2-1;k++,wk=wk*w1)//递推式求单位根wk &#123; a[k]=q[k]+wk*w[k]; a[k+n/2]=q[k]-wk*w[k]; &#125;&#125;cmplex a[MAXN],b[MAXN],c[MAXN];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;=n;i++) scanf("%lf",&amp;a[i].real); for(int i=0;i&lt;=m;i++) scanf("%lf",&amp;b[i].real); m=n+m;n=1;while(n&lt;m+1) n*=2; FFT(a,1,n);FFT(b,1,n);//求值,n个 for(int i=0;i&lt;=n-1;i++) c[i]=a[i]*b[i];//点值表达法的乘法运算 FFT(c,-1,n);//插值,n个 for(int i=0;i&lt;=m;i++) printf("%d ",int(c[i].real/n+0.5)); //输出系数(四舍五入后的实数部分)&#125; 优化递归实现FFT的做法容易爆栈，而且时间较长。给出两种解决方案：递归但不在函数里开数组、非递归 递归版代码2（个人独创版）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=410000;const double PI=acos(-1.0);struct cmplex&#123; double real,imag; cmplex() &#123;real=imag=0;&#125; cmplex(double r,double i) &#123;real=r;imag=i;&#125; cmplex operator + (const cmplex &amp;b) &#123; return cmplex(real+b.real,imag+b.imag); &#125; cmplex operator - (const cmplex &amp;b) &#123; return cmplex(real-b.real,imag-b.imag); &#125; cmplex operator * (const cmplex &amp;b) &#123; return cmplex(real*b.real-imag*b.imag,real*b.imag+imag*b.real); //(a+bi)(c+di)=ac+adi+bci+bdi^2=(ac-bd)+(ad+bc)i &#125; //baike.baidu.com/item/复数运算法则/2568041&#125;;cmplex t[MAXN];void FFT(cmplex *a,int op,int l,int r)&#123; int n=(r-l+1); if(n==1) return;//debug int lmid=n/2; int mid=l+lmid-1; for(int i=l;i&lt;=r;i++) t[i]=a[i]; for(int i=0;i&lt;=lmid-1;i++) &#123; a[l+i]=t[l+i*2];//偶数 a[l+lmid+i]=t[l+i*2+1];//奇数 &#125; //不复制好像也行？但代码复杂度较高 FFT(a,op,l,mid);FFT(a,op,mid+1,r);//n/2等价于平方 //for(int i=l;i&lt;=r;i++) t[i]=a[i]; cmplex wk(1,0),w1( cos(2*PI*op/n),sin(2*PI*op/n) ); for(int k=0;k&lt;=n/2-1;k++,wk=wk*w1)//递推式求单位根wk &#123; /*cmplex tt=wk*t[l+n/2+k]; a[l+k]=t[l+k]+tt;发现不用复制 a[l+n/2+k]=t[l+k]-tt;*/ cmplex tt=wk*a[l+n/2+k];//蝴蝶操作 a[l+n/2+k]=a[l+k]-tt;//先做这个 a[l+k]=a[l+k]+tt; &#125;&#125;cmplex a[MAXN],b[MAXN],c[MAXN];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;=n;i++) scanf("%lf",&amp;a[i].real); for(int i=0;i&lt;=m;i++) scanf("%lf",&amp;b[i].real); m=n+m;n=1;while(n&lt;m+1) n*=2; FFT(a,1,0,n-1);FFT(b,1,0,n-1);//求值,n个 for(int i=0;i&lt;=n-1;i++) c[i]=a[i]*b[i];//点值表达法的乘法运算 FFT(c,-1,0,n-1);//插值,n个 for(int i=0;i&lt;=m;i++) printf("%d ",int(c[i].real/n+0.5)); //输出系数(四舍五入后的实数部分)&#125; 想要非递归？递归实现FFT的做法容易爆栈，而且时间较长。 提示：找偶数奇数分治后的结果编号规律原本0(000) 1(001) 2(010) 3(011) 4(100) 5(101) 6(110) 7(111)最终0(000) 4(100) 2(010) 6(110) 1(001) 5(101) 3(011) 7(111)可以发现 不断偶数奇数分离后 每个数和他二进制相反的位置互换！！通俗点讲就是对于位置i，应当存放原位置是二进制翻转后的i的数值。（也有的博客称其为其数值来自的位置的翻转是递增的） 接下来就是预处理出i对应的翻转值了，有这样一个优美的方法：12for(int i=0;i&lt;=n-1;i++) R[i]= (R[i&gt;&gt;1]&gt;&gt;1) | ( (i&amp;1)&lt;&lt;(l-1) );//位运算DP求翻转，l=logn FFT中：12for(int i=0;i&lt;=n-1;i++) if(i&lt;R[i]) swap(a[i],a[R[i]]);//注意判断大小不然又换回来了 其实归根结底就是把递归中调用自己的部分的前面部分即偶数奇数分离预处理出，而后再层层合并上去。 非递归版代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//Zory-2017//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const double PI=acos(-1.0);const int MAXN=4*100000;//*******************全局定义*******************struct complex&#123; double r,i;//real,imag complex() &#123;r=i=0;&#125; complex(double rr,double ii) &#123;r=rr;i=ii;&#125; complex operator + (complex b) &#123;return complex(r+b.r,i+b.i);&#125; complex operator - (complex b) &#123;return complex(r-b.r,i-b.i);&#125; complex operator * (complex b) &#123;return complex(r*b.r-i*b.i,r*b.i+i*b.r);&#125; //(a+bi)(c+di)=ac+adi+bci+bdi^2=(ac-bd)+(ad+bc)i //baike.baidu.com/item/复数运算法则&#125;;//*******************实现*******************int R[MAXN+10];complex omega[MAXN+10];void CalcOmega(int n,int op)&#123; double t=2*PI*op/n; omega[0]=complex(1,0); omega[1]=complex(cos(t),sin(t)); for(int k=2;k&lt;=n/2-1;k++) omega[k]=omega[k-1]*omega[1];&#125;void FFT(complex *a,int n,int op)&#123; for(int i=0;i&lt;=n-1;i++) if(i&lt;R[i]) swap(a[i],a[R[i]]); //注意判断大小不然又换回来了 for(int L=1;L&lt;=n/2;L*=2)//合并前长度 &#123; CalcOmega(L*2,op); for(int j=0;j&lt;=n-1;j+=L*2)//开头,长度=L*2 &#123; for(int k=0;k&lt;=L-1;k++) &#123; complex x=a[j+k]; complex y=omega[k]*a[j+L+k]; a[j+k]=x+y; a[j+L+k]=x-y; //蝴蝶操作 &#125; &#125; &#125; if(op==-1) for(int i=0;i&lt;=n-1;i++) a[i].r=a[i].r/double(n);&#125;//*******************主函数*******************complex a[MAXN+10],b[MAXN+10];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;=n;i++) scanf("%lf",&amp;a[i].r); for(int i=0;i&lt;=m;i++) scanf("%lf",&amp;b[i].r); m=n+m+1;int log=0;n=1; while(n&lt;m) n*=2,log++; for(int i=0;i&lt;=n-1;i++) R[i]=( R[i&gt;&gt;1]&gt;&gt;1 ) | ( (i&amp;1)&lt;&lt;(log-1) ); //nlogn翻转二进制 FFT(a,n,1);FFT(b,n,1);//求值 for(int i=0;i&lt;=n-1;i++) a[i]=a[i]*b[i];//点值乘法 FFT(a,n,-1);//插值 for(int i=0;i&lt;=m-1;i++) printf("%d ",int(a[i].r+0.5)); //输出系数(四舍五入后的实数部分)&#125; 卷积最后再提提这个其实最重要的概念请牢记它，很多FFT的题目都需要将公式转化为这样A、B、C都是系数$C_i=\sum_{k=0}^i A_k \times B_{i-k}$ 推荐好文章精品：位于CSDN-心若为城位于CSDN-iamzky位于百度云-Rose位于百度文库-Voiphon位于CSDN-oiyangyuhao位于博客园-Neroysqmiskcoo1-位于CSDN-ACdreamers2-位于CSDN-ACdreamers 快速复习（考前适用） 函数的乘法运算对于系数表达法，将前面的每个项依次与后面的每个项乘机之和，时间复杂度$\Theta(n\times m)$对于点值表达法，x相同的点y值相乘，时间复杂度$\Theta(n+m-1)$ 求值与插值1.求A的n+m-1个单位根的点值，求B的n+m-1个单位根的点值。2.点值相乘，得到C的点值。3.计算C的多项式。 单位根 n次单位复数根恰好有n个，标号k从0到n-1 预备知识$e^t=cos(t)+sin(t)i$，注意cos是实数sin是虚数 $\omega_n^k=e^{ \frac{k}{n}2\pi } i$，是值的定义，用于推性质 $\omega_n^k=cos(\frac{k}{n}2\pi)+sin(\frac{k}{n}2\pi)i$，是值的具体体现，用于代码实现 递推式：$ \omega_n^k=\omega_n^{k-1}\times \omega_n^1 $ 消去引理：$\omega_{dn}^{dk} = \omega_n^k$推论：$\omega_{n/2}^{n} = \omega_2^1 = -1和1中的第一个=-1$，等下会用到。 折半引理：$(\omega_n^{k+n/2})^2=(\omega_n^k)^2 $ 求值首先假设n是偶数，然后将偶数奇数下标分离$Q(k)=a_0+a_2\times k+a_4\times k^2+…+a_n\times k^{n/2-1}$$W(k)=a_1+a_3\times k+a_5\times k^2+…+a_{n-1}\times k^{n/2-1}$易得$A(k)= Q(k^2)+k\times W(k^2)$ 所以，求$A(k)在k=\omega_n^0, \omega_n^1, \omega_n^2…\omega_n^{n-1}$处的值就转换成为求$Q(k)和W(k)在k=(\omega_n^0)^2,(\omega_n^1)^2,(\omega_n^2)^2…(\omega_n^{n-1} )^2$处的值 当然这样只是相当于展开，是时候利用单位根的性质了。 $对于k&lt; n/2，A(\omega_n^{k})=Q((\omega_n^{k})^2)+\omega_n^k\times W((\omega_n^{k})^2)$$对于k\geq n/2，A(\omega_n^{k+n/2})=Q((\omega_n^{k+n/2})^2)+\omega_n^{k+n/2}\times W((\omega_n^{k+n/2})^2)$根据折半引理$(\omega_n^{k+n/2})^2=(\omega_n^k)^2$再次简化（主要是减少了带入次数）$(\omega_n^{k+n/2})^2=(\omega_n^k)^2$$Q(\omega_n^{k+n/2})=Q(\omega_n^k)$$W(\omega_n^{k+n/2})=W(\omega_n^k)$$\omega_n^{k+n/2}=\omega_n^k \times \omega_n^{n/2}=\omega_n^k \times -1=-\omega_n^k$$对于k\geq n/2，A(\omega_n^{k+n/2})=Q((\omega_n^{k})^2)-\omega_n^k\times W((\omega_n^{k})^2)$ 边界：$\omega_1^0=1$ 插值用$\omega_n^{-1}$的值代替$\omega_n^1$，根据递推式从而让所有的$\omega$都不同最后再将答案除以n，得到的便是逆DFT的结果。 非递归找偶数奇数分治后的结果编号规律原本0(000) 1(001) 2(010) 3(011) 4(100) 5(101) 6(110) 7(111)最终0(000) 4(100) 2(010) 6(110) 1(001) 5(101) 3(011) 7(111)可以发现 不断偶数奇数分离后 每个数和他二进制相反的位置互换！！通俗点讲就是对于位置i，应当存放原位置是二进制翻转后的i的数值。（也有的博客称其为其数值来自的位置的翻转是递增的） 接下来就是预处理出i对应的翻转值了，有这样一个优美的方法：12for(int i=0;i&lt;=n-1;i++) R[i]= (R[i&gt;&gt;1]&gt;&gt;1) | ( (i&amp;1)&lt;&lt;(l-1) );//位运算DP求翻转，l=logn FFT中：12for(int i=0;i&lt;=n-1;i++) if(i&lt;R[i]) swap(a[i],a[R[i]]);//注意判断大小不然又换回来了 其实归根结底就是把递归中调用自己的部分的前面部分即偶数奇数分离预处理出，而后再层层合并上去。]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>原创精华</tag>
        <tag>快速傅里叶变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-13莫比乌斯反演]]></title>
    <url>%2Fposts%2Fd81d.html</url>
    <content type="text"><![CDATA[前方高能！请先学好线性筛 update:2017.11.27 莫比乌斯函数能使用线性筛获得是因为它是一个积性函数（注意并不是完全积性函数），而一个质数与任何数必定互质，所以能用后文介绍的方法求得。 注意：本文提到的除法运算都是向下取整，因为小数部分完全没有意义。 莫比乌斯反演,需要使用到一个名为莫比乌斯函数的东东即所谓 $\mu$(mu)函数 $\mu$函数的运用我们先不解释$\mu$(mu)函数，而是假设我们已经求得它，并尝试利用它做题例题：GCD-莫比乌斯1求数对(x,y)满足$gcd(x,y)=k$,其中$x\leq b,y\leq d$并且(1,2)和(2,1)算一对 解：先简化问题为$gcd(x,y)=1$,其中$x\leq b/k,y\leq d/k$为方便表示设n=b/k,m=d/k 设f(t)为满足gcd(x,y)=t的对数,其中$x\leq n,y\leq m$,本题相当于求f(1) 由于直接求f(t)较困难,考虑另一个函数F(d)为满足gcd(x,y)%d=0的对数,其中$x\leq n,y\leq m$,又因为两个数的最大公约数不可能超过任何一个数,所以$t和d \leq min(x,y)$ 当然$ t和d \leq min(n,m)$易知$F(d)=\frac{n}{d} \times \frac{m}{d}$ 算了还是证明一下这个“易知”吧x可以是$d或2d或3d\ldots一直到ad(\leq n)$，共$\frac{n}{d}个$y也可以是$d或2d或3d\ldots一直到bd(\leq m)$，共$\frac{m}{d}个$所以就是$\frac{n}{d} \times \frac{m}{d}$ 所以，F(d)可以轻松地算出，接下来就是要从F(d)反演出f(t)他们有如下关系（属于“倍数”类，另一种是约数类）$ F(d)=\sum f(t) 要求满足d|t且t\leq min(n,m) $通过莫比乌斯反演的倍数版公式转化为（原理是运用容斥，具体证明一会再讲）$ f(t)=\sum \mu(\frac{d}{t}) \times F(d) 要求满足t|d且d\leq min(n,m) $ G(a,b)为当n=a，m=b时的f(1)这道题的最后答案就是G(n,m)-G(n,n)/2 （假设n&lt;=m）原因可以看这幅图（转载）:也就是右边的公共部分只能取一半，所以减去另外不需要的一半。 $\mu$函数的计算和证明显然，$\mu$函数可以理解为一种针对F(d)的系数值为了与刚才的题目运用的公式不同从而让读者有更广泛的认知以及便于证明【因为倍数版太长啦！所以例题是倍数版，但我们计算和证明用约数版】约数版公式：$ f(t)=\sum \mu(\frac{t}{d}) \times F(d) 要求满足d|t且d\leq min(n,m) $ 额$\mu$这个符号比较麻烦，下文我可能用U表示相同的意义 $\mu$有以下性质(有原因，一会再解释)：$\mu(x)=1$ 当且仅当x能够分解成偶数个不同质数的乘积（其中1不能被分解，所以1的分解出的质数个数是0，所以U[1]=1）$\mu(x)=-1$ 当且仅当x能够分解成奇数个不同质数的乘积$\mu(x)=0$ 除开(2),(3)的其他情况 看上面关于$\mu$的定义可能有点看晕了，通俗一点的说:对于一个 x ,分解因式过后有 $x=(p_1^{e_1})(p_2^{e_2})…(p_r^{e_r})$$如果e_i中(1&lt;=i&lt;=r)有一个数大于1 那么 U[x]=0 $$不然的话 U[x]=(-1)^r$ 来几个栗子U[1]=1; 定义U[2]=-1;分解式 $2=2$U[6]=1; 分解式 $6=2\times 3$U[9]=0; 分解式 $9=3^2$U[12]=0;分解式 $12=2^2\times 3$ 设H(d,t)是计算f(t)时F(d)的系数然后从栗子中找规律$F(8)=H(8,8)\times G(8)+H(4,8)\times G(4)+H(2,8)\times G(2)+H(1,8)\times G(1) $举栗子自己推算，可以发现$H(d,t)=H(1,\frac{t}{d})$，于是我们把H的第一个元素略去，简写为H(x)，也就是如今的$\mu(x)$【这就是为什么上面的公式，$\mu$这个系数，下标是个这样的分数了】 好了性质讲完了，那为什么有这样的性质呢？我们边讲 计算，边证明这些性质【所以先忘记性质】： 首先需要明确2点！一是 F(x)中,一定包含一个f(1)，因为 1|x二是 f(1)=F(1) 【显而易见】 接下来从多种角度尝试，具体推算过程就略过了，自己动手试试吧~(0).如果 x=1，因为 f(1)=F(1) 所以 $\mu(1)=1$(1).假设 x 是一个 质数 ，易知 $\mu(x)=-1$(2).假设 x 可以写成2个不同质数的乘积，易知 $\mu(x)=1$(3).假设 x 可以写成3个不同质数的乘积，易知 $\mu(x)=-1$(4).假设 x 可以写成r个不同质数的乘积，易知 $\mu(x)=(-1)^r $(5).假设 x 可以写成一个质数的平方$ x=p^2 $，易知 $\mu(x)=0$(6).假设 x 可以写成一个质数的次幂$ x=p^g $，易知 $\mu(x)=0$总而言之，$\mu$函数的求法也就是其性质了，所以可以用线性筛素数来预处理出莫比乌斯函数【据说莫比乌斯函数在任何题目都不会变，变化的只是F(x)和f(x)的定义】 那么我写这一段的原因在于，不要只是单纯地记住这个性质，而是应该试图理解这是怎么来的。 $\mu$函数的特性 积性函数 当n&gt;1，$ \sum_{d|n} \mu(d)=0 $，当n=1则是1 $\sum_{d|n} \frac{\mu(d)}{d}=\frac{\varphi(n)}{n}$ 公式倍数和公式$F(d)=\sum f(t) 要求满足d|t $$f(t)=\sum \mu(\frac{d}{t})\times F(d) 要求满足t|d$约数和公式$F(d)=\sum f(t) 要求满足t|d $$f(t)=\sum \mu(d)\times F(\frac{t}{d}) 要求满足d|t$ （网上好像常见这个）$f(t)=\sum \mu(\frac{t}{d})\times F(d) 要求满足d|t$ （其实这个也是等效的） 莫比乌斯所有题目Tag-莫比乌斯反演]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>原创精华</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-12组合数学]]></title>
    <url>%2Fposts%2Fb51f.html</url>
    <content type="text"><![CDATA[前半部分为自己的创作后半部分为转载，因为并没有去理解 普通排列（在乎顺序）全排列n个人全部来排队，队长为n。第一个位置可以选n个，第二个位置可以选n-1个，以此类推得：$$P(n,n)=n\times (n-1)\times (n-2)……3\times 2\times 1=n! (规定0!=1)$$ 部分排列n个人选m个来排队(m&lt;=n)。第一个位置可以选n个，第二位置可以选n-1个，以此类推，第m个（最后一个）可以选(n-m+1)个，得：$$P(n,m)=n\times (n-1)\times (n-2)……(n-m+1)=\frac{n!}{(n-m)!}$$ 普通组合（不在乎顺序）n个人m(m&lt;=n)个出来，不排队，不在乎顺序C(n,m)。如果在乎排列那么就是P(n,m)，如果不在乎那么就要除掉重复，那么重复了多少？同样选出的来的m个人，他们还要”全排”得到P(m,m)，所以得:$$C(n,m)=\frac{P(n,m)}{P(m,m)}=\frac{n!}{m!(n-m)!}$$组合数的性质1:$$C(n,m)=C(n-1,m)+C(n-1,m-1)$$组合数的性质2: n&amp;k==k 则c(n,k)为奇数，否则为偶数 组合数与11与杨辉三角与二项式定理（原创）（做题碰到二项式定理，然后猜了一些，再上网验证）11 11 2 11 3 3 11 4 6 4 11 5 10 10 5 1……这是经典的杨辉三角（Pascal’s Triangle），哪怕是小学时也见过吧然后我从初三学生的角度看看这玩意 特点： 对称 从1开始，在1结束 第i行第j个（从0开始）=$C(i,j)$ 如果把空格隔开的数看作数字，成为一个无限进制数，则转化为10进制后，第i行=$11^{i-1}$ 因为是组合数三角，所以也是二项式定理三角（据说这就是初衷）然后这些是我没想到的： 第i行数字和为$2^{i-1}$ 【这其实就是组合数的和，选和不选两种情况】 $C(i,j)=C(i-1,j-1)+C(i-1,j)$ 多重集也就是允许元素重复的广义集合表示为$S={n_1 \cdot a_1,n_2 \cdot a_2,…n_k \cdot a_k}$ 全排列$\frac{n!}{n_1! \times n_2! … \times n_k!}$ 组合设选r个先考虑较为特殊的$r \leq n_i (\forall i \in [1,k])$然后我们就能直接把问题转化为求 $S={r \cdot 0,k-1 \cdot 1}$ 的全排列所以得到 $\frac{ (r+k-1)! }{r! \times (k-1)!}=C_{r+k-1}^{r}$ 例题：Counting Swaps 那如果不是这样特殊的r个呢？对问题取补，$ans=C_{r-k+1}^{r}-非法数量$而非法数量，就是说存在一个i，取的数量达到了$n_i+1$ 那么我们枚举出每个数的非法情况，然后每个非法的数字，都先定向删除$n_i+1$个，然后照常取【$r-已经删除的数量$】个 因为状态的重复，联想一下小学的时候学的简单容斥，不难算出如果非法数量num是奇数，就减去，偶数就补回去具体实现可以枚举二进制数来搞 例题：CF451E Devu and Flowers Catalan数问题有多少个01序列满足【任意前缀中，0的个数不少于1的个数】 通项公式$Cat_n=\frac{C_{2n}^n}{n+1}$ 性质 $Cat_n=C_{2n}^n-C_{2n}^{n-1}$，可以由定义得出 $Cat_n=\sum Cat_a \times Cat_{n-a-1}$ 应用 简单应用，例如【合法括号序列】、【出栈序列】 由性质2这个递推式可知，能够解决【不同形态二叉树】 错排问题求有多少个1~n的排列，满足每个$a_i \neq i$ 递推式考虑元素1，找到2~n中的k，使$a_k=1$，k有n-1种取值① $a_1=k$，此时相当于剩下n-2个元素，进行错排② otherwise，此时相当于剩下n-1个元素，进行错排所以$D_n=(n-1)(D_{n-1}+D_{n-2})$ 通项公式考虑容斥原理首先，总排列数=$n!$假设固定1个在正确位置上，有 $C_n^1$ 个选择，而其他人的排列为 $(n-1)!$ 个但不难发现，此时2个的情况，会在1固定和2固定的时候计算两次，所以要补回来补回来的话，3个的情况，会在12固定和23固定的时候计算两次，又要减回去……大概意会一下……按照这样的思路，不难得出通项公式$D_n=\sum (-1)^i C_n^i (n-i)!=\sum (-1)^i \frac{n!}{i!}$ (下文不保证正确性，因为我也不会) 2.3.3其他排列与组合(1)圆排列n个人全部来围成一圈为Q(n,n)，其中已经排好的一圈，从不同位置断开，又变成不同的队列。所以：$$Q(n,n)=\frac{P(n,n)}{n}=(n-1)!$$由此可知，部分圆排:$$Q(n,r)=\frac{P(n,r)}{r}=\frac{n!}{r\times (n-r)!}$$ (2)重复排列(有限)k种不一样的球，每种球的个数分别是a1,a2,…ak,设n=a1+a2+…+ak，这n个球的全排列数，为$$\frac{n!}{a1!\times a2!\times …\times ak!}$$ (3)重复组合(无限)n种不一样的球，每种球的个数是无限的,从中选k个出来，不用排列，是组合，为C(n+k-1,k)证明：假设选出来的数（排好序）$$1&lt;=b1&lt;=b2&lt;=b3……&lt;=bk&lt;=n$$这题的难点就是=号，现在去掉=号，所以有：$$1&lt;=b1&lt;b2+1&lt;b3+2&lt;b4+3……&lt;bk+k-1&lt;=n+k-1$$中间还是k个数！不过已经不是b系列，而是c系列假设c[i]:=b[i]+i-1，所以$$1&lt;=c1&lt;c2&lt;c3&lt;c4……&lt;ck&lt;=n+k-1$$所以问题就开始转换为无重复组合问题，即在n+k-1个元素中选中k个的组合数C(n+k-1,k)。 (4)不相邻排列1~n这n个自然数中选k个，这k个数中任何两个数不相邻数的组合有C(n-k+1,k)证明和(3)相同。 (5) stirling数（子集划分）性质：① S(n,m)= m*S(n-1,m) + S(n-1,m-1)② S(n,1)=1,S(n,0)=0, S(n,n)=1例：将n个数（1，2，…，n）分成r个部分。每个部分至少一个数。将不同划分方法的总数记为S(n,r)。例如，S(4,2)=7，这7种不同的划分方法依次为 { (1) , (234) }，{ (2) , (134) }，{ (3) , (124)}，{ (4) , (123) }，{ (12) , (34) }，{ (13) ,(24) }，{ (14) ,(23) }。当n=6，r=3时，S(6,3)=？题解：先固定一个数，对于其余的5个数考虑S(5,3)与S(5,2)，再分这两种情况对原固定的数进行分析。最后得到：S(6,3)=90。 写得也不错的:组合数学]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>二项式定理</tag>
        <tag>杨辉三角</tag>
        <tag>错排</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-11-BSGS]]></title>
    <url>%2Fposts%2Fc508.html</url>
    <content type="text"><![CDATA[BSGS，用于解决高次同余问题据说利用了分块的思想 BSGS算法，原名Baby Steps Giant Steps，又名大小步算法，拔山盖世算法，北上广深算法——by SLYZoier 问题$a^x=b (\mod p)$求最小正整数x BSGS算法条件：$gcd(a,p)=1$然后这样就能用欧拉定理了当然等会在柿子的移项中，也会暗中用到逆元。 我们只需要验证在$x=0~ \varphi(x)-1$中是否有解就行了如果这中间都不行，那么后面都是循环，也就没可能了然后如果对复杂度没有什么要求的话，就没必要算phi了，现在确保是在p以内就好了 如果直接枚举x，显然过慢我们引入分块思想中的根号，换一种方式枚举x 设$x=i \times m-j,m=\lceil \sqrt p \rceil$，其中$1 \leq i \leq m , 0 \leq j \leq m$那么原方程就能变形为$(a^m)^i=b \times a^j (\mod p)$那么只要把$b \times a^j (\mod p)$全部塞到一个hash表或者map里面，再枚举$(a^m)^i (\mod p)$来查找即可 有个小细节：预处理时可能得到相同的结果，为了保证得到最小的答案，需要把后面的j覆盖前面的j exBSGS算法条件：无观察柿子，a和p的公约数，b中也一定会有（除非b是0），否则无解。设d=gcd(a,p)，那么把一个a拉出来，同时把a、b、p除以d如果操作的次数为num，直到$d=gcd(a,\frac{p}{d^{num}})=1$，柿子变成：$(\frac{a}{d})^{num} \times a^{x-num}=\frac{b}{d^{num}} (\mod \frac{p}{d^{num}})$然后此时$gcd(\frac{a^{num}}{d^{num}}),\frac{p}{d^{num}})=1$所以可以把它逆元一下，放到右边去最后$x=BSGS(a,\frac{b}{d^{num}} \times inv(\frac{a}{d})^{num}),\frac{p}{d^{num}})+num$不过这样以后，我们强行使$x \geq num$，这样就漏了（例如a=4,x=0,b=1,c=4）不过我们观察一下，发现$num&lt;=log_2 c$，所以直接枚举出前面的$0~num-1$就好了，复杂度不变 总结核心思想就是【分块+预处理】相辅相成，复杂度下降到根号然后为了能满足条件，强行对柿子进行修改 练习Tag-BSGS]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-10斯特林数]]></title>
    <url>%2Fposts%2Fce21.html</url>
    <content type="text"><![CDATA[博弈 优秀的文章this 通项公式是通过容斥得出的，枚举空盒的位置，去除非法状态$S(n,m)=\frac{1}{m!} \sum_{k=0}^m (-1)^k C(m,k) (m-k)^n$ 注意这里说的卷积在fft一章有介绍因为数只有k和m-k两种形式（把m的阶乘消除后）]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-9线性基]]></title>
    <url>%2Fposts%2F6cd.html</url>
    <content type="text"><![CDATA[线性基的通俗解释 思想在普通线性基中用加、乘法，能表示出其对应线性空间中的所有数。在异或线性基中用异或操作，能表示出其对应线性空间中的所有数。然后一般第二种比较常用 主要的解法都是利用高斯消元（当然用插入版本的也行，比较动态，但本质上还是高斯消元），因为其【初等行列式变换】和加、乘法对应，行列间异或，其实也相当于是二进制，所以和异或对应。 性质：1.对于用高斯消元求出的异或线性基（还有用插入法的，不介绍了，因为复杂度一样）该列上唯一的1在这上面 2.异或线性基组合出来的数（即span张成）互不相同，而且不存在0可以用反证法证明：假设有一个柿子，左右两边都是异或出来的数字，把左边留下某一个，其他移项到右边，那么出现，那个数字能被其他数字表示出，则违反线性基定义不存在0也是相同的证明方法 这就是我目前理解的，灰常浅显的线性基应用。 简易代码1234567891011121314151617181920int n;bool zero;ll a[11000];int tot;//线性基长度void gauss()&#123; zero=0;tot=0; for(int i=60;i&gt;=0;i--) &#123; int nx=tot+1; while( !(a[nx]&amp;bin[i]) and nx&lt;=n ) nx++; if(nx&gt;n) continue; tot++;swap(a[tot],a[nx]); for(int k=1;k&lt;=n;k++) if(k!=tot and a[k]&amp;bin[i]) a[k]^=a[tot]; &#125; if(tot&lt;n) zero=1;&#125; 动态插入版12345678910111213141516ll bs[61]; void insert(ll now) &#123; for(int i=60;i&gt;=0;i--) if(now&amp;bin[i]) &#123; if(bs[i]&lt;0) &#123; bs[i]=now; //回代，这个看需求，例如第k大要用 for(int j=60;j&gt;i;j--) if(bs[j]&amp;bin[i]) bs[j]^=now; break; &#125; else now^=bs[i]; &#125; &#125; 练习Tag-线性基 By the way 通常看到异或和可以想想线性基，因为异或表达的时候，最多用一次 面对插入时有附加决策条件的题目，通常可以贪心，因为相互位之间不影响]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-8高斯消元]]></title>
    <url>%2Fposts%2Fe8f0.html</url>
    <content type="text"><![CDATA[用于求解线性方程组 思想模拟简单的解多元一次方程做法逐步改系数，通过柿子相减，消去公共元 流程 首先，用行列式表示左边各个$x_i$的系数，最后一列表示其右边的常量然后每行都代表一个方程，每一列都代表一个未知数 设当前要消除的是$x_i$，找到一行，对应的系数不为0，如果找不到，则不用消，直接跳过 把这一行移动到第i行，那么我们要做的就是消除下面的方程中的$x_i$上述步骤称为消元把每个$x_i$都解决后，就得到一个上三角行列式，下面开始返代从下往上枚举，用那个柿子给上面的柿子消元，最后得到一个对角矩阵，解方程完毕。 其实消元和返代是可以同时进行的……这里分开是为了好理解 然后可能出现的特殊情况： 如果出现某一行，系数都是0，但常量不是0，则无解 设不全为0的行，数量为k，则表示有n-k个自由元，其值可为任意实数 简易代码1234567891011121314151617181920212223double myabs(double x) &#123;return x&gt;0?x:-x;&#125;const double eps=1e-8;const int MAXN=20;double p[MAXN][MAXN];double a[MAXN][MAXN],b[MAXN];//系数、常数void gauss(int n)&#123; for(int i=1;i&lt;=n;i++)//目标为xi &#123; int nx=-1; for(int j=i;j&lt;=n;j++) if(myabs(a[j][i])&gt;eps) &#123;nx=j;break;&#125; if(nx&lt;0) continue; swap(b[i],b[nx]);for(int k=1;k&lt;=n;k++) swap(a[i][k],a[nx][k]); for(int j=1;j&lt;=n;j++) &#123; if(i==j) continue; double t=a[j][i]/a[i][i];//确保分母不为0 b[j]-=b[i]*t;for(int k=i;k&lt;=n;k++) a[j][k]-=a[i][k]*t; &#125; &#125;&#125; 练习Tag-高斯消元]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-7高精度]]></title>
    <url>%2Fposts%2F9163.html</url>
    <content type="text"><![CDATA[基本功：高精度 很久以前写的，变量名可能不甚雅观，还请见谅 Mine123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346#ifndef HPC_H#define HPC_H#include&lt;cstring&gt;#include&lt;sstream&gt;#include&lt;string&gt;using namespace std;bool error;//-------------------------↓类型定义-------------------------struct fuk&#123; int len,num[50]; bool isf; fuk() &#123; len=0; memset(num,0,sizeof(num)); isf=false; &#125;&#125;;//-------------------------↑类型定义-------------------------//-------------------------↓转换函数-------------------------string inttostr(int a)&#123; //return boost::lexical_cast&lt;string&gt;(a); stringstream ss;ss&lt;&lt;a; string s;ss&gt;&gt;s; return s;&#125;int strtoint(string s)&#123; //return boost::lexical_cast&lt;int&gt;(s); stringstream ss;ss&lt;&lt;s; int i;ss&gt;&gt;i; return i;&#125;fuk strtofuk(string s)&#123; fuk f; f.len=s.size(); for(int i=1;i&lt;=f.len;i++) f.num[f.len-i+1]=s[i-1]-'0'; return f;&#125;string fuktostr(fuk f)&#123; string s=""; for(int i=f.len;i&gt;=1;i--) s=s+inttostr(f.num[i]); return s;&#125;fuk inttofuk(int a)&#123; return strtofuk(inttostr(a));&#125;void fswap(fuk *a,fuk *b)&#123; fuk p; p=*a; *a=*b; *b=p;&#125;//-------------------------↑转换函数-------------------------//-------------------------↓比较函数-------------------------int maxer(int x,int y)&#123; return x&gt;y?x:y;&#125;int miner(int x,int y)&#123; return x&gt;y?y:x;&#125;//相等返回0，大于返回1，小于返回-1int fcmp(fuk a,fuk b)&#123; if( a.isf==true and b.isf==false ) return -1; if( a.isf==false and b.isf==true ) return 1; if( a.isf==true and b.isf==true ) fswap(&amp;a,&amp;b); if(a.len&gt;b.len) return 1; if(a.len&lt;b.len) return -1; int i=a.len; while(a.num[i]==b.num[i] and i&gt;0) i--; if(i==0) return 0; if(a.num[i]&gt;b.num[i]) return 1; else return -1;&#125;fuk fmax(fuk a,fuk b)&#123; if(fcmp(a,b)==1) return a; else return b;&#125;fuk fmin(fuk a,fuk b)&#123; if(fcmp(a,b)==-1) return a; else return b;&#125;int is0(fuk a)//-1 =&gt; a&lt;0 0 =&gt; a=0 1 =&gt; a&gt;0&#123; if(a.len==1 and a.num[1]==0) return 0; if(a.isf==true) return -1; return 1;&#125;//-------------------------↑比较函数-------------------------fuk h_add_i(fuk a,fuk b)&#123; fuk c; c.len=maxer(a.len,b.len); for(int i=1; i&lt;=c.len; i++) c.num[i]=a.num[i]+b.num[i]; for(int i=1; i&lt;=c.len; i++) &#123; c.num[i+1]+=c.num[i]/10; c.num[i]%=10; &#125; int i=c.len; while(c.num[i+1]&gt;0) &#123; i++; c.num[i+1]=c.num[i+1]+c.num[i]/10; c.num[i]=c.num[i]%10; &#125; while(c.num[i]==0 and i&gt;1) i--; c.len=i; return c;&#125;fuk h_add_l(fuk a,int b)&#123; a.num[1]+=b; for(int i=1; i&lt;=a.len; i++) &#123; a.num[i+1]+=a.num[i]/10; a.num[i]%=10; &#125; int i=a.len; while(a.num[i+1]&gt;0) &#123; i++; a.num[i+1]=a.num[i+1]+a.num[i]/10; a.num[i]=a.num[i]%10; &#125; while(a.num[i]==0 and i&gt;1) i--; a.len=i; return a;&#125;fuk h_sub_i(fuk a,fuk b)&#123; fuk c; int t=fcmp(a,b); if( t==0 ) &#123; c=strtofuk("0"); return c; &#125; if( t==-1 ) &#123; fswap(&amp;a,&amp;b); c.isf=true; &#125; c.len=a.len; for(int i=1;i&lt;=c.len;i++) c.num[i]=a.num[i]-b.num[i]; for(int i=1;i&lt;=c.len;i++) if(c.num[i]&lt;0) &#123; c.num[i]+=10; c.num[i+1]--; &#125; int i=c.len; while(c.num[i+1]&gt;0) &#123; i++; c.num[i+1]=c.num[i+1]+c.num[i]/10; c.num[i]=c.num[i]%10; &#125; while ( c.num[i]==0 and i&gt;1) i--; c.len=i; return c;&#125;fuk h_mul_l(fuk xx,int y)&#123; fuk ans; ans.len=xx.len; for(int i=1; i&lt;=ans.len; i++) ans.num[i]+=xx.num[i]*y; for(int i=1; i&lt;=ans.len; i++) &#123; ans.num[i+1]+=ans.num[i]/10; ans.num[i]%=10; &#125; int i=ans.len; while(ans.num[i+1]&gt;0) &#123; i++; ans.num[i+1]+=ans.num[i]/10; ans.num[i]%=10; &#125; while(ans.num[i]==0 and i&gt;0) i--; ans.len=i; return ans;&#125;fuk h_mul_i(fuk a,fuk b)&#123; fuk c; c.len=a.len+b.len+1; for(int i=1; i&lt;=a.len; i++) for(int j=1; j&lt;=b.len; j++) c.num[i+j-1]=c.num[i+j-1]+a.num[i]*b.num[j]; for(int i=1; i&lt;=c.len; i++) &#123; c.num[i+1]=c.num[i+1]+c.num[i]/10; c.num[i]=c.num[i]%10; &#125; int i=c.len; while(c.num[i+1]&gt;0) &#123; i++; c.num[i+1]=c.num[i+1]+c.num[i]/10; c.num[i]=c.num[i]%10; &#125; while(c.num[i]==0 and i&gt;1) i--; c.len=i; return c;&#125;fuk h_div_i(fuk a,fuk b)&#123; fuk ans=strtofuk("0"); if(is0(b)==0) &#123; error=true; return ans; &#125; if(is0(a)==0) return ans;//0 int t=fcmp(a,b); if(t&lt;0) return ans;//0 if(t==0) return strtofuk("1"); fuk d=strtofuk("0"); int pos=0; while(pos&lt;a.len) &#123; if(fcmp(d,b)&lt;0) &#123; pos++; d=h_add_l(h_mul_l(d,10),a.num[a.len-pos+1]); &#125; ans=h_mul_l(ans,10); int k=0; while(fcmp(d,b)&gt;=0) &#123; d=h_sub_i(d,b); k++; &#125; ans=h_add_l(ans,k); &#125; return ans;&#125;//外部接口string h_add(string a,string b)&#123; return fuktostr(h_add_i(strtofuk(a),strtofuk(b)));&#125;string h_sub(string a,string b)&#123; return fuktostr(h_sub_i(strtofuk(a),strtofuk(b)));&#125;string h_mul(string a,string b)&#123; return fuktostr(h_mul_i(strtofuk(a),strtofuk(b)));&#125;string h_mul2(string a,int b)&#123; return fuktostr(h_mul_l(strtofuk(a),b));&#125;string h_div(string a,string b)&#123; error=false; fuk c=h_div_i(strtofuk(a),strtofuk(b)); if(error==true) return "不能被0除"; return fuktostr(c);&#125;#endif 可参考1.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#ifndef HPC_H#define HPC_H#include&lt;iosfwd&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define MAX_L_HPC 500 //最大长度，可以修改class hpc&#123; public: int len,s[MAX_L_HPC];//数的长度，记录数组 bool sign;//符号 1正数 0负数//构造函数 hpc();//初始化 hpc(const char*); hpc(const string); hpc(const int);//强制转换 string tostr() const;//转化为字符串 friend istream&amp; operator&gt;&gt;(istream &amp;,hpc &amp;);//重载输入流 friend ostream&amp; operator&lt;&lt;(ostream &amp;,hpc &amp;);//重载输出流//重载赋值 hpc operator=(const char*); hpc operator=(const int); hpc operator=(const string);//重载各种比较 bool operator&gt;(const hpc &amp;) const; bool operator&gt;=(const hpc &amp;) const; bool operator&lt;(const hpc &amp;) const; bool operator&lt;=(const hpc &amp;) const; bool operator==(const hpc &amp;) const; bool operator!=(const hpc &amp;) const;//重载四则运算 hpc operator+(const hpc &amp;) const; hpc operator++(); hpc operator++(int); hpc operator+=(const hpc&amp;); hpc operator-(const hpc &amp;) const; hpc operator--(); hpc operator--(int); hpc operator-=(const hpc&amp;); hpc operator*(const hpc &amp;)const; hpc operator*(const int num)const; hpc operator*=(const hpc&amp;); hpc operator/(const hpc&amp;)const; hpc operator/=(const hpc&amp;);//四则运算的衍生运算 hpc operator%(const hpc&amp;)const;//取模（余数） hpc factorial()const;//阶乘 hpc sqrt() const;//整数开根（向下取整） hpc pow(const hpc&amp;)const;//次方//一些乱乱的函数 void clean();//退位 hpc abs() const;&#125;;//-------------------------void hpcswap(hpc *a,hpc *b) &#123;hpc p=*a;*a=*b;*b=p;&#125;int maxer(int x,int y) &#123;return x&gt;y?x:y;&#125;int miner(int x,int y) &#123;return x&gt;y?y:x;&#125;//-------------------------hpc::hpc()&#123; memset(s,0,sizeof(s)); len=1; sign=true;&#125;hpc::hpc(const char *num) &#123;*this=num;&#125;hpc::hpc(const string num) &#123;*this=num;&#125;hpc::hpc(const int num) &#123;*this=num;&#125;//链接到=string hpc::tostr() const&#123; string res=""; for(int i=0;i&lt;len;i++) res=char(s[i]+'0')+res; if(res=="") res="0"; if(sign==false and res!="0") res="-"+res; return res;&#125;istream &amp;operator&gt;&gt;(istream &amp;in,hpc &amp;num)&#123; string str; in&gt;&gt;str; num=str; return in;&#125;ostream &amp;operator&lt;&lt;(ostream &amp;out, hpc &amp;num)&#123; out&lt;&lt;num.tostr(); return out;&#125;hpc hpc::operator=(const char *num)&#123; memset(s,0,sizeof(s)); char a[MAX_L_HPC]=""; if(num[0]!='-') strcpy(a,num); else for(int i=1;i&lt;strlen(num);i++) a[i-1]=num[i]; sign=(num[0]!='-'); len=strlen(a); for(int i=0;i&lt;strlen(a);i++) s[i]=a[len-i-1]-'0'; return *this;&#125;hpc hpc::operator=(int num)&#123; if(num&lt;0) sign=false,num=-num; else sign=true; char temp[MAX_L_HPC]; sprintf(temp,"%d",num); *this=temp; return *this;&#125;hpc hpc::operator=(const string s)&#123; *this=s.c_str(); return *this;&#125;bool hpc::operator&lt;(const hpc &amp;num) const&#123; if(sign^num.sign) return num.sign; if(len!=num.len) return len&lt;num.len;//巧妙！ int i=len; while(s[i]==num.s[i] and i&gt;0) i--; if(i==0) return false; return s[i]&lt;num.s[i];&#125;bool hpc::operator&gt;(const hpc&amp;num)const &#123;return num&lt;*this;&#125;bool hpc::operator&lt;=(const hpc&amp;num)const &#123;return !(*this&gt;num);&#125;bool hpc::operator&gt;=(const hpc&amp;num)const &#123;return !(*this&lt;num);&#125;bool hpc::operator!=(const hpc&amp;num)const &#123;return *this&gt;num or *this&lt;num;&#125;bool hpc::operator==(const hpc&amp;num)const &#123;return !(num!=*this);&#125;hpc hpc::operator+(const hpc &amp;b) const&#123; if (sign^b.sign) &#123; if(sign) return *this-b.abs(); else return b-abs(); &#125; //已知:a,b&gt;=0 hpc c;c.len=maxer(len,b.len);c.sign=sign; for(int i=1;i&lt;=c.len;i++) c.s[i]=s[i]+b.s[i]; /*for(int i=1;i&lt;=c.len;i++) c.s[i+1]+=c.s[i]/10,c.s[i]%=10; int i=c.len; while(c.s[i+1]&gt;0) &#123;i++;c.s[i+1]+=c.s[i]/10;c.s[i]%=10;&#125; while(c.s[i]==0 and i&gt;1) i--; c.len=i;*/ c.clean(); return c;&#125;hpc hpc::operator++()&#123; *this=*this+1; return *this;&#125;hpc hpc::operator++(int)&#123; hpc old=*this; ++(*this); return old;&#125;hpc hpc::operator+=(const hpc &amp;num)&#123; *this=*this+num; return *this;&#125;hpc hpc::operator-(const hpc &amp;num) const&#123; hpc a=*this,b=num; if(a==b) return 0; if(b.sign==sign==false) return b.abs()-a.abs(); if(b.sign==false) return a+b.abs(); if(a.sign==false) return hpc(0)-(a.abs()+b); if(a&lt;b) return hpc(0)-(b-a); //已知:a,b&gt;=0;a&gt;b hpc c;c.len=a.len; for(int i=1;i&lt;=c.len;i++) c.num[i]=a.num[i]-b.num[i]; for(int i=1;i&lt;=c.len;i++) if(c.num[i]&lt;0) &#123; c.num[i]+=10; c.num[i+1]--; &#125; int i=c.len; while(c.num[i+1]&gt;0) &#123; i++; c.num[i+1]=c.num[i+1]+c.num[i]/10; c.num[i]=c.num[i]%10; &#125; while ( c.num[i]==0 and i&gt;1) i--; c.len=i; return c;&#125;hpc hpc::operator * (const hpc &amp;num)const&#123; hpc result; result.len = len + num.len; for (int i = 0; i &lt; len; i++) for (int j = 0; j &lt; num.len; j++) result.s[i + j] += s[i] * num.s[j]; for (int i = 0; i &lt; result.len; i++) &#123; result.s[i + 1] += result.s[i] / 10; result.s[i] %= 10; &#125; result.clean(); result.sign = !(sign^num.sign); return result;&#125;hpc hpc::operator*(const int num)const&#123; hpc x = num; hpc z = *this; return x*z;&#125;hpc hpc::operator*=(const hpc&amp;num)&#123; *this = *this * num; return *this;&#125;hpc hpc::operator /(const hpc&amp;num)const&#123; hpc ans; ans.len = len - num.len + 1; if (ans.len &lt; 0) &#123; ans.len = 1; return ans; &#125; hpc divisor = *this, divid = num; divisor.sign = divid.sign = 1; int k = ans.len - 1; int j = len - 1; while (k &gt;= 0) &#123; while (divisor.s[j] == 0) j--; if (k &gt; j) k = j; char z[MAX_L_HPC]; memset(z, 0, sizeof(z)); for (int i = j; i &gt;= k; i--) z[j - i] = divisor.s[i] + '0'; hpc dividend = z; if (dividend &lt; divid) &#123; k--; continue; &#125; int key = 0; while (divid*key &lt;= dividend) key++; key--; ans.s[k] = key; hpc temp = divid*key; for (int i = 0; i &lt; k; i++) temp = temp * 10; divisor = divisor - temp; k--; &#125; ans.clean(); ans.sign = !(sign^num.sign); return ans;&#125;hpc hpc::operator/=(const hpc&amp;num)&#123; *this = *this / num; return *this;&#125;hpc hpc::operator%(const hpc&amp; num)const&#123; hpc a = *this, b = num; a.sign = b.sign = 1; hpc result, temp = a / b*b; result = a - temp; result.sign = sign; return result;&#125;hpc hpc::pow(const hpc&amp; num)const&#123; hpc result = 1; for (hpc i = 0; i &lt; num; i++) result = result*(*this); return result;&#125;hpc hpc::factorial()const&#123; hpc result = 0; ++result; for (hpc i = 1; i &lt;= *this; i++) result *= i; return result;&#125;hpc hpc::sqrt()const&#123; if(*this&lt;0)return -1; if(*this&lt;=1)return *this; hpc l=0,r=*this,mid; while(r-l&gt;1) &#123; mid=(l+r)/2; if(mid*mid&gt;*this) r=mid; else l=mid; &#125; return l;&#125;void hpc::clean()//退位&#123; int i=len; for(int i=1;i&lt;=len;i++) &#123; s[i+1]+=s[i]/10;s[i]%=10; if(s[i]&lt;0) &#123;s[i]+=10;s[i+1]--;&#125; &#125; while(s[i+1]&gt;0) &#123;i++;s[i+1]+=s[i]/10;s[i]%=10;&#125; while(s[i]==0 and i&gt;1) i--; len=i;&#125;hpc hpc::abs() const&#123; hpc t=*this; t.sign=true; return t;&#125;#endif 另一个这里]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-6离散化]]></title>
    <url>%2Fposts%2F6189.html</url>
    <content type="text"><![CDATA[理论上就是让数字间相对关系保持不变但数字变小，以缩小占用空间（开数组时）。123456789101112131415161718struct nod&#123; int x,p,z;//x原值，p原位置，z新值&#125;a[99],b[99];int main()&#123; int n;cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i].x); a[i].p=i; b[i]=a[i]; &#125; sort2(1,n);b[1].z=1; for(int i=2;i&lt;=n;i++) b[i].z=b[i-1].z+(b[i].x==b[i-1].x); for(int i=1;i&lt;=n;i++) a[b[i].p].z=b[i].z; for(int i=1;i&lt;=n;i++) printf("%d ",a[i].z);&#125;]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-5快速乘及快速幂]]></title>
    <url>%2Fposts%2F3afc.html</url>
    <content type="text"><![CDATA[2.5.1分析其实原理很简单，就是可以合并啦作用： 快 能模，我不会证明QAQ，网上找找吧 2.5.2代码123456789101112131415161718192021lld Mod=10000003;lld qmul(lld x,lld y)&#123; lld ans=0; while(y) &#123; while(bool(y&amp;1)==0) x=(x+x)%Mod,y&gt;&gt;1; ans=(ans+x)%Mod;y--; &#125; return ans%Mod;&#125;lld qpow(lld x,lld y)&#123; lld ans=1;x=x%Mod; while(y) &#123; while(bool(y&amp;1)==0) x=qmul(x,x),y&gt;&gt;1; ans=qmul(ans,x);y--; &#125; return ans%Mod;&#125;]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-4矩阵乘法]]></title>
    <url>%2Fposts%2Fc6a2.html</url>
    <content type="text"><![CDATA[2.4.1定义矩阵乘法：用来求某种递推关系。矩阵相乘只有在第一个矩阵的列数和第二个矩阵的行数相同时才有意义。设A为A*M的矩阵，B为M*B的矩阵，那么矩阵C为矩阵A与B的乘积，其中矩阵C中的第i行第j列元素可以表示为：如下所示： 2.4.2例题【题目描述】a[1]=a[2]=a[3]=1a[x]=a[x-3]+a[x-1] (x&gt;3)求a数列的第n项对1000000007（10^9+7）取余的值。【输入格式】第一行一个整数T，表示询问个数。以下T行，每行一个正整数n。【输出格式】每行输出一个非负整数表示答案。【样例输入】36 8 10【样例输出】4 9 19【数据范围】T&lt;=100,n&lt;=2*10^9 开一个2*2的矩阵：主要是为了快速幂的方便，一个可以和自己乘上许多次（&gt;=2）的矩阵只有可能是正方形的，所以要开这样一个矩阵。然后就是使用矩阵乘法来递推。如果想要预处理，也是可以的，只不过T&lt;=100，所以偷懒省空间。 2.4.3代码12345678910111213141516171819202122232425262728293031323334353637383940struct mod&#123; long long a[4][4]; mod() &#123; memset(a,0,sizeof(a)); &#125;&#125;;mod mul(mod a,mod b)//矩阵乘法&#123; mod c; for(int i=1;i&lt;=3;i++) for(int j=1;j&lt;=3;j++) for(int k=1;k&lt;=3;k++) c.a[i][j]=(c.a[i][j]+a.a[i][k]*b.a[k][j])%1000000007; return c;&#125;void make(int n)&#123; mod a,c; c.a[1][1]=1;c.a[2][1]=1;c.a[3][1]=1; a.a[1][1]=0;a.a[1][2]=1;a.a[1][3]=0; a.a[2][1]=0;a.a[2][2]=0;a.a[2][3]=1; a.a[3][1]=1;a.a[3][2]=0;a.a[3][3]=1; n++; while(n&gt;0)//快速幂 &#123; if(n&amp;1) c=mul(c,a);//不能是mul(a,c) a=mul(a,a);//(A^n)*B n&gt;&gt;=1; &#125; printf("%d\n",c.a[3][3]%1000000007);&#125;int main(int argc,char *argv[])&#123; int t;scanf("%d",&amp;t); while(t--) &#123; int n; scanf("%d",&amp;n); make(n); &#125;&#125; 2.4.4正文开始！咳咳，上面的部分是我以前对于所谓矩阵乘法的浅显认知。首先，矩阵乘法经典中的经典：Matrix67矩阵乘法的精髓在于：能通过快速幂将操作简化 顺便介绍几个特殊01矩阵：单位矩阵，m[i][i]=1，其他是0，所有矩阵和它乘都是自己，相当于1邻接矩阵，m[i][j]=1表示从i能到j 再顺便说一下，通常而言，表示一个状态应该使用列向量，也就是一个a行1列的矩阵 2.4.5 众多练习题重点与精华，顺序不重要好吧虽然我写的时候是按照我的思路来写的所以如果有空的话，顺着做当然最好啦~题目好像真的蛮多的Tag-矩阵乘法]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-3逆元]]></title>
    <url>%2Fposts%2F71d2.html</url>
    <content type="text"><![CDATA[逆元(严格来说叫乘法逆元) 除法与模这个东西我们之前稍微讲了一下哈：【OI之路】02数论算法-1公约数公倍数与欧几里得 补充一些内容： $ (a+b)\mod p=(a\mod p)+(b\mod p)\mod p （对） $$ (a-b)\mod p=(a\mod p)-(b\mod p)\mod p （对） $$ (a\times b)\mod p=(a\mod p)\times (b\mod p) \mod p （对） $$ \frac{a}{b}\mod p=\frac{a\mod p}{b\mod p}\mod p （错） $$ a^b\mod p=(a^{b-k}\mod p)\times (a^{k}\mod p)\mod p （对） $没错，除法中是错误的【随便举个反例即可，毕竟“证明对的难，证明错的容易”】那容易爆的可以搞快速幂，但碰到有模数的时候，难道就不用除法了？当然不是，所以，有请逆元隆重登场！ 啥玩意？$a\times x=1 (\mod p)$是不是有点像数学里面的倒数？只不过这里因为是数论，所有是整数现在x就叫做mod p下a的逆元可见p不同，a的逆元也不同。 用法？可以把除以a变成乘以a的逆元（始终强调模意义下）爽吧~然后koi的时候就半懂不懂地杠最后一题，讲题的时候全程懵逼 求法1欧拉-费马定理条件：gcd(a,p)=1 【原本就是定理的条件】因为费马小定理还额外要求p是素数 【亲自实验验证】所以不定模数或者已知是合数的时候线性筛好欧拉函数$a^{\varphi(p)}=1 (\mod p)$$inv(a)=a^{-1}=a^{\varphi(p)-1} (\mod p)$ 求法2扩展欧几里德算法~就问你6不6条件：gcd(a,p)=1 【扩展欧几里德要求K（这里的1）是gcd(A,B)的倍数】$a\times x+p\times y=1$$a\times x\%p+p\times y\%p=1\%p$$a\times x\%p=1\%p$$x=inv(a) (\mod p)$复杂度O(loga)记得取最小正整数解哟 求法3当p是个质数的时候有$inv(a)=(p-\lfloor p/a \rfloor)\times inv(p\%a)\%p$ 证明：设$x=p\%a,y=\lfloor p/a \rfloor 【a&lt;p】$于是有$y\times a+x=p$ 【就是整数除法定义嘛】$y\times a+x=0 (\mod p)$$x=(-y)\times a (\mod p)$$inv(a)=(p-y)\times inv(x) (\mod p)$$inv(a)=(p-\lfloor p/a \rfloor)\times inv(p\%a) (\mod p)$ 边界：$inv(1)=1$时间复杂度：单个O(loga)，但加上记忆化可以线性 总结条件：gcd(a,p)=1这个条件不是由求法而得来的（例如第三种就不需要），而是由其定义$a \times inv(a)=1 (\mod p)$那么exBSGS算法中说过对于一个同余方程组，左边、右边和模数会有相同的质因子（除非是0）而现在右边是1，则$gcd(a \times inv(a),p)=1$则$gcd(a,p)=1$ 单个复杂度：O(loga)预处理：线性 练习Tag-逆元]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-2定理杂烩]]></title>
    <url>%2Fposts%2Fa06a.html</url>
    <content type="text"><![CDATA[数论定理杂烩 费马小定理条件：质数p，gcd(a,p)=1结果：$a^{p-1}=1 (\mod p)$顺便提一下，如果使用$a^p=a (\mod p)$的形式，不需要满足gcd(a,p)=1证明：不会应用：1.求逆元：【OI之路】11更高级数论-2逆元2.某些数据范围巨大的题目如Gauss Fibonacci矩阵游戏 欧拉函数与欧拉定理欧拉函数：对于正整数n，代表小于等于n的与n互质的数的个数，记作$\phi(n)$欧拉定理： 如果n为某一个素数p，则$\varphi(p)=p-1$ 设$n=p1^{a1}\times p2^{a2} ……\times pk^{ak}$，那么$\varphi(n)=n\times \frac{p1-1}{p1}\times \frac{p2-1}{p2}……\times \frac{pk-1}{pk}$ 如果n为某一个素数p的幂次，那么$\varphi(p^a)=(p-1)\times p^{a-1}$ 如果n为两个数a和b且满足gcd(a,b)=1的积，那么$\varphi(a\times b)=\varphi(a)\times \varphi(b)$ 【所以是积性函数】 当gcd(a,m)=1，$a^{\varphi(m)}=1 (\mod m)$ 对于n&gt;1，1~n中与n互质的数的和为$n \times \varphi(n)/2$ $\sum_{d|n} \varphi(d) = n$ 当$gcd(a,p)=1$时，满足$a^x=1 (mod p)$的最小正整数x一定是$\varphi(p)$的约数 证明： 显而易见 容斥原理？不会Up 2018.8.6 其乘积如果展开，就是对于素数p倍数的容斥 由定理2得出 由定理2得出 不会Up 2018.8.6 这个东西 这个证明灰常有趣因为$gcd(n,x)=gcd(n,n-x)$，可以看作是一对，则每一对的和都是n 不会 运用反证法假设存在最小的x0，不是其约数，则$\varphi(p)=t \times x0 + r (0&lt;r&lt;x0)$那么因为$a^{x0}=1 (\mod m)$，$a^{t \times x0}=1 (\mod m)$又因为$a^{\varphi(m)}=1 (\mod m)$，所以$a^r=1 (\mod m)$这与x0的最小相矛盾。 线性筛： $\varphi(p)=p-1$ 【p是素数】 $\varphi(p\times i)=p\times \varphi(i)$【p%i==0】 $\varphi(p\times i)=(p-1)\times \varphi(i)$【p%i!=0】 等比数列二分求和（好吧其实不是定理）神不神奇~不算难，但不好想举例：$S=A+A^2+A^3+…+A^k$采用分治的思想： k=1,$S_k=A$ k%2=0,$S_k=(1+A^{k/2})\times (A+A^2+A^3+…+A^{k/2})$ k%2=1,$S_k=S_{k-1}\times A^k$有木有一种熟悉感？没错，FFT的快速也是靠这个分治减少带入计算量！题目如Matrix Power Series 威尔逊定理万一派得上用场？当p是质数$ (p-1)! = -1 (\mod p) $$ (p-1)!\mod p = p-1 $ 二项式定理也可参阅组合数学一章$$(a+b)^k=\sum_{i=0}^kC_n^i \timesa^i \timesb^{n-i}$$ 差比数列每一项，可以拆分为等差数列和等比数列据说是高中常用知识…… 形如$S_n=a+A(a+d)+A^2(a+2d)…+A^n(a+nd)$参考等比数列中乘以A-1$$(A-1)S_n=-a+Aa-A(a+d)+A^2(a+d)-A^2(a+2d)…A^n(a+(n-1)d)-A^n(a+nd)+A^{n+1}(a+nd)$$ $$(A-1)S_n=-a-nAd+A^{n+1}(a+nd)$$ $$S_n=\frac{A^{n+1}(a+nd)-a-nAd}{A-1}$$ 神仙欧拉的另一个公式本公式属于拓扑学的研究范围不过之前做一道planar的题目用到过 对于一个平面图，一定满足$m \leq 3n-6$ 原公式：点数n+面数r-边数m=联通块数量cnt（当做无向图）+1对于当前的平面图判定，每条边最多给两个面使用，每个面至少有3条边也就是说，$r \leq \frac{2m}{3}$原式化为 $m=n+r-cnt-1$ 后带入，得到 $m \leq n+\frac{2}{3} m -cnt-1$$3m \leq 3n+2m-3cnt-3$显然cnt最小为1，则 $m \leq 3n-6$]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数论-1约数与欧几里得]]></title>
    <url>%2Fposts%2F7748.html</url>
    <content type="text"><![CDATA[2.1.0 前言：%和mod都表示C++中的取余运算$\lfloor x \rfloor$就是向下取整数论这一章，建议大家用C++实现的时候以long long为主长文预警！ 2.1.1 取余和取模顺便讲讲~首先声明C++中的%运算符是取余运算基本思路：①$c=a/b$ ②$r=a-c\times b$取余：在①中，向0方向取整取模：在①中，向负无穷方向取整举个栗子：(4)/(-3)≈-1.3$4 rem (-3)=4-(-1)\times (-3)=1$$4 mod (-3)=4-(-2)\times (-3)=-2$C++中的%运算符其实是rem，但为了方便我比较习惯用mod表示，小心混淆划重点：数论中为了化公式，经常要变成$r=a-\lfloor a/b \rfloor \times b$的形式 2.1.2 最大公约数Greatest Common Divisorgcd(x,y)=x和y的最大公约数公共约数中最大的定义：gcd(x,0)=x划重点：约数的定义域是自然数，所以不能是负数！ 2.1.3 最小公倍数Least Common Multiplelcm(x,y)=x和y的最小公倍数公共倍数中最小的 2.1.4 补充知识 x*y=最小公倍数*最大公倍数最小公倍数=x/最大公倍数*y （这样不容易爆） 证明：设两个数为x和y,其最大公约数为a,则最小公倍数为$(x/a)\times (y/a)\times a=x\times y/a$最大公约数和最小公倍数的乘积为$(a)\times (x\times y/a)=x\times y$ 2.1.5 欧几里得算法Euclid又名辗转相除法，对于大小关系没有要求内容： $gcd(a,b)=gcd(b,a\%b)$证明： 设d是a,b的一个约数，所以a/d,b/d为整数 $r=a-k\times b 【0\leq r&lt;b，k为整】$同时除以d，$r/d=a/d-kb/d$因为$a/d-k\times (b/d)$为整数所以r/d也是整数，所以r是d的倍数 d本身就是a,b的约数,又d是r的约数，所以是a,b,a%b的公约数既然公约数是一样的（因为d并非定值，可以应用于所有公约数）最大公约数也必然相等，得证1234int Euclid(int a,int b)&#123; return (b==0)?a:Euclid(b,a%b);&#125; 时间复杂度：$O(log2b)$，证明 2.1.6 扩展欧几里德算法ExEuclid内容： 利用 $gcd(a,b)=gcd(b,a\%b)$ 递归求解 $ax+by=gcd(a,b)$ 【属于丢番图方程】证明： Ⅰ.该方程必定是多解的，但我们只需要知道一个解，就能得出其他解，下文为简洁设$GCD=gcd(a,b)=gcd(b,a\%b)$$x=x0-b/GCD\times t$$y=y0-a/GCD\times t$注意上面两个通解公式只能选择其中一个，然后获得另一个，其存在意义在于保证都是整数解举个栗子：2x+3y=7，就是解2x+3y=1$x_0=-1，y_0=1$$x=(1-3y)/2，y=(1-2x)/3$$x=x_0-b/GCD\times t=-1-3\times t$$y=y_0-a/GCD\times t=1-2\times t$t=1 x=-4则y=3t=2 x=-7则y=5原理（这东西网上根本没人说啊啊啊啊，只有乱引经据典自我搪塞的）：首先，这个t可以看作一个系数，那么对于同一个方程显然x的t增大(t)则y的t变小(-t)带入：$a(x_0+b/GCD\times t)+b(y_0-a/GCD\times t)=GCD$化简：$ax_0+by_0=GCD$感觉很神hh Ⅱ.假设当前要求gcd(a,b)，并求出了一组x和y使得$ax+by=GCD$已经求出gcd(b,a%b)并求出了一组tx和ty使得$b\times tx+(a\%b)\times ty=GCD$那么这两个相邻的状态之间是否存在某种关系呢？$ax+by=GCD=b\times tx+(a\%b)\times ty$$ax+by=b\times tx+(a-\lfloor{a/b}\rfloor \times b)\times ty$$ax+by=b\times tx-\lfloor{a/b}\rfloor \times b\times ty+a\times ty$$ax+by=b\times (tx-\lfloor{a/b}\rfloor \times ty)+a\times ty$所以$x=ty,y=tx-\lfloor{a/b}\rfloor\times ty$这个其实挺好推的，不推荐死记硬背记住普通欧几里得后要用时再推一遍就好了 Ⅲ.x转最小非负整数解：$t=B/GCD$$x=(x\%t+t)\%t$举例：初始：x=-1 y=12x+7y=5t=B/GCD=7/1=7最后：x=6 y=-1 Code递归求解，用指针传递x,y123456789101112ll ExEuclid(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(b==0) &#123; x=1;y=0; return a; &#125; ll tx,ty; ll d=ExEuclid(b,a%b,tx,ty); x=ty;y=tx-(a/b)*ty; return d;&#125; 2.1.7 扩展欧几里德算法的运用1解不定方程Ax+By=K（得到的x和y只是其中一组解）给出A、B、K，求出x和y，满足Ax+By=K。123456789101112int main()&#123; ll A,B,K;scanf("%lld%lld%lld",&amp;A,&amp;B,&amp;K); ll x,y; ll d=ExEuclid(A,B,x,y); if(K%d!=0) printf("no solution!"); else &#123; x=x*K/d;y=(K-A*x)/B;//保险~ printf("%lld %lld",x,y); &#125;&#125; 测试点：Caioj1153 2.1.8 扩展欧几里德算法的运用2求解同余方程已知a,b,m,求x的最小非负整数解，使得ax=b(mod m)通俗讲就是ax mod m=b mod m那么b是个常数，所以直接b=b%m，不影响结果 $ax\%m=b\%m$$ax-\lfloor{ax/m}\rfloor \times m=b$$ax+m\times (-\lfloor{ax/m}\rfloor )=b$然后两边都有x怎么办？直接当作x和y的某种关系即可，因为我们只要求x。 Ax+By=KA=a,B=m,K=b123456789101112131415int main()&#123; ll a,b,m;scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;m); ll A=a,B=m,K=b; ll x,y; ll d=ExEuclid(A,B,x,y); if(K%d!=0) printf("no solution!"); else &#123; x=x*K/d; ll t=B/d; ll XX=(x%t+t)%t; printf("%lld",XX); &#125;&#125; 测试点：Caioj1154 2.1.9 扩展欧几里德算法的运用3同余方程是这样的：已知a,b,n,求x的最小非负整数解，使得ax=b(mod m)同余方程组是这样：也是求x的最小非负整数解，但已知a=1，b数组和m数组x=b[1](mod m[1])x=b[2](mod m[2])x=b[3](mod m[3])……………………x=b[n](mod m[n]) 在x=b(mod m)中，与上一个同理，由于b和m都是常数，可以令b=b%m即x%m=b将x当作P以防混淆，并新设x为商(即倍数)$m\times x+b=P$ 我们先选取前面两个柿子来寻找公共解：$m1\times x+b1=P……①$$m2\times y+b2=P……②$①-② $m1\times x+(-m2)\times y=b2-b1$A=m1,B=-m2,K=b2-b1调用ExEuclid得到x 等等，不对！B居然是负数！根据前面公约数的描述，不能求负数！网上无数人忽略了这个问题，反正我是没看到有人说这一句的那怎么办？实现的时候，我们并不需要y（因为可以由x得出），那么就把B换做正数，求出一个-y虽然这道题不用，但万一以后碰到这种情况而且还有求y，记得取相反数还原 $t=B/d$$x=x\times K/d$最小非负整数解$XX=(x\%t+t)\%t$ $P=m1\times XX+b1+若干倍的LCM(m1,m2)$若干倍的LCM(m1,m2)是因为XX只是其中一个最小非负整数解，仔细思考一下就会发现加上最后这个部分对于①和②都没有影响，x依然是整数我们要求 同余方程组 的解，就要考虑周全 回归到 $x=m1\times XX+b1(\mod LCM(m1,m2))$【提醒一下：因为是模，其实里面已经暗含“若干”了】最早的格式 $x=b(\mod m)$ 综上所述：$b=m1\times XX+b1$$m=LCM(m1,m2)$ 如此合并，最后一个b就是答案等到最后一次的时候，因为我们不再需要考虑后面了将“若干”取0就是最小非负整数解了 1234567891011121314151617181920212223242526int main()&#123; int n;scanf("%d",&amp;n);n--; ll b1,m1;scanf("%lld%lld",&amp;b1,&amp;m1);b1=b1%m1; ll XX; while(n--) &#123; ll b2,m2;scanf("%lld%lld",&amp;b2,&amp;m2);b2=b2%m2; ll A=m1,B=m2,K=b2-b1; ll x,y; ll d=ExEuclid(A,B,x,y); if(K%d!=0) &#123; printf("no solution!"); return 0; &#125; else &#123; x=x*K/d; ll t=B/d;XX=(x%t+t)%t; b1=m1*XX+b1; m1=A*B/d;//LCM(m1,m2)=LCM(A,B) &#125; &#125; printf("%lld",b1);&#125; 测试点：Caioj1155Poj2891（poj要调换输入、把无解换-1、多组数据） 2.1.10 总结一下exgcd其实和gcd很像啦把这些认认真真消化后，以后复习很快滴 顺带一提，目前网上介绍OI方面的扩展欧几里得的文章很少所以到处综合网上文章加上个人思考写下本文，希望能对大家有所帮助! 2018.01.24 UP:写这篇文章的时候我的博客还不支持公式，大家将就着看吧，懒得改了，影响不是太大。 2018.03.28 UP:咳咳，忍不住还是改好了…… 2.2.2 线性筛选素数线性筛选素数，也就是O(n)条件：积性函数，常见如素数函数、莫比乌斯函数、欧拉函数精髓：每个合数都只被它的最小质因子筛出注意，作为素数的循环j是在内部的那么当i%prime[j]==0，意味着i中已经包含了prime[j]那后面的数中，prime[j]一定会比prime[t]小那么 至少 最小质因数不会是prime[t]12345678910111213141516const int MAXN=21000000;int prime[1100000],pr;bool v[MAXN];void calcprime()&#123; for(int i=2;i&lt;=MAXN;i++) &#123; if(v[i]==0) prime[++pr]=i; if(pr==1000000) return;//满意而归 for(int j=1;j&lt;=pr and i*prime[j]&lt;=MAXN;j++) &#123; if(i%prime[j]==0) break; v[ i*prime[j] ]=1; &#125; &#125;&#125; 2.2.3 约数个数与和对于数字G$$G=p1^{a1}\times p2^{a2}\times p3^{a3}\times …\times pk^{ak}$$ $$约数个数=(a₁+1)(a₂+1)(a₃+1)…(ak+1)$$$$和=(p1^0+p1^1+…p1^{a1})(p2^0+p2^1+…p2^{a2})…(pk^0+pk^1+…pk^{ak})$$ 其实就是傻傻的乘法原理啦 2.2.4 其他知识附赠几个有用的东西： 1.通过$O(\sqrt n)$枚举出n的所有约数推论: n的约数总数，上限$2 \sqrt n$ 2.通过$O(n log_2 n)$枚举d，更新其倍数得到1~n的所有约数复杂度证明：调和级数推论：1~n的所有约数个数，上限$n log_2 n$ 3.对于int范围内的x，其质因子数量&lt;10证明就是把最小那几个乘起来然后指数总和&lt;31 4.素数分布数量1~n大致上看作n/log n]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>原创精华</tag>
        <tag>欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-10整体二分]]></title>
    <url>%2Fposts%2F55c7.html</url>
    <content type="text"><![CDATA[基于值域的整体分治 推荐资料2013许昊然论文-《浅谈数据结构题的几个非经典解法》 复杂度保证的关键通常而言，我们能通过一个log来把问题转化为局部子问题但这要求我们在判定二分的时候，所需要的时间不能和n有关，而只能和当前的局部区间长度有关 例题Dynamic Rankings123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int INF=0x3f3f3f3f; typedef long long ll; const int MAX_N=110000*3; int n; int bit[MAX_N]; int lowbit(int x) &#123;return x&amp;-x;&#125; void change(int x,int c) &#123; while(x&lt;=n) &#123; bit[x]+=c; x+=lowbit(x); &#125; &#125; int sum(int x) &#123; int ans=0; while(x&gt;=1) &#123; ans+=bit[x]; x-=lowbit(x); &#125; return ans; &#125; struct Qes &#123; int op; int l,r,k;//0询问 int pos,d,num;//1修改 int id; &#125;q[MAX_N],q1[MAX_N],q2[MAX_N]; int ans[MAX_N]; void solve(int l,int r,int fl,int fr) &#123; if(l&gt;r or fl&gt;fr) return; if(l==r) &#123; for(int i=fl;i&lt;=fr;i++) if(q[i].op==0) ans[q[i].id]=l; return; &#125; //printf("(%d,%d,%d,%d)\n",l,r,fl,fr); int mid=(l+r)/2,tot1=0,tot2=0; for(int i=fl;i&lt;=fr;i++) &#123; if(q[i].op==0) &#123; int left=sum(q[i].r)-sum(q[i].l-1); if(q[i].k&lt;=left) q1[++tot1]=q[i]; else q2[++tot2]=q[i],q2[tot2].k-=left; &#125; else &#123; if(q[i].d&lt;=mid) change(q[i].pos,q[i].num),q1[++tot1]=q[i]; else q2[++tot2]=q[i]; &#125; &#125; for(int i=1;i&lt;=tot1;i++) if(q1[i].op==1) change(q1[i].pos,-q1[i].num); for(int i=1;i&lt;=tot1;i++) q[fl+i-1]=q1[i]; for(int i=1;i&lt;=tot2;i++) q[fl+tot1+i-1]=q2[i]; solve(l,mid,fl,fl+tot1-1); solve(mid+1,r,fl+tot1,fr); &#125; int a[MAX_N]; void main() &#123; int m;scanf("%d%d",&amp;n,&amp;m); int tot=0; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); q[++tot]=(Qes)&#123;1,0,0,0,i,a[i],1,0&#125;; &#125; for(int now=1;now&lt;=m;now++) &#123; char str[5];scanf("%s",str); if(str[0]=='Q') &#123; int l,r,k;scanf("%d%d%d",&amp;l,&amp;r,&amp;k); q[++tot]=(Qes)&#123;0,l,r,k,0,0,0,now&#125;; &#125; else &#123; int pos,t;scanf("%d%d",&amp;pos,&amp;t); q[++tot]=(Qes)&#123;1,0,0,0,pos,a[pos],-1,0&#125;; q[++tot]=(Qes)&#123;1,0,0,0,pos,a[pos]=t,1,0&#125;; &#125; &#125; memset(ans,-1,sizeof ans);//debug solve(0,INF,1,tot); for(int i=1;i&lt;=m;i++) if(ans[i]&gt;-1) printf("%d\n",ans[i]); &#125;&#125;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-9-cdq分治]]></title>
    <url>%2Fposts%2Fd12f.html</url>
    <content type="text"><![CDATA[又称为基于时间的分治算法 要求 修改操作之间相互独立 允许离线 推荐资料2013许昊然论文-《浅谈数据结构题的几个非经典解法》 大致基本思想以时间轴排序每次分成两段，将左边的修改处理到右边后，就能分成两个子问题那么每一段的复杂度是与当前长度相关的，而不是总长度 题目自行搜索tag]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>cdq分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-8线段树]]></title>
    <url>%2Fposts%2Fb1b7.html</url>
    <content type="text"><![CDATA[线段树的各种题目集合，想学习可以参考注释 6.1.0 前言本文并非教学，其实本系列也基本上不考虑教学加入根本对基础不了解，可以自己先学习再阅读本文教程网上很多，顺便推广一下同学的：http://blog.csdn.net/qq_36038511/article/details/54616868http://blog.csdn.net/qq_36038511/article/details/54561938 本文主要为进阶选手提供，尝试培养一些针对题目特性的思路 6.1.1 简单的裸题忽略~ 6.1.2 （区间修改）加上Lazy优化Codevs线段树练习3 6.1.3 离散化市长的海报 6.1.4 查询后要删除糖果自动管理系统 6.1.5 区间修改单点最值+离散化城市地平线 6.1.6 结束了？远远没有……zkw线段树统计的力量-线段树全接触-张昆玮BeiYuwyfcyx 进阶区间查询，复杂度室友log的证明：假设某一次要同时访问左右两边，后面一定是刚进入就退出的（区间的连续性）所以说其实只有一次需要同时访问两边，复杂度为深度即log区间修改同样如此]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-7动态树]]></title>
    <url>%2Fposts%2Fe23c.html</url>
    <content type="text"><![CDATA[6.7.1 文章师兄写的浅谈LCT实现及应用.pdf 标准模板：Luogu动态树 6.7.2 练习弹飞绵羊Caioj1437Caioj1438Caioj1439Caioj1440 6.7.3 所有题目Tag-LCT 6.7.4 有兴趣刷题的可以看看这个http://www.cnblogs.com/flashhu/p/8324551.html]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-6主席树]]></title>
    <url>%2Fposts%2Fd299.html</url>
    <content type="text"><![CDATA[6.6.0 背景对于两颗上下界相同的线段树，其结构唯一，节点一一对应。至于主席树来历之类的八卦，请自行上网搜索。某大佬：http://blog.csdn.net/xgc_woker/article/details/78018297 6.6.1 性质主席树，主要用于解决区间大小关系询问类问题，当然也用到了身为区间问题始祖的前缀和。其实它本质上是一颗权值线段树，所以比较大小就比较方便啦。 由于它存储的值是，对应某段区间，在他管辖范围内的这些数字总共出现了多少次。也正是由于出现次数满足可加性，前缀和可以很好的解决。 对于长度为1的一个区间，如果只看有用的信息，它的形状大致是一根链（空间logn），所以应该看成残缺的线段树（否则就会需要大量空间导致MLE）利用前缀和思想，用n颗主席树分别维护1~i区间内的信息，合并重复信息即可。 哦对了因为是权值线段树，所以要离散化，既减少空间，也避免下标出现负数。 目前上面我只会上述这些解释，其实它还能应用于可持久化操作…… 6.6.2 例题应用Caioj1441Poj2104Hud2665 区间第k小（大）询问先利用前缀和获得对应区间信息，然后根据左右儿子的信息值，找到k在哪里，不断缩小范围，最后找到他的值。 caioj和hdu都AC然鹅，poj却RE，至今迷离，放弃治疗…… 6.6.3 例题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=100000;const int NUL=0;//*******************全局定义*******************struct nod&#123; int x,p,z;&#125;d[MAXN+10];//*******************离散化*******************bool cmp(nod a,nod b)&#123; return a.x&lt;=b.x;&#125;void lsh(int n)&#123; sort(d+1,d+1+n,cmp); for(int i=1;i&lt;=n;i++) d[d[i].p].z=i;&#125;//*******************主席树*******************struct mg&#123; int lc,rc; int c;&#125;s[20*MAXN];int ln;//因为动态建树，l、r要放这里void add(int &amp;x,int l,int r,int c)&#123; if(x==NUL) &#123; x=++ln; s[x].c=0; s[x].lc=s[x].rc=NUL; &#125; s[x].c++; if(l==r) return; int mid=(l+r)/2; if(c&lt;=mid) add(s[x].lc,l,mid,c); else add(s[x].rc,mid+1,r,c);&#125;void merg(int x,int &amp;y)&#123; if(x==NUL) return; if(y==NUL) &#123;y=x;return;&#125; s[y].c+=s[x].c; merg(s[x].lc,s[y].lc); merg(s[x].rc,s[y].rc);&#125;//x、y是节点编号，l、r是离散化值即排名int ask(int x,int y,int l,int r,int rk)&#123; if(l==r) return d[l].x;//排名为l的原值 int xlc=s[x].lc,ylc=s[y].lc; int ls=s[ylc].c-s[xlc].c; int mid=(l+r)/2; if(rk&lt;=ls) return ask(xlc,ylc,l,mid,rk); return ask(s[x].rc,s[y].rc,mid+1,r,rk-ls);&#125;//*******************主函数*******************int ys[MAXN+10];int main()&#123; //int t;scanf("%d",&amp;t); //while(t--) //&#123; ln=0;memset(ys,NUL,sizeof(ys)); int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;d[i].x),d[i].p=i; lsh(n); for(int i=1;i&lt;=n;i++) &#123; add(ys[i],1,n,d[i].z);//插入一条链 merg(ys[i-1],ys[i]);//合并从而形成前缀和 &#125; while(m--) &#123; int l,r,k;scanf("%d%d%d",&amp;l,&amp;r,&amp;k); printf("%d\n",ask(ys[l-1],ys[r],1,n,k)); //注意前缀和的-1 &#125; //&#125;&#125; 6.6.4 练习Bzoj1901 Zju2112Dynamic RankingsSpoj3267 D-query 6.4.7 所有题目Tag-主席树]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-5-kdtree]]></title>
    <url>%2Fposts%2F23c.html</url>
    <content type="text"><![CDATA[kdtree：同样是融合了贪心的某种暴力 好文章K-DTree-n+e.pdf 练习SJY摆棋子最近点对Hide and Seek 练习题Tag-kdtree]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>kdtree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-4莫队]]></title>
    <url>%2Fposts%2Fced6.html</url>
    <content type="text"><![CDATA[本文未完成，做题用到的时候再手推然后补上 莫队，主要用于解决区间问题，但标准版本是不支持修改的。 标准莫队首先，要离线解决问题~所以强制在线就没办法了然后精华就在于解决的顺序，经过一番神奇的时间复杂度计算，好吧其实就是类似曼哈顿距离的东西，然后如果想要完美的话可以搞个曼哈顿距离生成树，但更经济的办法是套分块。 待修莫队因为有修改，所以要进行一些修改，有点类似主席树。 树上莫队不会……]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-3伸展树]]></title>
    <url>%2Fposts%2F506a.html</url>
    <content type="text"><![CDATA[6.4.1 定义伸展树是一种相当灵活的平衡树结构（灵活：便于添加和删除）比较少直接使用，能应用于LCT 6.4.2 模版题我把最重要的讲解放在这里面了【Caioj1130】【Codevs4543】【Bzoj3224】普通平衡树 6.4.5 练习Codevs3303文艺平衡树Bzoj3196二逼平衡树Bzoj1500维修数列 6.4.5 其他题目Caioj1131 Bzoj1588 Codevs1296 HNOI2002 HNOI2014 营业额统计Caioj1132 Bzoj1503 Codevs1286 NOI2004 郁闷的出纳员Caioj1133 Bzoj1208 CCodevs1285 HNOI2004 宠物收养所Caioj1137 Bzoj1058 Codevs1429 ZJOI2007 报表统计 6.4.6 总结重点是利用伸展树的灵活性另外，每次Splay既是加速也是重要的更新（pushdown/pushup） 如果还看不懂，阔以看看介个文章：FlashHu 6.4.7 所有题目Tag-伸展树 update说说我对前驱后继操作的理解我的写法是兼容【参数不存在】的情况的findip会找到一个存在元素，可能不满足条件，但一定是在那个方向最接近的（如果比d小，那么一定是其中最大的，反之亦然）那么为了确保找到正确答案，不能直接找父亲什么的，要旋转到根，然后往那个方向按具体需求去找 目前已知的只有平衡树能实现，而set不能的功能： 找第k大等，与具体值没有关系，而且k不是首尾的操作（这里没必要用主席树） 目前已知的只有主席树能实现的东西：区间第k大（如果像二逼平衡树那样树套树也行，但显然的比赛找死行为）]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-2树状数组]]></title>
    <url>%2Fposts%2F1650.html</url>
    <content type="text"><![CDATA[6.2.0 前言本文同样不是教程，提供一些思路罢了 6.2.1 定义树状数组是一种利用正整数二进制的某种特殊性质，从而比线段树更精简但没这么强大的，并且借助了前缀和思路的特殊数组 6.2.2 有关二进制基础知识可以参考这篇文章主要就是这个函数，原理可以看网上的教程，主要就是O(1)找到自己的父亲（加上结果）和兄弟（减去结果）1234int lowbit(int x)&#123; return x&amp;-x;&#125; 6.2.2 单点更新, 区间询问前缀和:i到j就是ask(j)-ask(i-1) 12345678910111213141516171819void change(int x,int c)&#123; while(x&lt;=n) &#123; p[x]=c; x+=lowbit(x); //更新管理着x的所有父亲 &#125;&#125;int ask(int x)&#123; int s=0; while(x&gt;=1) &#123; s+=p[x]; x-=lowbit(x); //加上自己所管理不到的，在我前面的兄弟 &#125;&#125; 6.2.3 区间更新, 单点询问运用差分就是说原本的a[i]=p[1]+p[2]…+p[i]从而把数值变得依赖于前面的数值 若要将a数组区间[l,r]的元素都加上key，显然只需令p[l]+=key,p[r+1]-=key即可。 差分思想的运用灰常广泛，这只是其中一种简单的体现详见Tag-差分 6.2.4 区间更新, 区间询问假设现在求sum[s]，d[]是差分数组a[1]+a[2]+a[3]+…..+a[s-1]+a[s]=(d[1])+(d[1]+d[2])+…..+(d[1]+d[2]+…..+d[s])=(s)d[1]+(s-1)d[2]+…..+(1)d[s]=s(d[1]+d[2]+….+d[s])-((1-1)d[1]+(2-1)d[2]…+(s-1)d[s])为了简化，故定义另一个数组cc[i]=(i-1)d[i]从而把原式化简为=s*(d[1]+d[2]+….+d[s])-(c[1]+c[2]…+c[s]) 这样，只需要两个树状数组即可，一个维护d，一个维护c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;//*******************定义*******************typedef long long ld;ld n;ld c[2][210000];//*******************实现*******************ld lowbit(ld x)&#123; return x&amp;-x;&#125;void ch(ld f,ld x,ld s)&#123; while(x&lt;=n) &#123; c[f][x]+=s; x+=lowbit(x); &#125;&#125;ld sum(ld f,ld x)&#123; ld s=0; while(x&gt;0) &#123; s+=c[f][x]; x-=lowbit(x); &#125; return s;&#125;//*******************接口*******************ld ask(ld x)&#123; return x*sum(0,x)-sum(1,x);&#125;//*******************主函数*******************ld a[210000];int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;a[i]); ld d=a[i]-a[i-1]; ch(0,i,d); ch(1,i,(i-1)*d); &#125; int q;scanf("%d",&amp;q); while(q--) &#123; int o,a,b;scanf("%d%d%d",&amp;o,&amp;a,&amp;b); ld c; if(o==1) &#123; scanf("%lld",&amp;c); //d[i]+=c ch(0,a,c);ch(0,b+1,-c); //c[i]+=(i-1)*c ch(1,a,(a-1)*c);ch(1,b+1,-b*c); &#125; else printf("%lld\n",ask(b)-ask(a-1)); &#125;&#125; 可以去Codevs1082评测如果用线段树就灰常简单了：这篇文章 6.2.4 练习题Tag-树状数组 6.2.5 总结树状数组的核心竞争力在于比线段树容易实现（因为利用前缀和思想），但也正是因为用了前缀和，操作必须满足区间可加性，例如无法求最值]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-1分块]]></title>
    <url>%2Fposts%2F2aa7.html</url>
    <content type="text"><![CDATA[文章参考网页版：http://hzwer.com/8053.html 好吧，实话说已经灰常详细了，暂时不知道说些什么好…… 学习指导：Hzwer题表 所有题目Tag-分块]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】01语法与STL-5二叉树]]></title>
    <url>%2Fposts%2F212a.html</url>
    <content type="text"><![CDATA[初赛常考内容随便说点性质 性质1]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】01语法与STL-4原码反码补码]]></title>
    <url>%2Fposts%2Fa619.html</url>
    <content type="text"><![CDATA[初赛常考内容 5.1.1 基本概念字节：8各位。字长：若干个字节。到底是几个字节？具体看是哪种CPU。 比如2010普及组第11题就假设一个字长只有一个字节8个位。接下来原码、反码，补码都是建立在机器数在一个字长上的表示。为了方便理解，我们假设字长为一个字节。读者要注意事实上为32位CPU字长为4个字节，64位CPU字长为8个字节。 5.1.2 原码首位为符号位，其余为真值。比如：原码总结：范围：比如字长为8位，则范围为 11111111（－255） 至 01111111（＋255）。缺点：0有两个表示，分别为正零（00000000）和负零（10000000），给计算机计算带来不便。 5.1.3 反码首位为符号位，其它位分正数和负数两种情况。反码正数：所有位和原码一样；反码负数：除了符号位和原码一样，其他位相反。比如：77的反码表示为01001101 -77的反码表示为10110010补码总结：同样0有两个表示，也没有原码简单，反码存在的意义就是为了连接原码和补码。 5.1.4 补码分正数和负数两种情况。补码正数：所有位和反码一样，当然也和原码一样。补码负数：等于反码加1。简单的一句话，其实很麻烦。比如：77的补码表示为01001101（和原码、反码一致） -77的补码表示为10110011 加1之后会有进位，因为补码没有符号位，所以负零的补码表示也是00000000。补码总结：特点：表示比反码更麻烦。但是解决了一个问题：0只有一种表示。 原码 反码 补码 正零 00000000 00000000 00000000 负零 10000000 11111111 00000000 5.1.5 位运算不错的参考~和!都是取反，但~对符号位取反，!则不会]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】01语法与STL-3操作符和优先级]]></title>
    <url>%2Fposts%2Fd010.html</url>
    <content type="text"><![CDATA[表格 记忆方法：–摘自《C语言程序设计实用问答》 问题：如何记住运算符的15种优先级和结合性？解答：C语言中运算符种类比较繁多，优先级有15种，结合性有两种。如何记忆两种结合性和15种优先级？下面讲述一种记忆方法。结合性有两种，一种是自左至右，另一种是自右至左，大部分运算符的结合性是自左至右，只有单目运算符、三目运算符的赋值运算符的结合性自右至左。 优先级有15种。记忆方法如下：记住一个最高的：构造类型的元素或成员以及小括号。记住一个最低的：逗号运算符。剩余的是一、二、三、赋值。意思是单目、双目、三目和赋值运算符。在诸多运算符中，又分为：算术、关系、逻辑。两种位操作运算符中，移位运算符在算术运算符后边，逻辑位运算符在逻辑运算符的前面。再细分如下：1234算术运算符分 * / %高于+ -关系运算符中 &gt; &gt;= &lt; &lt;=高于== !=逻辑运算符中，除了逻辑求反(!)是单目外，逻辑与(&amp;&amp;)高于逻辑或(||)逻辑位运算符中，除了逻辑按位求反(~）外，按位与(&amp;)高于按位半加(^)高于按位或(|) 这样就将15种优先级都记住了，再将记忆方法总结如下：去掉一个最高的，去掉一个最低的，剩下的是一、二、三、赋值。双目运算符中，顺序为算术、关系和逻辑，移位和逻辑位插入其中。]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】01语法与STL-2STL]]></title>
    <url>%2Fposts%2Fa012.html</url>
    <content type="text"><![CDATA[壮哉我stl！ 字符串读取整行，getline(cin,s);123456789101112#include&lt;string&gt;string s1; //定义一个字符串s1，并初始化为空string s2(s1); //用s1初始化s2string s3("value"); //将s3初始化为"value"string s4(n,'c'); //将s4初始化为字符'c'的n个副本，简单来说就是n个'c'字符s.empty() //若s为空串，则返回true，否则为falses.size() //返回s中字符的个数，s.length()与其相同s.insert(pos,s2) //在s下标为pos的元素前插入字符串s2s.substr(pos,len) //返回s中下标为pos起的长度为len的子串s.replace(pos,l,s2) //替换s中下标为pos起的长度l个字符为字符串s2s.find(s2,pos) //在s中查找s2第一次出现的位置s.c_str() //返回一个C风格的字符串临时指针 关联式容器map &lt;类型1,类型2&gt; 变量名;在一些应用中，使用map容器来作为一个有序的映射表对map单次操作的时间复杂度为log(n)12345678910#include&lt;map&gt;ma["abc"]=2; //将字符串"abc"映射到整数2cout&lt;&lt;ma["abc"]; //输出为2ma.begin() //返回map中第一个元素的迭代器（指针）ma.end() //返回最后一个元素后一个的迭代器（指针）ma.size() //返回map中元素的个数ma.count(element) //判断元素element是否存在map中ma.clear() //初始化mapma.lower_bound() //返回键值大于等于给定元素的第一个位置,一旦map中的一个元素被访问，不论它之前是否已经被赋值，它都被视为存在operator[] //访问map中的元素，若该元素不存在,则创建一个新元素，并返回类型2初始值 set返回迭代器（直接减去begin()得到下标即排名，加上*得到值）begin()–返回指向第一个元素的迭代器end()–返回指向最后一个元素的迭代器find()–返回一个指向被查找到元素的迭代器，不存在则返回end()lower_bound()–返回指向大于（或等于）某值的第一个元素的迭代器，可外面，不存在则返回end()upper_bound()–返回大于某个值元素的迭代器，可外面，不存在则返回end() 用multiset可以完全代替优先队列，还可以同时小根、大根支持删除（s.erase(s.find())即可，只会删一个，如果传入值删除所有）、搜索元素 12得到最小值*(s.begin())最大值*(--s.end()) Zebras 1.2.9 迭代器123456map&lt;string,int&gt; m;for(map&lt;string,int&gt;::iterator i=m.begin();i!=m.end();i++)&#123; //或 cout&lt;&lt;i-&gt;first&lt;&lt;" "&lt;&lt;i-&gt;second&lt;&lt;endl; cout&lt;&lt;(*i).first&lt;&lt;" "&lt;&lt;(*i).second&lt;&lt;endl;&#125; 如果要反向枚举，可以从rbegin的结尾，到rend，注意遍历的时候要用++这样会方便很多，不用预处理st和edsort的时候（主要是vector）也会很方便：sort( a.rbegin(),a.rend() )这可以从大到小 bitset定义、初始化与赋值bitset 表示二进制长度为8默认初始值为0bs[0]=1 表示将最后一位设为1，而不是首位（bin[0]） 函数返回boolbs.any() 是否存在值为1的二进制位bs.none() 是否不存在值为1的二进制位，也就是0bs.count() 值为1的个数 返回bitsetbs.flip() 全部位逐位取反，等效于 ~bs 其他所有位运算，除了“!”，不知道原因赋值：set()全部1，reset()全部0 转化bs.to_string()bs.to_ulong() 变成 unsigned longbs.to_ullong() 变成 unsigned long longbs=”0001010”bs=31 优秀的空间复杂度 长度 bitset字节 bool[]字节 16 4 16 32 4 32 64 8 64 简而言之，每8位1个字节其实和用int存储是一样的，例如32位时4字节 时间复杂度每次操作，位数/32 其他nth_element(start, start+n, end)使第n大元素处于第n位置（从0开始,其位置是下标为 n的元素）常用于KD-Tree原理其实就是手写二分排序一样，然后只搞某一侧 deque与queue不同在于能任意访问其中的元素（因为是连续的空间），并且能在前面插入元素（与vector不同）（这是手写队列也无法做到的，虽然不常用，因为oi不考stl，只是作为工具） equal_range参数和lower_bound等类似能够返回容器内，等值区间，而且同样是左闭右开区间]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】01语法与STL-1概要]]></title>
    <url>%2Fposts%2F5fe4.html</url>
    <content type="text"><![CDATA[这些可能在NOIP初赛、日常做题比较有用当然也是计算机领域的一些常识 系统dfs栈windows默认60000左右，linux默认250000左右解决方法：手写栈 主定理用来分析复杂度的东东$T(n)=aT(\frac{n}{B})+f(n)$如果 $f(n)&lt;n^{log_b a},T(n)=O(n^{log_b a})$如果 $f(n)=n^{log_b a},T(n)=O(n^{log_b a} log n)$很多分治算法不太好计算，就可以用这个 树上的度指子节点数量，和通常说的不同！设ni为二叉树上，度为i的节点数量则n0=n2+1证明： n=n0+n1+n2 孩子节点总数=n1+2n2 显然n=n1+2n2+1 所以得证 树的层次，从第0层开始一棵树的高度，为其层数-1，所以和深度最大的节点，数值相同（根深度为0） 完美二叉树 Perfect Binary Tree: 没有度为0的节点完全二叉树 Complete Binary Tree：最后一层不满完满二叉树 Full Binary Tree：即国内通常指的满二叉树 初赛易错 主频1 GHZ=1000 MHz 区位码转国际码，分别加上32；国际码转机内码，分别加128 LAN 局域网，MAN 城域网， WAN 广域网 网络协议应用层：telnet（远程登陆），ftp，e-mail传输层：TCP（传输控制协议）， UDP（用户数据报协议）网络层：IP 网际协议，ICMP（网际控制报文协议），IGMP（组管理协议）网络结构层：设备驱动程序 DNS域名系统，将域名转化为地址 电子邮件：简单邮件传输协议SMTP，电子邮件拓展协议MIME，POP协议 不稳定排序：选择排序，希尔排序，快排，堆排， 只有堆排和归并最坏nlogn 16位色指有 $2^16$ 种颜色，即每个像素2字节 面向对象的语言：C#，c++，java，smalltalk，eiffel 第一种高级语言：Fortran 浮点数分阶码和尾数两部分,阶码位数越多，可表示的数的范围越大；尾数越多，所表示的数的精度越高 复杂度包括时间和空间P问题：存在多项式解法的问题；NP问题：多项式时间内验证答案的问题；NP-hard问题：所有NP问题可以在多项式复杂度内归约到它NPC问题：所有NP问题可以在多项式复杂度内归约到它，而且是NP问题 IP0.0.0.0 对应于当前主机255.255.255.255当前子网的广播地址127.0.0.1 代表本机IP地址 oth我的：原码、补码、反码操作符和优先级可变参数数据类型的对照 别人的：数制转换逻辑运算栈与卡特兰数二叉树的遍历和性质哈夫曼树和哈夫曼编码模拟与高精度算法排序与算法复杂度数据结构基础数论算法基础图论算法基础组合数学基础计算几何基础基本算法思想计算机文化基础计算机系统原理计算机网络基础计算机病毒防治计算机信息处理信息学奥林匹克]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【置顶】套路集锦]]></title>
    <url>%2Fposts%2F80c8.html</url>
    <content type="text"><![CDATA[经典套路集锦早就想搞了 一、解题思路1需求：最大化最小值、最小化最大值做法：二分答案举例：一抓一大把 2有些题可以从简单情况着手然后拓展到复杂情况（数学归纳法或者总结经验、模仿）或者先考虑普通情况，再考虑改进来解决特殊情况举例：noi2015 荷马史诗poj2442 Sequence平面几何，先研究三角形 3研究原问题较复杂时，可能取补会让问题简单化举例：Ch6401 创世纪各种组合数学题 4各种拆点姿势：按照时间等递增坐标按照出度和入度 5对于比较陌生的题目操作形式，可以多造几组数据来模拟，找到一些性质，用这些性质转化题目为简单问题 6对于某些有后效性的操作把时间倒流或许会有帮助 7平方形式，可以转为为数点对，或者用二次项定理拆开来（内部有东西的时候）举例：NOI2009 管道取珠蔬菜 二、枚举方法1有关区间问题并用到区间最值，求出l[i]和r[i]表示第一个比a[i]大的位置，则l[i]+1~r[i]-1中间，用到的最大值都是a[i]不过要小心最大值相等而重复的情况，可以强行把左边界改严格来限制洛谷18年7月月赛T4 2按照akc说的，碰到搜索，无脑倒序举例：poj1190 生日蛋糕虫食算 3当出现连续的$\lfloor \frac{n}{i} \rfloor$时，值一定是单调不递增的，同值的区间可以合起来计算复杂度：$O(\sqrt n)$① 当$i \leq \sqrt n$,分母只有$\sqrt n$种② 当$i &gt; \sqrt n$,$\lfloor \frac{n}{i} \rfloor &lt; \sqrt n$$last=\lfloor \frac{n}{ \lfloor \frac{n}{i} \rfloor } \rfloor$举例：CQOI2007 余数求和大部分莫比乌斯反演题，如gdoi2018d2t1 4对于许多计数类问题，如果有多个段可分，可以分成1+(n-1)，这样子能保证不会重复计数举例：noi2001 陨石的秘密 5很多计数问题要求排列可以时刻保证排列性，然后插入一个数，将比它大的数+151nod1296 有限制的排列 三、决策类1需求：维护前k个（方案）做法：堆维护，堆顶为最差元素举例：K远点对树上的路径Supermarket 2把决策转化为边，边权为代价举例：电路维修循环格 3找前k优的区间，固定一个点后，左边的优秀情况是极值问题可以用堆维护左边，取出一个位置后把左边区间拆成两半放回去举例：超级钢琴树上的路径 四、搜索类1搜索去掉次序性的套路：强行限制大小关系举例：poj1011 Sticks 2搜索的复杂度：把每次决策量也就是分支数量计算出来 3其他优化：优化搜索顺序排除等效的决策和物体可行性最优性记忆化 4对于一个序列，拆分成多个序列的问题有两种不同的方向： 给每个元素分配组（通常这个更快） 通过组，找元素最好能仔细根据题目斟酌一下策略本人多次无脑用2各种剪枝，也比不过裸的1……举例：SticksMissile Defence SystemZebras 五、数论技巧1面对gcd、lcm的限制条件，可以从质因数上考虑，从而变成min、max，省去log暴力判断的复杂度举例：Hankson的趣味题 2由调和级数1+1/2+1/3…1/n=logn 3如果要在中途，用一个简单的状态去尝试满足“成为某个数的倍数”或者需要以此简便地转移可以考虑只保留余数举例：Ahoi2009 同类分布 六、树1在一课树上，与该点最远的一定是直径的某个端点 2两棵树合并起来，新的直径端点一定在两边直径端点中产生 七、二分图最大 匹配数:顶点两两配对的对数最大 独立集:顶点两两不到达的点数最小 点覆盖:选一个点就能覆盖所有与它连接的边，求点覆盖所有边的点数最小 边覆盖:选一条边就能覆盖所有与它连接的点，求边覆盖所有点的边数 1 König定理 最小点覆盖（有时称为最小覆盖）=最大匹配数 最小边覆盖=最大独立集 最大独立集=去掉最少的点，剩下点之间没有边=n-最小点覆盖=n-匹配数 举例：经典模型 Muddy Fields 2在平面二分图上，如果存在使边不会重叠的方案，那么其中一定有一种是边长和最小的方案也就是把合法性、可行性问题转化为求边长和最小的问题证明的话，显然如果我能够选择不跨越，边长和会变小 七、感觉很假的结论八、完全不会证明的结论1 树上路径，覆盖所有边需要数量：$\lceil \frac{度=1的点数量}{2} \rceil$ 九、自己容易犯的sb错误1树剖类节点新编号题目、离散化等一定要注意数组的下标是什么意义，避免把原编号传入 2对于一道题意不裸的题，都应该用样例检验没有看错题、想出来算法的基本正确性，再去code]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>原创精华</tag>
      </tags>
  </entry>
</search>
